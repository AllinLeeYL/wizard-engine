// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, BinParserTester.new, _);
def X: Array<Value>;

def Z = [
	T("bin/empty", test_empty),
	T("bin/magic", test_magic),
	T("bin/version", test_version),
	T("bin/buf_offset", test_buf_offset),
	T("bin/hdr_split", test_hdr_split),
	T("bin/sect_empty", test_sect_empty),
	T("bin/sect_empty_s", test_sect_empty_s),
	T("bin/sect_underflow", test_sect_underflow),
	T("bin/sect_size0", test_sect_size0),
	T("bin/sect_eof", test_sect_eof),
	T("bin/sect_custom", test_sect_custom),
	()
];

class BinParserTester(t: Tester) {
	def invalid(expected: WasmError, raw: Array<byte>) {
		var m = mp();
		m.push(raw, 0, raw.length);
		assert_invalid(expected, m.finish());
	}
	def valid(raw: Array<byte>) {
		var m = mp();
		m.push(raw, 0, raw.length);
		assert_valid(m.finish());
	}
	def valid_split(raw: Array<byte>) {
		for (i < raw.length) {
			var m = mp();
			m.push(raw, 0, i);
			m.push(raw, i, raw.length - i);
			assert_valid(m.finish());
		}
	}
	def assert_invalid(expected: WasmError, r: BinParserResult) {
		match (r) {
			Ok(module) => t.fail1("expected error %s, but passed", expected.name);
			Error(code, filename, error_pos, error_msg) => {
				if (code == expected) return;
				var buf = StringBuffer.new();
				buf.put2("expected error %s, but got %s: ", expected.name, code.name);
				buf.put2("@+%d %s", error_pos, error_msg);
				t.fail(buf.extract());
			}
		}
	}
	def assert_valid(r: BinParserResult) {
		match (r) {
			Ok(module) => ;
			Error(code, filename, error_pos, error_msg) => {
				var buf = StringBuffer.new();
				buf.put1("expected success, but got %s: ", code.name);
				buf.put2("@+%d %s", error_pos, error_msg);
				t.fail(buf.extract());
			}
		}
	}
	def mp() -> ModuleParser {
		var v = if (wizeng.verbose, Verbosity.VERBOSE, Verbosity.SILENT);
		return ModuleParser.new(v, "test");
	}
}

def VALID_HEADER: Array<byte> = [
	0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00
];

def test_empty(t: BinParserTester) {
	for (i = 1; i <= 1; i++) {
		var mod = Arrays.range(VALID_HEADER, 0, i);
		t.invalid(WasmError.INVALID_HEADER, mod);
	}
}

def test_magic(t: BinParserTester) {
	def template = Arrays.range(VALID_HEADER, 0, VALID_HEADER.length);
	for (i < 4) {
		var prev = template[i];
		template[i] = 0xFF;
		t.invalid(WasmError.INVALID_HEADER, template);
		template[i] = prev;
	}
}

def test_version(t: BinParserTester) {
	def template = Arrays.range(VALID_HEADER, 0, VALID_HEADER.length);
	for (i = 4; i < 8; i++) {
		var prev = template[i];
		template[i] = 0xFF;
		t.invalid(WasmError.INVALID_HEADER, template);
		template[i] = prev;
	}
}

def test_buf_offset(t: BinParserTester) {
	def len = VALID_HEADER.length;
	var buffer = Array<byte>.new(3 * len);
	for (i < (len * 2) + 1) {
		Arrays.copyInto(buffer, i, VALID_HEADER, 0, len);
		var m = t.mp();
		m.push(buffer, i, len);
		t.assert_valid(m.finish());
	}
}

def test_hdr_split(t: BinParserTester) {
	def template = VALID_HEADER;
	t.valid_split(template);
}

def COUNTED_SECTIONS = [
	BpSection.Type,
	BpSection.Import,
	BpSection.Function,
	BpSection.Table,
	BpSection.Memory,
	BpSection.Global,
	BpSection.Export,
	BpSection.Element,
	BpSection.Code,
	BpSection.Data
];

class SingleEmptySectionTemplate {
	def len = VALID_HEADER.length;
	def template = Array<byte>.new(len + 3);
	def code_pos = len, size_pos = len + 1, count_pos = len + 2;
	new() {
		Arrays.copyInto(template, 0, VALID_HEADER, 0, len);
		template[size_pos] = 1;
		template[count_pos] = 0;
	}
	def set(sect: BpSection, size: int, count: int) {
		template[code_pos] = sect.code;
		template[size_pos] = byte.!(size);
		template[count_pos] = byte.!(count);
	}
}

def test_sect_empty(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// valid case
		s.set(sect, 1, 0);
		t.valid(s.template);
	}
}

def test_sect_empty_s(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// valid case
		s.set(sect, 1, 0);
		t.valid_split(s.template); // streaming
	}
}

def test_sect_underflow(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// Section read size smaller than expected
		s.set(sect, 2, 0);
		t.invalid(WasmError.INCOMPLETE_SECTION, s.template);
	}
}

def test_sect_size0(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// Section size not large enough to even include count
		s.set(sect, 0, 0);
		t.invalid(WasmError.OVERFLOW_SECTION, s.template);
	}
}

def test_sect_eof(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// EOF before first item
		if (sect == BpSection.Code) continue; // extra count check
		s.set(sect, 1, 1);
		t.invalid(WasmError.OVERFLOW_SECTION, s.template);
	}
}

def test_sect_custom(t: BinParserTester) {
	var v = Vector<byte>.new();
	for (i < 5) {
		v.addv(VALID_HEADER);
		v.add(0);
		BinEncoder.append_u32leb(v, u32.!(11 + i));
		BinEncoder.append_string(v, "my_section");
		for (j < i) v.add(77);
		t.valid_split(v.extract());
	}
}

// TODO: positive/negative tests for each of the counted section elements
// TODO: varying numbers of positive tests for counted sections
// TODO: EOF / early end of counted sections
// TODO: split / stream tests for more valid modules
// TODO: test all WasmError kinds
// TODO: limit tests for every kind of quantity whereever it can occur
// TODO: section constraints
// TODO: maximum number of memories / tables with extension config
// TODO: repeated sections

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, BinParserTester.new, _);
def X: Array<Value>;

def Z = [
	T("bin/empty", test_empty),
	T("bin/magic", test_magic),
	T("bin/version", test_version),
	T("bin/buf_offset", test_buf_offset),
	T("bin/hdr_split", test_hdr_split),
	T("bin/sect_empty", test_sect_empty),
	T("bin/sect_empty_s", test_sect_empty_s),
	T("bin/sect_underflow", test_sect_underflow),
	T("bin/sect_size0", test_sect_size0),
	T("bin/sect_eof", test_sect_eof),
	T("bin/sect_custom", test_sect_custom),
	T("bin/sect_custom_ovf", test_sect_custom_ovf),
	T("bin/types0", test_types0),
	T("bin/types1", test_types1),
	T("bin/typesN", test_typesN),
	T("bin/importsN", test_importsN),
	T("bin/funcsN", test_funcsN),
	T("bin/tablesN", test_tablesN),
	T("bin/memoriesN", test_memoriesN),
	T("bin/globalsN", test_globalsN),
	T("bin/exportsN", test_exportsN),
	T("bin/elementsN", test_elementsN),
	T("bin/dataN", test_dataN),
	()
];

class BinParserTester(t: Tester) {
	def invalid(expected: WasmError, raw: Array<byte>) {
		var m = mp();
		m.push(raw, 0, raw.length);
		assert_invalid(expected, m.finish());
	}
	def valid(raw: Array<byte>) {
		var m = mp();
		m.push(raw, 0, raw.length);
		assert_valid(m.finish());
	}
	def valid_split(raw: Array<byte>) {
		for (i < raw.length) {
			var m = mp();
			m.push(raw, 0, i);
			m.push(raw, i, raw.length - i);
			assert_valid(m.finish());
		}
	}
	def assert_invalid(expected: WasmError, r: BinParserResult) {
		match (r) {
			Ok(module) => t.fail1("expected error %s, but passed", expected.name);
			Error(code, filename, error_pos, error_msg) => {
				if (code == expected) return;
				var buf = StringBuffer.new();
				buf.put2("expected error %s, but got %s: ", expected.name, code.name);
				buf.put2("@+%d %s", error_pos, error_msg);
				t.fail(buf.extract());
			}
		}
	}
	def assert_valid(r: BinParserResult) {
		match (r) {
			Ok(module) => ;
			Error(code, filename, error_pos, error_msg) => {
				var buf = StringBuffer.new();
				buf.put1("expected success, but got %s: ", code.name);
				buf.put2("@+%d %s", error_pos, error_msg);
				t.fail(buf.extract());
			}
		}
	}
	def mp() -> ModuleParser {
		var v = if (wizeng.verbose, Verbosity.VERBOSE, Verbosity.SILENT);
		return ModuleParser.new(v, "test");
	}
}

def VALID_HEADER = BinUtil.WASM_HEADER;

def test_empty(t: BinParserTester) {
	for (i = 1; i <= 1; i++) {
		var mod = Arrays.range(VALID_HEADER, 0, i);
		t.invalid(WasmError.INVALID_HEADER, mod);
	}
}

def test_magic(t: BinParserTester) {
	def template = Arrays.range(VALID_HEADER, 0, VALID_HEADER.length);
	for (i < 4) {
		var prev = template[i];
		template[i] = 0xFF;
		t.invalid(WasmError.INVALID_HEADER, template);
		template[i] = prev;
	}
}

def test_version(t: BinParserTester) {
	def template = Arrays.range(VALID_HEADER, 0, VALID_HEADER.length);
	for (i = 4; i < 8; i++) {
		var prev = template[i];
		template[i] = 0xFF;
		t.invalid(WasmError.INVALID_HEADER, template);
		template[i] = prev;
	}
}

def test_buf_offset(t: BinParserTester) {
	def len = VALID_HEADER.length;
	var buffer = Array<byte>.new(3 * len);
	for (i < (len * 2) + 1) {
		Arrays.copyInto(buffer, i, VALID_HEADER, 0, len);
		var m = t.mp();
		m.push(buffer, i, len);
		t.assert_valid(m.finish());
	}
}

def test_hdr_split(t: BinParserTester) {
	def template = VALID_HEADER;
	t.valid_split(template);
}

def COUNTED_SECTIONS = [
	BpSection.Type,
	BpSection.Import,
	BpSection.Function,
	BpSection.Table,
	BpSection.Memory,
	BpSection.Global,
	BpSection.Export,
	BpSection.Element,
	BpSection.Code,
	BpSection.Data
];

def EMPTY_FUNC_TYPE: Array<byte> =
	[BpTypecon.Function.code, 0, 0];
def ONE_FUNC_TYPES_SECTION: Array<byte> =
	[BpSection.Type.code, 4, 1, BpTypecon.Function.code, 0, 0];

class SingleEmptySectionTemplate {
	def len = VALID_HEADER.length;
	def template = Array<byte>.new(len + 3);
	def code_pos = len, size_pos = len + 1, count_pos = len + 2;
	new() {
		Arrays.copyInto(template, 0, VALID_HEADER, 0, len);
		template[size_pos] = 1;
		template[count_pos] = 0;
	}
	def set(sect: BpSection, size: int, count: int) {
		template[code_pos] = sect.code;
		template[size_pos] = byte.!(size);
		template[count_pos] = byte.!(count);
	}
}

def test_sect_empty(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// valid case
		s.set(sect, 1, 0);
		t.valid(s.template);
	}
}

def test_sect_empty_s(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// valid case
		s.set(sect, 1, 0);
		t.valid_split(s.template); // streaming
	}
}

def test_sect_underflow(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// Section read size smaller than expected
		s.set(sect, 2, 0);
		t.invalid(WasmError.INCOMPLETE_SECTION, s.template);
	}
}

def test_sect_size0(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// Section size not large enough to even include count
		s.set(sect, 0, 0);
		t.invalid(WasmError.OVERFLOW_SECTION, s.template);
	}
}

def test_sect_eof(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// EOF before first item
		if (sect == BpSection.Code) continue; // extra count check
		s.set(sect, 1, 1);
		t.invalid(WasmError.OVERFLOW_SECTION, s.template);
	}
}

def test_sect_custom(t: BinParserTester) {
	var b = BinBuilder.new();
	for (i < 5) {
		b.put_header();
		b.add(BpSection.Unknown.code);
		b.put_u32leb(u32.!(11 + i));
		b.put_string("my_section");
		for (j < i) b.add(77);
		t.valid_split(b.extract());
	}
}

def test_sect_custom_ovf(t: BinParserTester) {
	def name = "x_section";
	var b = BinBuilder.new();
	for (i = name.length; i >= 0; i--) {
		b.put_header();
		b.add(BpSection.Unknown.code);
		b.put_u32leb(u32.!(i));
		b.put_string(name);
		t.invalid(WasmError.OVERFLOW_SECTION, b.extract());
	}
}

def test_types0(t: BinParserTester) {
	def EMPTY_FUNC: Array<byte> = [BpTypecon.Function.code, 0, 0];
	var b = BinBuilder.new();
	for (i < 5) {
		b.resize(0);
		b.put_header();
		b.beginShortSection(BpSection.Type);
		b.put_u32leb(u32.!(i));
		for (j < i) b.addv(EMPTY_FUNC);
		b.endSection();
		t.valid(b.extract());
	}
}

def test_types1(t: BinParserTester) {
	var b = BinBuilder.new();
	for (count < 3) {
		for (p < 3) {
			for (r < 2) { // ext:multi-value
				b.resize(0);
				b.put_header();
				b.beginShortSection(BpSection.Type);
				b.put_u32leb(u32.!(count));
				for (j < count) {
					b.add(BpTypecon.Function.code);
					b.add(byte.!(p));
					for (k < p) b.add(BpTypecon.I32.code);
					b.add(byte.!(r));
					for (k < r) b.add(BpTypecon.F32.code);
				}
				b.endSection();
				t.valid(b.extract());
			}
		}
	}
}

def testCountedSection(t: BinParserTester, max: int, sect: BpSection,
	pre: Array<byte>, entry: Array<byte>) {
	var b = BinBuilder.new();

	// Test up to 3 valid entries.
	var raw: Array<byte>;
	for (count < max+1) {
		b.resize(0);
		b.put_header();
		if (pre != null) b.addv(pre);
		b.beginShortSection(sect);
		b.put_u32leb(u32.!(count));
		for (j < count) b.addv(entry);
		b.endSection();
		raw = b.extract();

		t.valid_split(raw); // test splitting the module at all offsets
	}

	// Test truncated module by up to 3 entries.
	for (cut = 1; cut < entry.length * max; cut++) {
		var m = t.mp();
		m.push(raw, 0, raw.length - cut);
		t.assert_invalid(WasmError.INCOMPLETE_SECTION, m.finish());
	}
}

def test_typesN(t: BinParserTester) {
	testCountedSection(t, 3, BpSection.Type, null, [
		BpTypecon.Function.code, 1, BpTypecon.I32.code, 1, BpTypecon.I32.code
	]);
}

def test_importsN(t: BinParserTester) {
	testCountedSection(t, 3, BpSection.Import, null, [
		1, 0x65, 1, 0x66, BpImportExportKind.Global.code, BpTypecon.I32.code, 0
	]);
}

def test_funcsN(t: BinParserTester) {
	testCountedSection(t, 3, BpSection.Function, ONE_FUNC_TYPES_SECTION, [0]);
}

def test_tablesN(t: BinParserTester) {
	testCountedSection(t, 1/*ext:bulk-memory*/, BpSection.Table, null, [
		BpTypecon.AnyFunc.code, 0, 0
	]);
}

def test_memoriesN(t: BinParserTester) {
	testCountedSection(t, 1/*ext:multi-memory*/, BpSection.Memory, null, [
		0, 0
	]);
}

def test_globalsN(t: BinParserTester) {
	testCountedSection(t, 3, BpSection.Global, null, [
		BpTypecon.I32.code, 0, Opcode.I32_CONST.code, 0, Opcode.END.code
	]);
}

def test_exportsN(t: BinParserTester) { // TODO
}

def test_elementsN(t: BinParserTester) { // TODO
}

def test_dataN(t: BinParserTester) { // TODO
}

// TODO: positive/negative tests for each of the counted section elements
// TODO: varying numbers of positive tests for counted sections
// TODO: EOF / early end of counted sections
// TODO: split / stream tests for more valid modules
// TODO: test all WasmError kinds
// TODO: limit tests for every kind of quantity whereever it can occur
// TODO: section constraints
// TODO: maximum number of memories / tables with extension config
// TODO: repeated sections

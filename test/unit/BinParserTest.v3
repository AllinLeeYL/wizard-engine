// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, BinParserTester.new, _);
def X: Array<Value>;

def Z = [
	T("bin/empty", test_empty),
	T("bin/magic", test_magic),
	T("bin/version", test_version),
	T("bin/buf_offset", test_buf_offset),
	T("bin/hdr_split", test_hdr_split),
	T("bin/sect_empty", test_sect_empty),
	T("bin/sect_empty_s", test_sect_empty_s),
	T("bin/sect_underflow", test_sect_underflow),
	T("bin/sect_size0", test_sect_size0),
	T("bin/sect_eof", test_sect_eof),
	T("bin/sect_custom", test_sect_custom),
	T("bin/sect_custom_ovf", test_sect_custom_ovf),
	T("bin/types0", test_types0),
	T("bin/types1", test_types1),
	T("bin/imports0", test_imports0),
	T("bin/imports1", test_imports1),
	T("bin/typesN", test_typesN),
	T("bin/importsN", test_importsN),
	T("bin/funcsN", test_funcsN),
	T("bin/tablesN", test_tablesN),
	T("bin/memoriesN", test_memoriesN),
	T("bin/globalsN", test_globalsN),
	T("bin/exportsN", test_exportsN),
	T("bin/elementsN", test_elementsN),
	T("bin/dataN", test_dataN),
	()
];

class BinParserTester(t: Tester) {
	var test_split: bool = false;
	def valid(raw: Array<byte>) {
		validN(raw, 0, raw.length);
	}
	def validN(raw: Array<byte>, pos: int, length: int) {
		if (test_split) {
			// Test split modules at every offset.
			for (i < length) {
				var m = mp();
				m.push(raw, pos, i);
				m.push(raw, pos + i, length - i);
				if (!assert_valid(m.finish())) return;
			}
			return;
		}
		// Test only a complete module.
		var m = mp();
		m.push(raw, pos, length);
		assert_valid(m.finish());
	}
	def invalid(expected: WasmError, raw: Array<byte>) {
		invalidN(expected, raw, 0, raw.length);
	}
	def invalidN(expected: WasmError, raw: Array<byte>, pos: int, length: int) {
		if (test_split) {
			// Test split modules at every offset.
			for (i < length) {
				var m = mp();
				m.push(raw, pos, i);
				m.push(raw, pos + i, length - i);
				if (!assert_invalid(expected, m.finish())) return;
			}
			return;
		}
		// Test only a complete module.
		var m = mp();
		m.push(raw, pos, length);
		assert_invalid(expected, m.finish());
	}
	def assert_invalid(expected: WasmError, r: BinParserResult) -> bool {
		match (r) {
			Ok(module) => {
				t.fail1("expected error %s, but passed", expected.name);
				return false;
			}
			Error(code, filename, error_pos, error_msg) => {
				if (code == expected) return true;
				var buf = StringBuffer.new();
				buf.put2("expected error %s, but got %s: ", expected.name, code.name);
				buf.put2("@+%d %s", error_pos, error_msg);
				t.fail(buf.extract());
				return false;
			}
		}
	}
	def assert_valid(r: BinParserResult) -> bool {
		match (r) {
			Ok(module) => return true;
			Error(code, filename, error_pos, error_msg) => {
				var buf = StringBuffer.new();
				buf.put1("expected success, but got %s: ", code.name);
				buf.put2("@+%d %s", error_pos, error_msg);
				t.fail(buf.extract());
				return false;
			}
		}
	}
	def mp() -> ModuleParser {
		var v = if (wizeng.verbose, Verbosity.VERBOSE, Verbosity.SILENT);
		return ModuleParser.new(v, "test");
	}
}

def VALID_HEADER = BinUtil.WASM_HEADER;

def test_empty(t: BinParserTester) {
	for (i = 1; i <= 1; i++) {
		var mod = Arrays.range(VALID_HEADER, 0, i);
		t.invalid(WasmError.INVALID_HEADER, mod);
	}
}

def test_magic(t: BinParserTester) {
	def template = Arrays.range(VALID_HEADER, 0, VALID_HEADER.length);
	for (i < 4) {
		var prev = template[i];
		template[i] = 0xFF;
		t.invalid(WasmError.INVALID_HEADER, template);
		template[i] = prev;
	}
}

def test_version(t: BinParserTester) {
	def template = Arrays.range(VALID_HEADER, 0, VALID_HEADER.length);
	for (i = 4; i < 8; i++) {
		var prev = template[i];
		template[i] = 0xFF;
		t.invalid(WasmError.INVALID_HEADER, template);
		template[i] = prev;
	}
}

def test_buf_offset(t: BinParserTester) {
	def len = VALID_HEADER.length;
	var buffer = Array<byte>.new(3 * len);
	for (i < (len * 2) + 1) {
		Arrays.copyInto(buffer, i, VALID_HEADER, 0, len);
		var m = t.mp();
		m.push(buffer, i, len);
		t.assert_valid(m.finish());
	}
}

def test_hdr_split(t: BinParserTester) {
	def template = VALID_HEADER;
	t.test_split = true;
	t.valid(template);
}

def COUNTED_SECTIONS = [
	BpSection.Type,
	BpSection.Import,
	BpSection.Function,
	BpSection.Table,
	BpSection.Memory,
	BpSection.Global,
	BpSection.Export,
	BpSection.Element,
	BpSection.Code,
	BpSection.Data
];

def EMPTY_FUNC_TYPE: Array<byte> = [
	BpTypecon.Function.code, 0, 0
];
def ONE_FUNC_TYPES_SECTION: Array<byte> = [
	BpSection.Type.code, 4, 1, BpTypecon.Function.code, 0, 0
];
def ONE_FUNC_DECL_SECTION: Array<byte> = [
	BpSection.Function.code, 2, 1, 0
];
def ONE_GLOBAL_SECTION: Array<byte> = [
	BpSection.Global.code, 6, 1, BpTypecon.I32.code, 0,
		Opcode.I32_CONST.code, 0, Opcode.END.code
];
def ONE_PAGE_MEMORY_SECTION: Array<byte> = [
	BpSection.Memory.code, 3, 1, 0, 1
];

class SingleEmptySectionTemplate {
	def len = VALID_HEADER.length;
	def template = Array<byte>.new(len + 3);
	def code_pos = len, size_pos = len + 1, count_pos = len + 2;
	new() {
		Arrays.copyInto(template, 0, VALID_HEADER, 0, len);
		template[size_pos] = 1;
		template[count_pos] = 0;
	}
	def set(sect: BpSection, size: int, count: int) {
		template[code_pos] = sect.code;
		template[size_pos] = byte.!(size);
		template[count_pos] = byte.!(count);
	}
}

def test_sect_empty(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// valid case
		s.set(sect, 1, 0);
		t.valid(s.template);
	}
}

def test_sect_empty_s(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	t.test_split = true;
	for (sect in COUNTED_SECTIONS) {
		// valid case
		s.set(sect, 1, 0);
		t.valid(s.template);
	}
}

def test_sect_underflow(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// Section read size smaller than expected
		s.set(sect, 2, 0);
		t.invalid(WasmError.INCOMPLETE_SECTION, s.template);
	}
}

def test_sect_size0(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// Section size not large enough to even include count
		s.set(sect, 0, 0);
		t.invalid(WasmError.OVERFLOW_SECTION, s.template);
	}
}

def test_sect_eof(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// EOF before first item
		if (sect == BpSection.Code) continue; // extra count check
		s.set(sect, 1, 1);
		t.invalid(WasmError.OVERFLOW_SECTION, s.template);
	}
}

def test_sect_custom(t: BinParserTester) {
	var b = BinBuilder.new().put_header();
	t.test_split = true;
	b.add(BpSection.Unknown.code);
	var len = b.size();
	for (i < 5) {
		b.resize(len);
		b.put_u32leb(u32.!(11 + i));
		b.put_string("my_section");
		for (j < i) b.add(77);
		t.validN(b.storage());
	}
}

def test_sect_custom_ovf(t: BinParserTester) {
	def name = "x_section";
	var b = BinBuilder.new().put_header();
	b.add(BpSection.Unknown.code);
	var len = b.size();
	for (i = name.length; i >= 0; i--) {
		b.resize(len);
		b.put_u32leb(u32.!(i));
		b.put_string(name);
		var x = b.storage();
		t.invalidN(WasmError.OVERFLOW_SECTION, x.0, x.1, x.2);
	}
}

def test_types0(t: BinParserTester) {
	def EMPTY_FUNC: Array<byte> = [BpTypecon.Function.code, 0, 0];
	var b = BinBuilder.new().put_header();
	var len = b.size();
	for (i < 5) {
		b.resize(len);
		b.beginShortSection(BpSection.Type);
		b.put_u32leb(u32.!(i));
		for (j < i) b.addv(EMPTY_FUNC);
		b.endSection();
		t.validN(b.storage());
	}
}

def test_types1(t: BinParserTester) {
	var b = BinBuilder.new().put_header();
	var len = b.size();
	for (count < 3) {
		for (p < 3) {
			for (r < 2) { // ext:multi-value
				b.resize(len);
				b.beginShortSection(BpSection.Type);
				b.put_u32leb(u32.!(count));
				for (j < count) {
					b.add(BpTypecon.Function.code);
					b.add(byte.!(p));
					for (k < p) b.add(BpTypecon.I32.code);
					b.add(byte.!(r));
					for (k < r) b.add(BpTypecon.F32.code);
				}
				b.endSection();
				t.validN(b.storage());
			}
		}
	}
}

class BinSectionTester(t: BinParserTester, pre: Array<byte>, sect: BpSection) {
	def b = BinBuilder.new();
	var len: int;
	new() {
		b.put_header();
		if (pre != null) b.addv(pre);
		len = b.size();
	}
	def valid(raw: Array<byte>) {
		b.resize(len);
		b.beginSection(sect);
		b.addv(raw);
		b.endSection();
		t.validN(b.storage());
	}
	def invalid(err: WasmError, raw: Array<byte>) {
		b.resize(len);
		b.beginSection(sect);
		b.addv(raw);
		b.endSection();
		var x = b.storage();
		t.invalidN(err, x.0, x.1, x.2);
	}
}

def test_imports0(t: BinParserTester) {
	t.test_split = true;
	var s = BinSectionTester.new(t, ONE_FUNC_TYPES_SECTION, BpSection.Import);
	s.valid([1, 1, 'M', 1, 'g',
		BpImportExportKind.Function.code, 0]);
	s.valid([1, 1, 'N', 1, 'h',
		BpImportExportKind.Table.code, BpTypecon.AnyFunc.code, 0, 0]);
	s.valid([1, 1, 'O', 1, 'i',
		BpImportExportKind.Memory.code, 0, 0]);
	s.valid([1, 1, 'P', 1, 'j',
		BpImportExportKind.Global.code, BpTypecon.I32.code, 0]);
}

def test_imports1(t: BinParserTester) {
	var s = BinSectionTester.new(t, null, BpSection.Import);
	s.invalid(WasmError.INVALID_IMPORT_KIND,
		[1, 1, 'P', 1, 'j', /*invalid*/4]);
	s.invalid(WasmError.OOB_INDEX,
		[1, 1, 'M', 1, 'g', BpImportExportKind.Function.code, /*oob*/0]);
	s.invalid(WasmError.EXCEEDED_LIMIT, [1, 1, 'O', 1, 'i',
		BpImportExportKind.Memory.code, 0, /*limit*/0xFF, 0xFF, 0xFF, 0x0]);
	s.invalid(WasmError.INVALID_TYPE, [1, 1, 'P', 1, 'j',
		BpImportExportKind.Global.code, /*invalid*/0x2C, 0]);
}

def testCountedSection(t: BinParserTester, max: int, sect: BpSection,
	pre: Array<byte>, entry: Array<byte>) {

	// Test up to 3 valid entries.
	t.test_split = true;
	var b = BinBuilder.new().put_header();
	if (pre != null) b.addv(pre);
	var len = b.size();
	for (count < max+1) {
		b.resize(len);
		b.beginShortSection(sect);
		b.put_u32leb(u32.!(count));
		for (j < count) b.addv(entry);
		b.endSection();

		t.validN(b.storage()); // test splitting the module at all offsets
	}
	var raw = b.extract();

	// Test truncated module by up to 3 entries.
	for (cut = 1; cut < entry.length * max; cut++) {
		var m = t.mp();
		m.push(raw, 0, raw.length - cut);
		t.assert_invalid(WasmError.INCOMPLETE_SECTION, m.finish());
	}
}

def test_typesN(t: BinParserTester) {
	testCountedSection(t, 3, BpSection.Type, null, [
		BpTypecon.Function.code, 1, BpTypecon.I32.code, 1, BpTypecon.I32.code
	]);
}

def test_importsN(t: BinParserTester) {
	testCountedSection(t, 3, BpSection.Import, null, [
		1, 'M', 1, 'g', BpImportExportKind.Global.code, BpTypecon.I32.code, 0
	]);
}

def test_funcsN(t: BinParserTester) {
	testCountedSection(t, 3, BpSection.Function, ONE_FUNC_TYPES_SECTION, [0]);
}

def test_tablesN(t: BinParserTester) {
	testCountedSection(t, 1/*ext:bulk-memory*/, BpSection.Table, null, [
		BpTypecon.AnyFunc.code, 0, 0
	]);
}

def test_memoriesN(t: BinParserTester) {
	testCountedSection(t, 1/*ext:multi-memory*/, BpSection.Memory, null, [
		0, 0
	]);
}

def test_globalsN(t: BinParserTester) {
	testCountedSection(t, 3, BpSection.Global, null, [
		BpTypecon.I32.code, 0, Opcode.I32_CONST.code, 0, Opcode.END.code
	]);
}

def test_exportsN(t: BinParserTester) {
	testCountedSection(t, 3, BpSection.Export, ONE_GLOBAL_SECTION, [
		1, 'g', BpImportExportKind.Global.code, 0
	]);
}

def test_elementsN(t: BinParserTester) {
	var b = BinBuilder.new();
	// Add one type
	b.addv(ONE_FUNC_TYPES_SECTION);
	// Add one function
	b.addv(ONE_FUNC_DECL_SECTION);
	// Add one table
	b.beginShortSection(BpSection.Table);
	b.addv([1, BpTypecon.AnyFunc.code, 0, 5]);
	b.endSection();
	var setup = b.extract();

	testCountedSection(t, 3, BpSection.Element, setup, [
		0, Opcode.I32_CONST.code, 0, Opcode.END.code, 3, 0, 0, 0
	]);
}

def test_dataN(t: BinParserTester) {
	testCountedSection(t, 3, BpSection.Data, ONE_PAGE_MEMORY_SECTION, [
		0, Opcode.I32_CONST.code, 0, Opcode.END.code, 3, 'a', 'b', 'c'
	]);
}

// TODO: positive/negative tests for each of the counted section elements
// TODO: split / stream tests for more valid modules
// TODO: test all WasmError kinds
// TODO: limit tests for every kind of quantity whereever it can occur
// TODO: section constraints
// TODO: maximum number of memories / tables with extension config
// TODO: repeated sections

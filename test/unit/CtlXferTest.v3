// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, CtlXferTester.new, _);
def X = [
	T("ctlxfer/br1", test_br0),
	T("ctlxfer/br1", test_br1),
	()
];

class CtlXferTester(t: Tester) {
	var func_sig = SigCache.i_i;
	var orig: Array<byte>;
	var func: FunctionDecl;
	def sig(sig: TypeDecl.Function) -> this {
		func_sig = sig;
	}
	def code(raw: Array<byte>) -> this {
		var copy = Vector<byte>.new();
		copy.add(0); // no locals
		copy.addv(raw);
		copy.add(WasmOpcode.END.code);
		orig = copy.extract();
		func = FunctionDecl.new(false, 0, func_sig);
		func.code = FunctionCode.new(orig);
		var v = CodeValidator.new(null);
		var ok = v.validate(func);
		if (!ok) t.fail("invalid code");
	}
	def dump() {
		var x = func.code.ctl_xfer;
		if (x == null) {
			System.puts("0 ctl_xfer entries\n");
			return;
		}
		var buf = StringBuffer.new();
		buf.put1("%d ctl_xfer entries:\n", x.length);
		for (i < x.length) {
			var e = x[i];
			buf.put2("  #%d@+%d: ", i, int.!(e.0));
			buf.put3("dpc=%d valcount=%d popcount=%d\n", int.!(e.1), int.!(e.2), int.!(e.3));
		}
		System.puts(buf.extract());
	}
	def assert(pc: int, dpc: int, valcount: int, popcount: int) {
		var x = func.code.ctl_xfer;
		if (x == null) return t.fail("empty ctl_xfer entries");
		var last = 0, found = false;
		for (i < x.length) {
			var e = x[i];
			if (e.0 < last) return t.fail("ctl_xfer entries not sorted");
			if (e.0 != pc) continue;
			if (found) return t.fail1("duplicate entry for pc +%d", pc);
			found = true;
			if (e.1 != dpc) return t.fail2("dpc=%d, expected %d", int.!(e.1), dpc);
			if (e.2 != valcount) return t.fail2("valcount=%d, expected %d", int.!(e.2), valcount);
			if (e.3 != popcount) return t.fail2("popcount=%d, expected %d", int.!(e.3), popcount);
		}
		if (!found) return t.fail1("entry not found for pc %d", pc);
	}
}

def test_br0(t: CtlXferTester) {
	t.sig(SigCache.v_v);
	t.code([WasmOpcode.BR.code, 0]);
//	t.dump();
	t.assert(1, 2, 0, 0);

	t.code([WasmOpcode.BR.code, 0, WasmOpcode.BR.code, 0]);
//	t.dump();
	t.assert(1, 4, 0, 0);
	t.assert(3, 2, 0, 0);
}

def test_br1(t: CtlXferTester) {
	t.sig(SigCache.i_i);
	t.code([WasmOpcode.I32_CONST.code, 0,
		WasmOpcode.BR.code, 0]);
//	t.dump();
	t.assert(3, 2, 1, 0);

	t.code([WasmOpcode.I32_CONST.code, 3,
		WasmOpcode.BR.code, 0,
		WasmOpcode.I32_CONST.code, 4,
		WasmOpcode.BR.code, 0]);
//	t.dump();
	t.assert(3, 6, 1, 0);
	t.assert(7, 2, 1, 0);
	
	t.code([WasmOpcode.I32_CONST.code, 3,
		WasmOpcode.I32_CONST.code, 3,
		WasmOpcode.BR.code, 0,
		WasmOpcode.I32_CONST.code, 4,
		WasmOpcode.BR.code, 0]);
//	t.dump();
	t.assert(5, 6, 1, 1);
	t.assert(9, 2, 1, 0);
}

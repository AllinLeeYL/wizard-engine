// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, CtlXferTester.new, _);
def X = [
	T("ctlxfer/br0", test_br0),
	T("ctlxfer/br1", test_br1),
	T("ctlxfer/if0", test_if0),
	()
];

class CtlXferTester(t: Tester) extends ModuleBuilder {
	def codev(raw: Array<byte>) -> this {
		code(raw);
		var ok = validate();
		if (!ok) t.fail("invalid code");
	}
	def dump() {
		var x = func.code.ctl_xfer;
		if (x == null) {
			System.puts("0 ctl_xfer entries\n");
			return;
		}
		var buf = StringBuffer.new();
		buf.put1("%d ctl_xfer entries:\n", x.length);
		for (i < x.length) {
			var e = x[i];
			buf.put2("  #%d@+%d: ", i, int.!(e.0));
			buf.put3("dpc=%d valcount=%d popcount=%d\n", int.!(e.1), int.!(e.2), int.!(e.3));
		}
		System.puts(buf.extract());
	}
	def assert(pc: int, dpc: int, valcount: int, popcount: int) {
		var x = func.code.ctl_xfer;
		if (x == null) return t.fail("empty ctl_xfer entries");
		var last = 0, found = false;
		for (i < x.length) {
			var e = x[i];
			if (e.0 < last) return t.fail("ctl_xfer entries not sorted");
			if (e.0 != pc) continue;
			if (found) return t.fail1("duplicate entry for pc +%d", pc);
			found = true;
			if (e.1 != dpc) return t.fail2("dpc=%d, expected %d", int.!(e.1), dpc);
			if (e.2 != valcount) return t.fail2("valcount=%d, expected %d", int.!(e.2), valcount);
			if (e.3 != popcount) return t.fail2("popcount=%d, expected %d", int.!(e.3), popcount);
		}
		if (!found) return t.fail1("entry not found for pc %d", pc);
	}
}

def K = WasmOpcode.I32_CONST.code;
def BR = WasmOpcode.BR.code;
def END = WasmOpcode.END.code;
def BLOCK = WasmOpcode.BLOCK.code;
def IF = WasmOpcode.IF.code;
def ELSE = WasmOpcode.ELSE.code;
def N = BpTypecon.EmptyBlock.code;

def test_br0(t: CtlXferTester) {
	t.sig(SigCache.v_v);
	t.codev([BR, 0]);
	t.assert(1, 2, 0, 0);

	t.codev([BR, 0, BR, 0]);
	t.assert(1, 4, 0, 0);
	t.assert(3, 2, 0, 0);
	
	t.sig(SigCache.i_i);
	t.codev([K, 0,
		BR, 0]);
	t.assert(3, 2, 1, 0);

	t.codev([K, 3,
		BR, 0,
		K, 4,
		BR, 0]);
	t.assert(3, 6, 1, 0);
	t.assert(7, 2, 1, 0);
	
	t.codev([K, 3,
		K, 3,
		BR, 0,
		K, 4,
		BR, 0]);
	t.assert(5, 6, 1, 1);
	t.assert(9, 2, 1, 0);
}

def test_br1(t: CtlXferTester) {
	t.sig(SigCache.v_v);
	t.codev([BLOCK, N, BR, 0, END]);
	t.assert(3, 2, 0, 0);

	t.codev([BLOCK, N, BR, 1, END]);
	t.assert(3, 3, 0, 0);
	// TODO: tests with depth > 1
}

def test_if0(t: CtlXferTester) {
	t.sig(SigCache.v_v);
	t.codev([K, 0, IF, N, ELSE, END]);
	t.assert(3, 3, 0, 0);
	t.assert(5, 1, 0, 0);
}
// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, CtlXferTester.new, _);
def X = [
	T("ctlxfer:raw1", test_raw1),
	T("ctlxfer:raw2", test_raw2),
	T("ctlxfer:br0", test_br0),
	T("ctlxfer:br1", test_br1),
	T("ctlxfer:if0", test_if0),
	T("ctlxfer:relative", test_relative),
	T("ctlxfer:br_table0", test_br_table0),
	T("ctlxfer:br_loop_val", test_br_loop_val),
	()
];

class CtlXferTester(t: Tester) extends ModuleBuilder {
	def codev(raw: Array<byte>) -> this {
		code(raw);
		var r = v().validateFunc(func);
		match (r) {
			Ok => ;
			Error(error, pc, msg) => t.fail2("invalid code @+%d: %s", pc, msg);
		}
		if (Trace.verify) dump();
	}
	def dump() {
		var x = func.code.ctl_xfer;
		if (x == null) {
			System.puts("0 ctl_xfer entries\n");
			return;
		}
		var buf = StringBuilder.new();
		buf.put1("%d ctl_xfer entries:\n", x.length);
		for (i < x.length) {
			var e = x[i];
			buf.put2("  #%d@+%d: ", i, int.!(e.0));
			buf.put3("dpc=%d valcount=%d popcount=%d\n", int.!(e.1), int.!(e.2), int.!(e.3));
		}
		System.puts(buf.extract());
	}
	def assert(pc: int, dpc: int, valcount: int, popcount: int) {
		assert_entry(func.code.ctl_xfer, pc, dpc, valcount, popcount);
	}
	def assert_entry(x: Array<(u23, i23, u10, u23)>, pc: int, dpc: int, valcount: int, popcount: int) {
		if (x == null) return t.fail("empty ctl_xfer entries");
		var last = 0, found = false;
		for (i < x.length) {
			var e = x[i];
			if (e.0 < last) return t.fail("ctl_xfer entries not sorted");
			if (e.0 != pc) continue;
			if (found) return t.fail1("duplicate entry for pc +%d", pc);
			found = true;
			if (e.1 != dpc) return t.fail2("dpc=%d, expected %d", int.!(e.1), dpc);
			if (e.2 != valcount) return t.fail2("valcount=%d, expected %d", int.!(e.2), valcount);
			if (e.3 != popcount) return t.fail2("popcount=%d, expected %d", int.!(e.3), popcount);
		}
		if (!found) return t.fail1("entry not found for pc %d", pc);
	}
	def v() -> CodeValidator {
		return CodeValidator.new(extensions,
			Limits.new().set(extensions),
			module,
			WasmErrorGen.new(module.filename));
	}
}

def K = Opcode.I32_CONST.code;
def BR = Opcode.BR.code;
def END = Opcode.END.code;
def BLOCK = Opcode.BLOCK.code;
def LOOP = Opcode.LOOP.code;
def IF = Opcode.IF.code;
def ELSE = Opcode.ELSE.code;
def N = BpTypecon.EmptyBlock.code;
def I = BpTypecon.I32.code;

def test_raw1(t: CtlXferTester) {
	var b = CtlXferBuilder.new(null);
	var ce = ControlEntry.new();
	ce.start_pos = 40;
	ce.sig = SigCache.v_v;
	b.refV(ce, 55, 0, 0);
	b.refV(ce, 56, 1, 1);
	b.refV(ce, 66, 3, 4);
	b.bind(ce, 60);
	var entries = b.extract();
	t.assert_entry(entries, 55, 5, 0, 0);
	t.assert_entry(entries, 56, 4, 1, 1);
	t.assert_entry(entries, 66, -6, 3, 4);
}

def test_raw2(t: CtlXferTester) {
	var b = CtlXferBuilder.new(null);
	var ce = ControlEntry.new();
	ce.start_pos = 30;
	ce.val_stack_top = 1;
	ce.sig = SigCache.v_i;
	var val_stack = Stack<ValueType>.new();
	val_stack.push(ValueType.I32);
	val_stack.push(ValueType.I32);

	b.refS(ce, 35, val_stack); // 2 elems -> 1 val, pop 0

	val_stack.push(ValueType.I32);
	b.refS(ce, 36, val_stack); // 3 elems -> 1 val, pop 1

	val_stack.push(ValueType.I32);
	b.refS(ce, 66, val_stack); // 4 elems -> 1 val, pop 2

	b.bind(ce, 50);

	var entries = b.extract();
	t.assert_entry(entries, 35, 15, 1, 0);
	t.assert_entry(entries, 36, 14, 1, 1);
	t.assert_entry(entries, 66, -16, 1, 2);
}

def test_br0(t: CtlXferTester) {
	t.sig(SigCache.v_v);
	t.codev([BR, 0]);
	t.assert(1, 2, 0, 0);

	t.codev([BR, 0, BR, 0]);
	t.assert(1, 4, 0, 0);
	t.assert(3, 2, 0, 0);

	t.sig(SigCache.i_i);
	t.codev([K, 0,
		BR, 0]);
	t.assert(3, 2, 1, 0);

	t.codev([K, 3,
		BR, 0,
		K, 4,
		BR, 0]);
	t.assert(3, 6, 1, 0);
	t.assert(7, 2, 1, 0);

	t.codev([K, 3,
		K, 3,
		BR, 0,
		K, 4,
		BR, 0]);
	t.assert(5, 6, 1, 1);
	t.assert(9, 2, 1, 0);
}

def test_br1(t: CtlXferTester) {
	t.sig(SigCache.v_v);
	t.codev([BLOCK, N, BR, 0, END]);
	t.assert(3, 2, 0, 0);

	t.codev([BLOCK, N, BR, 1, END]);
	t.assert(3, 3, 0, 0);
	// TODO: tests with depth > 1
}

def test_if0(t: CtlXferTester) {
	t.sig(SigCache.v_v);
	t.codev([K, 0, IF, N, ELSE, END]);
	t.assert(3, 3, 0, 0);
	t.assert(5, 1, 0, 0);
}

def test_relative(t: CtlXferTester) {
	t.sig(SigCache.v_v);
	def code: Array<byte> = [K, 0, IF, N, ELSE, END];
	t.code(code);
	var v = t.v();
	var d = Decoder.new([0, 0, 0, 0], v.err);
	d.append(0, code, 0, code.length);
	d.skip_bytes(3);  // make sure entries are encoded relative to start pos.
	v.validate(t.func, d);
	t.assert(3, 3, 0, 0);
	t.assert(5, 1, 0, 0);
}

def test_br_table0(t: CtlXferTester) {
	t.sig(SigCache.v_v);
	t.codev([K, 1,
		Opcode.BR_TABLE.code, 2,
		0, 0, 0]);
	t.assert(3, 3, 0, 0);
	t.assert(4, 4, 0, 0);
	t.assert(5, 3, 0, 0);
	t.assert(6, 2, 0, 0);
}

def test_br_loop_val(t: CtlXferTester) {
	t.sig(SigCache.v_i);
	t.codev([LOOP, I,
		K, 0,
		BR, 0,
		END]);
	t.assert(5, -4, 0, 1);
}
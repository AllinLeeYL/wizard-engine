// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.register;
def X = [
	T("leb/i32", test_i32),
	T("leb/u32", test_u32),
	T("leb/i64", test_i64),
	T("leb/u64", test_u64),
	()
];
def assertOk<I>(t: Tester, f: Decoder -> I, bytes: Array<byte>, expected_len: int, expected_val: I) {
	var d = Decoder.new(bytes, ErrorGen.new());
	var result = f(d);
	if (!d.err.ok()) t.fail("decoding failed"); // TODO: msg
	if (d.pos != expected_len) t.fail("wrong length"); // TODO: msg
	if (result != expected_val) t.fail("wrong result"); // TODO: msg
}
def assertError<I>(t: Tester, f: Decoder -> I, bytes: Array<byte>) {
	var d = Decoder.new(bytes, ErrorGen.new());
	var result = f(d);
	if (d.err.ok()) t.fail("expected error");
}
// Signed 32-bit LEB unit tests.
def test_i32(t: Tester) {
	def ok = assertOk(t, Decoder.read_i32leb, _, _, _);
	ok([0x00], 1, 0);
	ok([0x01], 1, 1);
	ok([0x0D], 1, 13);
	ok([0x70], 1, -16);
	ok([0x0F, 0x00], 1, 15);
	ok([0x1F, 0x06], 1, 31);

	ok([0x74], 1, -12); 
	ok([0xF3, 0x7F], 2, -13); 
	ok([0xF1, 0xFF, 0x7F], 3, -15); 

	ok([0xA7, 0x7F], 2, -89);
	ok([0xA7, 0xFF, 0x7F], 3, -89);
	ok([0xA7, 0xFF, 0xFF, 0x7F], 4, -89);
	ok([0xA7, 0xFF, 0xFF, 0x7F], 4, -89);
	ok([0xA7, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F], 6, -89);

	ok([0x80, 0x01], 2, 128);
	ok([0x83, 0x80, 0x03], 3, 49155);
	ok([0x83, 0x80, 0x83, 0x00], 4, 49155);
	ok([0x83, 0x80, 0x83, 0x80, 0x00], 5, 49155);
	ok([0x83, 0x80, 0x83, 0x80, 0x80, 0x00], 6, 49155);

	ok([0b10110000, 0b10010100, 0b11101111, 0b11100111, 0b0011], 5, 1023134256);

	def err = assertError(t, Decoder.read_i32leb, _);
	err([0x80]);
	err([0x8E, 0x8E]);
	err([0x9E, 0x9F, 0x99]);
	err([0xFF, 0xFF, 0xFF, 0xFF]);

	err([0x83, 0x80, 0x83, 0x80, 0x80, 0x01]);
	err([0xA7, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E]);
	err([0b10110000, 0b10010100, 0b11101111, 0b11100111, 0b10011]);
}
// Unsigned 32-bit LEB unit tests.
def test_u32(t: Tester) {
	def ok = assertOk(t, Decoder.read_u32leb, _, _, _);
	ok([0x70], 1, 112);
	ok([0xA7, 0x7F], 2, 16295);
	ok([0xA7, 0xFE, 0x7F], 3, 2096935);
	ok([0xA7, 0xFE, 0xFD, 0x7F], 4, 268402471);
	ok([0xA7, 0xF0, 0xF1, 0xF2, 0x0E], 5, 3999037479u);
	ok([0xA7, 0xF0, 0xF1, 0xF2, 0x8E, 0x00], 6, 3999037479u);

	def err = assertError(t, Decoder.read_u32leb, _);
	err([0xA7, 0xF0, 0xF1, 0xF2, 0x1E]);
	err([0xA7, 0xF0, 0xF1, 0xF2, 0xFE]);
	err([0xA7, 0xF0, 0xF1, 0xF2, 0x80, 0x01]);
}
// Signed 64-bit LEB unit tests.
def test_i64(t: Tester) {
	def ok = assertOk(t, Decoder.read_i64leb, _, _, _);
	ok([0x00], 1, 0);
	ok([0x01], 1, 1);
	ok([0x0D], 1, 13);
	ok([0x70], 1, -16);

	ok([0xA7, 0x7F], 2, -89);
	ok([0xA6, 0xFF, 0x7F], 3, -90);
	ok([0xA5, 0xFF, 0xFF, 0x7F], 4, -91);
	ok([0xA4, 0xFF, 0xFF, 0x7F], 4, -92);
	ok([0xA3, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F], 6, -93);
	ok([0xA3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F], 7, -93);
	ok([0xA3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F], 8, -93);
	ok([0xA3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F], 9, -93);
	ok([0xA3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F], 10, -93);
	ok([0xA3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F], 11, -93);

	ok([0xF4, 0xD2, 0xA6, 0x87, 0x01], 5, 283748724);

	ok([0x81, 0x81, 0x81, 0x81, 0x01], 5, 270549121);
	ok([0x81, 0x82, 0x83, 0x84, 0x05], 5, 1350615297);
	ok([0x81, 0x82, 0x83, 0x84, 0x85, 0x06], 6, 207509045505);
	ok([0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x07], 7, 30993834623233);
	ok([0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x08], 8, 4534593461993729);
	ok([0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x09], 9, 653052939803345153);

	def err = assertError(t, Decoder.read_i64leb, _);
	err([0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x08]);
	err([0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x80, 0x01]);
	err([0xA3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x6F]);
	err([0xA3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E]);
}
// Unsigned 64-bit LEB unit tests.
def test_u64(t: Tester) {
	def ok = assertOk(t, Decoder.read_u64leb, _, _, _);
	ok([0x00], 1, 0);
	ok([0x01], 1, 1);
	ok([0x0D], 1, 13);
	ok([0x70], 1, 112);

	ok([0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x09], 9, 653052939803345153);
	ok([0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x00], 10, 653052939803345153);
	ok([0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x80, 0x00], 11, 653052939803345153);

	def err = assertError(t, Decoder.read_u64leb, _);
	err([0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x02]);
	err([0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x80, 0x01]);
}

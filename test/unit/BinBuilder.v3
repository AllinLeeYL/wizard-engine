// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A utility class for building binary modules.
class BinBuilder extends Vector<byte> {
	private var sect_body_start = -1;
	private var sect_size_pos = -1;

	def reset_header() -> this {
		var len = BinUtil.WASM_HEADER.length;
		if (size() < len) {
			resize(0);
			addv(BinUtil.WASM_HEADER);
		} else {
			resize(len);
		}
	}
	def put(bytes: Array<byte>) -> this {
		addv(bytes);
	}
	def put_u32leb(val: u32) -> this {
		var l = size();
		resize(l + 5);
		var r = write_u32leb(l, val);
		resize(l + r);
	}
	def put_ValueType(typ: ValueType) -> this {
		match (typ) {
			I32 => add(BpTypecon.I32.code);
			I64 => add(BpTypecon.I64.code);
			F32 => add(BpTypecon.F32.code);
			F64 => add(BpTypecon.F64.code);
			VEC128 => add(BpTypecon.VEC128.code);
			ANYREF => add(BpTypecon.AnyRef.code);
		}
	}
	def put_string(str: string) -> this {
		put_u32leb(u32.!(str.length));
		addv(str);
	}
	def put_FuncType(t: TypeDecl.Function) -> this {
		add(BpTypecon.Function.code);
		put_u32leb(u32.!(t.params.length));
		for (p in t.params) put_ValueType(p);
		put_u32leb(u32.!(t.results.length));
		for (r in t.results) put_ValueType(r);
	}
	// Begin a new section
	def beginSection(sect: BpSection) -> this {
		endSection();
		add(sect.code);
		sect_size_pos = size();
		for (i < 5) add(0);
		sect_body_start = size();
	}
	// Begin a new section which is expected to be less than 64 bytes long
	def beginShortSection(sect: BpSection) -> this {
		endSection();
		add(sect.code);
		sect_size_pos = size();
		add(0);
		sect_body_start = size();
	}
	// End the current section and patch its size
	def endSection() -> this {
		if (sect_body_start < 0) return;
		var size = size() - sect_body_start;
		var short = (sect_body_start == sect_size_pos + 1);
		if (short) this[sect_size_pos] = byte.!(size);
		else patch_u32leb(sect_size_pos, u32.!(size));
		sect_size_pos = -1;
		sect_body_start = -1;
	}
	private def write_u32leb(index: int, val: u32) -> int {
		var start = index;
		while (true) {
			var b = byte.!(val & 0x7f);
			var n = val >> 7;
			if (n == 0) {
				this[index++] = b;
				break;
			} else {
				this[index++] = b | byte.!(0x80);
				val = n;
			}
		}
		return index - start;
	}
	private def patch_u32leb(index: int, val: u32) {
		for (i < 4) {
			this[index++] = byte.!(val | 0x80);
			val = val >> 7;
		}
		this[index++] = byte.!(val);
	}
}
component BinUtil {
	def WASM_HEADER: Array<byte> = [
		0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00
	];
}

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.register;
def X: Array<Value>;
def NONE = BpTypecon.EmptyBlock.code;

// Registers a "unop" opcode test
def reg1<X, Z>(opcode: WasmOpcode,
		f: (Tester, WasmOpcode, Array<(Z, X)>) -> void,
		cases: Array<(Z, X)>) {
	var buf = StringBuffer.new();
	buf.put1("interp/%s", opcode.mnemonic);
	UnitTests.register(buf.extract(), f(_, opcode, cases));
}

// Registers a "binop" opcode test
def reg2<I, R>(opcode: WasmOpcode,
		f: (Tester, WasmOpcode, Array<(R, (I, I))>) -> void,
		cases: Array<(R, (I, I))>) {
	var buf = StringBuffer.new();
	buf.put1("interp/%s", opcode.mnemonic);
	UnitTests.register(buf.extract(), f(_, opcode, cases));
}

// Runs a "unop" opcode test
def test_x_z<X, Z>(t: Tester, opcode: WasmOpcode, sig: TypeDecl.Function,
	cases: Array<(Z, X)>,
	xv: X -> Value, zv: Z -> Value) {
	def i = InterpreterTester.new(t);
	i.sig(sig);
	i.code([WasmOpcode.LOCAL_GET.code, 0, WasmOpcode.LOCAL_GET.code, 1, opcode.code]);
	for (c in cases) {
		i.assert_r(Result.Value([zv(c.0)]), [xv(c.1)]);
	}
}
// Runs a "binop" opcode test that returns values
def test_xy_z<X, Y, Z>(t: Tester, opcode: WasmOpcode, sig: TypeDecl.Function,
	cases: Array<(Z, (X, Y))>,
	xv: X -> Value, yv: Y -> Value, zv: Z -> Value) {
	def i = InterpreterTester.new(t);
	i.sig(sig);
	i.code([WasmOpcode.LOCAL_GET.code, 0, WasmOpcode.LOCAL_GET.code, 1, opcode.code]);
	for (c in cases) {
		i.assert_r(Result.Value([zv(c.0)]), [xv(c.1.0), yv(c.1.1)]);
	}
}
// Runs a "binop" opcode test that may generate traps
def test_xy_r<X, Y>(t: Tester, opcode: WasmOpcode, sig: TypeDecl.Function,
	cases: Array<(Result, (X, Y))>,
	xv: X -> Value, yv: Y -> Value) {
	def i = InterpreterTester.new(t);
	i.sig(sig);
	i.code([WasmOpcode.LOCAL_GET.code, 0, WasmOpcode.LOCAL_GET.code, 1, opcode.code]);
	for (c in cases) {
		i.assert_r(c.0, [xv(c.1.0), yv(c.1.1)]);
	}
}
def T_u_u = reg1(_, test_x_z(_, _, SigCache.i_i, _, Values.u_v, Values.u_v), _);
def T_w_w = reg1(_, test_x_z(_, _, SigCache.l_l, _, Values.w_v, Values.w_v), _);

def T_ii_i = reg2(_, test_xy_z(_, _, SigCache.ii_i, _, Values.i_v, Values.i_v, Values.i_v), _);
def T_uu_u = reg2(_, test_xy_z(_, _, SigCache.ii_i, _, Values.u_v, Values.u_v, Values.u_v), _);
def T_ii_r = reg2(_, test_xy_r(_, _, SigCache.ii_i, _, Values.i_v, Values.i_v), _);
def T_uu_r = reg2(_, test_xy_r(_, _, SigCache.ii_i, _, Values.u_v, Values.u_v), _);
def T_ll_l = reg2(_, test_xy_z(_, _, SigCache.ll_l, _, Values.l_v, Values.l_v, Values.l_v), _);
def T_ww_w = reg2(_, test_xy_z(_, _, SigCache.ll_l, _, Values.w_v, Values.w_v, Values.w_v), _);
def T_ll_u = reg2(_, test_xy_z(_, _, SigCache.ll_i, _, Values.l_v, Values.l_v, Values.u_v), _);
def T_ww_u = reg2(_, test_xy_z(_, _, SigCache.ll_i, _, Values.w_v, Values.w_v, Values.u_v), _);


def ri32(val: i32) -> Result {
	return Result.Value([Value.I32(u32.!(val))]);
}
def ru32(val: u32) -> Result {
	return Result.Value([Value.I32(val)]);
}
def ri64(val: i64) -> Result {
	return Result.Value([Value.I64(u64.!(val))]);
}
def ru64(val: u64) -> Result {
	return Result.Value([Value.I64(val)]);
}

//===========================================================
// Begin registration of all tests
//===========================================================
def Z = [
	T("interp/unreachable", w(test_unreachable)),
	T("interp/nop", w(test_nop)),
	T("interp/block", w(test_block)),
	T("interp/loop", w(test_loop)),
	T("interp/if", w(test_if)),
	T("interp/else", w(test_else)),
	T("interp/end", w(test_end)),
	T("interp/br", w(test_br)),
	T("interp/br_if", w(test_br_if)),
	T("interp/br_table", w(test_br_table)),
	T("interp/return", w(test_return)),
	T("interp/call1", w(test_call1)),
	T("interp/call2", w(test_call2)),
	T("interp/call_indirect", w(test_call_indirect)),
	T("interp/drop", w(test_drop)),
	T("interp/select", w(test_select)),
	T("interp/locals1", w(test_locals1)),
	T("interp/locals2", w(test_locals2)),
	T("interp/params", w(test_params)),
	T("interp/globals", w(test_globals)),
	T("interp/const", w(test_const)),

	T_u_u(WasmOpcode.I32_EQZ, [
		(1, 0),
		(0, 0xFACEDEAD),
		(0, 1)]),
	T_ii_i(WasmOpcode.I32_EQ, [
		(1, (0, 0)),
		(1, (0xFACEDEAD, 0xFACEDEAD)),
		(0, (0xEACEEACE, 0xFACEEACE))]),
	T_ii_i(WasmOpcode.I32_NE, [
		(0, (99, 99)),
		(1, (0xFAEEDEAD, 0xFACEDEAD)),
		(0, (0xFACEEACE, 0xFACEEACE))]),
	T_ii_i(WasmOpcode.I32_LT_S, [
		(0, (55, 54)),
		(0, (55, 55)),
		(1, (55, 56)),
		(1, (-56, -55)),
		(1, (-55, 56))]),
	T_ii_i(WasmOpcode.I32_LT_U, [
		(0, (55, 54)),
		(0, (55, 55)),
		(1, (55, 56)),
		(1, (-56, -55)),
		(0, (-55, 56))]),
	T_ii_i(WasmOpcode.I32_GT_S, [
		(1, (55, 54)),
		(0, (55, 55)),
		(0, (55, 56)),
		(0, (-56, -55)),
		(0, (-55, 56))]),
	T_ii_i(WasmOpcode.I32_GT_U, [
		(1, (55, 54)),
		(0, (55, 55)),
		(0, (55, 56)),
		(0, (-56, -55)),
		(1, (-55, 56))]),
	T_ii_i(WasmOpcode.I32_LE_S, [
		(0, (55, 54)),
		(1, (55, 55)),
		(1, (55, 56)),
		(1, (-56, -55)),
		(1, (-55, 56))]),
	T_ii_i(WasmOpcode.I32_LE_U, [
		(0, (55, 54)),
		(1, (55, 55)),
		(1, (55, 56)),
		(1, (-56, -55)),
		(0, (-55, 56))]),
	T_ii_i(WasmOpcode.I32_GE_S, [
		(1, (55, 54)),
		(1, (55, 55)),
		(0, (55, 56)),
		(0, (-56, -55)),
		(0, (-55, 56))]),
	T_ii_i(WasmOpcode.I32_GE_U, [
		(1, (55, 54)),
		(1, (55, 55)),
		(0, (55, 56)),
		(0, (-56, -55)),
		(1, (-55, 56))]),

	T_u_u(WasmOpcode.I32_CLZ, [
		(32, 0),
		(16, 0x8000),
		(0, 0x80000000),
		(31, 1)]),
	T_u_u(WasmOpcode.I32_CTZ, [
		(32, 0),
		(15, 0x8000),
		(31, 0x80000000),
		(0, 1)]),
	T_u_u(WasmOpcode.I32_POPCNT, [
		(0, 0),
		(1, 1),
		(4, 0xF),
		(32, 0xFFFFFFFF)]),
	T_ii_i(WasmOpcode.I32_ADD, [
		(14233, (4312, 9921)),
		(0x00000000, (0xffff0000, 0x00010000)),
		(0x10000000, (0x0fff0000, 0x00010000)),
		(0xffffffff, (0xffff0000, 0x0000ffff))]),
	T_ii_i(WasmOpcode.I32_SUB, [
		(68700981, (76324872, 7623891)),
		(0xFFFFFFFF, (0, 1)),
		(0, (444, 444))]),
	T_ii_i(WasmOpcode.I32_MUL, [
		(544174, (8122, 67)),
		(0, (0xffff0000, 0)),
		(0x80975D68, (0x87234878, 0x1124783))]),
	T_ii_r(WasmOpcode.I32_DIV_S, [
		(ru32(33), (99, 3)),
		(ri32(-33), (99, -3)),
		(Result.Trap(TrapReason.DIV_BY_ZERO), (1, 0)),
		(Result.Trap(TrapReason.DIV_UNREPRESENTABLE), (0x80000000, 0xFFFFFFFF))]),
	T_ii_r(WasmOpcode.I32_DIV_U, [
		(ru32(33), (99, 3)),
		(ru32(0), (99, -3)),
		(Result.Trap(TrapReason.DIV_BY_ZERO), (1, 0)),
		(ru32(0), (0x80000000, 0xFFFFFFFF))]),
	T_ii_r(WasmOpcode.I32_REM_S, [
		(ru32(9), (99, 10)),
		(ri32(7), (107, -10)),
		(ri32(-7), (-107, -10)),
		(ri32(-7), (-107, 10)),
		(Result.Trap(TrapReason.REM_BY_ZERO), (1, 0)),
		(ru32(0), (5559823, 1)),
		(ru32(0), (0x80000000, 0xFFFFFFFF))]),
	T_ii_r(WasmOpcode.I32_REM_U, [
		(ru32(8), (13338, 10)),
		(ru32(99), (99, -3)),
		(Result.Trap(TrapReason.REM_BY_ZERO), (1, 0)),
		(ru32(0), (555, 1)),
		(ru32(0x80000000), (0x80000000, 0xFFFFFFFF))]),
	T_ii_i(WasmOpcode.I32_AND, [
		(0x000FF000, (0xFFFFF000, 0x000FFFFF))]),
	T_ii_i(WasmOpcode.I32_OR, [
		(0x0FFFFFFF, (0x0FFFF000, 0x000FFFFF))]),
	T_ii_i(WasmOpcode.I32_XOR, [
		(0x0FF00FFF, (0x0FFFF000, 0x000FFFFF))]),
	T_ii_i(WasmOpcode.I32_SHL, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF000, (0x000FF000, 32)),
		(0x80000000, (0xFFFFFFFF, 31)),
		(0x00FF0000, (0x000FF000, 36))]),
	T_ii_i(WasmOpcode.I32_SHR_S, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF000, (0x000FF000, 32)),
		(0x00000001, (0x0FFFFFFF, 27)),
		(0xFFFFFFF0, (0xFFFFFF00, 4)),
		(0x0000FF00, (0x000FF000, 36))]),
	T_ii_i(WasmOpcode.I32_SHR_U, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF000, (0x000FF000, 32)),
		(0x00000001, (0xFFFFFFFF, 31)),
		(0x0000FF00, (0x000FF000, 36))]),
	T_ii_i(WasmOpcode.I32_ROTL, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF000, (0x000FF000, 32)),
		(0xBCD0123A, (0xABCD0123, 36))]),
	T_ii_i(WasmOpcode.I32_ROTR, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF000, (0x000FF000, 32)),
		(0x3ABCD012, (0xABCD0123, 36))]),
	()
];


def r(t: Tester, f: InterpreterTester -> ()) {
	return f(InterpreterTester.new(t));
}
def w(f: InterpreterTester -> ()) -> Tester -> () {
	return r(_, f);
}

class InterpreterTester(t: Tester) {
	def module = Module.new();
	var func: FunctionDecl;
	var limit = 10000;
	def locals = Vector<(ValueType, u32)>.new();
	var num_locals: int;
	new() {
		var sig = SigCache.v_i;
		module.types.declared.add(sig);
		func = FunctionDecl.new(false, 0, sig);
		module.functions.declared.add(func);
	}
	def sig(sig: TypeDecl.Function) -> this {
		module.types.declared[0] = sig;
		func = FunctionDecl.new(false, 0, sig);
		module.functions.declared[0] = func;
	}
	def code(raw: Array<byte>) -> this {
		var body = makeBody(raw, this.locals);
		func.code = FunctionCode.new(body);
		func.code.num_locals = num_locals;
	}
	def makeBody(raw: Array<byte>, locals: Vector<(ValueType, u32)>) -> Array<byte> {
		var copy = Vector<byte>.new();
		BinEncoder.append_u32leb(copy, u32.!(locals.size()));
		for (i < locals.size()) {
			var e = locals[i];
			BinEncoder.append_u32leb(copy, u32.!(e.1));
			BinEncoder.append_ValueType(copy, e.0);
		}
		copy.addv(raw);
		copy.add(WasmOpcode.END.code);
		return copy.extract();
	}
	def global(typ: ValueType, init: InitExpr) -> int {
		var index = module.globals.size();
		module.globals.declared.add(GlobalDecl.new(false, typ, true, init));
		return index;
	}
	def local(typ: ValueType) -> int {
		var size = locals.size();
		if (size > 0) {
			var last = locals[size-1];
			if (last.0 == typ) {
				locals[size-1] = (last.0, last.1+1);
				return func.sig.params.length + num_locals++;
			}
		}
		locals.add((typ, 1));
		return func.sig.params.length + num_locals++;
	}
	def function(sig: TypeDecl.Function, raw: Array<byte>) -> int {
		var sig_index = module.types.size();
		module.types.declared.add(sig);
		var func = FunctionDecl.new(false, sig_index, sig);
		module.functions.declared.add(func);
		func.code = FunctionCode.new(makeBody(raw, Vector.new()));
		return module.functions.size() - 1;
	}
	def run(args: Array<Value>) -> Result {
		var instance = Instance.new(module, []);
		var f = instance.getFunction(0);
		var i = Interpreter.new();
		var r = i.run(limit, f, args);
		return r;
	}
	def run1(args: Array<Value>) -> Value {
		var r = run(args);
		match (r) {
			Break => t.fail("unexpected breakpoint");
			Trap(reason) => t.fail1("unexpected trap: %s", reason.name);
			Value(vals) => {
				if (vals.length != 1) t.fail1("expected 1 return value, got %d", vals.length);
				else return vals[0];
			}
		}
		return Value.Nil;
	}
	def assert_u32(expected: u32, args: Array<Value>) {
		assert_r(Result.Value([Value.I32(expected)]), args);
	}
	def assert_u64(expected: u64, args: Array<Value>) {
		assert_r(Result.Value([Value.I64(expected)]), args);
	}
	def assert_f32(expected: u32, args: Array<Value>) {
		assert_r(Result.Value([Value.F32(expected)]), args);
	}
	def assert_f64(expected: u64, args: Array<Value>) {
		assert_r(Result.Value([Value.F64(expected)]), args);
	}
	def assert_i_i(expected: u32, a: u32) {
		assert_u32(expected, [Value.I32(a)]);
	}
	def assert_ii_i(expected: u32, a: u32, b: u32) {
		assert_u32(expected, [Value.I32(a), Value.I32(b)]);
	}
	def assert_r(expected: Result, args: Array<Value>) {
		var got = run(args);
		if (expected.equals(got)) return;
		t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_trap(expected: TrapReason, args: Array<Value>) {
		assert_r(Result.Trap(expected), args);
	}
	def assert_nop(args: Array<Value>) {
		var r = run(args);
		match (r) {
			Break => t.fail("unexpected breakpoint");
			Trap(reason) => t.fail1("unexpected trap: %s", reason.name);
			Value(vals) => {
				var len = if(vals != null, vals.length);
				if (len > 0) t.fail1("expected no values, got %d value(s)", len);
			}
		}
	}
}

//===========================================================
// Begin actual tests
//===========================================================
def test_unreachable(i: InterpreterTester) {
	i.code([WasmOpcode.UNREACHABLE.code]).assert_trap(TrapReason.UNREACHABLE, X);
}

def test_nop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.NOP.code]).assert_nop(X);
}

def test_block(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.BLOCK.code, NONE, WasmOpcode.END.code]).assert_nop(X);
	// TODO: unit test blocks with block types
}

def test_loop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.LOOP.code, NONE, WasmOpcode.END.code]).assert_nop(X);
	// TODO: unit test loops with block types
}
def test_if(i: InterpreterTester) { /* TODO */ }
def test_else(i: InterpreterTester) { /* TODO */ }
def test_end(i: InterpreterTester) { /* TODO */ }
def test_br(i: InterpreterTester) { /* TODO */ }
def test_br_if(i: InterpreterTester) { /* TODO */ }
def test_br_table(i: InterpreterTester) { /* TODO */ }
def test_return(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.RETURN.code]).assert_nop(X);
	i.sig(SigCache.v_v).code([WasmOpcode.I32_CONST.code, 0,
				  WasmOpcode.RETURN.code]).assert_nop(X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 9,
				  WasmOpcode.RETURN.code]).assert_u32(9, X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 7,
				  WasmOpcode.I32_CONST.code, 13,
				  WasmOpcode.RETURN.code]).assert_u32(13, X);
}
def test_call1(i: InterpreterTester) {
	var f17 = byte.!(i.function(SigCache.v_i, [WasmOpcode.I32_CONST.code, 17]));
	var f18 = byte.!(i.function(SigCache.v_i, [WasmOpcode.I32_CONST.code, 18]));
	var f19 = byte.!(i.function(SigCache.v_i, [WasmOpcode.I32_CONST.code, 19]));
	i.code([WasmOpcode.CALL.code, f17]).assert_u32(17, X);
	i.code([WasmOpcode.CALL.code, f18]).assert_u32(18, X);
	i.code([WasmOpcode.CALL.code, f19]).assert_u32(19, X);
	// TODO: more call tests
}
def test_call2(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	var f1 = byte.!(i.function(SigCache.i_i, [WasmOpcode.LOCAL_GET.code, 0]));
	i.code([WasmOpcode.LOCAL_GET.code, 0, WasmOpcode.CALL.code, f1]);
	i.assert_i_i(197, 197);
	i.assert_i_i(36, 36);
	i.assert_i_i(31337, 31337);

	i.sig(SigCache.ii_i);
	var f2 = byte.!(i.function(SigCache.ii_i, [WasmOpcode.LOCAL_GET.code, 0]));
	var f3 = byte.!(i.function(SigCache.ii_i, [WasmOpcode.LOCAL_GET.code, 1]));
	i.code([WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.LOCAL_GET.code, 1,
		WasmOpcode.CALL.code, f2]);
	i.assert_ii_i(22, 22, 33);
	i.assert_ii_i(44, 44, 55);
	i.code([WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.LOCAL_GET.code, 1,
	WasmOpcode.CALL.code, f3]);
	i.assert_ii_i(88, 77, 88);
	i.assert_ii_i(99, 88, 99);
}
def test_call_indirect(i: InterpreterTester) { /* TODO */ }
def test_drop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.I32_CONST.code, 0, WasmOpcode.DROP.code])
		.assert_nop(X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 3,
				  WasmOpcode.DROP.code,
				  WasmOpcode.I32_CONST.code, 11])
		.assert_u32(11, X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 4,
				  WasmOpcode.I32_CONST.code, 5,
				  WasmOpcode.DROP.code])
		.assert_u32(4, X);
}
def test_select(i: InterpreterTester) { /* TODO */ }
def test_locals1(i: InterpreterTester) {
	i.sig(SigCache.i_i).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_i_i(11, 11);

	var i1 = byte.!(i.local(ValueType.I32));
	i.code([WasmOpcode.LOCAL_GET.code, i1]);
	i.assert_i_i(0, 17);

	i.code([
		WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.LOCAL_SET.code, i1,
		WasmOpcode.LOCAL_GET.code, i1
	]);
	i.assert_i_i(19, 19);

	var i2 = byte.!(i.local(ValueType.I32));
	i.code([
		WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.LOCAL_SET.code, i1,
		WasmOpcode.LOCAL_GET.code, i2
	]);
	i.assert_i_i(0, 23);
}
def test_locals2(i: InterpreterTester) {
	var l1 = byte.!(i.local(ValueType.I64));
	i.sig(SigCache.v_l).code([
		WasmOpcode.LOCAL_GET.code, l1
	]);
	i.assert_u64(0, X);

	var f1 = byte.!(i.local(ValueType.F32));
	i.sig(SigCache.v_f).code([
		WasmOpcode.LOCAL_GET.code, f1
	]);
	i.assert_f32(0, X);

	var d1 = byte.!(i.local(ValueType.F64));
	i.sig(SigCache.v_d).code([
		WasmOpcode.LOCAL_GET.code, d1
	]);
	i.assert_f64(0, X);
}
def test_params(i: InterpreterTester) {
	i.sig(SigCache.i_i).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_u32(13, [Value.I32(13)]);
	i.assert_u32(9991, [Value.I32(9991)]);

	i.sig(SigCache.l_l).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_u64(137, [Value.I64(137)]);
	i.assert_u64(999145, [Value.I64(999145)]);

	i.sig(SigCache.f_f).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_f32(137u, [Value.F32(137u)]);
	i.assert_f32(999145u, [Value.F32(999145u)]);

	i.sig(SigCache.d_d).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_f64(137u, [Value.F64(137u)]);
	i.assert_f64(999145u, [Value.F64(999145u)]);

	i.sig(SigCache.ii_i).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_u32(12, [Value.I32(12), Value.I32(15)]);
	i.assert_u32(9791, [Value.I32(9791), Value.I32(66)]);

	i.sig(SigCache.ii_i).code([WasmOpcode.LOCAL_GET.code, 1]);
	i.assert_u32(157, [Value.I32(12), Value.I32(157)]);
	i.assert_u32(8791, [Value.I32(9791), Value.I32(8791)]);
}
def test_globals(i: InterpreterTester) {
	var index = i.global(ValueType.I32, InitExpr.I32(34));
	i.code([WasmOpcode.GLOBAL_GET.code, byte.!(index)]).assert_u32(34, X);
	i.code([WasmOpcode.I32_CONST.code, 44,
		WasmOpcode.GLOBAL_SET.code, byte.!(index),
		WasmOpcode.GLOBAL_GET.code, byte.!(index)]).assert_u32(44, X);

	index = i.global(ValueType.I64, InitExpr.I64(55));
	i.code([WasmOpcode.GLOBAL_GET.code, byte.!(index)]).assert_u64(55, X);
}

def test_const(i: InterpreterTester) {
	i.code([WasmOpcode.I32_CONST.code, 1]).assert_u32(1, X);
	i.code([WasmOpcode.I32_CONST.code, 33]).assert_u32(33, X);
	i.code([WasmOpcode.I32_CONST.code, 0xA7, 0x7F]).assert_u32(16295, X);
	i.code([WasmOpcode.I32_CONST.code, 0x70]).assert_u32(112, X);
	i.code([WasmOpcode.I32_CONST.code, 0xA7, 0xF0, 0xF1, 0xF2,
		0x8E, 0x00]).assert_u32(3999037479u, X);

	i.code([WasmOpcode.I64_CONST.code, 1]).assert_u64(1, X);
	i.code([WasmOpcode.I64_CONST.code, 33]).assert_u64(33, X);
	i.code([WasmOpcode.I64_CONST.code, 0x70]).assert_u64(112, X);
	i.code([WasmOpcode.I64_CONST.code, 0x81, 0x82, 0x83, 0x84,
		0x85, 0x86, 0x87, 0x88, 0x09]).assert_u64(653052939803345153, X);

	i.code([WasmOpcode.F32_CONST.code, 0x44, 0x33, 0x22, 0x11]).assert_f32(0x11223344, X);
	i.code([WasmOpcode.F32_CONST.code, 0x66, 0x77, 0x88, 0x99]).assert_f32(0x99887766, X);
}

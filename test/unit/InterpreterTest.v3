// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, InterpreterTester.new, _);
def X: Array<Value>;
def NONE = BpTypecon.EmptyBlock.code;

// Registers a "unop" opcode test
def reg1<X, Z>(opcode: Opcode,
		f: (Tester, Opcode, Array<(Z, X)>) -> void,
		cases: Array<(Z, X)>) {
	var buf = StringBuilder.new();
	buf.put1("interp:%s", opcode.mnemonic);
	UnitTests.register(buf.extract(), f(_, opcode, cases));
}

// Registers a "binop" opcode test
def reg2<I, R>(opcode: Opcode,
		f: (Tester, Opcode, Array<((I, I), R)>) -> void,
		cases: Array<((I, I), R)>) {
	var buf = StringBuilder.new();
	buf.put1("interp:%s", opcode.mnemonic);
	UnitTests.register(buf.extract(), f(_, opcode, cases));
}

// Runs a "unop" opcode test
def test_x_z<X, Z>(t: Tester, opcode: Opcode, sig: TypeDecl.Function,
	cases: Array<(Z, X)>,
	xv: X -> Value, zv: Z -> Value) {
	def i = InterpreterTester.new(t);
	i.sig(sig);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_GET.code, 1, opcode.code]);
	for (c in cases) {
		i.assert_r([xv(c.1)], Result.Value([zv(c.0)]));
	}
}
// Runs a "binop" opcode test that returns values
def test_xy_z<X, Y, Z>(t: Tester, opcode: Opcode, sig: TypeDecl.Function,
	cases: Array<((X, Y), Z)>,
	xv: X -> Value, yv: Y -> Value, zv: Z -> Value) {
	def i = InterpreterTester.new(t);
	i.sig(sig);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_GET.code, 1, opcode.code]);
	for (c in cases) {
		i.assert_r([xv(c.0.0), yv(c.0.1)], Result.Value([zv(c.1)]));
	}
}
// Runs a "binop" opcode test that may generate traps
def test_xy_r<X, Y>(t: Tester, opcode: Opcode, sig: TypeDecl.Function,
	cases: Array<((X, Y), Result)>,
	xv: X -> Value, yv: Y -> Value) {
	def i = InterpreterTester.new(t);
	i.sig(sig);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_GET.code, 1, opcode.code]);
	for (c in cases) {
		i.assert_r([xv(c.0.0), yv(c.0.1)], c.1);
	}
}
def T_u_u = reg1(_, test_x_z(_, _, SigCache.i_i, _, Values.u_v, Values.u_v), _);
def T_w_w = reg1(_, test_x_z(_, _, SigCache.l_l, _, Values.w_v, Values.w_v), _);
def T_w_u = reg1(_, test_x_z(_, _, SigCache.l_i, _, Values.w_v, Values.u_v), _);

def T_ii_i = reg2(_, test_xy_z(_, _, SigCache.ii_i, _, Values.i_v, Values.i_v, Values.i_v), _);
def T_uu_u = reg2(_, test_xy_z(_, _, SigCache.ii_i, _, Values.u_v, Values.u_v, Values.u_v), _);
def T_ii_r = reg2(_, test_xy_r(_, _, SigCache.ii_i, _, Values.i_v, Values.i_v), _);
def T_uu_r = reg2(_, test_xy_r(_, _, SigCache.ii_i, _, Values.u_v, Values.u_v), _);
def T_ll_l = reg2(_, test_xy_z(_, _, SigCache.ll_l, _, Values.l_v, Values.l_v, Values.l_v), _);
def T_ll_r = reg2(_, test_xy_r(_, _, SigCache.ll_l, _, Values.l_v, Values.l_v), _);
def T_ww_w = reg2(_, test_xy_z(_, _, SigCache.ll_l, _, Values.w_v, Values.w_v, Values.w_v), _);
def T_ll_u = reg2(_, test_xy_z(_, _, SigCache.ll_i, _, Values.l_v, Values.l_v, Values.u_v), _);
def T_ww_u = reg2(_, test_xy_z(_, _, SigCache.ll_i, _, Values.w_v, Values.w_v, Values.u_v), _);


def i_r(val: i32) -> Result {
	return Result.Value([Value.I32(u32.!(val))]);
}
def u_r(val: u32) -> Result {
	return Result.Value([Value.I32(val)]);
}
def l_r(val: i64) -> Result {
	return Result.Value([Value.I64(u64.!(val))]);
}
def w_r(val: u64) -> Result {
	return Result.Value([Value.I64(val)]);
}

//===========================================================
// Begin registration of all tests
//===========================================================
def Z = [
	T("interp:unreachable", test_unreachable),
	T("interp:nop", test_nop),
	T("interp:block", test_block),
	T("interp:loop", test_loop),
	T("interp:if0", test_if0),
	T("interp:if1", test_if1),
	T("interp:br0", test_br0),
	T("interp:br1", test_br1),
	T("interp:br2", test_br2),
	T("interp:br_if", test_br_if),
	T("interp:br_table0", test_br_table0),
	T("interp:br_table1", test_br_table1),
	T("interp:br_table2", test_br_table2),
	T("interp:return", test_return),
	T("interp:call1", test_call1),
	T("interp:call2", test_call2),
	T("interp:callN", test_callN),
	T("interp:call_indirect", test_call_indirect),
	T("interp:drop", test_drop),
	T("interp:select", test_select),
	T("interp:locals1", test_locals1),
	T("interp:locals2", test_locals2),
	T("interp:params", test_params),
	T("interp:globals", test_globals),
	T("interp:const", test_const),
	T("interp:load8", test_load8),
	T("interp:load16", test_load16),
	T("interp:load32", test_load32),
	T("interp:load64", test_load64),
	T("interp:load_oob0", test_load_oob0),
	T("interp:load_oob1", test_load_oob1),
	T("interp:store8", test_store8),
	T("interp:store16", test_store16),
	T("interp:store32", test_store32),
	T("interp:store64", test_store64),
	T("interp:store_oob0", test_store_oob0),
	T("interp:store_oob1", test_store_oob1),
	T("interp:memory_size", test_memory_size),
	T("interp:memory_grow", test_memory_grow),
	T("interp:stack_overflow", test_stack_overflow),
	T("interp:sign_ext", test_sign_ext),
	T("interp:ref.null", test_ref_null),
	T("interp:ref.is_null", test_ref_is_null),
	T("interp:ref.func", test_ref_func),
	T("interp:data.drop", test_data_drop),
	T("interp:memory.fill", test_memory_fill),
	T("interp:elem.drop", test_elem_drop),
	T("interp:table.get", test_table_get),
	T("interp:table.set", test_table_set),
	T("interp:table.size", test_table_size),

	T_u_u(Opcode.I32_EQZ, [
		(1, 0),
		(0, 0xFACEDEAD),
		(0, 1)]),
	T_ii_i(Opcode.I32_EQ, [
		((0, 0), 1),
		((0xFACEDEAD, 0xFACEDEAD), 1),
		((0xEACEEACE, 0xFACEEACE), 0)]),
	T_ii_i(Opcode.I32_NE, [
		((99, 99), 0),
		((0xFAEEDEAD, 0xFACEDEAD), 1),
		((0xFACEEACE, 0xFACEEACE), 0)]),
	T_ii_i(Opcode.I32_LT_S, [
		((55, 54), 0),
		((55, 55), 0),
		((55, 56), 1),
		((-56, -55), 1),
		((-55, 56), 1)]),
	T_ii_i(Opcode.I32_LT_U, [
		((55, 54), 0),
		((55, 55), 0),
		((55, 56), 1),
		((-56, -55), 1),
		((-55, 56), 0)]),
	T_ii_i(Opcode.I32_GT_S, [
		((55, 54), 1),
		((55, 55), 0),
		((55, 56), 0),
		((-56, -55), 0),
		((-55, 56), 0)]),
	T_ii_i(Opcode.I32_GT_U, [
		((55, 54), 1),
		((55, 55), 0),
		((55, 56), 0),
		((-56, -55), 0),
		((-55, 56), 1)]),
	T_ii_i(Opcode.I32_LE_S, [
		((55, 54), 0),
		((55, 55), 1),
		((55, 56), 1),
		((-56, -55), 1),
		((-55, 56), 1)]),
	T_ii_i(Opcode.I32_LE_U, [
		((55, 54), 0),
		((55, 55), 1),
		((55, 56), 1),
		((-56, -55), 1),
		((-55, 56), 0)]),
	T_ii_i(Opcode.I32_GE_S, [
		((55, 54), 1),
		((55, 55), 1),
		((55, 56), 0),
		((-56, -55), 0),
		((-55, 56), 0)]),
	T_ii_i(Opcode.I32_GE_U, [
		((55, 54), 1),
		((55, 55), 1),
		((55, 56), 0),
		((-56, -55), 0),
		((-55, 56), 1)]),

	T_w_u(Opcode.I64_EQZ, [
		(1, 0),
		(0, 0xFACEDEAD),
		(0, 0x00300000000),
		(0, 1)]),
	T_ll_u(Opcode.I64_EQ, [
		((0, 0), 1),
		((0xFACEDEAD, 0xFACEDEAD), 1),
		((0x10000000FACEDEAD, 0x20000000FACEDEAD), 0),
		((0xEACEEACE, 0xFACEEACE), 0)]),
	T_ll_u(Opcode.I64_NE, [
		((99, 99), 0),
		((0xFAEEDEAD55, 0xFACEDEAD55), 1),
		((0xFACEEACE11223344, 0xFACEEACE11223344), 0)]),
	T_ll_u(Opcode.I64_LT_S, [
		((55000000000, 54000000000), 0),
		((55000000000, 55000000000), 0),
		((55000000000, 56000000000), 1),
		((-56000000000, -55000000000), 1),
		((-55000000000, 56000000000), 1)]),
	T_ll_u(Opcode.I64_LT_U, [
		((55111111111, 54111111111), 0),
		((55111111111, 55111111111), 0),
		((55111111111, 56111111111), 1),
		((-56111111111, -55111111111), 1),
		((-55111111111, 56111111111), 0)]),
	T_ll_u(Opcode.I64_GT_S, [
		((55222222222, 54222222222), 1),
		((55222222222, 55222222222), 0),
		((55222222222, 56222222222), 0),
		((-56222222222, -55222222222), 0),
		((-55222222222, 56222222222), 0)]),
	T_ll_u(Opcode.I64_GT_U, [
		((55333333333, 54333333333), 1),
		((55333333333, 55333333333), 0),
		((55333333333, 56333333333), 0),
		((-56333333333, -55333333333), 0),
		((-55333333333, 56333333333), 1)]),
	T_ll_u(Opcode.I64_LE_S, [
		((55444444444, 54444444444), 0),
		((55444444444, 55444444444), 1),
		((55444444444, 56444444444), 1),
		((-56444444444, -55444444444), 1),
		((-55444444444, 56444444444), 1)]),
	T_ll_u(Opcode.I64_LE_U, [
		((55555555555, 54555555555), 0),
		((55555555555, 55555555555), 1),
		((55555555555, 56555555555), 1),
		((-56555555555, -55555555555), 1),
		((-55555555555, 56555555555), 0)]),
	T_ll_u(Opcode.I64_GE_S, [
		((55666666666, 54666666666), 1),
		((55666666666, 55666666666), 1),
		((55666666666, 56666666666), 0),
		((-56666666666, -55666666666), 0),
		((-55666666666, 56666666666), 0)]),
	T_ll_u(Opcode.I64_GE_U, [
		((55777777777, 54777777777), 1),
		((55777777777, 55777777777), 1),
		((55777777777, 56777777777), 0),
		((-56777777777, -55777777777), 0),
		((-55777777777, 56777777777), 1)]),

	T_u_u(Opcode.I32_CLZ, [
		(32, 0),
		(16, 0x8000),
		(0, 0x80000000),
		(31, 1)]),
	T_u_u(Opcode.I32_CTZ, [
		(32, 0),
		(15, 0x8000),
		(31, 0x80000000),
		(0, 1)]),
	T_u_u(Opcode.I32_POPCNT, [
		(0, 0),
		(1, 1),
		(4, 0xF),
		(32, 0xFFFFFFFF)]),
	T_ii_i(Opcode.I32_ADD, [
		((4312, 9921), 14233),
		((0xffff0000, 0x00010000), 0x00000000),
		((0x0fff0000, 0x00010000), 0x10000000),
		((0xffff0000, 0x0000ffff), 0xffffffff)]),
	T_ii_i(Opcode.I32_SUB, [
		((76324872, 7623891), 68700981),
		((0, 1), 0xFFFFFFFF),
		((444, 444), 0)]),
	T_ii_i(Opcode.I32_MUL, [
		((8122, 67), 544174),
		((0xffff0000, 0), 0),
		((0x87234878, 0x1124783), 0x80975D68)]),
	T_ii_r(Opcode.I32_DIV_S, [
		((99, 3), u_r(33)),
		((99, -3), i_r(-33)),
		((1, 0), Result.Trap(TrapReason.DIV_BY_ZERO)),
		((i32.min, -1), Result.Trap(TrapReason.DIV_UNREPRESENTABLE))]),
	T_ii_r(Opcode.I32_DIV_U, [
		((99, 3), u_r(33)),
		((99, -3), u_r(0)),
		((1, 0), Result.Trap(TrapReason.DIV_BY_ZERO)),
		((0x80000000, 0xFFFFFFFF), u_r(0))]),
	T_ii_r(Opcode.I32_REM_S, [
		((99, 10), u_r(9)),
		((107, -10), i_r(7)),
		((-107, -10), i_r(-7)),
		((-107, 10), i_r(-7)),
		((1, 0), Result.Trap(TrapReason.REM_BY_ZERO)),
		((5559823, 1), u_r(0)),
		((0x80000000, 0xFFFFFFFF), u_r(0))]),
	T_ii_r(Opcode.I32_REM_U, [
		((13338, 10), u_r(8)),
		((99, -3), u_r(99)),
		((1, 0), Result.Trap(TrapReason.REM_BY_ZERO)),
		((555, 1), u_r(0)),
		((0x80000000, 0xFFFFFFFF), u_r(0x80000000))]),
	T_uu_u(Opcode.I32_AND, [
		((0xFFFFF000, 0x000FFFFF), 0x000FF000)]),
	T_uu_u(Opcode.I32_OR, [
		((0x0FFFF000, 0x000FFFFF), 0x0FFFFFFF)]),
	T_uu_u(Opcode.I32_XOR, [
		((0x0FFFF000, 0x000FFFFF), 0x0FF00FFF)]),
	T_uu_u(Opcode.I32_SHL, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0xFFFFFFFF, 31), 0x80000000),
		((0x000FF000, 36), 0x00FF0000)]),
	T_uu_u(Opcode.I32_SHR_S, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0x0FFFFFFF, 27), 0x00000001),
		((0xFFFFFF00, 4), 0xFFFFFFF0),
		((0x000FF000, 36), 0x0000FF00)]),
	T_uu_u(Opcode.I32_SHR_U, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0xFFFFFFFF, 31), 0x00000001),
		((0x000FF000, 36), 0x0000FF00)]),
	T_uu_u(Opcode.I32_ROTL, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0xABCD0123, 36), 0xBCD0123A)]),
	T_uu_u(Opcode.I32_ROTR, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0xABCD0123, 36), 0x3ABCD012)]),

	T_w_w(Opcode.I64_CLZ, [
		(64, 0),
		(48, 0x8000),
		(32, 0x80000000),
		(0, 0x8000000000000000),
		(63, 1)]),
	T_w_w(Opcode.I64_CTZ, [
		(64, 0),
		(15, 0x8000),
		(31, 0x80000000),
		(63, 0x8000000000000000),
		(0, 1)]),
	T_w_w(Opcode.I64_POPCNT, [
		(0, 0),
		(1, 1),
		(4, 0xF),
		(8, 0xF00000000F0),
		(32, 0x3333333333333333),
		(64, 0xFFFFFFFFFFFFFFFF),
		(32, 0xFFFFFFFF)]),
	T_ww_w(Opcode.I64_ADD, [
		((4312000111000, 9921111000111), 14233111111111),
		((0xffff0000, 0x00010000), 0x100000000),
		((0x0fff0000, 0x00010000), 0x10000000),
		((0xffff0000, 0x0000ffff), 0xffffffff)]),
	T_ll_l(Opcode.I64_SUB, [
		((76324872010101, 7623891010101), 68700981000000),
		((0, 1), -1),
		((4449988776655, 4449988776655), 0)]),
	T_ww_w(Opcode.I64_MUL, [
		((8122000, 67000), 544174000000),
		((0xffff0000, 0), 0),
		((0x87234878, 0x1124783), 0x90C98380975D68)]),
	T_ll_r(Opcode.I64_DIV_S, [
		((99, 3), w_r(33)),
		((99, -3), l_r(-33)),
		((1, 0), Result.Trap(TrapReason.DIV_BY_ZERO)),
		((i64.min, -1), Result.Trap(TrapReason.DIV_UNREPRESENTABLE))]),
	T_ll_r(Opcode.I64_DIV_U, [
		((99, 3), w_r(33)),
		((99, -3), w_r(0)),
		((1, 0), Result.Trap(TrapReason.DIV_BY_ZERO)),
		((i64.min, -1), w_r(0))]),
	T_ll_r(Opcode.I64_REM_S, [
		((99, 10), w_r(9)),
		((107, -10), l_r(7)),
		((-107, -10), l_r(-7)),
		((-107, 10), l_r(-7)),
		((1, 0), Result.Trap(TrapReason.REM_BY_ZERO)),
		((5559823, 1), w_r(0)),
		((i64.min, -1), w_r(0))]),
	T_ll_r(Opcode.I64_REM_U, [
		((13338, 10), w_r(8)),
		((99, -3), w_r(99)),
		((1, 0), Result.Trap(TrapReason.REM_BY_ZERO)),
		((555, 1), w_r(0)),
		((0x80000000u, -1), w_r(0x80000000u))]),
	T_ww_w(Opcode.I64_AND, [
		((0xFFFFFFFFFF00FF00, 0xFF00FF00FFFFFFFF), 0xFF00FF00FF00FF00)]),
	T_ww_w(Opcode.I64_OR, [
		((0x0FFFFFFFF0000000, 0x0000000FFFFFFFFF), 0x0FFFFFFFFFFFFFFF)]),
	T_ww_w(Opcode.I64_XOR, [
		((0xFFFFFFFFFF00FF00, 0xFF00FF00FFFFFFFF), 0x00FF00FF00FF00FF)]),
	T_ww_w(Opcode.I64_SHL, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 64), 0x000FF000),
		((0x000FF000, 32), 0x000FF00000000000),
		((0xFFFFFFFF, 31), 0x7FFFFFFF80000000),
		((0x000FF000, 68), 0x00FF0000),
		((0x000FF000, 36), 0x00FF000000000000)]),
	T_ww_w(Opcode.I64_SHR_S, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 64), 0x000FF000),
		((0x000FF00000000000, 32), 0x000FF000),
		((0x0FFFFFFF, 27), 0x00000001),
		((0xFFFFFFFFFFFFFF00, 4), 0xFFFFFFFFFFFFFFF0),
		((0x000FF000, 68), 0x0000FF00)]),
	T_ww_w(Opcode.I64_SHR_U, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF00011223344, 32), 0x000FF000),
		((0x000FF000, 64), 0x000FF000),
		((0xFFFFFFFFFFFFFFFF, 63), 0x00000001),
		((0x000FF000, 68), 0x0000FF00)]),
	T_ww_w(Opcode.I64_ROTL, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF00000000000, 32), 0x000FF000),
		((0x000FF000, 64), 0x000FF000),
		((0x0123456789ABCDEF, 68), 0x123456789ABCDEF0)]),
	T_ww_w(Opcode.I64_ROTR, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF00000000000),
		((0x000FF000, 64), 0x000FF000),
		((0x0123456789ABCDEF, 68), 0xF0123456789ABCDE)]),
	()
];


class InterpreterTester(t: Tester) extends ModuleBuilder {
	var limit = 1000;
	var max_call_depth = 100;

	def timeout(t: int) -> this {
		limit = t;
	}
	def codev(raw: Array<byte>) -> this {
		code(raw);
		var v = CodeValidator.new(extensions, Limits.new().set(extensions), module, WasmErrorGen.new(module.filename));
		var r = v.validateFunc(func);
		match (r) {
			Ok => ;
			Error(error, pc, msg) => t.fail2("invalid code @+%d: %s", pc, msg);
		}
	}
	def run(args: Array<Value>) -> (Instance, Result) {
		var instance = Instantiator.new(module, []).run();
		var f = instance.getFunction(0);
		var i = Interpreter.new();
		i.max_call_depth = max_call_depth;
		var buf: StringBuilder;
		if (Trace.interpreter) {
			buf = StringBuilder.new();
			buf.puts("run (");
			if (args != null) for (i < args.length) {
				if (i > 0) buf.puts(", ");
				Values.render(buf, args[i]);
			}
			buf.puts(")\n");
			System.puts(buf.extract());
		}
		var r = i.run(limit, f, args);
		if (Trace.interpreter) {
			buf.put1(" -> %q\n", r.render);
			System.puts(buf.extract());
		}
		return (instance, r);
	}
	def run1(args: Array<Value>) -> Value {
		var r = run(args).1;
		match (r) {
			Break => t.fail("unexpected breakpoint");
			Trap(reason) => t.fail1("unexpected trap: %s", reason.name);
			Value(vals) => {
				if (vals.length != 1) t.fail1("expected 1 return value, got %d", vals.length);
				else return vals[0];
			}
		}
		return Value.Null;
	}
	def assert_u32(args: Array<Value>, expected: u32) {
		assert_r(args, Result.Value([Value.I32(expected)]));
	}
	def assert_u64(args: Array<Value>, expected: u64) {
		assert_r(args, Result.Value([Value.I64(expected)]));
	}
	def assert_f32(args: Array<Value>, expected: u32) {
		assert_r(args, Result.Value([Value.F32(expected)]));
	}
	def assert_f64(args: Array<Value>, expected: u64) {
		assert_r(args, Result.Value([Value.F64(expected)]));
	}
	def assert_i_i(arg: u32, expected: u32) {
		assert_u32([Value.I32(arg)], expected);
	}
	def assert_i(expected: u32) {
		assert_u32(X, expected);
	}
	def assert_l_l(arg: u64, expected: u64) {
		assert_u64([Value.I64(arg)], expected);
	}
	def assert_i_l(arg: u32, expected: u64) {
		assert_u64([Value.I32(arg)], expected);
	}
	def assert_ii_i(args: (u32, u32), expected: u32) {
		assert_u32([Value.I32(args.0), Value.I32(args.1)], expected);
	}
	def assert_mem(args: Array<Value>, offset: u32, expected: Array<byte>) {
		var tr = run(args), instance = tr.0, r = tr.1;
		checkNop(r);
		var data = instance.memories[0].data;
		for (i < expected.length) {
			var addr = int.!(offset) + i;
			var got = data[addr];
			if (expected[i] != got) return t.fail3("expected mem[%x] = %x, got %x", addr, expected[i], got);
		}
	}
	def assert_r(args: Array<Value>, expected: Result) {
		var got = run(args).1;
		if (expected.equals(got)) return;
		t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_g(args: Array<Value>, findex: int) {
		var r = run(args), instance = r.0, got = r.1;
		var expected = Result.Value([Value.FuncRef(instance.getFunction(findex))]);
		if (expected.equals(got)) return;
		t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_trap(args: Array<Value>, expected: TrapReason) {
		assert_r(args, Result.Trap(expected));
	}
	def assert_nop(args: Array<Value>) {
		var r = run(args);
		checkNop(r.1);
	}
	def checkNop(r: Result) {
		match (r) {
			Break => t.fail("unexpected breakpoint");
			Trap(reason) => t.fail1("unexpected trap: %s", reason.name);
			Value(vals) => {
				var len = if(vals != null, vals.length);
				if (len > 0) t.fail1("expected no values, got %d value(s)", len);
			}
		}
	}
}

//===========================================================
// Begin actual tests
//===========================================================
def test_unreachable(i: InterpreterTester) {
	i.code([Opcode.UNREACHABLE.code]).assert_trap(X, TrapReason.UNREACHABLE);
}

def test_nop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([Opcode.NOP.code]).assert_nop(X);
}

def test_block(i: InterpreterTester) {
	i.sig(SigCache.v_v);
	i.code([Opcode.BLOCK.code, NONE,
		Opcode.END.code]);
	i.assert_nop(X);

	i.sig(SigCache.i_i);
	i.code([Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.END.code]);
	i.assert_i_i(9, 9);
	i.assert_i_i(7, 7);

	i.sig(SigCache.l_l);
	i.code([Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.END.code]);
	i.assert_l_l(9, 9);
	i.assert_l_l(7, 7);
}

def test_loop(i: InterpreterTester) {
	i.sig(SigCache.v_v);
	i.code([Opcode.LOOP.code, NONE, Opcode.END.code]);
	i.assert_nop(X);

	i.sig(SigCache.i_i);
	i.codev([Opcode.LOOP.code, NONE,
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_SUB.code,
		Opcode.LOCAL_TEE.code, 0,
		Opcode.BR_IF.code, 0,
		Opcode.END.code,
		Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(1, 0);
	i.assert_i_i(5, 0);

	i.codev([Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_SUB.code,
		Opcode.LOCAL_TEE.code, 0,
		Opcode.BR_IF.code, 0,
		Opcode.END.code]);
	i.assert_i_i(1, 1);
	i.assert_i_i(5, 1);
}

// TODO: test loops with fall through values
// TODO: test loops with arguments

def test_if0(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, NONE,
		Opcode.I32_CONST.code, 11,
		Opcode.RETURN.code,
		Opcode.ELSE.code,
		Opcode.I32_CONST.code, 22,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.UNREACHABLE.code]);
	i.assert_i_i(9, 11);
	i.assert_i_i(0, 22);
	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, NONE,
		Opcode.I32_CONST.code, 33,
		Opcode.LOCAL_SET.code, 0,
		Opcode.ELSE.code,
		Opcode.I32_CONST.code, 44,
		Opcode.LOCAL_SET.code, 0,
		Opcode.END.code,
		Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(7, 33);
	i.assert_i_i(0, 44);

	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, NONE,
		Opcode.I32_CONST.code, 13,
		Opcode.LOCAL_SET.code, 0,
		Opcode.END.code,
		Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(7, 13);
	i.assert_i_i(0, 0);
}
def test_if1(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 17,
		Opcode.ELSE.code,
		Opcode.I32_CONST.code, 27,
		Opcode.END.code]);
	i.assert_i_i(6, 17);
	i.assert_i_i(0, 27);

	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 18,
		Opcode.BR.code, 0,
		Opcode.ELSE.code,
		Opcode.I32_CONST.code, 28,
		Opcode.BR.code, 0,
		Opcode.END.code]);
	i.assert_i_i(4, 18);
	i.assert_i_i(0, 28);
}
def test_br0(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.LOCAL_GET.code, 0, Opcode.BR.code, 0]);
	i.assert_i_i(3, 3);
	i.assert_i_i(9, 9);

	i.sig(SigCache.ii_i);
	i.codev([Opcode.LOCAL_GET.code, 1, Opcode.LOCAL_GET.code, 0, Opcode.BR.code, 0]);
	i.assert_ii_i((7, 11), 7);
	i.assert_ii_i((5, 99), 5);
}
def test_br1(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR.code, 0,
		Opcode.END.code]);
	i.assert_i_i(37, 37);
	i.assert_i_i(94, 94);

	i.sig(SigCache.ii_i);
	i.codev([Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR.code, 0,
		Opcode.END.code,
		Opcode.RETURN.code]);
	i.assert_ii_i((71, 11), 71);
	i.assert_ii_i((52, 99), 52);
}
def test_br2(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([
		Opcode.I32_CONST.code, 9,
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 5,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR.code, 0,
		Opcode.END.code,
		Opcode.I32_ADD.code]);
	i.assert_i_i(37, 46);
	i.assert_i_i(94, 103);
}
def test_br_if(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.I32_CONST.code, 7,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_IF.code, 0,
		Opcode.DROP.code,
		Opcode.I32_CONST.code, 8]);
	i.assert_i_i(11, 7);
	i.assert_i_i(0, 8);

	i.sig(SigCache.i_i);
	i.codev([Opcode.BLOCK.code, NONE,
		Opcode.I32_CONST.code, 9,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_IF.code, 1,
		Opcode.DROP.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 5]);
	i.assert_i_i(17, 9);
	i.assert_i_i(0, 5);
}
def test_br_table0(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.I32_CONST.code, 7,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2,
		0, 0, 0,
		Opcode.UNREACHABLE.code]);
	i.assert_i_i(0, 7);
	i.assert_i_i(1, 7);
	i.assert_i_i(2, 7);
	i.assert_i_i(3, 7);
	i.assert_i_i(4, 7);
	i.assert_i_i(0xFFFFFFFF, 7);

	i.codev([Opcode.BLOCK.code, NONE,
		Opcode.BLOCK.code, NONE,
		Opcode.BLOCK.code, NONE,
		Opcode.BLOCK.code, NONE,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2,
		0, 2, 1,
		Opcode.UNREACHABLE.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 16,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 17,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 18,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.UNREACHABLE.code
		]);
	i.assert_i_i(0, 16);
	i.assert_i_i(1, 18);
	i.assert_i_i(2, 17);
	i.assert_i_i(3, 17);
	i.assert_i_i(4, 17);
	i.assert_i_i(0xFFFFFFFF, 17);
}
def test_br_table1(i: InterpreterTester) {
	i.sig(SigCache.ii_i);

	i.codev([Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2,
		0, 2, 1,
		Opcode.UNREACHABLE.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 16,
		Opcode.I32_ADD.code,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 17,
		Opcode.I32_ADD.code,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 18,
		Opcode.I32_ADD.code,
		Opcode.RETURN.code,
		Opcode.END.code
		]);
	i.assert_ii_i((0, 0), 16);
	i.assert_ii_i((0, 10), 26);
	i.assert_ii_i((1, 0), 18);
	i.assert_ii_i((1, 20), 38);
	i.assert_ii_i((2, 0), 17);
	i.assert_ii_i((2, 30), 47);
	i.assert_ii_i((3, 0), 17);
	i.assert_ii_i((3, 40), 57);
	i.assert_ii_i((4, 0), 17);
	i.assert_ii_i((4, 50), 67);
	i.assert_ii_i((0xFFFFFFFF, 0), 17);
	i.assert_ii_i((0xFFFFFFFF, 60), 77);
}
def test_br_table2(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([
		Opcode.I32_CONST.code, 9,
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 42,
		Opcode.I32_CONST.code, 42,
		Opcode.I32_CONST.code, 42,
		Opcode.I32_CONST.code, 5,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 0, 0,
		Opcode.END.code,
		Opcode.I32_ADD.code]);
	i.assert_i_i(0, 14);
	i.assert_i_i(1, 14);
	i.assert_i_i(444, 14);
}
def test_return(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([Opcode.RETURN.code]).assert_nop(X);
	i.sig(SigCache.v_v).code([Opcode.I32_CONST.code, 0,
				  Opcode.RETURN.code]).assert_nop(X);
	i.sig(SigCache.v_i).code([Opcode.I32_CONST.code, 9,
				  Opcode.RETURN.code]).assert_i(9);
	i.sig(SigCache.v_i).code([Opcode.I32_CONST.code, 7,
				  Opcode.I32_CONST.code, 13,
				  Opcode.RETURN.code]).assert_i(13);
}
def test_call1(i: InterpreterTester) {
	var f17 = byte.!(i.addFunction(SigCache.v_i, [Opcode.I32_CONST.code, 17]).0);
	var f18 = byte.!(i.addFunction(SigCache.v_i, [Opcode.I32_CONST.code, 18]).0);
	var f19 = byte.!(i.addFunction(SigCache.v_i, [Opcode.I32_CONST.code, 19]).0);
	i.code([Opcode.CALL.code, f17]).assert_i(17);
	i.code([Opcode.CALL.code, f18]).assert_i(18);
	i.code([Opcode.CALL.code, f19]).assert_i(19);
}
def test_call2(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	var f1 = byte.!(i.addFunction(SigCache.i_i, [Opcode.LOCAL_GET.code, 0]).0);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.CALL.code, f1]);
	i.assert_i_i(197, 197);
	i.assert_i_i(36, 36);
	i.assert_i_i(31337, 31337);

	i.sig(SigCache.ii_i);
	var f2 = byte.!(i.addFunction(SigCache.ii_i, [Opcode.LOCAL_GET.code, 0]).0);
	var f3 = byte.!(i.addFunction(SigCache.ii_i, [Opcode.LOCAL_GET.code, 1]).0);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.CALL.code, f2]);
	i.assert_ii_i((22, 33), 22);
	i.assert_ii_i((44, 55), 44);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
	Opcode.CALL.code, f3]);
	i.assert_ii_i((77, 88), 88);
	i.assert_ii_i((88, 99), 99);
}
def test_callN(i: InterpreterTester) {
	var I = ValueType.I32;
	var sig_iiiii_i = TypeDecl.Function([I, I, I, I, I], [I]);
	i.sig(sig_iiiii_i);
	for (j < byte.!(5)) {
		var body = [Opcode.LOCAL_GET.code, j];
		var fx = byte.!(i.addFunction(sig_iiiii_i, body).0);
		i.codev([Opcode.LOCAL_GET.code, 0,
			Opcode.LOCAL_GET.code, 1,
			Opcode.LOCAL_GET.code, 2,
			Opcode.LOCAL_GET.code, 3,
			Opcode.LOCAL_GET.code, 4,
			Opcode.CALL.code, fx]);
		var args: Array<Value> = [Value.I32(j + 100u),
				Value.I32(j + 200u),
				Value.I32(j + 300u),
				Value.I32(j + 400u),
				Value.I32(j + 500u)];
		var result = args[j];
		i.assert_r(args, Result.Value([result]));
	}
}
def test_call_indirect(i: InterpreterTester) {
	i.sig(SigCache.ii_i);
	var f1 = i.addFunction(SigCache.i_i, [Opcode.I32_CONST.code, 11]);
	var f2 = i.addFunction(SigCache.i_i, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 22,
		Opcode.I32_ADD.code
	]);
	var f3 = i.addFunction(SigCache.v_v, []);
	i.addTable(7, 0, [f1.0, f2.0, f3.0, f1.0, f2.0, f3.0]);
	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.CALL_INDIRECT.code, byte.!(f1.1.sig_index), 0]);
	i.assert_ii_i((0, 0), 11);
	i.assert_ii_i((0, 1), 22);
	i.assert_ii_i((44, 1), 66);
	i.assert_ii_i((0, 3), 11);
	i.assert_ii_i((0, 4), 22);
	i.assert_ii_i((49, 4), 71);
	i.assert_trap([Value.I32(0), Value.I32(2)], TrapReason.FUNC_SIG_MISMATCH);
	i.assert_trap([Value.I32(0), Value.I32(5)], TrapReason.FUNC_SIG_MISMATCH);
	i.assert_trap([Value.I32(0), Value.I32(6)], TrapReason.FUNC_INVALID);
	i.assert_trap([Value.I32(0), Value.I32(7)], TrapReason.FUNC_INVALID);
}
def test_drop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([Opcode.I32_CONST.code, 0, Opcode.DROP.code])
		.assert_nop(X);
	i.sig(SigCache.v_i).code([Opcode.I32_CONST.code, 3,
				  Opcode.DROP.code,
				  Opcode.I32_CONST.code, 11])
		.assert_i(11);
	i.sig(SigCache.v_i).code([Opcode.I32_CONST.code, 4,
				  Opcode.I32_CONST.code, 5,
				  Opcode.DROP.code])
		.assert_i(4);
}
def test_select(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.code([Opcode.I32_CONST.code, 11,
		Opcode.I32_CONST.code, 22,
		Opcode.LOCAL_GET.code, 0,
		Opcode.SELECT.code]);
	i.assert_i_i(1, 11);
	i.assert_i_i(108, 11);
	i.assert_i_i(0, 22);

	i.sig(SigCache.l_l);
	i.code([Opcode.I64_CONST.code, 33,
		Opcode.I64_CONST.code, 44,
		Opcode.LOCAL_GET.code, 0,
		Opcode.SELECT.code]);
	i.assert_u64([Value.I32(1)], 33);
	i.assert_u64([Value.I32(109)], 33);
	i.assert_u64([Value.I32(0)], 44);

	i.sig(SigCache.f_f);
	i.code([Opcode.F32_CONST.code, 0x11, 0x22, 0x33, 0x44,
		Opcode.F32_CONST.code, 0x55, 0x66, 0x77, 0x88,
		Opcode.LOCAL_GET.code, 0,
		Opcode.SELECT.code]);
	i.assert_f32([Value.I32(1)], 0x44332211);
	i.assert_f32([Value.I32(66)], 0x44332211);
	i.assert_f32([Value.I32(0)], 0x88776655);

	i.sig(SigCache.d_d);
	i.code([Opcode.F64_CONST.code, 0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,
		Opcode.F64_CONST.code, 0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,
		Opcode.LOCAL_GET.code, 0,
		Opcode.SELECT.code]);
	i.assert_f64([Value.I32(1)], 0x8877665544332211);
	i.assert_f64([Value.I32(66)], 0x8877665544332211);
	i.assert_f64([Value.I32(0)], 0x0807060504030201);
}
def test_locals1(i: InterpreterTester) {
	i.sig(SigCache.i_i).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(11, 11);

	var i1 = byte.!(i.addLocal(ValueType.I32));
	i.code([Opcode.LOCAL_GET.code, i1]);
	i.assert_i_i(17, 0);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_SET.code, i1,
		Opcode.LOCAL_GET.code, i1]);
	i.assert_i_i(19, 19);

	var i2 = byte.!(i.addLocal(ValueType.I32));
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_SET.code, i1,
		Opcode.LOCAL_GET.code, i2]);
	i.assert_i_i(23, 0);
}
def test_locals2(i: InterpreterTester) {
	var l1 = byte.!(i.addLocal(ValueType.I64));
	i.sig(SigCache.v_l).code([
		Opcode.LOCAL_GET.code, l1
	]);
	i.assert_u64(X, 0);

	var f1 = byte.!(i.addLocal(ValueType.F32));
	i.sig(SigCache.v_f).code([
		Opcode.LOCAL_GET.code, f1
	]);
	i.assert_f32(X, 0);

	var d1 = byte.!(i.addLocal(ValueType.F64));
	i.sig(SigCache.v_d).code([
		Opcode.LOCAL_GET.code, d1
	]);
	i.assert_f64(X, 0);
}
def test_params(i: InterpreterTester) {
	i.sig(SigCache.i_i).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(13, 13);
	i.assert_i_i(9991, 9991);

	i.sig(SigCache.l_l).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_u64([Value.I64(137)], 137);
	i.assert_u64([Value.I64(999145)], 999145);

	i.sig(SigCache.f_f).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_f32([Value.F32(137u)], 137u);
	i.assert_f32([Value.F32(999145u)], 999145u);

	i.sig(SigCache.d_d).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_f64([Value.F64(137u)], 137u);
	i.assert_f64([Value.F64(999145u)], 999145u);

	i.sig(SigCache.ii_i).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_ii_i((12, 15), 12);
	i.assert_ii_i((9791, 66), 9791);

	i.sig(SigCache.ii_i).code([Opcode.LOCAL_GET.code, 1]);
	i.assert_ii_i((12, 157), 157);
	i.assert_ii_i((9791, 8791), 8791);
}
def test_globals(i: InterpreterTester) {
	var index = byte.!(i.addGlobal(ValueType.I32, InitExpr.I32(34)));
	i.code([Opcode.GLOBAL_GET.code, index]).assert_i(34);
	i.code([Opcode.I32_CONST.code, 44,
		Opcode.GLOBAL_SET.code, index,
		Opcode.GLOBAL_GET.code, index]).assert_i(44);

	index = byte.!(i.addGlobal(ValueType.I64, InitExpr.I64(55)));
	i.code([Opcode.GLOBAL_GET.code, index]).assert_u64(X, 55);
}

def test_const(i: InterpreterTester) {
	i.code([Opcode.I32_CONST.code, 1]).assert_i(1);
	i.code([Opcode.I32_CONST.code, 33]).assert_i(33);
	i.code([Opcode.I32_CONST.code, 0xA7, 0x7F]).assert_i(u32.!(-89));
	i.code([Opcode.I32_CONST.code, 0x70]).assert_i(u32.!(-16));
	i.code([Opcode.I32_CONST.code, 0xA7, 0xF0, 0xF1, 0xF2,
		0x0E]).assert_i(3999037479u);

	i.code([Opcode.I64_CONST.code, 1]).assert_u64(X, 1);
	i.code([Opcode.I64_CONST.code, 33]).assert_u64(X, 33);
	i.code([Opcode.I64_CONST.code, 0x70]).assert_u64(X, u64.!(-16));
	i.code([Opcode.I64_CONST.code, 0x81, 0x82, 0x83, 0x84,
		0x85, 0x86, 0x87, 0x88, 0x09]).assert_u64(X, 653052939803345153);

	i.code([Opcode.F32_CONST.code, 0x44, 0x33, 0x22, 0x11]).assert_f32(X, 0x11223344);
	i.code([Opcode.F32_CONST.code, 0x66, 0x77, 0x88, 0x99]).assert_f32(X, 0x99887766);
}

def test_load8(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.addMemory(1, 1);
	i.addData(4, [0xF0, 0xF1]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD8_U.code, 0, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(3, 0);
	i.assert_i_i(4, 0xF0);
	i.assert_i_i(5, 0xF1);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD8_S.code, 0, 2]);
	i.assert_i_i(0, 0);
	i.assert_i_i(1, 0);
	i.assert_i_i(2, 0xFFFFFFF0);
	i.assert_i_i(3, 0xFFFFFFF1);

	i.sig(SigCache.i_l);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD8_U.code, 0, 1]);
	i.assert_i_l(0, 0);
	i.assert_i_l(3, 0xF0);
	i.assert_i_l(4, 0xF1);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD8_S.code, 0, 3]);
	i.assert_i_l(0, 0);
	i.assert_i_l(1, 0xFFFFFFFFFFFFFFF0);
	i.assert_i_l(2, 0xFFFFFFFFFFFFFFF1);
}
def test_load16(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.addMemory(1, 1);
	i.addData(8, [0xF2, 0xF3, 0xCC, 0xDD]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD16_U.code, 0, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(3, 0);
	i.assert_i_i(8, 0xF3F2);
	i.assert_i_i(9, 0xCCF3);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD16_S.code, 0, 2]);
	i.assert_i_i(0, 0);
	i.assert_i_i(4, 0);
	i.assert_i_i(6, 0xFFFFF3F2);
	i.assert_i_i(7, 0xFFFFCCF3);

	i.sig(SigCache.i_l);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD16_U.code, 0, 1]);
	i.assert_i_l(0, 0);
	i.assert_i_l(7, 0xF3F2);
	i.assert_i_l(9, 0xDDCC);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD16_S.code, 0, 3]);
	i.assert_i_l(0, 0);
	i.assert_i_l(5, 0xFFFFFFFFFFFFF3F2);
	i.assert_i_l(7, 0xFFFFFFFFFFFFDDCC);
}
def test_load32(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.addMemory(1, 1);
	i.addData(10, [0xF5, 0xF6, 0xAA, 0xBB, 0xCC, 0xDD]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD.code, 0, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(6, 0);
	i.assert_i_i(10, 0xBBAAF6F5);
	i.assert_i_i(12, 0xDDCCBBAA);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD.code, 0, 8]);
	i.assert_i_i(0, 0xF6F50000);
	i.assert_i_i(6, 0x0000DDCC);

	i.sig(SigCache.i_l);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD32_U.code, 0, 1]);
	i.assert_i_l(0, 0);
	i.assert_i_l(8, 0xAAF6F500);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD32_S.code, 0, 3]);
	i.assert_i_l(0, 0);
	i.assert_i_l(7, 0xFFFFFFFFBBAAF6F5);
	i.assert_i_l(9, 0xFFFFFFFFDDCCBBAA);
}
def test_load64(i: InterpreterTester) {
	i.sig(SigCache.i_l);
	i.addMemory(1, 1);
	i.addData(12, [0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD.code, 0, 0]);
	i.assert_i_l(0, 0);
	i.assert_i_l(3, 0);
	i.assert_i_l(12, 0x8877665544332211);
	i.assert_i_l(13, 0x0088776655443322);
}
def test_load_oob0(i: InterpreterTester) {
	i.addMemory(0, 0);
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD.code, 0, 0]);
	i.assert_r([Value.I32(0)], Result.Trap(TrapReason.MEM_OUT_OF_BOUNDS));
}
def test_load_oob1(i: InterpreterTester) {
	i.addMemory(1, 1);
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD.code, 0, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(65532, 0);
	i.assert_r([Value.I32(65533)], Result.Trap(TrapReason.MEM_OUT_OF_BOUNDS));
}
def test_store8(i: InterpreterTester) {
	i.addMemory(1, 1);
	var sig_i_v = TypeDecl.Function(SigCache.arr_i, []);
	i.sig(sig_i_v);
	i.addData(5, [0x99, 0x88, 0x77]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 3,
		Opcode.I32_STORE8.code, 0, 2]);
	i.assert_mem([Value.I32(3)], 4, [0,    3, 0x88, 0x77, 0]);
	i.assert_mem([Value.I32(4)], 4, [0, 0x99,    3, 0x77, 0]);
	i.assert_mem([Value.I32(5)], 4, [0, 0x99, 0x88,    3, 0]);
	i.assert_mem([Value.I32(6)], 4, [0, 0x99, 0x88, 0x77, 3]);
}
def test_store16(i: InterpreterTester) {
	i.addMemory(1, 1);
	var sig_i_v = TypeDecl.Function(SigCache.arr_i, []);
	i.sig(sig_i_v);
	i.addData(11, [0x99, 0x88, 0x77]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 0x83, 0x08,
		Opcode.I32_STORE16.code, 0, 7]);
	i.assert_mem([Value.I32(4)], 10, [0,    3,    4, 0x77, 0, 0]);
	i.assert_mem([Value.I32(5)], 10, [0, 0x99,    3,    4, 0, 0]);
	i.assert_mem([Value.I32(6)], 10, [0, 0x99, 0x88,    3, 4, 0]);
	i.assert_mem([Value.I32(7)], 10, [0, 0x99, 0x88, 0x77, 3, 4]);
}
def test_store32(i: InterpreterTester) {
	i.addMemory(1, 1);
	var sig_i_v = TypeDecl.Function(SigCache.arr_i, []);
	i.sig(sig_i_v);
	i.addData(19, [0x99, 0x88, 0x77, 0x66, 0x55]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 0x91, 0xC4, 0xCC, 0xA1, 0x04,
		Opcode.I32_STORE.code, 0, 9]);
	i.assert_mem([Value.I32(10)], 18, [0, 0x11, 0x22, 0x33, 0x44, 0x55, 0, 0]);
	i.assert_mem([Value.I32(11)], 18, [0, 0x99, 0x11, 0x22, 0x33, 0x44, 0, 0]);
	i.assert_mem([Value.I32(12)], 18, [0, 0x99, 0x88, 0x11, 0x22, 0x33, 0x44, 0]);
}
def test_store64(i: InterpreterTester) {
	i.addMemory(1, 1);
	var sig_il_v = TypeDecl.Function([ValueType.I32, ValueType.I64], []);
	i.sig(sig_il_v);
	i.addData(33, [0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.I64_STORE.code, 0, 22]);
	i.assert_mem([Value.I32(12), Value.I64(0x0807060504030201)], 32, [0, 0x99, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]);
	i.assert_mem([Value.I32(14), Value.I64(0xA8B7C6D5E4F30201)], 32, [0, 0x99, 0x88, 0x77, 0x01, 0x02, 0xF3, 0xE4, 0xD5, 0xC6, 0xB7, 0xA8]);
}
def test_store_oob0(i: InterpreterTester) {
	i.addMemory(0, 0);
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 5,
		Opcode.I32_STORE.code, 0, 0,
		Opcode.I32_CONST.code, 3]);
	i.assert_r([Value.I32(0)], Result.Trap(TrapReason.MEM_OUT_OF_BOUNDS));
}
def test_store_oob1(i: InterpreterTester) {
	i.addMemory(1, 1);
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 5,
		Opcode.I32_STORE.code, 0, 0,
		Opcode.I32_CONST.code, 42]);
	i.assert_i_i(0, 42);
	i.assert_i_i(65532, 42);
	i.assert_r([Value.I32(65533)], Result.Trap(TrapReason.MEM_OUT_OF_BOUNDS));
}
def test_memory_size(i: InterpreterTester) {
	i.addMemory(0, 0);
	i.sig(SigCache.v_i);
	i.code([Opcode.MEMORY_SIZE.code, 0]);
	i.assert_i(0);

	i.addMemory(2, 2);
	i.sig(SigCache.v_i);
	i.code([Opcode.MEMORY_SIZE.code, 1]);
	i.assert_i(2);
}
def test_memory_grow(i: InterpreterTester) {
	i.addMemory(0, 5);
	i.sig(SigCache.i_i);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.MEMORY_GROW.code, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(1, 0);
	i.assert_i_i(5, 0);
	i.assert_i_i(6, 0xFFFFFFFF);

	i.addMemory(1, 2);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.MEMORY_GROW.code, 1]);
	i.assert_i_i(0, 1);
	i.assert_i_i(1, 1);
	i.assert_i_i(2, 0xFFFFFFFF);
}

def test_stack_overflow(i: InterpreterTester) {
	i.code([Opcode.CALL.code, 0]);
	i.max_call_depth = 10;
	i.assert_trap([Value.I32(0), Value.I32(2)], TrapReason.STACK_OVERFLOW);
}

def test_sign_ext(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I32_EXTEND8_S.code]);
	i.assert_i_i(0, 0);
	i.assert_i_i(1, 1);
	i.assert_i_i(127, 127);
	i.assert_i_i(0x80, 0xFFFFFF80);
	i.assert_i_i(0x100, 0);

	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I32_EXTEND16_S.code]);
	i.assert_i_i(0, 0);
	i.assert_i_i(1, 1);
	i.assert_i_i(127, 127);
	i.assert_i_i(0x82, 0x82);
	i.assert_i_i(0x8030, 0xFFFF8030);
	i.assert_i_i(0x10000, 0);

	i.sig(SigCache.l_l);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I64_EXTEND8_S.code]);
	i.assert_l_l(0, 0);
	i.assert_l_l(1, 1);
	i.assert_l_l(127, 127);
	i.assert_l_l(0x87, 0xFFFFFFFFFFFFFF87);
	i.assert_l_l(0x300, 0);

	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I64_EXTEND16_S.code]);
	i.assert_l_l(0, 0);
	i.assert_l_l(1, 1);
	i.assert_l_l(0x7FFF, 0x7FFF);
	i.assert_l_l(0x19a, 0x19a);
	i.assert_l_l(0x8720, 0xFFFFFFFFFFFF8720);
	i.assert_l_l(0x50000, 0);

	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I64_EXTEND32_S.code]);
	i.assert_l_l(0, 0);
	i.assert_l_l(1, 1);
	i.assert_l_l(0x7FFF, 0x7FFF);
	i.assert_l_l(0x7FFF1234, 0x7FFF1234);
	i.assert_l_l(0x19a, 0x19a);
	i.assert_l_l(0x8720abcd, 0xFFFFFFFF8720abcd);
}

// TODO: tests for multi-value block, if, loop
// TODO: tests for multi-value return
// TODO: tests for block, if, loop with value args
// TODO: lots more tests for br_table
// TODO: tests for multi_memory

def test_ref_null(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	i.sig(SigCache.v_e);
	i.code([Opcode.REF_NULL.code, BpTypecon.ExternRef.code]);
	i.assert_r(X, Result.Value([Value.Null]));
}

def test_ref_is_null(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	// externs
	i.sig(SigCache.e_i);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.REF_IS_NULL.code, BpTypecon.ExternRef.code]);
	i.assert_r([Value.Null], Result.Value([Values.I32_1]));
	i.assert_r([Value.ExternRef(null)], Result.Value([Values.I32_0]));
	// funcs
	i.sig(SigCache.g_i);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.REF_IS_NULL.code, BpTypecon.FuncRef.code]);
	i.assert_r([Value.Null], Result.Value([Values.I32_1]));
	i.assert_r([Value.FuncRef(null)], Result.Value([Values.I32_0]));
}

def test_ref_func(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	i.sig(SigCache.v_g);
	i.code([Opcode.REF_FUNC.code, 0]);
	i.assert_g(X, 0);
}

def test_data_drop(i: InterpreterTester) {
	i.extensions |= Extension.BULK_MEMORY;
	i.sig(SigCache.v_v);
	i.addMemory(1, 1);
	i.addData(0, [0]);
	i.code([Opcode.DATA_DROP.prefix, Opcode.DATA_DROP.code, 0]);
	var t = i.run(X), instance = t.0;
	if (instance.dropped_data[0] != true) i.t.fail("expected dropped data[0]");
}

def test_memory_fill(i: InterpreterTester) {
	i.extensions |= Extension.BULK_MEMORY;
	i.sig(SigCache.iii_v);
	i.addMemory(1, 1);
	i.code([Opcode.MEMORY_FILL.prefix, Opcode.MEMORY_FILL.code, 0]);
	i.assert_mem([Values.I32_0, Values.I32_0, Values.I32_0], 0, [0]);
	i.assert_mem([Value.I32(3), Value.I32(77), Value.I32(2)], 0, [0, 0, 0, 77, 77, 0]);
	i.assert_mem([Value.I32(4), Value.I32(99), Value.I32(4)], 0, [0, 0, 0, 0, 99, 99, 99, 99, 0]);
	i.assert_mem([Value.I32(65536), Value.I32(99), Value.I32(0)], 0,[]);
	i.assert_trap([Value.I32(65536), Value.I32(91), Value.I32(1)], TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap([Value.I32(65535), Value.I32(92), Value.I32(2)], TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap([Value.I32(65537), Value.I32(93), Value.I32(1)], TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap([Value.I32(65537), Value.I32(94), Value.I32(0xFFFFFFF0)], TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap([Value.I32(0xFFFFFFF0), Value.I32(95), Value.I32(0xF0)], TrapReason.MEM_OUT_OF_BOUNDS);
}

def test_elem_drop(i: InterpreterTester) {
	i.extensions |= Extension.BULK_MEMORY;
	i.sig(SigCache.v_v);
	i.addTable(1, 0, [0]);
	i.code([Opcode.ELEM_DROP.prefix, Opcode.ELEM_DROP.code, 0]);
	var t = i.run(X), instance = t.0;
	if (instance.dropped_elems[0] != true) i.t.fail("expected dropped elems[0]");
}

def test_table_get(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	var f2 = i.addFunction(SigCache.v_v, [Opcode.END.code]);
	var f3 = i.addFunction(SigCache.v_v, [Opcode.END.code]);
	i.addTable(3, 0, [0, f2.0, f3.0]);
	i.sig(TypeDecl.Function(SigCache.arr_i, [ValueType.FUNCREF]));
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.TABLE_GET.code, 0]);
	i.assert_g([Value.I32(0)], 0);
	i.assert_g([Value.I32(1)], f2.0);
	i.assert_g([Value.I32(2)], f3.0);
	i.assert_trap([Value.I32(3)], TrapReason.TABLE_INDEX_OUT_OF_BOUNDS);
}

def test_table_set(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	var f2 = i.addFunction(SigCache.v_v, [Opcode.END.code]);
	var f3 = i.addFunction(SigCache.v_v, [Opcode.END.code]);
	i.addTable(3, 0, [0, f2.0, f3.0]);
	i.sig(TypeDecl.Function([ValueType.I32, ValueType.FUNCREF], SigCache.arr_v));
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_GET.code, 1, Opcode.TABLE_SET.code, 0]);

	var gv1 = Value.FuncRef(WasmFunction.new(null, f3.1));
	var t = i.run([Value.I32(1), gv1]), instance = t.0;
	var got = FunctionTable.!(instance.tables[0]).elems[1];
	if (gv1.val != got) i.t.fail("wrong table[1] value");

	i.assert_trap([Value.I32(3), gv1], TrapReason.TABLE_INDEX_OUT_OF_BOUNDS);
}

def test_table_size(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	i.addTable(3, 0, [0, 0, 0]);
	i.sig(SigCache.v_i);
	i.code([Opcode.TABLE_SIZE.prefix, Opcode.TABLE_SIZE.code, 0]);
	i.assert_i(3);
}
// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, InterpreterTester.new, _);
def X: Array<Value>;
def NONE = BpTypecon.EmptyBlock.code;

// Registers a "unop" opcode test
def reg1<X, Z>(opcode: WasmOpcode,
		f: (Tester, WasmOpcode, Array<(Z, X)>) -> void,
		cases: Array<(Z, X)>) {
	var buf = StringBuffer.new();
	buf.put1("interp/%s", opcode.mnemonic);
	UnitTests.register(buf.extract(), f(_, opcode, cases));
}

// Registers a "binop" opcode test
def reg2<I, R>(opcode: WasmOpcode,
		f: (Tester, WasmOpcode, Array<(R, (I, I))>) -> void,
		cases: Array<(R, (I, I))>) {
	var buf = StringBuffer.new();
	buf.put1("interp/%s", opcode.mnemonic);
	UnitTests.register(buf.extract(), f(_, opcode, cases));
}

// Runs a "unop" opcode test
def test_x_z<X, Z>(t: Tester, opcode: WasmOpcode, sig: TypeDecl.Function,
	cases: Array<(Z, X)>,
	xv: X -> Value, zv: Z -> Value) {
	def i = InterpreterTester.new(t);
	i.sig(sig);
	i.code([WasmOpcode.LOCAL_GET.code, 0, WasmOpcode.LOCAL_GET.code, 1, opcode.code]);
	for (c in cases) {
		i.assert_r(Result.Value([zv(c.0)]), [xv(c.1)]);
	}
}
// Runs a "binop" opcode test that returns values
def test_xy_z<X, Y, Z>(t: Tester, opcode: WasmOpcode, sig: TypeDecl.Function,
	cases: Array<(Z, (X, Y))>,
	xv: X -> Value, yv: Y -> Value, zv: Z -> Value) {
	def i = InterpreterTester.new(t);
	i.sig(sig);
	i.code([WasmOpcode.LOCAL_GET.code, 0, WasmOpcode.LOCAL_GET.code, 1, opcode.code]);
	for (c in cases) {
		i.assert_r(Result.Value([zv(c.0)]), [xv(c.1.0), yv(c.1.1)]);
	}
}
// Runs a "binop" opcode test that may generate traps
def test_xy_r<X, Y>(t: Tester, opcode: WasmOpcode, sig: TypeDecl.Function,
	cases: Array<(Result, (X, Y))>,
	xv: X -> Value, yv: Y -> Value) {
	def i = InterpreterTester.new(t);
	i.sig(sig);
	i.code([WasmOpcode.LOCAL_GET.code, 0, WasmOpcode.LOCAL_GET.code, 1, opcode.code]);
	for (c in cases) {
		i.assert_r(c.0, [xv(c.1.0), yv(c.1.1)]);
	}
}
def T_u_u = reg1(_, test_x_z(_, _, SigCache.i_i, _, Values.u_v, Values.u_v), _);
def T_w_w = reg1(_, test_x_z(_, _, SigCache.l_l, _, Values.w_v, Values.w_v), _);
def T_w_u = reg1(_, test_x_z(_, _, SigCache.l_i, _, Values.w_v, Values.u_v), _);

def T_ii_i = reg2(_, test_xy_z(_, _, SigCache.ii_i, _, Values.i_v, Values.i_v, Values.i_v), _);
def T_uu_u = reg2(_, test_xy_z(_, _, SigCache.ii_i, _, Values.u_v, Values.u_v, Values.u_v), _);
def T_ii_r = reg2(_, test_xy_r(_, _, SigCache.ii_i, _, Values.i_v, Values.i_v), _);
def T_uu_r = reg2(_, test_xy_r(_, _, SigCache.ii_i, _, Values.u_v, Values.u_v), _);
def T_ll_l = reg2(_, test_xy_z(_, _, SigCache.ll_l, _, Values.l_v, Values.l_v, Values.l_v), _);
def T_ll_r = reg2(_, test_xy_r(_, _, SigCache.ll_l, _, Values.l_v, Values.l_v), _);
def T_ww_w = reg2(_, test_xy_z(_, _, SigCache.ll_l, _, Values.w_v, Values.w_v, Values.w_v), _);
def T_ll_u = reg2(_, test_xy_z(_, _, SigCache.ll_i, _, Values.l_v, Values.l_v, Values.u_v), _);
def T_ww_u = reg2(_, test_xy_z(_, _, SigCache.ll_i, _, Values.w_v, Values.w_v, Values.u_v), _);


def i_r(val: i32) -> Result {
	return Result.Value([Value.I32(u32.!(val))]);
}
def u_r(val: u32) -> Result {
	return Result.Value([Value.I32(val)]);
}
def l_r(val: i64) -> Result {
	return Result.Value([Value.I64(u64.!(val))]);
}
def w_r(val: u64) -> Result {
	return Result.Value([Value.I64(val)]);
}

//===========================================================
// Begin registration of all tests
//===========================================================
def Z = [
	T("interp/unreachable", test_unreachable),
	T("interp/nop", test_nop),
	T("interp/block", test_block),
	T("interp/loop", test_loop),
	T("interp/if0", test_if0),
	T("interp/if1", test_if1),
	T("interp/else", test_else),
	T("interp/end", test_end),
	T("interp/br", test_br),
	T("interp/br_if", test_br_if),
	T("interp/br_table", test_br_table),
	T("interp/return", test_return),
	T("interp/call1", test_call1),
	T("interp/call2", test_call2),
	T("interp/call_indirect", test_call_indirect),
	T("interp/drop", test_drop),
	T("interp/select", test_select),
	T("interp/locals1", test_locals1),
	T("interp/locals2", test_locals2),
	T("interp/params", test_params),
	T("interp/globals", test_globals),
	T("interp/const", test_const),

	T_u_u(WasmOpcode.I32_EQZ, [
		(1, 0),
		(0, 0xFACEDEAD),
		(0, 1)]),
	T_ii_i(WasmOpcode.I32_EQ, [
		(1, (0, 0)),
		(1, (0xFACEDEAD, 0xFACEDEAD)),
		(0, (0xEACEEACE, 0xFACEEACE))]),
	T_ii_i(WasmOpcode.I32_NE, [
		(0, (99, 99)),
		(1, (0xFAEEDEAD, 0xFACEDEAD)),
		(0, (0xFACEEACE, 0xFACEEACE))]),
	T_ii_i(WasmOpcode.I32_LT_S, [
		(0, (55, 54)),
		(0, (55, 55)),
		(1, (55, 56)),
		(1, (-56, -55)),
		(1, (-55, 56))]),
	T_ii_i(WasmOpcode.I32_LT_U, [
		(0, (55, 54)),
		(0, (55, 55)),
		(1, (55, 56)),
		(1, (-56, -55)),
		(0, (-55, 56))]),
	T_ii_i(WasmOpcode.I32_GT_S, [
		(1, (55, 54)),
		(0, (55, 55)),
		(0, (55, 56)),
		(0, (-56, -55)),
		(0, (-55, 56))]),
	T_ii_i(WasmOpcode.I32_GT_U, [
		(1, (55, 54)),
		(0, (55, 55)),
		(0, (55, 56)),
		(0, (-56, -55)),
		(1, (-55, 56))]),
	T_ii_i(WasmOpcode.I32_LE_S, [
		(0, (55, 54)),
		(1, (55, 55)),
		(1, (55, 56)),
		(1, (-56, -55)),
		(1, (-55, 56))]),
	T_ii_i(WasmOpcode.I32_LE_U, [
		(0, (55, 54)),
		(1, (55, 55)),
		(1, (55, 56)),
		(1, (-56, -55)),
		(0, (-55, 56))]),
	T_ii_i(WasmOpcode.I32_GE_S, [
		(1, (55, 54)),
		(1, (55, 55)),
		(0, (55, 56)),
		(0, (-56, -55)),
		(0, (-55, 56))]),
	T_ii_i(WasmOpcode.I32_GE_U, [
		(1, (55, 54)),
		(1, (55, 55)),
		(0, (55, 56)),
		(0, (-56, -55)),
		(1, (-55, 56))]),

	T_w_u(WasmOpcode.I64_EQZ, [
		(1, 0),
		(0, 0xFACEDEAD),
		(0, 0x00300000000),
		(0, 1)]),
	T_ll_u(WasmOpcode.I64_EQ, [
		(1, (0, 0)),
		(1, (0xFACEDEAD, 0xFACEDEAD)),
		(0, (0x10000000FACEDEAD, 0x20000000FACEDEAD)),
		(0, (0xEACEEACE, 0xFACEEACE))]),
	T_ll_u(WasmOpcode.I64_NE, [
		(0, (99, 99)),
		(1, (0xFAEEDEAD55, 0xFACEDEAD55)),
		(0, (0xFACEEACE11223344, 0xFACEEACE11223344))]),
	T_ll_u(WasmOpcode.I64_LT_S, [
		(0, (55000000000, 54000000000)),
		(0, (55000000000, 55000000000)),
		(1, (55000000000, 56000000000)),
		(1, (-56000000000, -55000000000)),
		(1, (-55000000000, 56000000000))]),
	T_ll_u(WasmOpcode.I64_LT_U, [
		(0, (55111111111, 54111111111)),
		(0, (55111111111, 55111111111)),
		(1, (55111111111, 56111111111)),
		(1, (-56111111111, -55111111111)),
		(0, (-55111111111, 56111111111))]),
	T_ll_u(WasmOpcode.I64_GT_S, [
		(1, (55222222222, 54222222222)),
		(0, (55222222222, 55222222222)),
		(0, (55222222222, 56222222222)),
		(0, (-56222222222, -55222222222)),
		(0, (-55222222222, 56222222222))]),
	T_ll_u(WasmOpcode.I64_GT_U, [
		(1, (55333333333, 54333333333)),
		(0, (55333333333, 55333333333)),
		(0, (55333333333, 56333333333)),
		(0, (-56333333333, -55333333333)),
		(1, (-55333333333, 56333333333))]),
	T_ll_u(WasmOpcode.I64_LE_S, [
		(0, (55444444444, 54444444444)),
		(1, (55444444444, 55444444444)),
		(1, (55444444444, 56444444444)),
		(1, (-56444444444, -55444444444)),
		(1, (-55444444444, 56444444444))]),
	T_ll_u(WasmOpcode.I64_LE_U, [
		(0, (55555555555, 54555555555)),
		(1, (55555555555, 55555555555)),
		(1, (55555555555, 56555555555)),
		(1, (-56555555555, -55555555555)),
		(0, (-55555555555, 56555555555))]),
	T_ll_u(WasmOpcode.I64_GE_S, [
		(1, (55666666666, 54666666666)),
		(1, (55666666666, 55666666666)),
		(0, (55666666666, 56666666666)),
		(0, (-56666666666, -55666666666)),
		(0, (-55666666666, 56666666666))]),
	T_ll_u(WasmOpcode.I64_GE_U, [
		(1, (55777777777, 54777777777)),
		(1, (55777777777, 55777777777)),
		(0, (55777777777, 56777777777)),
		(0, (-56777777777, -55777777777)),
		(1, (-55777777777, 56777777777))]),

	T_u_u(WasmOpcode.I32_CLZ, [
		(32, 0),
		(16, 0x8000),
		(0, 0x80000000),
		(31, 1)]),
	T_u_u(WasmOpcode.I32_CTZ, [
		(32, 0),
		(15, 0x8000),
		(31, 0x80000000),
		(0, 1)]),
	T_u_u(WasmOpcode.I32_POPCNT, [
		(0, 0),
		(1, 1),
		(4, 0xF),
		(32, 0xFFFFFFFF)]),
	T_ii_i(WasmOpcode.I32_ADD, [
		(14233, (4312, 9921)),
		(0x00000000, (0xffff0000, 0x00010000)),
		(0x10000000, (0x0fff0000, 0x00010000)),
		(0xffffffff, (0xffff0000, 0x0000ffff))]),
	T_ii_i(WasmOpcode.I32_SUB, [
		(68700981, (76324872, 7623891)),
		(0xFFFFFFFF, (0, 1)),
		(0, (444, 444))]),
	T_ii_i(WasmOpcode.I32_MUL, [
		(544174, (8122, 67)),
		(0, (0xffff0000, 0)),
		(0x80975D68, (0x87234878, 0x1124783))]),
	T_ii_r(WasmOpcode.I32_DIV_S, [
		(u_r(33), (99, 3)),
		(i_r(-33), (99, -3)),
		(Result.Trap(TrapReason.DIV_BY_ZERO), (1, 0)),
		(Result.Trap(TrapReason.DIV_UNREPRESENTABLE), (i32.min, -1))]),
	T_ii_r(WasmOpcode.I32_DIV_U, [
		(u_r(33), (99, 3)),
		(u_r(0), (99, -3)),
		(Result.Trap(TrapReason.DIV_BY_ZERO), (1, 0)),
		(u_r(0), (0x80000000, 0xFFFFFFFF))]),
	T_ii_r(WasmOpcode.I32_REM_S, [
		(u_r(9), (99, 10)),
		(i_r(7), (107, -10)),
		(i_r(-7), (-107, -10)),
		(i_r(-7), (-107, 10)),
		(Result.Trap(TrapReason.REM_BY_ZERO), (1, 0)),
		(u_r(0), (5559823, 1)),
		(u_r(0), (0x80000000, 0xFFFFFFFF))]),
	T_ii_r(WasmOpcode.I32_REM_U, [
		(u_r(8), (13338, 10)),
		(u_r(99), (99, -3)),
		(Result.Trap(TrapReason.REM_BY_ZERO), (1, 0)),
		(u_r(0), (555, 1)),
		(u_r(0x80000000), (0x80000000, 0xFFFFFFFF))]),
	T_uu_u(WasmOpcode.I32_AND, [
		(0x000FF000, (0xFFFFF000, 0x000FFFFF))]),
	T_uu_u(WasmOpcode.I32_OR, [
		(0x0FFFFFFF, (0x0FFFF000, 0x000FFFFF))]),
	T_uu_u(WasmOpcode.I32_XOR, [
		(0x0FF00FFF, (0x0FFFF000, 0x000FFFFF))]),
	T_uu_u(WasmOpcode.I32_SHL, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF000, (0x000FF000, 32)),
		(0x80000000, (0xFFFFFFFF, 31)),
		(0x00FF0000, (0x000FF000, 36))]),
	T_uu_u(WasmOpcode.I32_SHR_S, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF000, (0x000FF000, 32)),
		(0x00000001, (0x0FFFFFFF, 27)),
		(0xFFFFFFF0, (0xFFFFFF00, 4)),
		(0x0000FF00, (0x000FF000, 36))]),
	T_uu_u(WasmOpcode.I32_SHR_U, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF000, (0x000FF000, 32)),
		(0x00000001, (0xFFFFFFFF, 31)),
		(0x0000FF00, (0x000FF000, 36))]),
	T_uu_u(WasmOpcode.I32_ROTL, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF000, (0x000FF000, 32)),
		(0xBCD0123A, (0xABCD0123, 36))]),
	T_uu_u(WasmOpcode.I32_ROTR, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF000, (0x000FF000, 32)),
		(0x3ABCD012, (0xABCD0123, 36))]),

	T_w_w(WasmOpcode.I64_CLZ, [
		(64, 0),
		(48, 0x8000),
		(32, 0x80000000),
		(0, 0x8000000000000000),
		(63, 1)]),
	T_w_w(WasmOpcode.I64_CTZ, [
		(64, 0),
		(15, 0x8000),
		(31, 0x80000000),
		(63, 0x8000000000000000),
		(0, 1)]),
	T_w_w(WasmOpcode.I64_POPCNT, [
		(0, 0),
		(1, 1),
		(4, 0xF),
		(8, 0xF00000000F0),
		(32, 0x3333333333333333),
		(64, 0xFFFFFFFFFFFFFFFF),
		(32, 0xFFFFFFFF)]),
	T_ww_w(WasmOpcode.I64_ADD, [
		(14233111111111, (4312000111000, 9921111000111)),
		(0x100000000, (0xffff0000, 0x00010000)),
		(0x10000000, (0x0fff0000, 0x00010000)),
		(0xffffffff, (0xffff0000, 0x0000ffff))]),
	T_ll_l(WasmOpcode.I64_SUB, [
		(68700981000000, (76324872010101, 7623891010101)),
		(-1, (0, 1)),
		(0, (4449988776655, 4449988776655))]),
	T_ww_w(WasmOpcode.I64_MUL, [
		(544174000000, (8122000, 67000)),
		(0, (0xffff0000, 0)),
		(0x90C98380975D68, (0x87234878, 0x1124783))]),
	T_ll_r(WasmOpcode.I64_DIV_S, [
		(w_r(33), (99, 3)),
		(l_r(-33), (99, -3)),
		(Result.Trap(TrapReason.DIV_BY_ZERO), (1, 0)),
		(Result.Trap(TrapReason.DIV_UNREPRESENTABLE), (i64.min, -1))]),
	T_ll_r(WasmOpcode.I64_DIV_U, [
		(w_r(33), (99, 3)),
		(w_r(0), (99, -3)),
		(Result.Trap(TrapReason.DIV_BY_ZERO), (1, 0)),
		(w_r(0), (i64.min, -1))]),
	T_ll_r(WasmOpcode.I64_REM_S, [
		(w_r(9), (99, 10)),
		(l_r(7), (107, -10)),
		(l_r(-7), (-107, -10)),
		(l_r(-7), (-107, 10)),
		(Result.Trap(TrapReason.REM_BY_ZERO), (1, 0)),
		(w_r(0), (5559823, 1)),
		(w_r(0), (i64.min, -1))]),
	T_ll_r(WasmOpcode.I64_REM_U, [
		(w_r(8), (13338, 10)),
		(w_r(99), (99, -3)),
		(Result.Trap(TrapReason.REM_BY_ZERO), (1, 0)),
		(w_r(0), (555, 1)),
		(w_r(0x80000000u), (0x80000000u, -1))]),
	T_ww_w(WasmOpcode.I64_AND, [
		(0xFF00FF00FF00FF00, (0xFFFFFFFFFF00FF00, 0xFF00FF00FFFFFFFF))]),
	T_ww_w(WasmOpcode.I64_OR, [
		(0x0FFFFFFFFFFFFFFF, (0x0FFFFFFFF0000000, 0x0000000FFFFFFFFF))]),
	T_ww_w(WasmOpcode.I64_XOR, [
		(0x00FF00FF00FF00FF, (0xFFFFFFFFFF00FF00, 0xFF00FF00FFFFFFFF))]),
	T_ww_w(WasmOpcode.I64_SHL, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF000, (0x000FF000, 64)),
		(0x000FF00000000000, (0x000FF000, 32)),
		(0x7FFFFFFF80000000, (0xFFFFFFFF, 31)),
		(0x00FF0000, (0x000FF000, 68)),
		(0x00FF000000000000, (0x000FF000, 36))]),
	T_ww_w(WasmOpcode.I64_SHR_S, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF000, (0x000FF000, 64)),
		(0x000FF000, (0x000FF00000000000, 32)),
		(0x00000001, (0x0FFFFFFF, 27)),
		(0xFFFFFFFFFFFFFFF0, (0xFFFFFFFFFFFFFF00, 4)),
		(0x0000FF00, (0x000FF000, 68))]),
	T_ww_w(WasmOpcode.I64_SHR_U, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF000, (0x000FF00011223344, 32)),
		(0x000FF000, (0x000FF000, 64)),
		(0x00000001, (0xFFFFFFFFFFFFFFFF, 63)),
		(0x0000FF00, (0x000FF000, 68))]),
	T_ww_w(WasmOpcode.I64_ROTL, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF000, (0x000FF00000000000, 32)),
		(0x000FF000, (0x000FF000, 64)),
		(0x123456789ABCDEF0, (0x0123456789ABCDEF, 68))]),
	T_ww_w(WasmOpcode.I64_ROTR, [
		(0x000FF000, (0x000FF000, 0)),
		(0x000FF00000000000, (0x000FF000, 32)),
		(0x000FF000, (0x000FF000, 64)),
		(0xF0123456789ABCDE, (0x0123456789ABCDEF, 68))]),
	()
];


class InterpreterTester(t: Tester) extends ModuleBuilder {
	var limit = 1000;

	def timeout(t: int) -> this {
		limit = t;
	}
	def run(args: Array<Value>) -> Result {
		var instance = Instance.new(module, []);
		var f = instance.getFunction(0);
		var i = Interpreter.new();
		var buf: StringBuffer;
		if (wizeng.verbose) {
			buf = StringBuffer.new();
			buf.puts("[");
			if (args != null) for (i < args.length) {
				if (i > 0) buf.puts(", ");
				Values.render(buf, args[i]);
			}
			buf.puts("]: \n");
			System.puts(buf.extract());
		}
		var r = i.run(limit, f, args);
		if (wizeng.verbose) {
			buf.put1(" => %q\n", r.render);
			System.puts(buf.extract());
		}
		return r;
	}
	def run1(args: Array<Value>) -> Value {
		var r = run(args);
		match (r) {
			Break => t.fail("unexpected breakpoint");
			Trap(reason) => t.fail1("unexpected trap: %s", reason.name);
			Value(vals) => {
				if (vals.length != 1) t.fail1("expected 1 return value, got %d", vals.length);
				else return vals[0];
			}
		}
		return Value.Nil;
	}
	def assert_u32(expected: u32, args: Array<Value>) {
		assert_r(Result.Value([Value.I32(expected)]), args);
	}
	def assert_u64(expected: u64, args: Array<Value>) {
		assert_r(Result.Value([Value.I64(expected)]), args);
	}
	def assert_f32(expected: u32, args: Array<Value>) {
		assert_r(Result.Value([Value.F32(expected)]), args);
	}
	def assert_f64(expected: u64, args: Array<Value>) {
		assert_r(Result.Value([Value.F64(expected)]), args);
	}
	def assert_i_i(expected: u32, a: u32) {
		assert_u32(expected, [Value.I32(a)]);
	}
	def assert_ii_i(expected: u32, a: u32, b: u32) {
		assert_u32(expected, [Value.I32(a), Value.I32(b)]);
	}
	def assert_r(expected: Result, args: Array<Value>) {
		var got = run(args);
		if (expected.equals(got)) return;
		t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_trap(expected: TrapReason, args: Array<Value>) {
		assert_r(Result.Trap(expected), args);
	}
	def assert_nop(args: Array<Value>) {
		var r = run(args);
		match (r) {
			Break => t.fail("unexpected breakpoint");
			Trap(reason) => t.fail1("unexpected trap: %s", reason.name);
			Value(vals) => {
				var len = if(vals != null, vals.length);
				if (len > 0) t.fail1("expected no values, got %d value(s)", len);
			}
		}
	}
}

//===========================================================
// Begin actual tests
//===========================================================
def test_unreachable(i: InterpreterTester) {
	i.code([WasmOpcode.UNREACHABLE.code]).assert_trap(TrapReason.UNREACHABLE, X);
}

def test_nop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.NOP.code]).assert_nop(X);
}

def test_block(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.BLOCK.code, NONE, WasmOpcode.END.code]).assert_nop(X);
	// TODO: unit test blocks with block types
}

def test_loop(i: InterpreterTester) {
	i.sig(SigCache.v_v);
	i.code([WasmOpcode.LOOP.code, NONE, WasmOpcode.END.code]);
	i.assert_nop(X);

	i.sig(SigCache.i_i);
	i.code([WasmOpcode.LOOP.code, NONE,
		WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.I32_CONST.code, 1,
		WasmOpcode.I32_SUB.code,
		WasmOpcode.LOCAL_TEE.code, 0,
		WasmOpcode.BR_IF.code, 0,
		WasmOpcode.END.code,
		WasmOpcode.LOCAL_GET.code, 0]);
	i.validate();
	i.assert_i_i(0, 1);
	i.assert_i_i(0, 5);
	// TODO: unit test loops with block types
}
def test_if0(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.code([WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.IF.code, NONE,
		WasmOpcode.I32_CONST.code, 11,
		WasmOpcode.RETURN.code,
		WasmOpcode.ELSE.code,
		WasmOpcode.I32_CONST.code, 22,
		WasmOpcode.RETURN.code,
		WasmOpcode.END.code]);
	i.validate();
	i.assert_i_i(11, 9);
	i.assert_i_i(22, 0);
	i.code([WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.IF.code, NONE,
		WasmOpcode.I32_CONST.code, 33,
		WasmOpcode.LOCAL_SET.code, 0,
		WasmOpcode.ELSE.code,
		WasmOpcode.I32_CONST.code, 44,
		WasmOpcode.LOCAL_SET.code, 0,
		WasmOpcode.END.code,
		WasmOpcode.LOCAL_GET.code, 0]);
	i.validate();
	i.assert_i_i(33, 7);
	i.assert_i_i(44, 0);

	i.code([WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.IF.code, NONE,
		WasmOpcode.I32_CONST.code, 13,
		WasmOpcode.LOCAL_SET.code, 0,
		WasmOpcode.END.code,
		WasmOpcode.LOCAL_GET.code, 0]);
	i.validate();
	i.assert_i_i(13, 7);
	i.assert_i_i(0, 0);
}
def test_if1(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.code([WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.IF.code, BpTypecon.I32.code,
		WasmOpcode.I32_CONST.code, 17,
		WasmOpcode.ELSE.code,
		WasmOpcode.I32_CONST.code, 27,
		WasmOpcode.END.code]);
	i.validate();
	i.assert_i_i(17, 6);
	i.assert_i_i(27, 0);

	i.code([WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.IF.code, BpTypecon.I32.code,
		WasmOpcode.I32_CONST.code, 18,
		WasmOpcode.BR.code, 0,
		WasmOpcode.ELSE.code,
		WasmOpcode.I32_CONST.code, 28,
		WasmOpcode.BR.code, 0,
		WasmOpcode.END.code]);
	i.validate();
	i.assert_i_i(18, 4);
	i.assert_i_i(28, 0);
}
def test_else(i: InterpreterTester) { /* TODO */ }
def test_end(i: InterpreterTester) { /* TODO */ }
def test_br(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.code([WasmOpcode.LOCAL_GET.code, 0, WasmOpcode.BR.code, 0]);
	i.validate();
	i.assert_i_i(3, 3);
	i.assert_i_i(9, 9);

	i.sig(SigCache.ii_i);
	i.code([WasmOpcode.LOCAL_GET.code, 1, WasmOpcode.LOCAL_GET.code, 0, WasmOpcode.BR.code, 0]);
	i.validate();
	i.assert_ii_i(7, 7, 11);
	i.assert_ii_i(5, 5, 99);
}
def test_br_if(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.code([WasmOpcode.I32_CONST.code, 7,
		WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.BR_IF.code, 0,
		WasmOpcode.DROP.code,
		WasmOpcode.I32_CONST.code, 8]);
	i.validate();
	i.assert_i_i(7, 11);
	i.assert_i_i(8, 0);

	i.sig(SigCache.i_i);
	i.code([WasmOpcode.BLOCK.code, NONE,
		WasmOpcode.I32_CONST.code, 9,
		WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.BR_IF.code, 1,
		WasmOpcode.DROP.code,
		WasmOpcode.END.code,
		WasmOpcode.I32_CONST.code, 5]);
	i.validate();
	i.assert_i_i(9, 17);
	i.assert_i_i(5, 0);
}
def test_br_table(i: InterpreterTester) { /* TODO */ }
def test_return(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.RETURN.code]).assert_nop(X);
	i.sig(SigCache.v_v).code([WasmOpcode.I32_CONST.code, 0,
				  WasmOpcode.RETURN.code]).assert_nop(X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 9,
				  WasmOpcode.RETURN.code]).assert_u32(9, X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 7,
				  WasmOpcode.I32_CONST.code, 13,
				  WasmOpcode.RETURN.code]).assert_u32(13, X);
}
def test_call1(i: InterpreterTester) {
	var f17 = byte.!(i.addFunction(SigCache.v_i, [WasmOpcode.I32_CONST.code, 17]));
	var f18 = byte.!(i.addFunction(SigCache.v_i, [WasmOpcode.I32_CONST.code, 18]));
	var f19 = byte.!(i.addFunction(SigCache.v_i, [WasmOpcode.I32_CONST.code, 19]));
	i.code([WasmOpcode.CALL.code, f17]).assert_u32(17, X);
	i.code([WasmOpcode.CALL.code, f18]).assert_u32(18, X);
	i.code([WasmOpcode.CALL.code, f19]).assert_u32(19, X);
	// TODO: more call tests
}
def test_call2(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	var f1 = byte.!(i.addFunction(SigCache.i_i, [WasmOpcode.LOCAL_GET.code, 0]));
	i.code([WasmOpcode.LOCAL_GET.code, 0, WasmOpcode.CALL.code, f1]);
	i.assert_i_i(197, 197);
	i.assert_i_i(36, 36);
	i.assert_i_i(31337, 31337);

	i.sig(SigCache.ii_i);
	var f2 = byte.!(i.addFunction(SigCache.ii_i, [WasmOpcode.LOCAL_GET.code, 0]));
	var f3 = byte.!(i.addFunction(SigCache.ii_i, [WasmOpcode.LOCAL_GET.code, 1]));
	i.code([WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.LOCAL_GET.code, 1,
		WasmOpcode.CALL.code, f2]);
	i.assert_ii_i(22, 22, 33);
	i.assert_ii_i(44, 44, 55);
	i.code([WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.LOCAL_GET.code, 1,
	WasmOpcode.CALL.code, f3]);
	i.assert_ii_i(88, 77, 88);
	i.assert_ii_i(99, 88, 99);
}
def test_call_indirect(i: InterpreterTester) { /* TODO */ }
def test_drop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.I32_CONST.code, 0, WasmOpcode.DROP.code])
		.assert_nop(X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 3,
				  WasmOpcode.DROP.code,
				  WasmOpcode.I32_CONST.code, 11])
		.assert_u32(11, X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 4,
				  WasmOpcode.I32_CONST.code, 5,
				  WasmOpcode.DROP.code])
		.assert_u32(4, X);
}
def test_select(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.code([WasmOpcode.I32_CONST.code, 11,
		WasmOpcode.I32_CONST.code, 22,
		WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.SELECT.code]);
	i.assert_i_i(11, 1);
	i.assert_i_i(11, 108);
	i.assert_i_i(22, 0);
	// TODO: test select with i64, f32, f64
}
def test_locals1(i: InterpreterTester) {
	i.sig(SigCache.i_i).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_i_i(11, 11);

	var i1 = byte.!(i.addLocal(ValueType.I32));
	i.code([WasmOpcode.LOCAL_GET.code, i1]);
	i.assert_i_i(0, 17);

	i.code([
		WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.LOCAL_SET.code, i1,
		WasmOpcode.LOCAL_GET.code, i1
	]);
	i.assert_i_i(19, 19);

	var i2 = byte.!(i.addLocal(ValueType.I32));
	i.code([
		WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.LOCAL_SET.code, i1,
		WasmOpcode.LOCAL_GET.code, i2
	]);
	i.assert_i_i(0, 23);
}
def test_locals2(i: InterpreterTester) {
	var l1 = byte.!(i.addLocal(ValueType.I64));
	i.sig(SigCache.v_l).code([
		WasmOpcode.LOCAL_GET.code, l1
	]);
	i.assert_u64(0, X);

	var f1 = byte.!(i.addLocal(ValueType.F32));
	i.sig(SigCache.v_f).code([
		WasmOpcode.LOCAL_GET.code, f1
	]);
	i.assert_f32(0, X);

	var d1 = byte.!(i.addLocal(ValueType.F64));
	i.sig(SigCache.v_d).code([
		WasmOpcode.LOCAL_GET.code, d1
	]);
	i.assert_f64(0, X);
}
def test_params(i: InterpreterTester) {
	i.sig(SigCache.i_i).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_u32(13, [Value.I32(13)]);
	i.assert_u32(9991, [Value.I32(9991)]);

	i.sig(SigCache.l_l).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_u64(137, [Value.I64(137)]);
	i.assert_u64(999145, [Value.I64(999145)]);

	i.sig(SigCache.f_f).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_f32(137u, [Value.F32(137u)]);
	i.assert_f32(999145u, [Value.F32(999145u)]);

	i.sig(SigCache.d_d).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_f64(137u, [Value.F64(137u)]);
	i.assert_f64(999145u, [Value.F64(999145u)]);

	i.sig(SigCache.ii_i).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_u32(12, [Value.I32(12), Value.I32(15)]);
	i.assert_u32(9791, [Value.I32(9791), Value.I32(66)]);

	i.sig(SigCache.ii_i).code([WasmOpcode.LOCAL_GET.code, 1]);
	i.assert_u32(157, [Value.I32(12), Value.I32(157)]);
	i.assert_u32(8791, [Value.I32(9791), Value.I32(8791)]);
}
def test_globals(i: InterpreterTester) {
	var index = i.addGlobal(ValueType.I32, InitExpr.I32(34));
	i.code([WasmOpcode.GLOBAL_GET.code, byte.!(index)]).assert_u32(34, X);
	i.code([WasmOpcode.I32_CONST.code, 44,
		WasmOpcode.GLOBAL_SET.code, byte.!(index),
		WasmOpcode.GLOBAL_GET.code, byte.!(index)]).assert_u32(44, X);

	index = i.addGlobal(ValueType.I64, InitExpr.I64(55));
	i.code([WasmOpcode.GLOBAL_GET.code, byte.!(index)]).assert_u64(55, X);
}

def test_const(i: InterpreterTester) {
	i.code([WasmOpcode.I32_CONST.code, 1]).assert_u32(1, X);
	i.code([WasmOpcode.I32_CONST.code, 33]).assert_u32(33, X);
	i.code([WasmOpcode.I32_CONST.code, 0xA7, 0x7F]).assert_u32(16295, X);
	i.code([WasmOpcode.I32_CONST.code, 0x70]).assert_u32(112, X);
	i.code([WasmOpcode.I32_CONST.code, 0xA7, 0xF0, 0xF1, 0xF2,
		0x8E, 0x00]).assert_u32(3999037479u, X);

	i.code([WasmOpcode.I64_CONST.code, 1]).assert_u64(1, X);
	i.code([WasmOpcode.I64_CONST.code, 33]).assert_u64(33, X);
	i.code([WasmOpcode.I64_CONST.code, 0x70]).assert_u64(112, X);
	i.code([WasmOpcode.I64_CONST.code, 0x81, 0x82, 0x83, 0x84,
		0x85, 0x86, 0x87, 0x88, 0x09]).assert_u64(653052939803345153, X);

	i.code([WasmOpcode.F32_CONST.code, 0x44, 0x33, 0x22, 0x11]).assert_f32(0x11223344, X);
	i.code([WasmOpcode.F32_CONST.code, 0x66, 0x77, 0x88, 0x99]).assert_f32(0x99887766, X);
}

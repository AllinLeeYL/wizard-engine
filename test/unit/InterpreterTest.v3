// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.register;
def X: Array<Value>;
def NONE = BpTypecon.EmptyBlock.code;

def reg<I, R>(opcode: WasmOpcode,
		f: (Tester, WasmOpcode, Array<(R, (I, I))>) -> void,
		cases: Array<(R, (I, I))>) {
	var buf = StringBuffer.new();
	buf.put1("interp/%s", opcode.mnemonic);
	UnitTests.register(buf.extract(), f(_, opcode, cases));
}

def T_ii_i = reg(_, test_ii_i, _);
def T_ii_r = reg(_, test_ii_r, _);

def Z = [
	T("interp/unreachable", w(test_unreachable)),
	T("interp/nop", w(test_nop)),
	T("interp/block", w(test_block)),
	T("interp/loop", w(test_loop)),
	T("interp/if", w(test_if)),
	T("interp/else", w(test_else)),
	T("interp/end", w(test_end)),
	T("interp/br", w(test_br)),
	T("interp/br_if", w(test_br_if)),
	T("interp/br_table", w(test_br_table)),
	T("interp/return", w(test_return)),
	T("interp/call1", w(test_call1)),
	T("interp/call2", w(test_call2)),
	T("interp/call_indirect", w(test_call_indirect)),
	T("interp/drop", w(test_drop)),
	T("interp/select", w(test_select)),
	T("interp/locals1", w(test_locals1)),
	T("interp/locals2", w(test_locals2)),
	T("interp/params", w(test_params)),
	T("interp/globals", w(test_globals)),
	T("interp/const", w(test_const)),

	T_ii_i(WasmOpcode.I32_ADD, [
		(14233, (4312, 9921)),
		(0x00000000, (0xffff0000, 0x00010000)),
		(0x10000000, (0x0fff0000, 0x00010000)),
		(0xffffffff, (0xffff0000, 0x0000ffff))]),
	T_ii_r(WasmOpcode.I32_DIV_S, [
		(ru32(33), (99, 3)),
		(ri32(-33), (99, u32.!(-3))),
		(Result.Trap(TrapReason.DIV_BY_ZERO), (1, 0)),
		(Result.Trap(TrapReason.DIV_UNREPRESENTABLE), (0x80000000, 0xFFFFFFFF))]),
	T_ii_r(WasmOpcode.I32_DIV_U, [
		(ru32(33), (99, 3)),
		(ru32(0), (99, u32.!(-3))),
		(Result.Trap(TrapReason.DIV_BY_ZERO), (1, 0)),
		(ru32(0), (0x80000000, 0xFFFFFFFF))]),
	()
];


def r(t: Tester, f: InterpreterTester -> ()) {
	return f(InterpreterTester.new(t));
}
def w(f: InterpreterTester -> ()) -> Tester -> () {
	return r(_, f);
}

class InterpreterTester(t: Tester) {
	def module = Module.new();
	var func: FunctionDecl;
	var limit = 10000;
	def locals = Vector<(ValueType, u32)>.new();
	var num_locals: int;
	new() {
		var sig = SigCache.v_i;
		module.types.declared.add(sig);
		func = FunctionDecl.new(false, 0, sig);
		module.functions.declared.add(func);
	}
	def sig(sig: TypeDecl.Function) -> this {
		module.types.declared[0] = sig;
		func = FunctionDecl.new(false, 0, sig);
		module.functions.declared[0] = func;
	}
	def code(raw: Array<byte>) -> this {
		var body = makeBody(raw, this.locals);
		func.code = FunctionCode.new(body);
		func.code.num_locals = num_locals;
	}
	def makeBody(raw: Array<byte>, locals: Vector<(ValueType, u32)>) -> Array<byte> {
		var copy = Vector<byte>.new();
		BinEncoder.append_u32leb(copy, u32.!(locals.size()));
		for (i < locals.size()) {
			var e = locals[i];
			BinEncoder.append_u32leb(copy, u32.!(e.1));
			BinEncoder.append_ValueType(copy, e.0);
		}
		copy.addv(raw);
		copy.add(WasmOpcode.END.code);
		return copy.extract();
	}
	def global(typ: ValueType, init: InitExpr) -> int {
		var index = module.globals.size();
		module.globals.declared.add(GlobalDecl.new(false, typ, true, init));
		return index;
	}
	def local(typ: ValueType) -> int {
		var size = locals.size();
		if (size > 0) {
			var last = locals[size-1];
			if (last.0 == typ) {
				locals[size-1] = (last.0, last.1+1);
				return func.sig.params.length + num_locals++;
			}
		}
		locals.add((typ, 1));
		return func.sig.params.length + num_locals++;
	}
	def function(sig: TypeDecl.Function, raw: Array<byte>) -> int {
		var sig_index = module.types.size();
		module.types.declared.add(sig);
		var func = FunctionDecl.new(false, sig_index, sig);
		module.functions.declared.add(func);
		func.code = FunctionCode.new(makeBody(raw, Vector.new()));
		return module.functions.size() - 1;
	}
	def run(args: Array<Value>) -> Result {
		var instance = Instance.new(module, []);
		var f = instance.getFunction(0);
		var i = Interpreter.new();
		var r = i.run(limit, f, args);
		return r;
	}
	def run1(args: Array<Value>) -> Value {
		var r = run(args);
		match (r) {
			Break => t.fail("unexpected breakpoint");
			Trap(reason) => t.fail1("unexpected trap: %s", reason.name);
			Value(vals) => {
				if (vals.length != 1) t.fail1("expected 1 return value, got %d", vals.length);
				else return vals[0];
			}
		}
		return Value.Nil;
	}
	def assert_u32(expected: u32, args: Array<Value>) {
		assert_r(Result.Value([Value.I32(expected)]), args);
	}
	def assert_u64(expected: u64, args: Array<Value>) {
		assert_r(Result.Value([Value.I64(expected)]), args);
	}
	def assert_f32(expected: u32, args: Array<Value>) {
		assert_r(Result.Value([Value.F32(expected)]), args);
	}
	def assert_f64(expected: u64, args: Array<Value>) {
		assert_r(Result.Value([Value.F64(expected)]), args);
	}
	def assert_i_i(expected: u32, a: u32) {
		assert_u32(expected, [Value.I32(a)]);
	}
	def assert_ii_i(expected: u32, a: u32, b: u32) {
		assert_u32(expected, [Value.I32(a), Value.I32(b)]);
	}
	def assert_r(expected: Result, args: Array<Value>) {
		var got = run(args);
		if (expected.equals(got)) return;
		t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_trap(expected: TrapReason, args: Array<Value>) {
		assert_r(Result.Trap(expected), args);
	}
	def assert_nop(args: Array<Value>) {
		var r = run(args);
		match (r) {
			Break => t.fail("unexpected breakpoint");
			Trap(reason) => t.fail1("unexpected trap: %s", reason.name);
			Value(vals) => {
				var len = if(vals != null, vals.length);
				if (len > 0) t.fail1("expected no values, got %d value(s)", len);
			}
		}
	}
}

def ri32(val: i32) -> Result {
	return Result.Value([Value.I32(u32.!(val))]);
}
def ru32(val: u32) -> Result {
	return Result.Value([Value.I32(val)]);
}
def test_ii_i(t: Tester, opcode: WasmOpcode, cases: Array<(u32, (u32, u32))>) {
	def i = InterpreterTester.new(t);
	i.sig(SigCache.ii_i);
	i.code([WasmOpcode.LOCAL_GET.code, 0, WasmOpcode.LOCAL_GET.code, 1, opcode.code]);
	for (c in cases) {
		i.assert_ii_i(c.0, c.1.0, c.1.1);
	}
}

def test_ii_r(t: Tester, opcode: WasmOpcode, cases: Array<(Result, (u32, u32))>) {
	def i = InterpreterTester.new(t);
	i.sig(SigCache.ii_i);
	i.code([WasmOpcode.LOCAL_GET.code, 0, WasmOpcode.LOCAL_GET.code, 1, opcode.code]);
	for (c in cases) {
		i.assert_r(c.0, [Value.I32(c.1.0), Value.I32(c.1.1)]);
	}
}

def test_unreachable(i: InterpreterTester) {
	i.code([WasmOpcode.UNREACHABLE.code]).assert_trap(TrapReason.UNREACHABLE, X);
}

def test_nop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.NOP.code]).assert_nop(X);
}

def test_block(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.BLOCK.code, NONE, WasmOpcode.END.code]).assert_nop(X);
	// TODO: unit test blocks with block types
}

def test_loop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.LOOP.code, NONE, WasmOpcode.END.code]).assert_nop(X);
	// TODO: unit test loops with block types
}
def test_if(i: InterpreterTester) { /* TODO */ }
def test_else(i: InterpreterTester) { /* TODO */ }
def test_end(i: InterpreterTester) { /* TODO */ }
def test_br(i: InterpreterTester) { /* TODO */ }
def test_br_if(i: InterpreterTester) { /* TODO */ }
def test_br_table(i: InterpreterTester) { /* TODO */ }
def test_return(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.RETURN.code]).assert_nop(X);
	i.sig(SigCache.v_v).code([WasmOpcode.I32_CONST.code, 0,
				  WasmOpcode.RETURN.code]).assert_nop(X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 9,
				  WasmOpcode.RETURN.code]).assert_u32(9, X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 7,
				  WasmOpcode.I32_CONST.code, 13,
				  WasmOpcode.RETURN.code]).assert_u32(13, X);
}
def test_call1(i: InterpreterTester) {
	var f17 = byte.!(i.function(SigCache.v_i, [WasmOpcode.I32_CONST.code, 17]));
	var f18 = byte.!(i.function(SigCache.v_i, [WasmOpcode.I32_CONST.code, 18]));
	var f19 = byte.!(i.function(SigCache.v_i, [WasmOpcode.I32_CONST.code, 19]));
	i.code([WasmOpcode.CALL.code, f17]).assert_u32(17, X);
	i.code([WasmOpcode.CALL.code, f18]).assert_u32(18, X);
	i.code([WasmOpcode.CALL.code, f19]).assert_u32(19, X);
	// TODO: more call tests
}
def test_call2(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	var f1 = byte.!(i.function(SigCache.i_i, [WasmOpcode.LOCAL_GET.code, 0]));
	i.code([WasmOpcode.LOCAL_GET.code, 0, WasmOpcode.CALL.code, f1]);
	i.assert_i_i(197, 197);
	i.assert_i_i(36, 36);
	i.assert_i_i(31337, 31337);

	i.sig(SigCache.ii_i);
	var f2 = byte.!(i.function(SigCache.ii_i, [WasmOpcode.LOCAL_GET.code, 0]));
	var f3 = byte.!(i.function(SigCache.ii_i, [WasmOpcode.LOCAL_GET.code, 1]));
	i.code([WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.LOCAL_GET.code, 1,
		WasmOpcode.CALL.code, f2]);
	i.assert_ii_i(22, 22, 33);
	i.assert_ii_i(44, 44, 55);
	i.code([WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.LOCAL_GET.code, 1,
	WasmOpcode.CALL.code, f3]);
	i.assert_ii_i(88, 77, 88);
	i.assert_ii_i(99, 88, 99);
}
def test_call_indirect(i: InterpreterTester) { /* TODO */ }
def test_drop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.I32_CONST.code, 0, WasmOpcode.DROP.code])
		.assert_nop(X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 3,
				  WasmOpcode.DROP.code,
				  WasmOpcode.I32_CONST.code, 11])
		.assert_u32(11, X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 4,
				  WasmOpcode.I32_CONST.code, 5,
				  WasmOpcode.DROP.code])
		.assert_u32(4, X);
}
def test_select(i: InterpreterTester) { /* TODO */ }
def test_locals1(i: InterpreterTester) {
	i.sig(SigCache.i_i).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_i_i(11, 11);

	var i1 = byte.!(i.local(ValueType.I32));
	i.code([WasmOpcode.LOCAL_GET.code, i1]);
	i.assert_i_i(0, 17);

	i.code([
		WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.LOCAL_SET.code, i1,
		WasmOpcode.LOCAL_GET.code, i1
	]);
	i.assert_i_i(19, 19);

	var i2 = byte.!(i.local(ValueType.I32));
	i.code([
		WasmOpcode.LOCAL_GET.code, 0,
		WasmOpcode.LOCAL_SET.code, i1,
		WasmOpcode.LOCAL_GET.code, i2
	]);
	i.assert_i_i(0, 23);
}
def test_locals2(i: InterpreterTester) {
	var l1 = byte.!(i.local(ValueType.I64));
	i.sig(SigCache.v_l).code([
		WasmOpcode.LOCAL_GET.code, l1
	]);
	i.assert_u64(0, X);

	var f1 = byte.!(i.local(ValueType.F32));
	i.sig(SigCache.v_f).code([
		WasmOpcode.LOCAL_GET.code, f1
	]);
	i.assert_f32(0, X);

	var d1 = byte.!(i.local(ValueType.F64));
	i.sig(SigCache.v_d).code([
		WasmOpcode.LOCAL_GET.code, d1
	]);
	i.assert_f64(0, X);
}
def test_params(i: InterpreterTester) {
	i.sig(SigCache.i_i).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_u32(13, [Value.I32(13)]);
	i.assert_u32(9991, [Value.I32(9991)]);

	i.sig(SigCache.l_l).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_u64(137, [Value.I64(137)]);
	i.assert_u64(999145, [Value.I64(999145)]);

	i.sig(SigCache.f_f).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_f32(137u, [Value.F32(137u)]);
	i.assert_f32(999145u, [Value.F32(999145u)]);

	i.sig(SigCache.d_d).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_f64(137u, [Value.F64(137u)]);
	i.assert_f64(999145u, [Value.F64(999145u)]);

	i.sig(SigCache.ii_i).code([WasmOpcode.LOCAL_GET.code, 0]);
	i.assert_u32(12, [Value.I32(12), Value.I32(15)]);
	i.assert_u32(9791, [Value.I32(9791), Value.I32(66)]);

	i.sig(SigCache.ii_i).code([WasmOpcode.LOCAL_GET.code, 1]);
	i.assert_u32(157, [Value.I32(12), Value.I32(157)]);
	i.assert_u32(8791, [Value.I32(9791), Value.I32(8791)]);
}
def test_globals(i: InterpreterTester) {
	var index = i.global(ValueType.I32, InitExpr.I32(34));
	i.code([WasmOpcode.GLOBAL_GET.code, byte.!(index)]).assert_u32(34, X);
	i.code([WasmOpcode.I32_CONST.code, 44,
		WasmOpcode.GLOBAL_SET.code, byte.!(index),
		WasmOpcode.GLOBAL_GET.code, byte.!(index)]).assert_u32(44, X);

	index = i.global(ValueType.I64, InitExpr.I64(55));
	i.code([WasmOpcode.GLOBAL_GET.code, byte.!(index)]).assert_u64(55, X);
}

def test_const(i: InterpreterTester) {
	i.code([WasmOpcode.I32_CONST.code, 1]).assert_u32(1, X);
	i.code([WasmOpcode.I32_CONST.code, 33]).assert_u32(33, X);
	i.code([WasmOpcode.I32_CONST.code, 0xA7, 0x7F]).assert_u32(16295, X);
	i.code([WasmOpcode.I32_CONST.code, 0x70]).assert_u32(112, X);
	i.code([WasmOpcode.I32_CONST.code, 0xA7, 0xF0, 0xF1, 0xF2,
		0x8E, 0x00]).assert_u32(3999037479u, X);

	i.code([WasmOpcode.I64_CONST.code, 1]).assert_u64(1, X);
	i.code([WasmOpcode.I64_CONST.code, 33]).assert_u64(33, X);
	i.code([WasmOpcode.I64_CONST.code, 0x70]).assert_u64(112, X);
	i.code([WasmOpcode.I64_CONST.code, 0x81, 0x82, 0x83, 0x84,
		0x85, 0x86, 0x87, 0x88, 0x09]).assert_u64(653052939803345153, X);

	i.code([WasmOpcode.F32_CONST.code, 0x44, 0x33, 0x22, 0x11]).assert_f32(0x11223344, X);
	i.code([WasmOpcode.F32_CONST.code, 0x66, 0x77, 0x88, 0x99]).assert_f32(0x99887766, X);
}

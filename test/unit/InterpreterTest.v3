// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.register;
def Z = [
	T("interp/unreachable", w(test_unreachable)),
	T("interp/nop", w(test_nop)),
	T("interp/block", w(test_block)),
	T("interp/loop", w(test_loop)),
	T("interp/if", w(test_if)),
	T("interp/else", w(test_else)),
	T("interp/end", w(test_end)),
	T("interp/br", w(test_br)),
	T("interp/br_if", w(test_br_if)),
	T("interp/table", w(test_table)),
	T("interp/return", w(test_return)),
	T("interp/call", w(test_call)),
	T("interp/call_indirect", w(test_call_indirect)),
	T("interp/drop", w(test_drop)),
	T("interp/select", w(test_select)),
	T("interp/locals", w(test_locals)),
	T("interp/globals", w(test_globals)),
	T("interp/const", w(test_const)),
	()
];


def r(t: Tester, f: InterpreterTester -> ()) {
	return f(InterpreterTester.new(t));
}
def w(f: InterpreterTester -> ()) -> Tester -> () {
	return r(_, f);
}

class InterpreterTester(t: Tester) {
	def module = Module.new();
	var func: FunctionDecl;
	var limit = 10000;
	new() {
		var sig = SigCache.v_i;
		module.types.declared.add(sig);
		func = FunctionDecl.new(false, 0, sig);
		module.functions.declared.add(func);
	}
	def sig(sig: TypeDecl.Function) -> this {
		module.types.declared[0] = sig;
		func = FunctionDecl.new(false, 0, sig);
		module.functions.declared[0] = func;
	}
	def code(raw: Array<byte>) -> this {
		var copy = Array<byte>.new(raw.length + 1);
		for (i < raw.length) copy[i] = raw[i];
		copy[raw.length] = WasmOpcode.END.code;
		func.code = FunctionCode.new(copy);
	}
	def run(args: Array<Value>) -> Result {
		var instance = Instance.new(module, []);
		var f = instance.getFunction(0);
		var i = Interpreter.new();
		var r = i.run(limit, f, args);
		return r;
	}
	def run1(args: Array<Value>) -> Value {
		var r = run(args);
		match (r) {
			Break => t.fail("unexpected breakpoint");
			Trap(reason) => t.fail1("unexpected trap: %s", reason.name);
			Value(vals) => {
				if (vals.length != 1) t.fail1("expected 1 return value, got %d", vals.length);
				else return vals[0];
			}
		}
		return Value.Nil;
	}
	def assert_u32(expected: u32, args: Array<Value>) {
		var result = run1(args);
		if (!Value.I32.?(result)) return t.fail1("expected i32, got %q", Values.render(_, result));
		var r = Value.I32.!(result).val;
		if (expected != r) return t.fail2("expected %d, got %d", expected, r);
	}
	def assert_u64(expected: u64, args: Array<Value>) {
		var result = run1(args);
		if (!Value.I64.?(result)) return t.fail1("expected i64, got %q", Values.render(_, result));
		var r = u64.!(Value.I64.!(result).val);
		if (expected != r) return t.fail2("expected %d, got %d", expected, r);
	}
	def assert_f32(expected: u32, args: Array<Value>) {
		var result = run1(args);
		if (!Value.F32.?(result)) return t.fail1("expected f32, got %q", Values.render(_, result));
		var r = Value.F32.!(result).bits;
		if (expected != r) return t.fail2("expected 0x%x:f, got 0x%x:f", expected, r);
	}
	def assert_f64(expected: u64, args: Array<Value>) {
		var result = run1(args);
		if (!Value.F64.?(result)) return t.fail1("expected f64, got %q", Values.render(_, result));
		var r = Value.F64.!(result).bits;
		if (expected != r) return t.fail2("expected 0x%x:d, got 0x%x:d", expected, r);
	}
	def assert_trap(expected: TrapReason, args: Array<Value>) {
		var r = run(args);
		match (r) {
			Break => t.fail("unexpected breakpoint");
			Trap(reason) => {
				if (reason != expected) { 
					t.fail2("expected trap %s, got trap %s",
						expected.name, reason.name);
				}
			}
			Value(vals) => t.fail1("expected trap %s, got value(s)", expected.name);
		}
	}
	def assert_nop(args: Array<Value>) {
		var r = run(args);
		match (r) {
			Break => t.fail("unexpected breakpoint");
			Trap(reason) => t.fail1("unexpected trap: %s", reason.name);
			Value(vals) => {
				var len = if(vals != null, vals.length);
				if (len > 0) t.fail1("expected no values, got %d value(s)", len);
			}
		}
	}
}

def box_ii(a: u32, b: u32) -> Array<Value> { return [Value.I32(u32.!(a)), Value.I32(u32.!(b))]; }
def X: Array<Value>;
def NONE = BpTypecon.EmptyBlock.code;

def test_unreachable(i: InterpreterTester) {
	i.code([WasmOpcode.UNREACHABLE.code]).assert_trap(TrapReason.UNREACHABLE, X);
}

def test_nop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.NOP.code]).assert_nop(X);
}

def test_block(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.BLOCK.code, NONE, WasmOpcode.END.code]).assert_nop(X);
	// TODO: unit test blocks with block types
}

def test_loop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.LOOP.code, NONE, WasmOpcode.END.code]).assert_nop(X);
	// TODO: unit test loops with block types
}
def test_if(i: InterpreterTester) { /* TODO */ }
def test_else(i: InterpreterTester) { /* TODO */ }
def test_end(i: InterpreterTester) { /* TODO */ }
def test_br(i: InterpreterTester) { /* TODO */ }
def test_br_if(i: InterpreterTester) { /* TODO */ }
def test_table(i: InterpreterTester) { /* TODO */ }
def test_return(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.RETURN.code]).assert_nop(X);
	i.sig(SigCache.v_v).code([WasmOpcode.I32_CONST.code, 0,
				  WasmOpcode.RETURN.code]).assert_nop(X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 9,
				  WasmOpcode.RETURN.code]).assert_u32(9, X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 7,
				  WasmOpcode.I32_CONST.code, 13,
				  WasmOpcode.RETURN.code]).assert_u32(13, X);
}
def test_call(i: InterpreterTester) { /* TODO */ }
def test_call_indirect(i: InterpreterTester) { /* TODO */ }
def test_drop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([WasmOpcode.I32_CONST.code, 0, WasmOpcode.DROP.code])
		.assert_nop(X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 3,
				  WasmOpcode.DROP.code,
				  WasmOpcode.I32_CONST.code, 11])
		.assert_u32(11, X);
	i.sig(SigCache.v_i).code([WasmOpcode.I32_CONST.code, 4,
				  WasmOpcode.I32_CONST.code, 5,
				  WasmOpcode.DROP.code])
		.assert_u32(4, X);
}
def test_select(i: InterpreterTester) { /* TODO */ }
def test_locals(i: InterpreterTester) { /* TODO */ }
def test_globals(i: InterpreterTester) { /* TODO */ }
	
def test_const(i: InterpreterTester) {
	i.code([WasmOpcode.I32_CONST.code, 1]).assert_u32(1, X);
	i.code([WasmOpcode.I32_CONST.code, 33]).assert_u32(33, X);
	i.code([WasmOpcode.I32_CONST.code, 0xA7, 0x7F]).assert_u32(16295, X);
	i.code([WasmOpcode.I32_CONST.code, 0x70]).assert_u32(112, X);
	i.code([WasmOpcode.I32_CONST.code, 0xA7, 0xF0, 0xF1, 0xF2,
		0x8E, 0x00]).assert_u32(3999037479u, X);

	i.code([WasmOpcode.I64_CONST.code, 1]).assert_u64(1, X);
	i.code([WasmOpcode.I64_CONST.code, 33]).assert_u64(33, X);
	i.code([WasmOpcode.I64_CONST.code, 0x70]).assert_u64(112, X);
	i.code([WasmOpcode.I64_CONST.code, 0x81, 0x82, 0x83, 0x84,
		0x85, 0x86, 0x87, 0x88, 0x09]).assert_u64(653052939803345153, X);

	i.code([WasmOpcode.F32_CONST.code, 0x44, 0x33, 0x22, 0x11]).assert_f32(0x11223344, X);
	i.code([WasmOpcode.F32_CONST.code, 0x66, 0x77, 0x88, 0x99]).assert_f32(0x99887766, X);
}


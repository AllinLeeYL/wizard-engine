// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, SpecTestParserTester.new, _);
def X = [
	T("specparse:i32", test_i32_const),
	T("specparse:i64", test_i64_const),
	T("specparse:f32", test_f32_const),
	T("specparse:f64", test_f64_const),
	T("specparse:string1", test_string1),
	T("specparse:string2", test_string2),
	T("specparse:stringx", test_stringx),
	T("specparse:stringp", test_stringp),
	T("specparse:modbin1", test_modbin1),
	T("specparse:modbinx", test_modbinx),
	T("specparse:modquote1", test_modquote1),
	T("specparse:modx", test_modx),
	T("specparse:mod_named", test_mod_named),
	T("specparse:invoke1", test_invoke1),
	T("specparse:invokex", test_invokex),
	T("specparse:invoke_named", test_invoke_named),
	T("specparse:get1", test_get1),
	T("specparse:getx", test_getx),
	T("specparse:get_named", test_get_named),
	T("specparse:register1", test_register1),
	T("specparse:registerx", test_registerx),
	T("specparse:register_named", test_register_named),
	T("specparse:assert_return", test_assert_return),
	T("specparse:assert_trap", test_assert_trap),
	T("specparse:assert_exhaustion", test_assert_exhaustion),
	T("specparse:assert_invalid", test_assert_invalid),
	T("specparse:assert_malformed", test_assert_malformed),
	T("specparse:assert_unlinkable", test_assert_unlinkable),
	T("specparse:nested1", test_nested1),
	T("specparse:nested2", test_nested2),
	T("specparse:cmds1", test_cmds1),
	T("specparse:cmds2", test_cmds2),
	T("specparse:cmds3", test_cmds3),
	()
];

def FILENAME = "SpecTestParserTest.v3";
class SpecTestParserTester(t: Tester) {
	def parseCommand(input: string) -> SpecTestCommand {
		var p = SpecTestParser.new(FILENAME, input);
		var c = p.parseOneCommand();
		return if(p.ok, c);
	}
	def assert_i(input: string, expected: int) {
		assert_const(input, Value.I32(u32.!(expected)));
	}
	def assert_const(input: string, expected: Value) {
		var v = parseCommand(input);
		if (StCommand.Constant.?(v.cmd)) {
			var got = StCommand.Constant.!(v.cmd).val;
			if (got != expected) {
				t.fail2("expected %q, got %q",
					Values.render(_, expected), Values.render(_, got));
			}
		} else {
			t.fail1("expected constant, got %s", v.cmd.name);
		}
	}
	def assert_string(input: string, expected: string) {
		var p = SpecTestParser.new(FILENAME, input);
		var r = p.parseString();
		if (expected == null) {
			return if(p.ok, t.fail("expected error, but passed"));
		}
		if (!p.ok) return t.fail("expected string, but got error");
		t.assert_string(expected, r);
	}
	def assert_err(input: string) {
		var p = SpecTestParser.new(FILENAME, input);
		var c = p.parseOneCommand();
		if (p.ok) t.fail1("expected error, got %s", c.cmd.name);
	}
	def assert_bin(input: string, expected_varname: string, expected_bytes: Array<byte>) {
		var c = parseCommand(input);
		if (c == null) return t.fail("expected binary module, but got error");
		match (c.cmd) {
			BinaryModule(varname, bytes) => {
				t.assert_string(expected_varname, varname);
				t.assertb(expected_bytes, bytes);
			}
			_ => return t.fail1("expected binary module, but got %s", c.cmd.name);
		}
	}
	def assert_quote(input: string, expected_varname: string, expected_source: string) {
		var c = parseCommand(input);
		if (c == null) return t.fail("expected quote module, but got error");
		match (c.cmd) {
			QuotedModule(varname, source) => {
				t.assert_string(expected_varname, varname);
				t.assert_string(expected_source, source);
			}
			_ => return t.fail1("expected quote module, but got %s", c.cmd.name);
		}
	}
	def assert_invoke(input: string, expected_varname: string, expected_funcname: string) {
		var c = parseCommand(input);
		if (c == null) return t.fail("expected invoke, but got error");
		match (c.cmd) {
			Invoke(varname, funcname) => {
				t.assert_string(expected_varname, varname);
				t.assert_string(expected_funcname, funcname);
			}
			_ => return t.fail1("expected invoke, but got %s", c.cmd.name);
		}
	}
	def assert_get(input: string, expected_varname: string, expected_globalname: string) {
		var c = parseCommand(input);
		if (c == null) return t.fail("expected get, but got error");
		match (c.cmd) {
			GetGlobal(varname, globalname) => {
				t.assert_string(expected_varname, varname);
				t.assert_string(expected_globalname, globalname);
			}
			_ => return t.fail1("expected get, but got %s", c.cmd.name);
		}
	}
	def assert_register(input: string, expected_varname: string, expected_regname: string) {
		var c = parseCommand(input);
		if (c == null) return t.fail("expected register, but got error");
		match (c.cmd) {
			Register(varname, regname) => {
				t.assert_string(expected_varname, varname);
				t.assert_string(expected_regname, regname);
			}
			_ => return t.fail1("expected register, but got %s", c.cmd.name);
		}
	}
}

def test_i32_const(t: SpecTestParserTester) {
	t.assert_i("(i32.const 0)", 0);
	t.assert_i("(i32.const 23)", 23);
	t.assert_i("(i32.const -32)", -32);
	t.assert_i("(i32.const 0xABCDEF01)", 0xABCDEF01);
	t.assert_i("(i32.const 0x12345678)", 0x12345678);
	t.assert_i("(i32.const -0x97531)", 0-0x97531);
	t.assert_i("(i32.const 1469788397)", 1469788397);
	t.assert_i("(i32.const 1469837011)", 1469837011);
	t.assert_i("(i32.const 1469837011)", 1469837011);
	t.assert_i("(i32.const 1989852383)", 1989852383);
	t.assert_i("(i32.const 1989852383)", 1989852383);
	t.assert_i("(i32.const 2147483647)", 2147483647);
	t.assert_i("(i32.const 2147483648)", int.!(2147483648));
	t.assert_i("(i32.const -2147483647)", -2147483647);
	t.assert_i("(i32.const -2147483648)", -2147483648);
	t.assert_i("(i32.const 2147483661)", int.!(2147483661));
	t.assert_i("(i32.const 2882377846)", int.!(2882377846));
	t.assert_i("(i32.const 2965492451)", int.!(2965492451));
	t.assert_i("(i32.const 3758997519)", int.!(3758997519));
	t.assert_i("(i32.const 406477942)", int.!(406477942));
	t.assert_i("(i32.const 4261469184)", int.!(4261469184));
	t.assert_i("(i32.const 4294967277)", int.!(4294967277));
	t.assert_i("(i32.const 4294967295)", int.!(4294967295));
	t.assert_i("(i32.const 0x80000000)", 0x80000000);
	t.assert_i("(i32.const 0xffffffff)", 0xffffffff);
	t.assert_i("(i32.const 0x7fffffff)", 0x7fffffff);
	t.assert_i("(i32.const -0x80000000)", 0-0x80000000);
	t.assert_i("(i32.const -0xffffffff)", 0-0xffffffff);
	t.assert_i("(i32.const -0x7fffffff)", 0-0x7fffffff);
}

def test_i64_const(t: SpecTestParserTester) {
	if (true) return; // TODO: i64.const
	t.assert_err("(i64.const 0x3456436598bacdef)");
	t.assert_err("(i64.const 0x43)");
	t.assert_err("(i64.const 0x56346543)");
	t.assert_err("(i64.const 0x6543)");
	t.assert_err("(i64.const 0x98bacdef)");
	t.assert_err("(i64.const 0xcdef)");
	t.assert_err("(i64.const 0xef)");
	t.assert_err("(i64.const 0xfedcba9856346543)");
	t.assert_err("(i64.const 0xffffffff98bacdef)");
	t.assert_err("(i64.const 0xffffffffffffcdef)");
	t.assert_err("(i64.const 0xffffffffffffffef)");
	t.assert_err("(i64.const 7034535277573963776)");
}

def test_f32_const(t: SpecTestParserTester) {
	if (true) return; // TODO: f32.const
	t.assert_err("(f32.const -0x1.000002p+0)");
	t.assert_err("(f32.const -0x1.fffffcp+22)");
	t.assert_err("(f32.const -0x1.fffffep+22)");
	t.assert_err("(f32.const -0x1.fffffep+23)");
	t.assert_err("(f32.const -0x1.fffffep-1)");
	t.assert_err("(f32.const -0x1p+23)");
	t.assert_err("(f32.const -1.0)");
	t.assert_err("(f32.const -2.0)");
	t.assert_err("(f32.const 0.0)");
	t.assert_err("(f32.const 0x1.000002p+0)");
	t.assert_err("(f32.const 0x1.000002p+23)");
	t.assert_err("(f32.const 0x1.000004p+23)");
	t.assert_err("(f32.const 0x1.fffffcp+22)");
	t.assert_err("(f32.const 0x1.fffffep+22)");
	t.assert_err("(f32.const 0x1.fffffep+23)");
	t.assert_err("(f32.const 0x1.fffffep+47)");
	t.assert_err("(f32.const 0x1.fffffep-1)");
	t.assert_err("(f32.const 0x1.fffffep-2)");
	t.assert_err("(f32.const 0x1p+2)");
	t.assert_err("(f32.const 0x1p+23)");
	t.assert_err("(f32.const 0x1.098064p-3)");
	t.assert_err("(f32.const 0x1.166002p-113)");
	t.assert_err("(f32.const 0x1.176406p-60)");
	t.assert_err("(f32.const 0x1.1f6d0ep-2)");
	t.assert_err("(f32.const 0x1.26a62ep+27)");
	t.assert_err("(f32.const 0x1.2e82a4p+59)");
	t.assert_err("(f32.const 0x1.30eb2cp-120)");
	t.assert_err("(f32.const 0x1.3684dp-71)");
	t.assert_err("(f32.const 0x1.3dfb5p-15)");
	t.assert_err("(f32.const 0x1.42b5b6p-4)");
	t.assert_err("(f32.const 0x1.56p+7)");
	t.assert_err("(f32.const 0x1.594dfcp-23)");
	t.assert_err("(f32.const 0x1.5c4052p+50)");
	t.assert_err("(f32.const 0x1.65787cp+118)");
	t.assert_err("(f32.const 0x1.70b23p-2)");
	t.assert_err("(f32.const 0x1.798762p-57)");
	t.assert_err("(f32.const 0x1.84685p+13)");
	t.assert_err("(f32.const 0x1.8ebae2p-36)");
	t.assert_err("(f32.const 0x1.937e38p-8)");
	t.assert_err("(f32.const 0x1.a2744cp+3)");
	t.assert_err("(f32.const 0x1.a4789cp-12)");
	t.assert_err("(f32.const 0x1.cb705cp-123)");
	t.assert_err("(f32.const 0x1.d8bc4ep-11)");
	t.assert_err("(f32.const 0x1.d9befp+100)");
	t.assert_err("(f32.const 0x1.e5020ap-62)");
	t.assert_err("(f32.const 0x1.ebf9eap-6)");
	t.assert_err("(f32.const 1.0)");
	t.assert_err("(f32.const 2.0)");
}

def test_f64_const(t: SpecTestParserTester) {
	if (true) return; // TODO: f64.const
	t.assert_err("(f64.const -0x1.0000000000001p+0)");
	t.assert_err("(f64.const -0x1.ffffffffffffep+51)");
	t.assert_err("(f64.const -0x1.fffffffffffffp+51)");
	t.assert_err("(f64.const -0x1.fffffffffffffp+52)");
	t.assert_err("(f64.const -0x1.fffffffffffffp-1)");
	t.assert_err("(f64.const -0x1p+52)");
	t.assert_err("(f64.const -1.0)");
	t.assert_err("(f64.const -2.0)");
	t.assert_err("(f64.const 0.0)");
	t.assert_err("(f64.const 0x1.0000000000001p+0)");
	t.assert_err("(f64.const 0x1.0000000000001p+52)");
	t.assert_err("(f64.const 0x1.0000000000002p+52)");
	t.assert_err("(f64.const 0x1.ffffffffffffep+51)");
	t.assert_err("(f64.const 0x1.fffffffffffffp+105)");
	t.assert_err("(f64.const 0x1.fffffffffffffp+51)");
	t.assert_err("(f64.const 0x1.fffffffffffffp+52)");
	t.assert_err("(f64.const 0x1.fffffffffffffp-1)");
	t.assert_err("(f64.const 0x1.fffffffffffffp-2)");
	t.assert_err("(f64.const 0x1p+52)");
	t.assert_err("(f64.const 1.0)");
	t.assert_err("(f64.const 2.0)");
}

def test_string1(t: SpecTestParserTester) {
	t.assert_string("\"\"", "");
	t.assert_string("\"a\"", "a");
	t.assert_string("\"bcdefgh\"", "bcdefgh");
	t.assert_string("\"ijklmnopqrstuvwxyz\"", "ijklmnopqrstuvwxyz");
	t.assert_string("\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
	t.assert_string("\"0123456789\"", "0123456789");
	t.assert_string("\"+=-_)(*&^%$#@!\"", "+=-_)(*&^%$#@!");
	t.assert_string("\",<.>/?;:\"", ",<.>/?;:");
	t.assert_string("\"[{]}|`~\"", "[{]}|`~");
	t.assert_string("\" \"", " ");
	t.assert_string("\"  \"", "  ");
	t.assert_string("\"   \"", "   ");
	t.assert_string("\"f g\"", "f g");
	t.assert_string("\"spec (test) man\"", "spec (test) man");
	t.assert_string("\"(module (foo (bar)))\"", "(module (foo (bar)))");
}

def test_string2(t: SpecTestParserTester) {
	t.assert_string("\"\\\"", null);
	t.assert_string("\"\\\\\"", null);
	t.assert_string("\"\\n\"", null);
	t.assert_string("\"\\r\"", null);
	t.assert_string("\"\\z\"", null);
	t.assert_string("\"\\t\"", null);
}

def test_stringx(t: SpecTestParserTester) {
	t.assert_string("\"\\00\"", "\x00");
	t.assert_string("\"\\01\"", "\x01");
	t.assert_string("\"\\1a\\2b\\3c\\4d\\5e\\6f\"", "\x1a\x2b\x3c\x4d\x5e\x6f");
	t.assert_string("\"\\9A\\8B\\7C\\6D\\5E\\4F\"", "\x9a\x8b\x7c\x6d\x5e\x4f");
}

def test_stringp(t: SpecTestParserTester) {
	t.assert_string("\"A\"\"B\"", "A");
	t.assert_string("\"XYZ\"  \"012\"", "XYZ");
}

def test_modbin1(t: SpecTestParserTester) {
	t.assert_bin("(module binary \"\")", null, []);
	t.assert_bin("(module binary \"\\EF\")", null, [0xEF]);
	t.assert_bin("(module binary \"\\01\\02\\03\")", null, [0x01, 0x02, 0x03]);
	t.assert_bin("(module binary \"\\AA\" \"\\BB\" \"\\CC\")", null, [0xAA, 0xBB, 0xCC]);
	t.assert_bin("(module binary \"\\22\"\n\"\\33\"\n\"\\44\"\n)", null, [0x22, 0x33, 0x44]);
}

def test_modbinx(t: SpecTestParserTester) {
	t.assert_err("(module bin");
	t.assert_err("(module binary");
	t.assert_err("(module binary)");
	t.assert_err("(module binary )");
	t.assert_err("(module binary \")");
	t.assert_err("(module binary foo)");
	t.assert_err("(module binary ())");
}

def test_modquote1(t: SpecTestParserTester) {
	t.assert_quote("(module quote \"\")", null, "");
	t.assert_quote("(module quote \"(module foo)\")", null, "(module foo)");
	t.assert_quote("(module quote \"(module\" \" foo)\")", null, "(module foo)");
	t.assert_quote("(module quote \"(module\"\n\" foo)\")", null, "(module foo)");
}

def test_modquotex(t: SpecTestParserTester) {
	t.assert_err("(module quo");
	t.assert_err("(module quote");
	t.assert_err("(module quote)");
	t.assert_err("(module quote )");
	t.assert_err("(module quote \")");
	t.assert_err("(module quote foo)");
	t.assert_err("(module quote ())");
}

def test_modx(t: SpecTestParserTester) {
	t.assert_err("(module");
	t.assert_err("(module ");
	t.assert_err("(module)");
	t.assert_err("(module )");
	t.assert_err("(module foo)");
}

def test_mod_named(t: SpecTestParserTester) {
	t.assert_bin("(module $f binary \"\")", "$f", []);
	t.assert_bin("(module $az_09_AZ binary \"\")", "$az_09_AZ", []);
	t.assert_quote("(module $__ quote \"(foo)\")", "$__", "(foo)");
}

def test_invoke1(t: SpecTestParserTester) {
	t.assert_invoke("(invoke \"foo\")", null, "foo");
	t.assert_invoke("(invoke \"ABCDEG\")", null, "ABCDEG");
}

def test_invokex(t: SpecTestParserTester) {
	t.assert_err("(invoke");
	t.assert_err("(invoke)");
	t.assert_err("(invoke foo)");
	t.assert_err("(invoke ())");
	t.assert_err("(invoke \"foo\" barf)");
}

def test_invoke_named(t: SpecTestParserTester) {
	t.assert_invoke("(invoke $M \"foo\")", "$M", "foo");
	t.assert_invoke("(invoke $Ng \"ABCDEG\")", "$Ng", "ABCDEG");
}

def test_get1(t: SpecTestParserTester) {
	t.assert_get("(get \"foo\")", null, "foo");
	t.assert_get("(get \"ABCDEG\")", null, "ABCDEG");
}

def test_getx(t: SpecTestParserTester) {
	t.assert_err("(get");
	t.assert_err("(get)");
	t.assert_err("(get foo)");
	t.assert_err("(get ())");
	t.assert_err("(get \"foo\" barf)");
}

def test_get_named(t: SpecTestParserTester) {
	t.assert_get("(get $M \"foo\")", "$M", "foo");
	t.assert_get("(get $Ng \"ABCDEG\")", "$Ng", "ABCDEG");
	t.assert_get("(get $_0 \"ABCDEG\")", "$_0", "ABCDEG");
}

def test_register1(t: SpecTestParserTester) {
	t.assert_register("(register \"foo\")", null, "foo");
	t.assert_register("(register \"ABCDEG\")", null, "ABCDEG");
}

def test_registerx(t: SpecTestParserTester) {
	t.assert_err("(register");
	t.assert_err("(register)");
	t.assert_err("(register foo)");
	t.assert_err("(register ())");
	t.assert_err("(register barf \"foo\")");
	t.assert_err("(register \"foo\" baz)");
}

def test_register_named(t: SpecTestParserTester) {
	t.assert_register("(register \"foo\" $M)", "$M", "foo");
	t.assert_register("(register \"ABCDEG\" $Ng)", "$Ng", "ABCDEG");
	t.assert_register("(register \"ABCDEG\" $_0)", "$_0", "ABCDEG");
}

// to avoid specializing {testValidStringCommand} for each command type
def unpackStringCommand<C>(name: C -> string, cmd: StCommand) -> (bool, string) {
	if (!C.?(cmd)) return (false, null);
	return (true, name(C.!(cmd)));
}

def testStringCommand(t: SpecTestParserTester, cmd: string,
		unpack: StCommand -> (bool, string)) {
	var buf = StringBuffer.new();

	t.assert_err(buf.put1("(%s", cmd).extract());
	t.assert_err(buf.put1("(%s foo", cmd).extract());
	t.assert_err(buf.put1("(%s foo)", cmd).extract());
	t.assert_err(buf.put1("(%s ())", cmd).extract());

	def cases = [
		("(%s)", null),
		("(%s \"\")", ""),
		("(%s \"a098ZY\")", "a098ZY")
	];
	for (k in cases) {
		var str = buf.put1(k.0, cmd).extract();
		var c = t.parseCommand(str);
		var r = unpack(c.cmd);
		if (!r.0) return t.t.fail2("expected %s, got %s", cmd, c.cmd.name);
		t.t.assert_string(k.1, r.1);
	}
}

def test_assert_return(t: SpecTestParserTester) {
	t.assert_err("(assert_return");
	t.assert_err("(assert_return foo)");
	t.assert_err("(assert_return \"\")");
	t.assert_err("(assert_return ())");
	var c = t.parseCommand("(assert_return)");
	if (c == null) return t.t.fail("expected AssertReturn, but got error");
	if (!StCommand.AssertReturn.?(c.cmd)) return t.t.fail1("expected AssertReturn, got %s", c.cmd.name);
}

def test_assert_trap(t: SpecTestParserTester) {
	testStringCommand(t, "assert_trap",
		unpackStringCommand(StCommand.AssertTrap.msg, _));
}

def test_assert_exhaustion(t: SpecTestParserTester) {
	testStringCommand(t, "assert_exhaustion",
			unpackStringCommand(StCommand.AssertExhaustion.msg, _));
}

def test_assert_invalid(t: SpecTestParserTester) {
	testStringCommand(t, "assert_invalid",
			unpackStringCommand(StCommand.AssertInvalid.msg, _));
}

def test_assert_malformed(t: SpecTestParserTester) {
	testStringCommand(t, "assert_malformed",
			unpackStringCommand(StCommand.AssertMalformed.msg, _));
}

def test_assert_unlinkable(t: SpecTestParserTester) {
	testStringCommand(t, "assert_unlinkable",
			unpackStringCommand(StCommand.AssertUnlinkable.msg, _));
}

def testCommands(t: SpecTestParserTester, input: string, extags: Array<byte>) {
	var p = SpecTestParser.new(FILENAME, input);
	p.parseFile();
	if (!p.ok) return t.t.fail3("failed @ %d:%d, %s", p.error_loc.0, p.error_loc.1, p.error_msg);
	var excnt = extags.length, gotcnt = p.commands.length;
	if (gotcnt != excnt) return t.t.fail2("expected %d commands, got %d", excnt, gotcnt);
	// Check the tags (only) of the returned commands
	for (i < extags.length) {
		var extag = extags[i], gottag = p.commands[i].cmd.tag;
		if (extag != gottag) return t.t.fail3("expected tag %d, got command[%d].tag == %d", int.!(extag), i, int.!(gottag));
	}
}

def testNestedCommands(t: SpecTestParserTester, pattern: string, tag: byte) {
	var cases: Array<(string, Array<byte>)> = [
		("", []),
		("(i32.const 1)",
			[StCommand.Constant.tag]),
		("(module binary \"\") (i32.const 4)",
			[StCommand.BinaryModule.tag, StCommand.Constant.tag]),
		("(invoke \"x\")",
			[StCommand.Invoke.tag]),
		("(invoke \"y\" (i32.const 5))",
			[StCommand.Constant.tag, StCommand.Invoke.tag]),
		("(get \"z\")",
			[StCommand.GetGlobal.tag])
	];
	var buf = StringBuffer.new();
	for (k in cases) {
		var input = buf.put1(pattern, k.0).extract();
		var p = SpecTestParser.new(FILENAME, input);
		p.parseOneCommand();
		var excnt = 1 + k.1.length, gotcnt = p.commands.length;
		if (gotcnt != excnt) return t.t.fail2("expected %d commands, got %d", excnt, gotcnt);
		// Check the tags (only) of the returned commands
		for (i < k.1.length) {
			var extag = k.1[i], gottag = p.commands[i].cmd.tag;
			if (extag != gottag) return t.t.fail3("expected tag %d, got command[%d].tag == %d", int.!(extag), i, int.!(gottag));
		}
		var lasttag = p.commands[p.commands.length-1].cmd.tag;
		if (tag != lasttag) return t.t.fail2("expected tag %d, got last.tag == %d", int.!(tag), int.!(lasttag));
	}
}

def test_nested1(t: SpecTestParserTester) {
	testNestedCommands(t, "(assert_return %s)", StCommand.AssertReturn.tag);

	testNestedCommands(t, "(invoke \"foo\" %s)", StCommand.Invoke.tag);
	testNestedCommands(t, "(invoke $var \"foo\" %s)", StCommand.Invoke.tag);
}

def test_nested2(t: SpecTestParserTester) {
	testNestedCommands(t, "(assert_trap %s)", StCommand.AssertTrap.tag);
	testNestedCommands(t, "(assert_trap %s \"msg\")", StCommand.AssertTrap.tag);

	testNestedCommands(t, "(assert_exhaustion %s)", StCommand.AssertExhaustion.tag);
	testNestedCommands(t, "(assert_exhaustion %s \"msg\")", StCommand.AssertExhaustion.tag);

	testNestedCommands(t, "(assert_invalid %s)", StCommand.AssertInvalid.tag);
	testNestedCommands(t, "(assert_invalid %s \"msg\")", StCommand.AssertInvalid.tag);

	testNestedCommands(t, "(assert_malformed %s)", StCommand.AssertMalformed.tag);
	testNestedCommands(t, "(assert_malformed %s \"msg\")", StCommand.AssertMalformed.tag);

	testNestedCommands(t, "(assert_unlinkable %s)", StCommand.AssertUnlinkable.tag);
	testNestedCommands(t, "(assert_unlinkable %s \"msg\")", StCommand.AssertUnlinkable.tag);
}

def test_cmds1(t: SpecTestParserTester) {
	testCommands(t, "(assert_return (invoke  \"add\" (i32.const 1) (i32.const 1)) (i32.const 2))", [
		StCommand.Constant.tag,
		StCommand.Constant.tag,
		StCommand.Invoke.tag,
		StCommand.Constant.tag,
		StCommand.AssertReturn.tag
	]);

	testCommands(t, "(assert_invalid (module binary \"\\00\") \"type mismatch\")", [
		StCommand.BinaryModule.tag,
		StCommand.AssertInvalid.tag
	]);

	testCommands(t, "(assert_trap (invoke \"x\" (i32.const 1) (i32.const 6)) \"unreachable\")", [
		StCommand.Constant.tag,
		StCommand.Constant.tag,
		StCommand.Invoke.tag,
		StCommand.AssertTrap.tag
	]);

	testCommands(t, "(assert_return (get $Ng \"Mg.glob\") (i32.const 42))", [
		StCommand.GetGlobal.tag,
		StCommand.Constant.tag,
		StCommand.AssertReturn.tag
	]);
}

def test_cmds2(t: SpecTestParserTester) {
	testCommands(t, "(module binary \"\") (register \"foo\")", [
		StCommand.BinaryModule.tag,
		StCommand.Register.tag
	]);

	testCommands(t, "(module binary \"\") (register \"foo\" $v)", [
		StCommand.BinaryModule.tag,
		StCommand.Register.tag
	]);
}

def test_cmds3(t: SpecTestParserTester) {
	testCommands(t, "(action (invoke \"foo\"))", [
		StCommand.Invoke.tag
	]);

	testCommands(t, "(assert_uninstantiable (module binary \"\"))", [
		StCommand.BinaryModule.tag,
		StCommand.AssertTrap.tag
	]);
}

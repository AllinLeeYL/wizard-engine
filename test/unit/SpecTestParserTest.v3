// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, SpecTestParserTester.new, _);
def X = [
	T("specparse:i32", test_i32_const),
	T("specparse:i64", test_i64_const),
	T("specparse:f32hex", test_f32hex),
	T("specparse:f32nan", test_f32nan),
	T("specparse:f32sub", test_f32sub),
	T("specparse:f64hex", test_f64hex),
	T("specparse:f64nan", test_f64nan),
	T("specparse:string1", test_string1),
	T("specparse:string2", test_string2),
	T("specparse:stringx", test_stringx),
	T("specparse:stringp", test_stringp),
	T("specparse:modbin1", test_modbin1),
	T("specparse:modbinx", test_modbinx),
	T("specparse:modquote1", test_modquote1),
	T("specparse:modx", test_modx),
	T("specparse:mod_named", test_mod_named),
	T("specparse:invoke1", test_invoke1),
	T("specparse:invokex", test_invokex),
	T("specparse:invoke_named", test_invoke_named),
	T("specparse:get1", test_get1),
	T("specparse:getx", test_getx),
	T("specparse:get_named", test_get_named),
	T("specparse:register1", test_register1),
	T("specparse:registerx", test_registerx),
	T("specparse:register_named", test_register_named),
	T("specparse:assert_returnx", test_assert_returnx),
	T("specparse:assert_trapx", test_assert_trapx),
	T("specparse:assert_exhaustionx", test_assert_exhaustionx),
	T("specparse:assert_invalidx", test_assert_invalidx),
	T("specparse:assert_malformedx", test_assert_malformedx),
	T("specparse:assert_unlinkablex", test_assert_unlinkablex),
	T("specparse:action", test_action),
	T("specparse:assert_return", test_assert_return),
	T("specparse:assert_trap", test_assert_trap),
	T("specparse:assert_exhaustion", test_assert_exhaustion),
	T("specparse:assert_invalid", test_assert_invalid),
	T("specparse:assert_malformed", test_assert_malformed),
	T("specparse:assert_unlinkable", test_assert_unlinkable),
	T("specparse:cmds1", test_cmds1),
	T("specparse:cmds2", test_cmds2),
	T("specparse:cmds3", test_cmds3),
	()
];

def FILENAME = "SpecTestParserTest.v3";
class SpecTestParserTester(t: Tester) {
	def parseCommand(input: string) -> SpecTestCommand {
		var p = SpecTestParser.new(FILENAME, input);
		var c = p.parseOneCommandForTesting();
		return if(p.ok, c);
	}
	def assert_cmds(expected: StCommand, input: string) -> bool {
		var p = SpecTestParser.new(FILENAME, input);
		var got = p.parseOneCommandForTesting();
		if (!p.ok || got == null) {
			if (p.error_msg == null) t.fail1("expected %s, got error", expected.name);
			else t.fail2("expected %s, got error", expected.name, p.error_msg);
			return false;
		}
		return assert_cmd(expected, got.cmd);
	}
	def assert_mod(expected: StModule, got: StModule) -> bool {
		if (expected.tag != got.tag) {
			t.fail2("expected module %s, got %s", expected.name, got.name);
			return false;
		}
		match (expected) {
			Binary(varname, bytes) => {
				var that = StModule.Binary.!(got);
				t.assert_string(varname, that.varname);
				t.assert_string(bytes, that.bytes);
			}
			Quote(varname, source) => {
				var that = StModule.Quote.!(got);
				t.assert_string(varname, that.varname);
				t.assert_string(source, that.source);
			}
		}
		return true;
	}
	def assert_cmd(expected: StCommand, got: StCommand) -> bool {
		if (expected.tag != got.tag) {
			t.fail2("expected command %s, got %s", expected.name, got.name);
			return false;
		}
		if (expected == got) return t.ok;
		match (expected) {
			Module(module) => {
				assert_mod(module, StCommand.Module.!(got).module);
			}
			Register(varname, regname) => {
				var that = StCommand.Register.!(got);
				t.assert_string(varname, that.varname);
				t.assert_string(regname, that.regname);
			}
			Action(action) => {
				var that = StCommand.Action.!(got);
				assert_action(expected.name, action, that.action);
			}
			AssertReturn(action, expected_vals) => {
				var that = StCommand.AssertReturn.!(got);
				assert_action(expected.name, action, that.action);
				assert_vals(expected_vals, that.expected);
			}
			AssertTrap(action, msg) => {
				var that = StCommand.AssertTrap.!(got);
				assert_action(expected.name, action, that.action);
				t.assert_string(msg, that.msg);
			}
			AssertExhaustion(action, msg) => {
				var that = StCommand.AssertExhaustion.!(got);
				assert_action(expected.name, action, that.action);
				t.assert_string(msg, that.msg);
			}
			AssertInvalid(module, msg) => {
				var that = StCommand.AssertInvalid.!(got);
				assert_mod(module, that.module);
				t.assert_string(msg, that.msg);
			}
			AssertMalformed(module, msg) => {
				var that = StCommand.AssertMalformed.!(got);
				assert_mod(module, that.module);
				t.assert_string(msg, that.msg);
			}
			AssertUnlinkable(module, msg) => {
				var that = StCommand.AssertUnlinkable.!(got);
				assert_mod(module, that.module);
				t.assert_string(msg, that.msg);
			}
			AssertUninstantiable(module, msg) => {
				var that = StCommand.AssertUninstantiable.!(got);
				assert_mod(module, that.module);
				t.assert_string(msg, that.msg);
			}
		}
		return t.ok;
	}
	def assert_vals(expected: Array<Value>, got: Array<Value>) {
		if (expected.length != got.length) return t.fail2("expected %d values, got %d", expected.length, got.length);
		for (i < expected.length) {
			if (expected[i] != got[i]) {
				return t.fail3("expected values[%d] = %q, got %q",
					i, Values.render(_, expected[i]),
					Values.render(_, got[i]));
			}
		}
	}
	def assert_action(cmd: string, expected: StAction, got: StAction) -> bool {
		if (expected.tag != got.tag) {
			var buf = StringBuffer.new();
			if (cmd != null) {
				buf.put2("expected (%s (%s ...)), ", cmd, expected.name);
				buf.put2("got (%s (%s ...))", cmd, got.name);
			} else {
				buf.put2("expected action %s, got %s", expected.name, got.name);
			}
			t.fail(buf.extract());
			return false;
		}
		if (expected == got) return t.ok;
		match (expected) {
			Invoke(varname, funcname, args) => {
				var that = StAction.Invoke.!(got);
				t.assert_string(varname, that.varname);
				t.assert_string(funcname, that.funcname);
				assert_vals(args, that.args);
			}
			GlobalGet(varname, globalname) => {
				var that = StAction.GlobalGet.!(got);
				t.assert_string(varname, that.varname);
				t.assert_string(globalname, that.globalname);
			}
		}
		return t.ok;
	}
	def assert_i(input: string, expected: int) {
		assert_const(input, Value.I32(u32.!(expected)));
	}
	def assert_l(input: string, expected: u64) {
		assert_const(input, Value.I64(expected));
	}
	def assert_f(input: string, expected: u32) {
		assert_const(input, Value.F32(expected));
	}
	def assert_d(input: string, expected: u64) {
		assert_const(input, Value.F64(expected));
	}
	def assert_const(input: string, expected: Value) {
		var p = SpecTestParser.new(FILENAME, input);
		var got = p.parseNested(p.parseConstant);
		if (!p.ok) t.fail1("expected constant, got %s", p.error_msg);
		if (got != expected) {
			t.fail2("expected %q, got %q",
				Values.render(_, expected), Values.render(_, got));
		}
	}
	def assert_string(input: string, expected: string) {
		var p = SpecTestParser.new(FILENAME, input);
		var r = p.parseString();
		if (expected == null) {
			return if(p.ok, t.fail("expected error, but passed"));
		}
		if (!p.ok) return t.fail("expected string, but got error");
		t.assert_string(expected, r);
	}
	def assert_err(input: string) {
		var p = SpecTestParser.new(FILENAME, input);
		var c = p.parseOneCommandForTesting();
		if (p.ok) {
			if (c == null) t.fail("expected error, got success, but null cmd");
			else t.fail1("expected error, got %s", c.cmd.name);
		}
	}
	def assert_bin(input: string, expected_varname: string, expected_bytes: Array<byte>) {
		var c = parseCommand(input);
		if (c == null) return t.fail("expected binary module, but got error");
		var exp = StCommand.Module(StModule.Binary(expected_varname,
					expected_bytes));
		assert_cmd(exp, c.cmd);
	}
	def assert_quote(input: string, expected_varname: string, expected_source: string) {
		var c = parseCommand(input);
		if (c == null) return t.fail("expected quote module, but got error");
		var exp = StCommand.Module(StModule.Quote(expected_varname,
					expected_source));
		assert_cmd(exp, c.cmd);
	}
	def assert_invoke(input: string, expected_varname: string, expected_funcname: string) {
		var p = SpecTestParser.new(FILENAME, input);
		var a = p.parseNested(p.parseAction);
		if (!p.ok) return t.fail("expected invoke, but got error");
		// TODO: arguments
		assert_action([], StAction.Invoke(expected_varname, expected_funcname, []), a);
	}
	def assert_get(input: string, expected_varname: string, expected_globalname: string) {
		var p = SpecTestParser.new(FILENAME, input);
		var a = p.parseNested(p.parseAction);
		if (!p.ok) return t.fail("expected get, but got error");
		assert_action([], StAction.GlobalGet(expected_varname, expected_globalname), a);
	}
	def assert_register(input: string, expected_varname: string, expected_regname: string) {
		var c = parseCommand(input);
		if (c == null) return t.fail("expected register, but got error");
		assert_cmd(StCommand.Register(expected_varname, expected_regname), c.cmd);
	}
}

def test_i32_const(t: SpecTestParserTester) {
	t.assert_i("(i32.const 0)", 0);
	t.assert_i("( i32.const  0 ) ", 0);
	t.assert_i("(\ti32.const\t0\t)\t", 0);
	t.assert_i("(\ni32.const\n0\n)\n", 0);

	t.assert_i("(i32.const 23)", 23);
	t.assert_i("(i32.const -32)", -32);
	t.assert_i("(i32.const 1_469_788_397)", 1469788397);
	t.assert_i("(i32.const 1_4_6_9_7_8_8_3_9_7)", 1469788397);

	t.assert_i("(i32.const 0xABCDEF01)", 0xABCDEF01);
	t.assert_i("(i32.const 0xABCD_EF01)", 0xABCDEF01);
	t.assert_i("(i32.const 0xAB_CD_EF_01)", 0xABCDEF01);

	t.assert_i("(i32.const 0x12345678)", 0x12345678);
	t.assert_i("(i32.const -0x97531)", 0-0x97531);
	t.assert_i("(i32.const 1469788397)", 1469788397);
	t.assert_i("(i32.const 1469837011)", 1469837011);
	t.assert_i("(i32.const 1469837011)", 1469837011);
	t.assert_i("(i32.const 1989852383)", 1989852383);
	t.assert_i("(i32.const 1989852383)", 1989852383);
	t.assert_i("(i32.const 2147483647)", 2147483647);
	t.assert_i("(i32.const 2147483648)", int.!(2147483648));
	t.assert_i("(i32.const -2147483647)", -2147483647);
	t.assert_i("(i32.const -2147483648)", -2147483648);
	t.assert_i("(i32.const 2147483661)", int.!(2147483661));
	t.assert_i("(i32.const 2882377846)", int.!(2882377846));
	t.assert_i("(i32.const 2965492451)", int.!(2965492451));
	t.assert_i("(i32.const 3758997519)", int.!(3758997519));
	t.assert_i("(i32.const 406477942)", int.!(406477942));
	t.assert_i("(i32.const 4261469184)", int.!(4261469184));
	t.assert_i("(i32.const 4294967277)", int.!(4294967277));
	t.assert_i("(i32.const 4294967295)", int.!(4294967295));
	t.assert_i("(i32.const 0x80000000)", 0x80000000);
	t.assert_i("(i32.const 0xffffffff)", 0xffffffff);
	t.assert_i("(i32.const 0x7fffffff)", 0x7fffffff);
	t.assert_i("(i32.const -0x80000000)", 0-0x80000000);
	t.assert_i("(i32.const -0xffffffff)", 0-0xffffffff);
	t.assert_i("(i32.const -0x7fffffff)", 0-0x7fffffff);
	// TODO: test invalid i32 constants
}

def test_i64_const(t: SpecTestParserTester) {
	t.assert_l("(i64.const 0x43)", 0x43);
	t.assert_l("( i64.const  0x43 ) ", 0x43);
	t.assert_l("(\ti64.const\t0x43\t)\t", 0x43);
	t.assert_l("(\ni64.const\n0x43\n)\n", 0x43);

	t.assert_l("(i64.const 406477942333)", 406477942333);
	t.assert_l("(i64.const 406_477_942_333)", 406477942333);
	t.assert_l("(i64.const 4_06_47_79_42_3_33)", 406477942333);

	t.assert_l("(i64.const 0x3456436598bacdef)", 0x3456436598bacdef);
	t.assert_l("(i64.const 0x43)", 0x43);
	t.assert_l("(i64.const 0x56346543)", 0x56346543);
	t.assert_l("(i64.const 0x6543)", 0x6543);
	t.assert_l("(i64.const 0x98bacdef)", 0x98bacdef);
	t.assert_l("(i64.const 0xcdef)", 0xcdef);
	t.assert_l("(i64.const 0xef)", 0xef);
	t.assert_l("(i64.const 0xfedcba9856346543)", 0xfedcba9856346543);
	t.assert_l("(i64.const 0xffffffff98bacdef)", 0xffffffff98bacdef);
	t.assert_l("(i64.const 0xffffffffffffcdef)", 0xffffffffffffcdef);
	t.assert_l("(i64.const 0xffffffffffffffef)", 0xffffffffffffffef);
	t.assert_l("(i64.const 7034535277573963776)", 7034535277573963776);
	t.assert_l("(i64.const 9223372036854775807)", 9223372036854775807);
	t.assert_l("(i64.const 18446744073709551615)", 18446744073709551615u);
	t.assert_l("(i64.const 0x8000000000000000)", 0x8000000000000000ul);

	t.assert_l("(i64.const -0x3456436598bacdef)", 0ul - 0x3456436598bacdef);
	t.assert_l("(i64.const -0x43)", 0ul - 0x43);
	t.assert_l("(i64.const -7034535277573963776)", 0ul - 7034535277573963776);
	t.assert_l("(i64.const -9223372036854775807)", 0ul - 9223372036854775807);
	t.assert_l("(i64.const -9223372036854775808)", 0x8000000000000000ul);
	t.assert_l("(i64.const -0x8000000000000000)", 0x8000000000000000ul);
	t.assert_l("(i64.const -18446744073709551615)", 0ul - 18446744073709551615u);
	// TODO: test invalid i64 constants
}

def test_f32hex(t: SpecTestParserTester) {
	t.assert_f("(f32.const 0x0.00000000000000000p+0)", 0x00000000);
	t.assert_f("(f32.const 0x0.00000000000000000p+3)", 0x00000000);
	t.assert_f("(f32.const 0x0.00000000000000000p+9)", 0x00000000);
	t.assert_f("(f32.const 0x0.00000000000000000p-11)", 0x00000000);
	t.assert_f("(f32.const -0x0.00000000000000000p+0)", 0x80000000);
	t.assert_f("(f32.const -0x0.00000000000000000p+5)", 0x80000000);
	t.assert_f("(f32.const -0x0.00000000000000000p+7)", 0x80000000);
	t.assert_f("(f32.const -0x0.00000000000000000p-19)", 0x80000000);

	t.assert_f("(f32.const -0x1.000002p+0)", 0xbf800001);
	t.assert_f("( f32.const -0x1.000002p+0)", 0xbf800001);
	t.assert_f("(f32.const   -0x1.000002p+0)", 0xbf800001);
	t.assert_f("(f32.const -0x1.000002p+0 )", 0xbf800001);
	t.assert_f("(f32.const -0x1.000002p+0) ", 0xbf800001);
	t.assert_f("( f32.const  -0x1.000002p+0 ) ", 0xbf800001);
	t.assert_f("(\tf32.const\t-0x1.000002p+0\t)\t", 0xbf800001);
	t.assert_f("(\nf32.const\n-0x1.000002p+0\n)\n", 0xbf800001);

	t.assert_f("(f32.const -0x1.fffffcp+22)", 0xcafffffe);
	t.assert_f("(f32.const -0x1.ff_ff_fcp+22)", 0xcafffffe);

	t.assert_f("(f32.const -0x1.fffffep+22)", 0xcaffffff);
	t.assert_f("(f32.const -0x1.fffffep+23)", 0xcb7fffff);
	t.assert_f("(f32.const -0x1.fffffep-1)", 0xbf7fffff);
	t.assert_f("(f32.const -0x1p+23)", 0xcb000000);
	t.assert_f("(f32.const 0x1.000002p+0)", 0x3f800001);
	t.assert_f("(f32.const 0x1.000002p+23)", 0x4b000001);
	t.assert_f("(f32.const 0x1.000004p+23)", 0x4b000002);
	t.assert_f("(f32.const 0x1.fffffcp+22)", 0x4afffffe);
	t.assert_f("(f32.const 0x1.fffffep+22)", 0x4affffff);
	t.assert_f("(f32.const 0x1.fffffep+23)", 0x4b7fffff);
	t.assert_f("(f32.const 0x1.fffffep+47)", 0x577fffff);
	t.assert_f("(f32.const 0x1.fffffep-1)", 0x3f7fffff);
	t.assert_f("(f32.const 0x1.fffffep-2)", 0x3effffff);
	t.assert_f("(f32.const 0x1p+2)", 0x40800000);
	t.assert_f("(f32.const 0x1p+23)", 0x4b000000);
	t.assert_f("(f32.const 0x1.098064p-3)", 0x3e04c032);
	t.assert_f("(f32.const 0x1.166002p-113)", 0x070b3001);
	t.assert_f("(f32.const 0x1.176406p-60)", 0x218bb203);
	t.assert_f("(f32.const 0x1.1f6d0ep-2)", 0x3e8fb687);
	t.assert_f("(f32.const 0x1.26a62ep+27)", 0x4d135317);
	t.assert_f("(f32.const 0x1.2e82a4p+59)", 0x5d174152);
	t.assert_f("(f32.const 0x1.30eb2cp-120)", 0x03987596);
	t.assert_f("(f32.const 0x1.3684dp-71)", 0x1c1b4268);
	t.assert_f("(f32.const 0x1.3dfb5p-15)", 0x381efda8);
	t.assert_f("(f32.const 0x1.42b5b6p-4)", 0x3da15adb);
	t.assert_f("(f32.const 0x1.56p+7)", 0x432b0000);
	t.assert_f("(f32.const 0x1.594dfcp-23)", 0x342ca6fe);
	t.assert_f("(f32.const 0x1.5c4052p+50)", 0x58ae2029);
	t.assert_f("(f32.const 0x1.65787cp+118)", 0x7ab2bc3e);
	t.assert_f("(f32.const 0x1.70b23p-2)", 0x3eb85918);
	t.assert_f("(f32.const 0x1.798762p-57)", 0x233cc3b1);
	t.assert_f("(f32.const 0x1.84685p+13)", 0x46423428);
	t.assert_f("(f32.const 0x1.8ebae2p-36)", 0x2dc75d71);
	t.assert_f("(f32.const 0x1.937e38p-8)", 0x3bc9bf1c);
	t.assert_f("(f32.const 0x1.a2744cp+3)", 0x41513a26);
	t.assert_f("(f32.const 0x1.a4789cp-12)", 0x39d23c4e);
	t.assert_f("(f32.const 0x1.00000000000000000p-50)", 0x26800000);
	t.assert_f("(f32.const -0x1.00000000000000000p-50)", 0xa6800000);
	t.assert_f("(f32.const -0x1.000000000000000013p-50)", 0xa6800000);
}

def test_f32nan(t: SpecTestParserTester) {
	t.assert_f("(f32.const nan)", 0x7fc00000);
	t.assert_f("(f32.const -nan)", 0xffc00000);
	t.assert_f("(f32.const infinity)", 0x7f800000);
	t.assert_f("(f32.const -infinity)", 0xff800000);
	t.assert_f("(f32.const inf)", 0x7f800000);
	t.assert_f("(f32.const -inf)", 0xff800000);
	t.assert_f("(f32.const nan:canonical)", 0x7fc00000);
	t.assert_f("(f32.const nan:arithmetic)", 0x7fc00000);
	t.assert_f("(f32.const nan:0x1)", 0x7f800001);
	t.assert_f("(f32.const nan:0x455)", 0x7f800455);
	t.assert_f("(f32.const nan:0xbcdef)", 0x7f8bcdef);
	t.assert_f("(f32.const nan:0x1bcdef)", 0x7f9bcdef);
}

def test_f32sub(t: SpecTestParserTester) {
	if (true) return; // TODO: implement subnormal cases
	t.assert_f("(f32.const 0x1p-149)", 0x00000001);
	t.assert_f("(f32.const 0x1p-148)", 0x00000002);
	t.assert_f("(f32.const 0x1p-124)", 0x01800000);
	t.assert_f("(f32.const 0x1p-125)", 0x01000000);
	t.assert_f("(f32.const 0x1p-126)", 0x00800000);
}

def test_f64hex(t: SpecTestParserTester) {
	t.assert_d("(f64.const 0x0.00000000000000000p+0)", 0x00000000);
	t.assert_d("(f64.const 0x0.00000000000000000p+3)", 0x00000000);
	t.assert_d("(f64.const 0x0.00000000000000000p+9)", 0x00000000);
	t.assert_d("(f64.const 0x0.00000000000000000p-11)", 0x00000000);
	t.assert_d("(f64.const -0x0.00000000000000000p+0)", 0x8000000000000000);
	t.assert_d("(f64.const -0x0.00000000000000000p+5)", 0x8000000000000000);
	t.assert_d("(f64.const -0x0.00000000000000000p-11)", 0x8000000000000000);

	t.assert_d("(f64.const -0x1.0000000000001p+0)", 0xbff0000000000001ul);
	t.assert_d("( f64.const  -0x1.0000000000001p+0 ) ", 0xbff0000000000001ul);
	t.assert_d("(\tf64.const\t-0x1.0000000000001p+0\t)\t", 0xbff0000000000001ul);
	t.assert_d("(\nf64.const\n-0x1.0000000000001p+0\n)\n", 0xbff0000000000001ul);

	t.assert_d("(f64.const -0x1.ffffffffffffep+51)", 0xc32ffffffffffffeul);
	t.assert_d("(f64.const -0x1.fffffffffffffp+51)", 0xc32ffffffffffffful);
	t.assert_d("(f64.const -0x1.fffffffffffffp+52)", 0xc33ffffffffffffful);
	t.assert_d("(f64.const -0x1.fffffffffffffp-1)", 0xbfeffffffffffffful);
	t.assert_d("(f64.const -0x1p+52)", 0xc330000000000000ul);
	t.assert_d("(f64.const 0x1.0000000000001p+0)", 0x3ff0000000000001ul);
	t.assert_d("(f64.const 0x1.0000000000001p+52)", 0x4330000000000001ul);
	t.assert_d("(f64.const 0x1.0000000000002p+52)", 0x4330000000000002ul);
	t.assert_d("(f64.const 0x1.ffffffffffffep+51)", 0x432ffffffffffffeul);
	t.assert_d("(f64.const 0x1.fffffffffffffp+105)", 0x468ffffffffffffful);
	t.assert_d("(f64.const 0x1.fffffffffffffp+51)", 0x432ffffffffffffful);
	t.assert_d("(f64.const 0x1.fffffffffffffp+52)", 0x433ffffffffffffful);
	t.assert_d("(f64.const 0x1.fffffffffffffp-1)", 0x3feffffffffffffful);
	t.assert_d("(f64.const 0x1.fffffffffffffp-2)", 0x3fdffffffffffffful);
	t.assert_d("(f64.const 0x1p+52)", 0x4330000000000000ul);
	t.assert_d("(f64.const 0x1.a3d7_0a3d_70a3_dp+0)", 0x3FFA3D70A3D70A3D);
}

def test_f64nan(t: SpecTestParserTester) {
	t.assert_d("(f64.const nan)", 0x7ff8000000000000);
	t.assert_d("(f64.const -nan)", 0xfff8000000000000);
	t.assert_d("(f64.const infinity)", 0x7ff0000000000000);
	t.assert_d("(f64.const -infinity)", 0xfff0000000000000);
	t.assert_d("(f64.const inf)", 0x7ff0000000000000);
	t.assert_d("(f64.const -inf)", 0xfff0000000000000);
	t.assert_d("(f64.const nan:canonical)", 0x7ff8000000000000);
	t.assert_d("(f64.const nan:arithmetic)", 0x7ff8000000000000);
	t.assert_d("(f64.const nan:0x1)", 0x7ff0000000000001);
	t.assert_d("(f64.const nan:0x455)", 0x7ff0000000000455);
	t.assert_d("(f64.const nan:0xabcdef)", 0x7ff0000000abcdef);
	t.assert_d("(f64.const nan:0xabcdef0123456)", 0x7ffabcdef0123456);
}

def test_string1(t: SpecTestParserTester) {
	t.assert_string("\"\"", "");
	t.assert_string("\"a\"", "a");
	t.assert_string("\"bcdefgh\"", "bcdefgh");
	t.assert_string("\"ijklmnopqrstuvwxyz\"", "ijklmnopqrstuvwxyz");
	t.assert_string("\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
	t.assert_string("\"0123456789\"", "0123456789");
	t.assert_string("\"+=-_)(*&^%$#@!\"", "+=-_)(*&^%$#@!");
	t.assert_string("\",<.>/?;:\"", ",<.>/?;:");
	t.assert_string("\"[{]}|`~\"", "[{]}|`~");
	t.assert_string("\" \"", " ");
	t.assert_string("\"  \"", "  ");
	t.assert_string("\"   \"", "   ");
	t.assert_string("\"f g\"", "f g");
	t.assert_string("\"spec (test) man\"", "spec (test) man");
	t.assert_string("\"(module (foo (bar)))\"", "(module (foo (bar)))");
}

def test_string2(t: SpecTestParserTester) {
	t.assert_string("\"\\\"", null);
	t.assert_string("\"\\z\"", null);
	t.assert_string("\"\\\'\"", null);
}

def test_stringx(t: SpecTestParserTester) {
	t.assert_string("\"\\00\"", "\x00");
	t.assert_string("\"\\01\"", "\x01");
	t.assert_string("\"\\1a\\2b\\3c\\4d\\5e\\6f\"", "\x1a\x2b\x3c\x4d\x5e\x6f");
	t.assert_string("\"\\9A\\8B\\7C\\6D\\5E\\4F\"", "\x9a\x8b\x7c\x6d\x5e\x4f");
	t.assert_string("\"\\\"\"", "\"");
	t.assert_string("\"\\n\"", "\n");
	t.assert_string("\"\\r\"", "\r");
	t.assert_string("\"\\t\"", "\t");
	t.assert_string("\"\\\\\"", "\\");
}

def test_stringp(t: SpecTestParserTester) {
	t.assert_string("\"A\"\"B\"", "A");
	t.assert_string("\"XYZ\"  \"012\"", "XYZ");
}

def test_modbin1(t: SpecTestParserTester) {
	t.assert_bin("(module binary \"\")", null, []);
	t.assert_bin("(module binary \"\\EF\")", null, [0xEF]);
	t.assert_bin("(module binary \"\\01\\02\\03\")", null, [0x01, 0x02, 0x03]);
	t.assert_bin("(module binary \"\\AA\" \"\\BB\" \"\\CC\")", null, [0xAA, 0xBB, 0xCC]);
	t.assert_bin("(module binary \"\\22\"\n\"\\33\"\n\"\\44\"\n)", null, [0x22, 0x33, 0x44]);
}

def test_modbinx(t: SpecTestParserTester) {
	t.assert_err("(module bin");
	t.assert_err("(module binary");
	t.assert_err("(module binary)");
	t.assert_err("(module binary )");
	t.assert_err("(module binary \")");
	t.assert_err("(module binary foo)");
	t.assert_err("(module binary ())");
}

def test_modquote1(t: SpecTestParserTester) {
	t.assert_quote("(module quote \"\")", null, "");
	t.assert_quote("(module quote \"(module foo)\")", null, "(module foo)");
	t.assert_quote("(module quote \"(module\" \" foo)\")", null, "(module foo)");
	t.assert_quote("(module quote \"(module\"\n\" foo)\")", null, "(module foo)");
}

def test_modquotex(t: SpecTestParserTester) {
	t.assert_err("(module quo");
	t.assert_err("(module quote");
	t.assert_err("(module quote)");
	t.assert_err("(module quote )");
	t.assert_err("(module quote \")");
	t.assert_err("(module quote foo)");
	t.assert_err("(module quote ())");
}

def test_modx(t: SpecTestParserTester) {
	t.assert_err("(module");
	t.assert_err("(module ");
	t.assert_err("(module)");
	t.assert_err("(module )");
	t.assert_err("(module foo)");
}

def test_mod_named(t: SpecTestParserTester) {
	t.assert_bin("(module $f binary \"\")", "$f", []);
	t.assert_bin("(module $az_09_AZ binary \"\")", "$az_09_AZ", []);
	t.assert_quote("(module $__ quote \"(foo)\")", "$__", "(foo)");
}

def test_invoke1(t: SpecTestParserTester) {
	t.assert_invoke("(invoke \"foo\")", null, "foo");
	t.assert_invoke("(invoke \"ABCDEG\")", null, "ABCDEG");
}

def test_invokex(t: SpecTestParserTester) {
	t.assert_err("(invoke");
	t.assert_err("(invoke)");
	t.assert_err("(invoke foo)");
	t.assert_err("(invoke ())");
	t.assert_err("(invoke \"foo\" barf)");
}

def test_invoke_named(t: SpecTestParserTester) {
	t.assert_invoke("(invoke $M \"foo\")", "$M", "foo");
	t.assert_invoke("(invoke $Ng \"ABCDEG\")", "$Ng", "ABCDEG");
}

def test_get1(t: SpecTestParserTester) {
	t.assert_get("(get \"foo\")", null, "foo");
	t.assert_get("(get \"ABCDEG\")", null, "ABCDEG");
}

def test_getx(t: SpecTestParserTester) {
	t.assert_err("(get");
	t.assert_err("(get)");
	t.assert_err("(get foo)");
	t.assert_err("(get ())");
	t.assert_err("(get \"foo\" barf)");
}

def test_get_named(t: SpecTestParserTester) {
	t.assert_get("(get $M \"foo\")", "$M", "foo");
	t.assert_get("(get $Ng \"ABCDEG\")", "$Ng", "ABCDEG");
	t.assert_get("(get $_0 \"ABCDEG\")", "$_0", "ABCDEG");
}

def test_register1(t: SpecTestParserTester) {
	t.assert_register("(register \"foo\")", null, "foo");
	t.assert_register("(register \"ABCDEG\")", null, "ABCDEG");
}

def test_registerx(t: SpecTestParserTester) {
	t.assert_err("(register");
	t.assert_err("(register)");
	t.assert_err("(register foo)");
	t.assert_err("(register ())");
	t.assert_err("(register barf \"foo\")");
	t.assert_err("(register \"foo\" baz)");
}

def test_register_named(t: SpecTestParserTester) {
	t.assert_register("(register \"foo\" $M)", "$M", "foo");
	t.assert_register("(register \"ABCDEG\" $Ng)", "$Ng", "ABCDEG");
	t.assert_register("(register \"ABCDEG\" $_0)", "$_0", "ABCDEG");
}

def ACTION_CASES = [
	("(invoke \"A\")", StAction.Invoke(null, "A", Values.NONE)),
	("(invoke $f \"C\")", StAction.Invoke("$f", "C", Values.NONE)),
	("(invoke $g \"D\" (i32.const 11))", StAction.Invoke("$g", "D", [Value.I32(11)])),
	("(get \"A\")", StAction.GlobalGet(null, "A")),
	("(get $h \"X\")", StAction.GlobalGet("$h", "X"))
];
def testActionCommand(t: SpecTestParserTester, pat: string,
		make: StAction -> StCommand) {
	var buf = StringBuffer.new();
	for (a in ACTION_CASES) {
		buf.puts("(").put1(pat, a.0).puts(")");
		var input = buf.extract();
		var expected = make(a.1);
		if (wizeng.verbose) {
			System.puts("  action: ");
			System.puts(input);
			System.ln();
		}
		t.assert_cmds(expected, input);
	}
}

def STRING_CASES = [
	("(%s)", null),
	("(%s \"\")", ""),
	("(%s \"a098ZY\")", "a098ZY")
];
def testStringCommand(t: SpecTestParserTester, cmd: string, make: string -> StCommand) {
	var buf = StringBuffer.new();

	t.assert_err(buf.put1("(%s", cmd).extract());
	t.assert_err(buf.put1("(%s foo", cmd).extract());
	t.assert_err(buf.put1("(%s foo)", cmd).extract());
	t.assert_err(buf.put1("(%s ())", cmd).extract());

	for (k in STRING_CASES) {
		var input = buf.put1(k.0, cmd).extract();
		var expected = make(k.1);
		t.assert_cmds(expected, input);
	}
}

def MODULE_CASES = [
	("(module binary \"\")", StModule.Binary(null, [])),
	("(module $f binary \"\")", StModule.Binary("$f", [])),
	("(module $g binary \"\\6E\\AA\")", StModule.Binary("$g", [0x6E, 0xAA]))
];
def testModuleCommand(t: SpecTestParserTester, pat: string,
		make: StModule -> StCommand) {
	var buf = StringBuffer.new();
	for (a in MODULE_CASES) {
		buf.puts("(").put1(pat, a.0).puts(")");
		var input = buf.extract();
		var expected = make(a.1);
		if (wizeng.verbose) {
			System.puts("  module: ");
			System.puts(input);
			System.ln();
		}
		t.assert_cmds(expected, input);
	}
}

def testCommonErrors(t: SpecTestParserTester, cmd: string) {
	def cases = [
		"(%s",
		"(%s foo)",
		"(%s \"\")",
		"(%s ())",
		"(%s)",
		"(%s ()"
	];
	for (k in cases) {
		var input = Strings.format1(k, cmd);
		if (wizeng.verbose) {
			System.puts("  error: ");
			System.puts(input);
			System.ln();
		}
		t.assert_err(input);
	}
}

def test_action(t: SpecTestParserTester) {
	def X = Values.NONE;
	testActionCommand(t, "action %s",
		StCommand.Action(_));
}

def test_assert_returnx(t: SpecTestParserTester) {
	testCommonErrors(t, "assert_return");
}

def test_assert_return(t: SpecTestParserTester) {
	def X = Values.NONE;
	testActionCommand(t, "assert_return %s",
		StCommand.AssertReturn(_, X));
	testActionCommand(t, "assert_return %s (i32.const 66)",
		StCommand.AssertReturn(_, [Value.I32(66)]));
}

def test_assert_trapx(t: SpecTestParserTester) {
	testCommonErrors(t, "assert_trap");
}

def test_assert_trap(t: SpecTestParserTester) {
	testActionCommand(t, "assert_trap %s",
		StCommand.AssertTrap(_, null));
	testActionCommand(t, "assert_trap %s \"bad input\"",
		StCommand.AssertTrap(_, "bad input"));
}

def test_assert_exhaustionx(t: SpecTestParserTester) {
	testCommonErrors(t, "assert_exhaustion");
}

def test_assert_exhaustion(t: SpecTestParserTester) {
	testActionCommand(t, "assert_exhaustion %s",
		StCommand.AssertExhaustion(_, null));
	testActionCommand(t, "assert_exhaustion %s \"stack overflow\"",
		StCommand.AssertExhaustion(_, "stack overflow"));
}

def test_assert_invalidx(t: SpecTestParserTester) {
	testCommonErrors(t, "assert_invalid");
}

def test_assert_invalid(t: SpecTestParserTester) {
	testModuleCommand(t, "assert_invalid %s",
		StCommand.AssertInvalid(_, null));
	testModuleCommand(t, "assert_invalid %s \"bad foo\"",
		StCommand.AssertInvalid(_, "bad foo"));
}

def test_assert_malformedx(t: SpecTestParserTester) {
	testCommonErrors(t, "assert_malformed");
}

def test_assert_malformed(t: SpecTestParserTester) {
	t.assert_cmds(StCommand.AssertMalformed(StModule.Quote(null, "source"), "msg1"),
		"(assert_malformed (module quote \"source\") \"msg1\")");

}

def test_assert_unlinkablex(t: SpecTestParserTester) {
	testCommonErrors(t, "assert_unlinkable");
}

def test_assert_unlinkable(t: SpecTestParserTester) {
	testModuleCommand(t, "assert_unlinkable %s",
		StCommand.AssertUnlinkable(_, null));
	testModuleCommand(t, "assert_unlinkable %s \"bad home\"",
		StCommand.AssertUnlinkable(_, "bad home"));
}

def testCommands(t: SpecTestParserTester, input: string, extags: Array<byte>) {
	var p = SpecTestParser.new(FILENAME, input);
	p.parseFile();
	if (!p.ok) return t.t.fail3("failed @ %d:%d, %s", p.error_loc.0, p.error_loc.1, p.error_msg);
	var excnt = extags.length, gotcnt = p.commands.length;
	if (gotcnt != excnt) return t.t.fail2("expected %d commands, got %d", excnt, gotcnt);
	// Check the tags (only) of the returned commands
	for (i < extags.length) {
		var extag = extags[i], gottag = p.commands[i].cmd.tag;
		if (extag != gottag) return t.t.fail3("expected tag %d, got command[%d].tag == %d", int.!(extag), i, int.!(gottag));
	}
}

def test_cmds1(t: SpecTestParserTester) {
	testCommands(t, "(assert_return (invoke  \"add\" (i32.const 1) (i32.const 1)) (i32.const 2))", [
		StCommand.AssertReturn.tag
	]);

	testCommands(t, "(assert_invalid (module binary \"\\00\") \"type mismatch\")", [
		StCommand.AssertInvalid.tag
	]);

	testCommands(t, "(assert_trap (invoke \"x\" (i32.const 1) (i32.const 6)) \"unreachable\")", [
		StCommand.AssertTrap.tag
	]);

	testCommands(t, "(assert_return (get $Ng \"Mg.glob\") (i32.const 42))", [
		StCommand.AssertReturn.tag
	]);
}

def test_cmds2(t: SpecTestParserTester) {
	testCommands(t, "(module binary \"\") (register \"foo\")", [
		StCommand.Module.tag,
		StCommand.Register.tag
	]);

	testCommands(t, "(module binary \"\") (register \"foo\" $v)", [
		StCommand.Module.tag,
		StCommand.Register.tag
	]);
}

def test_cmds3(t: SpecTestParserTester) {
	testCommands(t, "(action (invoke \"foo\"))", [
		StCommand.Action.tag
	]);

	testCommands(t, "(assert_uninstantiable (module binary \"\"))", [
		StCommand.AssertUninstantiable.tag
	]);
}

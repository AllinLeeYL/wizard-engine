// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, SpecTestParserTester.new, _);
def X = [
	T("specparse:i32", test_i32_const),
	T("specparse:i64", test_i64_const),
	T("specparse:f32", test_f32_const),
	T("specparse:f64", test_f64_const),
	T("specparse:string1", test_string1),
	T("specparse:string2", test_string2),
	T("specparse:stringx", test_stringx),
	T("specparse:stringp", test_stringp),
	T("specparse:modbin1", test_modbin1),
	T("specparse:modbinx", test_modbinx),
	T("specparse:modquote1", test_modquote1),
	T("specparse:modx", test_modx),
	T("specparse:mod_named", test_mod_named),
	T("specparse:invoke1", test_invoke1),
	T("specparse:invokex", test_invokex),
	T("specparse:invoke_named", test_invoke_named),
	T("specparse:get1", test_get1),
	T("specparse:getx", test_getx),
	T("specparse:get_named", test_get_named),
	()
];

def FILENAME = "SpecTestParserTest.v3";
class SpecTestParserTester(t: Tester) {
	def parseCommand(input: string) -> SpecTestCommand {
		var p = SpecTestParser.new(FILENAME, input);
		var c = p.parseOneCommand();
		return if(p.ok, c);
	}
	def assert_i(input: string, expected: int) {
		assert_const(input, Value.I32(u32.!(expected)));
	}
	def assert_const(input: string, expected: Value) {
		var v = parseCommand(input);
		if (StCommand.Constant.?(v.cmd)) {
			var got = StCommand.Constant.!(v.cmd).val;
			if (got != expected) {
				t.fail2("expected %q, got %q",
					Values.render(_, expected), Values.render(_, got));
			}
		} else {
			t.fail1("expected constant, got %s", v.cmd.name);
		}
	}
	def assert_string(input: string, expected: string) {
		var p = SpecTestParser.new(FILENAME, input);
		var r = p.parseString();
		if (expected == null) {
			return if(p.ok, t.fail("expected error, but passed"));
		}
		if (!p.ok) return t.fail("expected string, but got error");
		t.assert_string(expected, r);
	}
	def assert_err(input: string) {
		var p = SpecTestParser.new(FILENAME, input);
		var c = p.parseOneCommand();
		if (p.ok) t.fail1("expected error, got %s", c.cmd.name);
	}
	def assert_bin(input: string, expected_varname: string, expected_bytes: Array<byte>) {
		var c = parseCommand(input);
		if (c == null) return t.fail("expected binary module, but got error");
		match (c.cmd) {
			BinaryModule(varname, bytes) => {
				t.assert_string(expected_varname, varname);
				t.assertb(expected_bytes, bytes);
			}
			_ => return t.fail1("expected binary module, but got %s", c.cmd.name);
		}
	}
	def assert_quote(input: string, expected_varname: string, expected_source: string) {
		var c = parseCommand(input);
		if (c == null) return t.fail("expected quote module, but got error");
		match (c.cmd) {
			QuotedModule(varname, source) => {
				t.assert_string(expected_varname, varname);
				t.assert_string(expected_source, source);
			}
			_ => return t.fail1("expected quote module, but got %s", c.cmd.name);
		}
	}
	def assert_invoke(input: string, expected_varname: string, expected_funcname: string) {
		var c = parseCommand(input);
		if (c == null) return t.fail("expected invoke, but got error");
		match (c.cmd) {
			Invoke(varname, funcname) => {
				t.assert_string(expected_varname, varname);
				t.assert_string(expected_funcname, funcname);
			}
			_ => return t.fail1("expected invoke, but got %s", c.cmd.name);
		}
	}
	def assert_get(input: string, expected_varname: string, expected_globalname: string) {
		var c = parseCommand(input);
		if (c == null) return t.fail("expected get, but got error");
		match (c.cmd) {
			GetGlobal(varname, globalname) => {
				t.assert_string(expected_varname, varname);
				t.assert_string(expected_globalname, globalname);
			}
			_ => return t.fail1("expected get, but got %s", c.cmd.name);
		}
	}
}

def test_i32_const(t: SpecTestParserTester) {
	t.assert_i("(i32.const 0)", 0);
	t.assert_i("(i32.const 23)", 23);
	t.assert_i("(i32.const -32)", -32);
	t.assert_i("(i32.const 0xABCDEF01)", 0xABCDEF01);
	t.assert_i("(i32.const 0x12345678)", 0x12345678);
	t.assert_i("(i32.const -0x97531)", 0-0x97531);
	t.assert_i("(i32.const 1469788397)", 1469788397);
	t.assert_i("(i32.const 1469837011)", 1469837011);
	t.assert_i("(i32.const 1469837011)", 1469837011);
	t.assert_i("(i32.const 1989852383)", 1989852383);
	t.assert_i("(i32.const 1989852383)", 1989852383);
	t.assert_i("(i32.const 2147483647)", 2147483647);
	t.assert_i("(i32.const 2147483648)", int.!(2147483648));
	t.assert_i("(i32.const -2147483647)", -2147483647);
	t.assert_i("(i32.const -2147483648)", -2147483648);
	t.assert_i("(i32.const 2147483661)", int.!(2147483661));
	t.assert_i("(i32.const 2882377846)", int.!(2882377846));
	t.assert_i("(i32.const 2965492451)", int.!(2965492451));
	t.assert_i("(i32.const 3758997519)", int.!(3758997519));
	t.assert_i("(i32.const 406477942)", int.!(406477942));
	t.assert_i("(i32.const 4261469184)", int.!(4261469184));
	t.assert_i("(i32.const 4294967277)", int.!(4294967277));
	t.assert_i("(i32.const 4294967295)", int.!(4294967295));
	t.assert_i("(i32.const 0x80000000)", 0x80000000);
	t.assert_i("(i32.const 0xffffffff)", 0xffffffff);
	t.assert_i("(i32.const 0x7fffffff)", 0x7fffffff);
	t.assert_i("(i32.const -0x80000000)", 0-0x80000000);
	t.assert_i("(i32.const -0xffffffff)", 0-0xffffffff);
	t.assert_i("(i32.const -0x7fffffff)", 0-0x7fffffff);
}

def test_i64_const(t: SpecTestParserTester) {
	// TODO
}

def test_f32_const(t: SpecTestParserTester) {
	// TODO
}

def test_f64_const(t: SpecTestParserTester) {
	// TODO
}

def test_string1(t: SpecTestParserTester) {
	t.assert_string("\"\"", "");
	t.assert_string("\"a\"", "a");
	t.assert_string("\"bcdefgh\"", "bcdefgh");
	t.assert_string("\"ijklmnopqrstuvwxyz\"", "ijklmnopqrstuvwxyz");
	t.assert_string("\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
	t.assert_string("\"0123456789\"", "0123456789");
	t.assert_string("\"+=-_)(*&^%$#@!\"", "+=-_)(*&^%$#@!");
	t.assert_string("\",<.>/?;:\"", ",<.>/?;:");
	t.assert_string("\"[{]}|`~\"", "[{]}|`~");
	t.assert_string("\" \"", " ");
	t.assert_string("\"  \"", "  ");
	t.assert_string("\"   \"", "   ");
	t.assert_string("\"f g\"", "f g");
	t.assert_string("\"spec (test) man\"", "spec (test) man");
	t.assert_string("\"(module (foo (bar)))\"", "(module (foo (bar)))");
}

def test_string2(t: SpecTestParserTester) {
	t.assert_string("\"\\\"", null);
	t.assert_string("\"\\\\\"", null);
	t.assert_string("\"\\n\"", null);
	t.assert_string("\"\\r\"", null);
	t.assert_string("\"\\z\"", null);
	t.assert_string("\"\\t\"", null);
}

def test_stringx(t: SpecTestParserTester) {
	t.assert_string("\"\\00\"", "\x00");
	t.assert_string("\"\\01\"", "\x01");
	t.assert_string("\"\\1a\\2b\\3c\\4d\\5e\\6f\"", "\x1a\x2b\x3c\x4d\x5e\x6f");
	t.assert_string("\"\\9A\\8B\\7C\\6D\\5E\\4F\"", "\x9a\x8b\x7c\x6d\x5e\x4f");
}

def test_stringp(t: SpecTestParserTester) {
	t.assert_string("\"A\"\"B\"", "A");
	t.assert_string("\"XYZ\"  \"012\"", "XYZ");
}

def test_modbin1(t: SpecTestParserTester) {
	t.assert_bin("(module binary \"\")", null, []);
	t.assert_bin("(module binary \"\\EF\")", null, [0xEF]);
	t.assert_bin("(module binary \"\\01\\02\\03\")", null, [0x01, 0x02, 0x03]);
	t.assert_bin("(module binary \"\\AA\" \"\\BB\" \"\\CC\")", null, [0xAA, 0xBB, 0xCC]);
	t.assert_bin("(module binary \"\\22\"\n\"\\33\"\n\"\\44\"\n)", null, [0x22, 0x33, 0x44]);
}

def test_modbinx(t: SpecTestParserTester) {
	t.assert_err("(module bin");
	t.assert_err("(module binary");
	t.assert_err("(module binary)");
	t.assert_err("(module binary )");
	t.assert_err("(module binary \")");
	t.assert_err("(module binary foo)");
	t.assert_err("(module binary ())");
}

def test_modquote1(t: SpecTestParserTester) {
	t.assert_quote("(module quote \"\")", null, "");
	t.assert_quote("(module quote \"(module foo)\")", null, "(module foo)");
	t.assert_quote("(module quote \"(module\" \" foo)\")", null, "(module foo)");
	t.assert_quote("(module quote \"(module\"\n\" foo)\")", null, "(module foo)");
}

def test_modquotex(t: SpecTestParserTester) {
	t.assert_err("(module quo");
	t.assert_err("(module quote");
	t.assert_err("(module quote)");
	t.assert_err("(module quote )");
	t.assert_err("(module quote \")");
	t.assert_err("(module quote foo)");
	t.assert_err("(module quote ())");
}

def test_modx(t: SpecTestParserTester) {
	t.assert_err("(module");
	t.assert_err("(module ");
	t.assert_err("(module)");
	t.assert_err("(module )");
	t.assert_err("(module foo)");
}

def test_mod_named(t: SpecTestParserTester) {
	t.assert_bin("(module $f binary \"\")", "$f", []);
	t.assert_bin("(module $az_09_AZ binary \"\")", "$az_09_AZ", []);
	t.assert_quote("(module $__ quote \"(foo)\")", "$__", "(foo)");
}

def test_invoke1(t: SpecTestParserTester) {
	t.assert_invoke("(invoke \"foo\")", null, "foo");
	t.assert_invoke("(invoke \"ABCDEG\")", null, "ABCDEG");
}

def test_invokex(t: SpecTestParserTester) {
	t.assert_err("(invoke");
	t.assert_err("(invoke)");
	t.assert_err("(invoke foo)");
	t.assert_err("(invoke ())");
	t.assert_err("(invoke \"foo\" barf)");
}

def test_invoke_named(t: SpecTestParserTester) {
	t.assert_invoke("(invoke $M \"foo\")", "$M", "foo");
	t.assert_invoke("(invoke $Ng \"ABCDEG\")", "$Ng", "ABCDEG");
}

def test_get1(t: SpecTestParserTester) {
	t.assert_get("(get \"foo\")", null, "foo");
	t.assert_get("(get \"ABCDEG\")", null, "ABCDEG");
}

def test_getx(t: SpecTestParserTester) {
	t.assert_err("(get");
	t.assert_err("(get)");
	t.assert_err("(get foo)");
	t.assert_err("(get ())");
	t.assert_err("(get \"foo\" barf)");
}

def test_get_named(t: SpecTestParserTester) {
	t.assert_get("(get $M \"foo\")", "$M", "foo");
	t.assert_get("(get $Ng \"ABCDEG\")", "$Ng", "ABCDEG");
	t.assert_get("(get $_0 \"ABCDEG\")", "$_0", "ABCDEG");
}

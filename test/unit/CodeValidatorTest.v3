// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, CodeValidatorTester.new, _);
def X = [
	T("validator:local0", test_local0),
	T("validator:local1", test_local1),
	T("validator:ret0", test_ret0),
	T("validator:ret1", test_ret1),
	T("validator:br_table0", test_br_table0),
	T("validator:br_table1", test_br_table1),
	T("validator:if0", test_if0),
	T("validator:if1", test_if1),
	T("validator:if_unr", test_if_unr),
	T("validator:loop0", test_loop0),
	T("validator:loop_br", test_loop_br),
	T("validator:loopv", test_loopv),
	T("validator:blockp1", test_blockp1),
	T("validator:blockp2", test_blockp2),
	T("validator:blockv2", test_blockv2),
	T("validator:blockinv", test_blockinv),
	T("validator:unterm", test_unterm),
	T("validator:else", test_else0),
	T("validator:simple_ops_v", test_simple_ops_v),
	T("validator:simple_ops_r", test_simple_ops_r),
	T("validator:simple_ops0", test_simple_ops0),
	T("validator:simple_ops1", test_simple_ops1),
	T("validator:simple_ops2", test_simple_ops2),
	T("validator:memindex1", test_memindex1),
	T("validator:memindex2", test_memindex2),
	T("validator:tabindex1", test_tabindex1),
	T("validator:tabindex2", test_tabindex2),
	()
];

class CodeValidatorTester(t: Tester) extends ModuleBuilder {
	def err = WasmErrorGen.new("CodeValidatorTest.v3");
	var validator: CodeValidator; // FAST: reuse validator
	new() {
		validator = CodeValidator.new(extensions, Limits.new().set(extensions), module, err);
	}
	def setExtensions(e: Extension.set) {
		extensions = e;
		validator = CodeValidator.new(extensions, Limits.new().set(extensions), module, err);
	}
	def valid(raw: Array<byte>) {
		code(raw);
		err.reset();
		match (validator.validateFunc(func)) {
			Ok => ;
			Error(error, pc, msg) => t.fail2("expected success, got error @+%d: %s", pc, msg);
		}
	}
	def invalid(expected: WasmError, raw: Array<byte>, error_pc: int) {
		code(raw);
		err.reset();
		match (validator.validateFunc(func)) {
			Ok => t.fail2("expected error %s @+%d, got success", expected.name, error_pc);
			Error(error, pc, msg) => {
				if (error != expected) {
					t.fail3("expected error %s, got %s @+%d\n",
						expected.name, error.name, pc);
				} else if (pc != error_pc) {
					t.fail3("expected error @+%d, got error @+%d: %s", error_pc, pc, msg);
				}
			}
		}
	}
	def TypeError(code: Array<byte>, error_pc: int) {
		invalid(WasmError.TYPE_MISMATCH, code, error_pc);
	}
}

def EB = BpTypecon.EmptyBlock.code;

def test_local0(t: CodeValidatorTester) {
	var code1: Array<byte> = [Opcode.LOCAL_GET.code, 0];
	t.invalid(WasmError.OOB_INDEX, code1, 1);
	t.sig(SigCache.i_i);
	t.valid(code1);
}

def test_local1(t: CodeValidatorTester) {
	var code1: Array<byte> = [Opcode.LOCAL_GET.code, 0];
	t.sig(SigCache.i_i);
	t.addLocals(10000000, ValueType.I32);
	t.invalid(WasmError.EXCEEDED_LIMIT, code1, 1);
}

def test_ret0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([]);
	t.valid([Opcode.RETURN.code]);

	t.TypeError([Opcode.I32_CONST.code, 0], 3);
	t.TypeError([Opcode.I64_CONST.code, 0], 3);
	t.TypeError([Opcode.F32_CONST.code, 0, 0, 0, 0], 6);
	t.TypeError([Opcode.F64_CONST.code, 0, 0, 0, 0, 0, 0, 0, 0], 10);
}

def test_ret1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.TypeError([], 1);
	t.TypeError([Opcode.RETURN.code], 1);

	t.valid([Opcode.I32_CONST.code, 0]);
	t.TypeError([Opcode.I64_CONST.code, 0], 3);
	t.TypeError([Opcode.F32_CONST.code, 0, 0, 0, 0], 6);
	t.TypeError([Opcode.F64_CONST.code, 0, 0, 0, 0, 0, 0, 0, 0], 10);
}

def test_br_table0(t: CodeValidatorTester) {
	var code1: Array<byte> = [
		Opcode.I32_CONST.code, 7,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2, 0, 0, 0];
	t.sig(SigCache.i_i);
	t.valid(code1);

	t.sig(SigCache.f_i);
	t.TypeError(code1, 5);

	t.sig(SigCache.i_f);
	t.TypeError(code1, 5);

	var code2: Array<byte> = [
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 7,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2, 0, 1, 0,
		Opcode.END.code];
	t.sig(SigCache.i_i);
	t.valid(code2);

	t.sig(SigCache.f_i);
	t.TypeError(code2, 7);
}

def test_br_table1(t: CodeValidatorTester) {
	var code1: Array<byte> = [
		Opcode.BLOCK.code, EB,
		Opcode.I32_CONST.code, 8,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2, 0, 1, 0,
		Opcode.END.code];
	t.sig(SigCache.i_i);
	t.TypeError(code1, 7);

	var code2: Array<byte> = [
		Opcode.F32_CONST.code, 0, 0, 0, 0,
		Opcode.LOOP.code, BpTypecon.F32.code,
		Opcode.I32_CONST.code, 9,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2, 0, 1, 0,
		Opcode.END.code];
	t.sig(SigCache.i_i);
	t.TypeError(code2, 12);
}

def test_if0(t: CodeValidatorTester) {
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, EB,
		Opcode.ELSE.code,
		Opcode.END.code
	];
	t.sig(SigCache.i_v);
	t.valid(code1);

	t.sig(SigCache.l_v);
	t.TypeError(code1, 3);

	var code2: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, EB,
		Opcode.BR.code, 0,
		Opcode.ELSE.code,
		Opcode.RETURN.code,
		Opcode.END.code
	];
	t.sig(SigCache.i_v);
	t.valid(code2);

	t.sig(SigCache.l_v);
	t.TypeError(code2, 3);

	var code3: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, EB,
		Opcode.BR.code, 1,
		Opcode.END.code
	];
	t.sig(SigCache.i_v);
	t.valid(code3);

	t.sig(SigCache.l_v);
	t.TypeError(code3, 3);
}

def test_if1(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.ELSE.code,
		Opcode.END.code
	], 5);

	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.ELSE.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.END.code
	], 5);

	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.ELSE.code,
		Opcode.END.code
	], 8);

	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.UNREACHABLE.code,
		Opcode.ELSE.code,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	]);

	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 1,
		Opcode.ELSE.code,
		Opcode.LOCAL_GET.code, 1,
		Opcode.END.code
	];
	t.sig(SigCache.ii_i);
	t.valid(code1);

	t.sig(TypeDecl.Function(SigCache.arr_if, SigCache.arr_i));
	t.TypeError(code1, 7);

	var code2: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.F32.code,
		Opcode.UNREACHABLE.code,
		Opcode.ELSE.code,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	];
	t.sig(SigCache.ii_i);
	t.TypeError(code2, 9);
}

def test_if_unr(t: CodeValidatorTester) {
	// TODO: test if with unreachable in true/false blocks
}

def test_loop0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([
		Opcode.LOOP.code, EB,
		Opcode.END.code
	]);
	t.sig(SigCache.v_i);
	t.valid([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	]);
	t.sig(SigCache.v_i);
	t.valid([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 0,
		Opcode.END.code
	]);
	t.TypeError([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.I64_CONST.code, 0,
		Opcode.END.code
	], 5);
	t.TypeError([
		Opcode.LOOP.code, BpTypecon.I64.code,
		Opcode.I64_CONST.code, 0,
		Opcode.END.code
	], 6);
}

def test_loop_br(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([
		Opcode.LOOP.code, EB,
		Opcode.BR.code, 0,
		Opcode.END.code
	]);
	t.valid([
		Opcode.LOOP.code, EB,
		Opcode.BR.code, 1,
		Opcode.END.code
	]);
	t.invalid(WasmError.OOB_LABEL, [
		Opcode.LOOP.code, EB,
		Opcode.BR.code, 2,
		Opcode.END.code
	], 3);
	t.sig(SigCache.v_i);
	t.valid([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.BR.code, 0,
		Opcode.END.code
	]);
	t.valid([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 0,
		Opcode.BR.code, 1,
		Opcode.END.code
	]);
}

def test_loopv(t: CodeValidatorTester) {
	var i_v = byte.!(t.addSig(SigCache.i_v));
	var i_i = byte.!(t.addSig(SigCache.i_i));
	var f_f = byte.!(t.addSig(SigCache.f_f));
	var i_f = byte.!(t.addSig(SigCache.i_f));

	t.sig(SigCache.if_v);
	t.TypeError([
		Opcode.LOOP.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 1);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOOP.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 3);
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOOP.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	]);
}

def test_blockp1(t: CodeValidatorTester) {
	var i_v = byte.!(t.addSig(SigCache.i_v));
	var f_v = byte.!(t.addSig(TypeDecl.Function(SigCache.arr_f, SigCache.arr_v)));

	t.sig(SigCache.if_v);
	t.TypeError([
		Opcode.BLOCK.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 1);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 3);
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.BLOCK.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 3);
	t.valid([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_v,
		Opcode.DROP.code,
		Opcode.END.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.BLOCK.code, f_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 3);
}

def test_blockp2(t: CodeValidatorTester) {
	var i_v = byte.!(t.addSig(SigCache.i_v));
	var f_f = byte.!(t.addSig(SigCache.f_f));
	var f_l = byte.!(t.addSig(SigCache.f_l));

	t.sig(SigCache.if_v);
	t.TypeError([
		Opcode.BLOCK.code, f_f,
		Opcode.END.code
	], 1);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.BLOCK.code, f_f,
		Opcode.END.code,
		Opcode.DROP.code
	], 3);
	t.valid([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_f,
		Opcode.END.code,
		Opcode.DROP.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_f,
		Opcode.DROP.code,
		Opcode.I32_CONST.code, 0,
		Opcode.END.code,
		Opcode.DROP.code
	], 8);
	t.valid([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_l,
		Opcode.DROP.code,
		Opcode.I64_CONST.code, 0,
		Opcode.END.code,
		Opcode.DROP.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_l,
		Opcode.DROP.code,
		Opcode.I32_CONST.code, 0,
		Opcode.END.code,
		Opcode.DROP.code
	], 8);
}

def test_blockv2(t: CodeValidatorTester) {
	// TODO
}

def test_blockinv(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	t.invalid(WasmError.INVALID_BLOCK_TYPE, [
		Opcode.BLOCK.code, 33,
		Opcode.END.code
	], 2);
}

def test_unterm(t: CodeValidatorTester) {
	t.invalid(WasmError.UNTERMINATED_BODY, [
		Opcode.I32_CONST.code, 0,
		Opcode.IF.code, EB
	], 6);
	t.invalid(WasmError.UNTERMINATED_BODY, [
		Opcode.I32_CONST.code, 0,
		Opcode.IF.code, EB,
		Opcode.ELSE.code
	], 7);
	t.sig(SigCache.v_v);
	t.invalid(WasmError.OOB_LABEL, [Opcode.END.code], 2);
}

def test_else0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.invalid(WasmError.MISMATCHED_ELSE, [Opcode.ELSE.code], 1);

	t.invalid(WasmError.MISMATCHED_ELSE, [
		Opcode.I32_CONST.code, 0,
		Opcode.IF.code, EB,
		Opcode.ELSE.code,
		Opcode.ELSE.code,
		Opcode.END.code
	], 6);

}

def test_simple_ops_v(t: CodeValidatorTester) {
	var code = Vector<byte>.new();
	for (op in Opcode) {
		if (!Opcodes.isShortOperator[op.code]) continue;
		t.sig(op.sig);
		for (i < op.sig.params.length) {
			code.put(Opcode.LOCAL_GET.code);
			code.put(byte.!(i));
		}
		code.put(op.code);
		t.valid(code.extract());
	}
}

def test_simple_ops_r(t: CodeValidatorTester) {
	var code = Vector<byte>.new();
	var types = [ValueType.I32, ValueType.I64, ValueType.F32, ValueType.F64];
	for (op in Opcode) {
		if (!Opcodes.isShortOperator[op.code]) continue;
		// Test all possible (expected) return types for all simple opcodes.
		for (rt in types) {
			var sig = TypeDecl.Function(op.sig.params, [rt]);
			t.sig(sig);
			for (i < op.sig.params.length) {
				code.put(Opcode.LOCAL_GET.code);
				code.put(byte.!(i));
			}
			code.put(op.code);
			if (op.sig.results.length == 1 && op.sig.results[0] == rt) {
				t.valid(code.extract());
			} else {
				var pt = code.length + 1;
				t.TypeError(code.extract(), pt);
			}
		}
	}

}

def test_simple_ops0(t: CodeValidatorTester) {
	var template: Array<byte> = [
		Opcode.LOCAL_GET.code,
		/* local_pt */0,
		/* opcode_pt */0
	];
	var local_pt = 1, opcode_pt = 2;

	t.sig(SigCache.v_i); // for proper local numbering
	var locals = [
		t.addLocal(ValueType.I32),
		t.addLocal(ValueType.I64),
		t.addLocal(ValueType.F32),
		t.addLocal(ValueType.F64)
	];
	for (op in Opcode) {
		if (!Opcodes.isShortOperator[op.code]) continue;
		if (op.sig.params.length != 0) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local_pt] = byte.!(l);
			template[opcode_pt] = op.code;
			var pt = template.length + 9;
			t.TypeError(template, pt);
		}
	}
}

def test_simple_ops1(t: CodeValidatorTester) {
	var template: Array<byte> = [
		Opcode.LOCAL_GET.code,
		/* local_pt */0,
		/* opcode_pt */0
	];
	var local_pt = 1, opcode_pt = 2;

	t.sig(SigCache.i_i); // for proper local numbering
	var locals = [
		(ValueType.I32, t.addLocal(ValueType.I32)),
		(ValueType.I64, t.addLocal(ValueType.I64)),
		(ValueType.F32, t.addLocal(ValueType.F32)),
		(ValueType.F64, t.addLocal(ValueType.F64))
	];
	for (op in Opcode) {
		if (!Opcodes.isShortOperator[op.code]) continue;
		if (op.sig.params.length != 1) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local_pt] = byte.!(l.1);
			template[opcode_pt] = op.code;
			if (l.0 == op.sig.params[0]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.TypeError(template, pt);
			}
		}
	}
}

def test_simple_ops2(t: CodeValidatorTester) {
	var template: Array<byte> = [
		Opcode.LOCAL_GET.code,
		/* local0_pt */0,
		Opcode.LOCAL_GET.code,
		/* local1_pt */0,
		/* opcode_pt */0
	];
	var local0_pt = 1, local1_pt = 3, opcode_pt = 4;

	t.sig(SigCache.ii_i); // for proper local numbering
	var locals = [
		(ValueType.I32, t.addLocal(ValueType.I32)),
		(ValueType.I64, t.addLocal(ValueType.I64)),
		(ValueType.F32, t.addLocal(ValueType.F32)),
		(ValueType.F64, t.addLocal(ValueType.F64))
	];
	for (op in Opcode) {
		if (!Opcodes.isShortOperator[op.code]) continue;
		if (op.sig.params.length != 2) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local0_pt] = 0;
			template[local1_pt] = byte.!(l.1);
			template[opcode_pt] = op.code;
			if (l.0 == op.sig.params[1]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.TypeError(template, pt);
			}

			template[local0_pt] = byte.!(l.1);
			template[local1_pt] = 1;
			template[opcode_pt] = op.code;
			if (l.0 == op.sig.params[0]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.TypeError(template, pt);
			}
		}
	}
}

def test_memindex1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.addMemory(1, 1);
	t.valid([
		Opcode.MEMORY_SIZE.code, 0
	]);
	t.valid([
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0
	]);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.MEMORY_SIZE.code, 1
	], 2);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 1
	], 4);

	// expect a zero byte if no multi-memory
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.MEMORY_SIZE.code, 0x80, 0
	], 2);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0x80, 0
	], 4);

	// allow a full LEB if multi-memory
	t.setExtensions(Extension.MULTI_MEMORY);
	t.valid([
		Opcode.MEMORY_SIZE.code, 0x80, 0
	]);
	t.valid([
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0x80, 0
	]);
}

def test_memindex2(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.MEMORY_SIZE.code, 0
	], 2);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0
	], 4);
	// allow a full LEB if multi-memory
	t.setExtensions(Extension.MULTI_MEMORY);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.MEMORY_SIZE.code, 0x80, 0
	], 2);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0x80, 0
	], 4);
}

def test_tabindex1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.addTable(1, 1, null);
	t.valid([
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0
	]);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 1
	], 5);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0x80, 0
	], 5);
	// allow a full LEB if multi-memory
	t.setExtensions(Extension.REFERENCE_TYPES);
	t.valid([
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0x80, 0
	]);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 1
	], 5);
}

def test_tabindex2(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0
	], 5);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 1
	], 5);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0x80, 0
	], 5);
	// allow a full LEB if multi-memory
	t.setExtensions(Extension.REFERENCE_TYPES);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0x80, 0
	], 5);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 1
	], 5);
}

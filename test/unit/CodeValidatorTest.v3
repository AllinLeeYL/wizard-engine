// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, CodeValidatorTester.new, _);
def X = [
	T("validator:local0", test_local0),
	T("validator:local1", test_local1),
	T("validator:localref", test_localref),
	T("validator:globalref", test_globalref),
	T("validator:refparam", test_refparam),
	T("validator:ret0", test_ret0),
	T("validator:ret1", test_ret1),
	T("validator:br_table0", test_br_table0),
	T("validator:br_table1", test_br_table1),
	T("validator:if0", test_if0),
	T("validator:if1", test_if1),
	T("validator:if2", test_if2),
	T("validator:if_end", test_if_end),
	T("validator:if_unr", test_if_unr),
	T("validator:loop0", test_loop0),
	T("validator:loop_br", test_loop_br),
	T("validator:loopv", test_loopv),
	T("validator:blockp1", test_blockp1),
	T("validator:blockp2", test_blockp2),
	T("validator:blockv2", test_blockv2),
	T("validator:blockinv", test_blockinv),
	T("validator:unterm", test_unterm),
	T("validator:else", test_else0),
	T("validator:simple_ops_v", test_simple_ops_v),
	T("validator:simple_ops_r", test_simple_ops_r),
	T("validator:simple_ops0", test_simple_ops0),
	T("validator:simple_ops1", test_simple_ops1),
	T("validator:simple_ops2", test_simple_ops2),
	T("validator:memindex1", test_memindex1),
	T("validator:memindex2", test_memindex2),
	T("validator:tabindex1", test_tabindex1),
	T("validator:tabindex2", test_tabindex2),
	T("validator:retcall1", test_retcall1),
	T("validator:retcall2", test_retcall2),
	T("validator:invalid1", test_invalid1),
	T("validator:invalid2", test_invalid2),
	T("validator:prefix1", test_prefix_ops1),
	T("validator:ref.null", test_ref_null),
	T("validator:ref.is_null", test_ref_is_null),
	T("validator:ref.func", test_ref_func),
	T("validator:memory.init", test_memory_init),
	T("validator:data.drop", test_data_drop),
	T("validator:memory.copy", test_memory_copy),
	T("validator:memory.fill", test_memory_fill),
	T("validator:table.init", test_table_init),
	T("validator:elem.drop", test_elem_drop),
	T("validator:table.get", test_table_get),
	T("validator:table.set", test_table_set),
	T("validator:table.copy", test_table_copy),
	T("validator:table.grow", test_table_grow),
	T("validator:table.size", test_table_size),
	T("validator:table.fill", test_table_fill),
	()
];

class CodeValidatorTester(t: Tester) extends ModuleBuilder {
	def err = WasmErrorGen.new("CodeValidatorTest.v3");
	var validator: CodeValidator; // FAST: reuse validator
	new() {
		validator = CodeValidator.new(extensions, Limits.new().set(extensions), module, err);
	}
	def setExtensions(e: Extension.set) {
		extensions = e;
		validator = CodeValidator.new(extensions, Limits.new().set(extensions), module, err);
	}
	def valid(raw: Array<byte>) {
		code(raw);
		err.reset();
		match (validator.validateFunc(func)) {
			Ok => ;
			Error(error, pc, msg) => t.fail2("expected success, got error @+%d: %s", pc, msg);
		}
	}
	def invalid(expected: WasmError, raw: Array<byte>, error_pc: int) {
		code(raw);
		err.reset();
		match (validator.validateFunc(func)) {
			Ok => t.fail2("expected error %s @+%d, got success", expected.name, error_pc);
			Error(error, pc, msg) => {
				if (error != expected) {
					t.fail3("expected error %s, got %s @+%d\n",
						expected.name, error.name, pc);
				} else if (pc != error_pc) {
					t.fail3("expected error @+%d, got error @+%d: %s", error_pc, pc, msg);
				}
			}
		}
	}
	def TypeError(code: Array<byte>, error_pc: int) {
		invalid(WasmError.TYPE_MISMATCH, code, error_pc);
	}
}

def EB = BpTypecon.EmptyBlock.code;

def test_local0(t: CodeValidatorTester) {
	var code1: Array<byte> = [Opcode.LOCAL_GET.code, 0];
	t.invalid(WasmError.OOB_INDEX, code1, 1);
	t.sig(SigCache.i_i);
	t.valid(code1);
}

def test_local1(t: CodeValidatorTester) {
	var code1: Array<byte> = [Opcode.LOCAL_GET.code, 0];
	t.sig(SigCache.i_i);
	t.addLocals(10000000, ValueType.I32);
	t.invalid(WasmError.EXCEEDED_LIMIT, code1, 1);
}

def test_localref(t: CodeValidatorTester) {
	var lg = t.addLocals(1, ValueType.FUNCREF);
	var le = t.addLocals(1, ValueType.EXTERNREF);
	var sig = ValueType.Function([ValueType.FUNCREF, ValueType.EXTERNREF], SigCache.arr_v);
	t.sig(sig);
	t.valid([Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_SET.code, byte.!(lg)]);
	t.valid([Opcode.LOCAL_GET.code, 1, Opcode.LOCAL_SET.code, byte.!(le)]);

	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_SET.code, byte.!(le)], 7);
	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.LOCAL_GET.code, 1, Opcode.LOCAL_SET.code, byte.!(lg)], 7);
}

def test_globalref(t: CodeValidatorTester) {
	var lg = t.addGlobal(ValueType.FUNCREF, InitExpr.Null(ValueType.FUNCREF));
	var le = t.addGlobal(ValueType.EXTERNREF, InitExpr.Null(ValueType.EXTERNREF));
	var sig = ValueType.Function([ValueType.FUNCREF, ValueType.EXTERNREF], SigCache.arr_v);
	t.sig(sig);
	t.valid([Opcode.LOCAL_GET.code, 0, Opcode.GLOBAL_SET.code, byte.!(lg)]);
	t.valid([Opcode.LOCAL_GET.code, 1, Opcode.GLOBAL_SET.code, byte.!(le)]);

	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.LOCAL_GET.code, 0, Opcode.GLOBAL_SET.code, byte.!(le)], 3);
	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.LOCAL_GET.code, 1, Opcode.GLOBAL_SET.code, byte.!(lg)], 3);
}

def test_refparam(t: CodeValidatorTester) {
	var code1: Array<byte> = [Opcode.LOCAL_GET.code, 0];
	var refs = [ValueType.FUNCREF, ValueType.EXTERNREF];
	for (p in refs) {
		for (r in refs) {
			var sig = ValueType.Function([p], [r]);
			t.sig(sig);
			if (p == r) t.valid(code1);
			else t.invalid(WasmError.TYPE_MISMATCH, code1, 3);
		}
	}
}

def test_ret0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([]);
	t.valid([Opcode.RETURN.code]);

	t.TypeError([Opcode.I32_CONST.code, 0], 3);
	t.TypeError([Opcode.I64_CONST.code, 0], 3);
	t.TypeError([Opcode.F32_CONST.code, 0, 0, 0, 0], 6);
	t.TypeError([Opcode.F64_CONST.code, 0, 0, 0, 0, 0, 0, 0, 0], 10);
}

def test_ret1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.TypeError([], 1);
	t.TypeError([Opcode.RETURN.code], 1);

	t.valid([Opcode.I32_CONST.code, 0]);
	t.TypeError([Opcode.I64_CONST.code, 0], 3);
	t.TypeError([Opcode.F32_CONST.code, 0, 0, 0, 0], 6);
	t.TypeError([Opcode.F64_CONST.code, 0, 0, 0, 0, 0, 0, 0, 0], 10);
}

def test_br_table0(t: CodeValidatorTester) {
	var code1: Array<byte> = [
		Opcode.I32_CONST.code, 7,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2, 0, 0, 0];
	t.sig(SigCache.i_i);
	t.valid(code1);

	t.sig(SigCache.f_i);
	t.TypeError(code1, 5);

	t.sig(SigCache.i_f);
	t.TypeError(code1, 5);

	var code2: Array<byte> = [
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 7,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2, 0, 1, 0,
		Opcode.END.code];
	t.sig(SigCache.i_i);
	t.valid(code2);

	t.sig(SigCache.f_i);
	t.TypeError(code2, 7);
}

def test_br_table1(t: CodeValidatorTester) {
	var code1: Array<byte> = [
		Opcode.BLOCK.code, EB,
		Opcode.I32_CONST.code, 8,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2, 0, 1, 0,
		Opcode.END.code];
	t.sig(SigCache.i_i);
	t.TypeError(code1, 7);

	var code2: Array<byte> = [
		Opcode.F32_CONST.code, 0, 0, 0, 0,
		Opcode.LOOP.code, BpTypecon.F32.code,
		Opcode.I32_CONST.code, 9,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2, 0, 1, 0,
		Opcode.END.code];
	t.sig(SigCache.i_i);
	t.TypeError(code2, 12);
}

def test_if0(t: CodeValidatorTester) {
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, EB,
		Opcode.ELSE.code,
		Opcode.END.code
	];
	t.sig(SigCache.i_v);
	t.valid(code1);

	t.sig(SigCache.l_v);
	t.TypeError(code1, 3);

	var code2: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, EB,
		Opcode.BR.code, 0,
		Opcode.ELSE.code,
		Opcode.RETURN.code,
		Opcode.END.code
	];
	t.sig(SigCache.i_v);
	t.valid(code2);

	t.sig(SigCache.l_v);
	t.TypeError(code2, 3);

	var code3: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, EB,
		Opcode.BR.code, 1,
		Opcode.END.code
	];
	t.sig(SigCache.i_v);
	t.valid(code3);

	t.sig(SigCache.l_v);
	t.TypeError(code3, 3);
}

def test_if1(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.ELSE.code,
		Opcode.END.code
	], 5);

	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.ELSE.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.END.code
	], 5);

	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.ELSE.code,
		Opcode.END.code
	], 8);

	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.UNREACHABLE.code,
		Opcode.ELSE.code,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	]);

	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 1,
		Opcode.ELSE.code,
		Opcode.LOCAL_GET.code, 1,
		Opcode.END.code
	];
	t.sig(SigCache.ii_i);
	t.valid(code1);

	t.sig(ValueType.Function(SigCache.arr_if, SigCache.arr_i));
	t.TypeError(code1, 7);

	var code2: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.F32.code,
		Opcode.UNREACHABLE.code,
		Opcode.ELSE.code,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	];
	t.sig(SigCache.ii_i);
	t.TypeError(code2, 9);
}

def test_if2(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 5,
		Opcode.END.code
	], 7);
}

def test_if_end(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	var i_i = byte.!(t.addSig(SigCache.i_i));
	var i_f = byte.!(t.addSig(SigCache.i_f));
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, i_i,
		Opcode.END.code
	]);
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, i_i,
		Opcode.DROP.code,
		Opcode.I32_CONST.code, 5,
		Opcode.END.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, i_i,
		Opcode.I32_CONST.code, 5,
		Opcode.END.code
	], 9);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, i_f,
		Opcode.F32_CONST.code, 3, 3, 3, 3,
		Opcode.END.code
	], 12);

}

def test_if_unr(t: CodeValidatorTester) {
	// TODO: test if with unreachable in true/false blocks
}

def test_loop0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([
		Opcode.LOOP.code, EB,
		Opcode.END.code
	]);
	t.sig(SigCache.v_i);
	t.valid([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	]);
	t.sig(SigCache.v_i);
	t.valid([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 0,
		Opcode.END.code
	]);
	t.TypeError([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.I64_CONST.code, 0,
		Opcode.END.code
	], 5);
	t.TypeError([
		Opcode.LOOP.code, BpTypecon.I64.code,
		Opcode.I64_CONST.code, 0,
		Opcode.END.code
	], 6);
}

def test_loop_br(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([
		Opcode.LOOP.code, EB,
		Opcode.BR.code, 0,
		Opcode.END.code
	]);
	t.valid([
		Opcode.LOOP.code, EB,
		Opcode.BR.code, 1,
		Opcode.END.code
	]);
	t.invalid(WasmError.OOB_LABEL, [
		Opcode.LOOP.code, EB,
		Opcode.BR.code, 2,
		Opcode.END.code
	], 3);
	t.sig(SigCache.v_i);
	t.valid([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.BR.code, 0,
		Opcode.END.code
	]);
	t.valid([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 0,
		Opcode.BR.code, 1,
		Opcode.END.code
	]);
}

def test_loopv(t: CodeValidatorTester) {
	var i_v = byte.!(t.addSig(SigCache.i_v));
	var i_i = byte.!(t.addSig(SigCache.i_i));
	var f_f = byte.!(t.addSig(SigCache.f_f));
	var i_f = byte.!(t.addSig(SigCache.i_f));

	t.sig(SigCache.if_v);
	t.TypeError([
		Opcode.LOOP.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 1);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOOP.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 3);
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOOP.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	]);
}

def test_blockp1(t: CodeValidatorTester) {
	var i_v = byte.!(t.addSig(SigCache.i_v));
	var f_v = byte.!(t.addSig(ValueType.Function(SigCache.arr_f, SigCache.arr_v)));

	t.sig(SigCache.if_v);
	t.TypeError([
		Opcode.BLOCK.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 1);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 3);
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.BLOCK.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 3);
	t.valid([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_v,
		Opcode.DROP.code,
		Opcode.END.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.BLOCK.code, f_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 3);
}

def test_blockp2(t: CodeValidatorTester) {
	var i_v = byte.!(t.addSig(SigCache.i_v));
	var f_f = byte.!(t.addSig(SigCache.f_f));
	var f_l = byte.!(t.addSig(SigCache.f_l));

	t.sig(SigCache.if_v);
	t.TypeError([
		Opcode.BLOCK.code, f_f,
		Opcode.END.code
	], 1);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.BLOCK.code, f_f,
		Opcode.END.code,
		Opcode.DROP.code
	], 3);
	t.valid([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_f,
		Opcode.END.code,
		Opcode.DROP.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_f,
		Opcode.DROP.code,
		Opcode.I32_CONST.code, 0,
		Opcode.END.code,
		Opcode.DROP.code
	], 8);
	t.valid([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_l,
		Opcode.DROP.code,
		Opcode.I64_CONST.code, 0,
		Opcode.END.code,
		Opcode.DROP.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_l,
		Opcode.DROP.code,
		Opcode.I32_CONST.code, 0,
		Opcode.END.code,
		Opcode.DROP.code
	], 8);
}

def test_blockv2(t: CodeValidatorTester) {
	// TODO
}

def test_blockinv(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	t.invalid(WasmError.INVALID_BLOCK_TYPE, [
		Opcode.BLOCK.code, 33,
		Opcode.END.code
	], 2);
}

def test_unterm(t: CodeValidatorTester) {
	t.invalid(WasmError.UNTERMINATED_BODY, [
		Opcode.I32_CONST.code, 0,
		Opcode.IF.code, EB
	], 6);
	t.invalid(WasmError.UNTERMINATED_BODY, [
		Opcode.I32_CONST.code, 0,
		Opcode.IF.code, EB,
		Opcode.ELSE.code
	], 7);
	t.sig(SigCache.v_v);
	t.invalid(WasmError.OOB_LABEL, [Opcode.END.code], 2);
}

def test_else0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.invalid(WasmError.MISMATCHED_ELSE, [Opcode.ELSE.code], 1);

	t.invalid(WasmError.MISMATCHED_ELSE, [
		Opcode.I32_CONST.code, 0,
		Opcode.IF.code, EB,
		Opcode.ELSE.code,
		Opcode.ELSE.code,
		Opcode.END.code
	], 6);

}
def isSimpleOp(op: Opcode) -> bool {
	return op.prefix == 0 && Opcodes.attributes[op.code].SHORT_OP;
}

def test_simple_ops_v(t: CodeValidatorTester) {
	var code = Vector<byte>.new();
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		t.sig(op.sig);
		for (i < op.sig.params.length) {
			code.put(Opcode.LOCAL_GET.code);
			code.put(byte.!(i));
		}
		code.put(op.code);
		t.valid(code.extract());
	}
}

def test_simple_ops_r(t: CodeValidatorTester) {
	var code = Vector<byte>.new();
	var types = [ValueType.I32, ValueType.I64, ValueType.F32, ValueType.F64];
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		// Test all possible (expected) return types for all simple opcodes.
		for (rt in types) {
			var sig = ValueType.Function(op.sig.params, [rt]);
			t.sig(sig);
			for (i < op.sig.params.length) {
				code.put(Opcode.LOCAL_GET.code);
				code.put(byte.!(i));
			}
			code.put(op.code);
			if (op.sig.results.length == 1 && op.sig.results[0] == rt) {
				t.valid(code.extract());
			} else {
				var pt = code.length + 1;
				t.TypeError(code.extract(), pt);
			}
		}
	}

}

def test_simple_ops0(t: CodeValidatorTester) {
	var template: Array<byte> = [
		Opcode.LOCAL_GET.code,
		/* local_pt */0,
		/* opcode_pt */0
	];
	var local_pt = 1, opcode_pt = 2;

	t.sig(SigCache.v_i); // for proper local numbering
	var locals = [
		t.addLocal(ValueType.I32),
		t.addLocal(ValueType.I64),
		t.addLocal(ValueType.F32),
		t.addLocal(ValueType.F64)
	];
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		if (op.sig.params.length != 0) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local_pt] = byte.!(l);
			template[opcode_pt] = op.code;
			var pt = template.length + 9;
			t.TypeError(template, pt);
		}
	}
}

def test_simple_ops1(t: CodeValidatorTester) {
	var template: Array<byte> = [
		Opcode.LOCAL_GET.code,
		/* local_pt */0,
		/* opcode_pt */0
	];
	var local_pt = 1, opcode_pt = 2;

	t.sig(SigCache.i_i); // for proper local numbering
	var locals = [
		(ValueType.I32, t.addLocal(ValueType.I32)),
		(ValueType.I64, t.addLocal(ValueType.I64)),
		(ValueType.F32, t.addLocal(ValueType.F32)),
		(ValueType.F64, t.addLocal(ValueType.F64))
	];
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		if (op.sig.params.length != 1) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local_pt] = byte.!(l.1);
			template[opcode_pt] = op.code;
			if (l.0 == op.sig.params[0]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.TypeError(template, pt);
			}
		}
	}
}

def test_simple_ops2(t: CodeValidatorTester) {
	var template: Array<byte> = [
		Opcode.LOCAL_GET.code,
		/* local0_pt */0,
		Opcode.LOCAL_GET.code,
		/* local1_pt */0,
		/* opcode_pt */0
	];
	var local0_pt = 1, local1_pt = 3, opcode_pt = 4;

	t.sig(SigCache.ii_i); // for proper local numbering
	var locals = [
		(ValueType.I32, t.addLocal(ValueType.I32)),
		(ValueType.I64, t.addLocal(ValueType.I64)),
		(ValueType.F32, t.addLocal(ValueType.F32)),
		(ValueType.F64, t.addLocal(ValueType.F64))
	];
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		if (op.sig.params.length != 2) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local0_pt] = 0;
			template[local1_pt] = byte.!(l.1);
			template[opcode_pt] = op.code;
			if (l.0 == op.sig.params[1]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.TypeError(template, pt);
			}

			template[local0_pt] = byte.!(l.1);
			template[local1_pt] = 1;
			template[opcode_pt] = op.code;
			if (l.0 == op.sig.params[0]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.TypeError(template, pt);
			}
		}
	}
}

def test_memindex1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.addMemory(1, 1);
	t.valid([
		Opcode.MEMORY_SIZE.code, 0
	]);
	t.valid([
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0
	]);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.MEMORY_SIZE.code, 1
	], 2);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 1
	], 4);

	// expect a zero byte if no multi-memory
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.MEMORY_SIZE.code, 0x80, 0
	], 2);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0x80, 0
	], 4);

	// allow a full LEB if multi-memory
	t.setExtensions(Extension.MULTI_MEMORY);
	t.valid([
		Opcode.MEMORY_SIZE.code, 0x80, 0
	]);
	t.valid([
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0x80, 0
	]);
}

def test_memindex2(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.MEMORY_SIZE.code, 0
	], 2);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0
	], 4);
	// allow a full LEB if multi-memory
	t.setExtensions(Extension.MULTI_MEMORY);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.MEMORY_SIZE.code, 0x80, 0
	], 2);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0x80, 0
	], 4);
}

def test_tabindex1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.addTable(1, 1, null);
	t.valid([
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0
	]);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 1
	], 5);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0x80, 0
	], 5);
	// allow a full LEB if multi-memory
	t.setExtensions(Extension.REFERENCE_TYPES);
	t.valid([
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0x80, 0
	]);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 1
	], 5);
}

def test_tabindex2(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0
	], 5);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 1
	], 5);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0x80, 0
	], 5);
	// allow a full LEB if multi-memory
	t.setExtensions(Extension.REFERENCE_TYPES);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0x80, 0
	], 5);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 1
	], 5);
}

def test_retcall1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	var code1: Array<byte> = [
		Opcode.RETURN_CALL.code, 0
	];
	t.invalid(WasmError.INVALID_OPCODE, code1, 1);

	t.setExtensions(Extension.TAIL_CALL);
	t.valid(code1);

	var f2 = t.addFunction(SigCache.v_v, [Opcode.END.code]);
	t.invalid(WasmError.TYPE_MISMATCH, [
		Opcode.RETURN_CALL.code, byte.!(f2.0)
	], 1);

	var f3 = t.addFunction(SigCache.v_l, [Opcode.END.code]);
	t.invalid(WasmError.TYPE_MISMATCH, [
		Opcode.RETURN_CALL.code, byte.!(f3.0)
	], 1);
}

def test_retcall2(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.addTable(1, 1, null);
	var code1: Array<byte> = [
		Opcode.I32_CONST.code, 5,
		Opcode.RETURN_CALL_INDIRECT.code, 0, 0
	];
	t.invalid(WasmError.INVALID_OPCODE, code1, 3);

	t.setExtensions(Extension.TAIL_CALL);
	t.valid(code1);

	var s2 = t.addSig(SigCache.v_v);
	t.invalid(WasmError.TYPE_MISMATCH, [
		Opcode.I32_CONST.code, 5,
		Opcode.RETURN_CALL_INDIRECT.code, 1, 0
	], 3);
}

def test_invalid1(t: CodeValidatorTester) {
	t.invalid(WasmError.INVALID_OPCODE, [0xFF], 1);
}

def test_invalid2(t: CodeValidatorTester) {
	var code: Array<byte> = [0];
	for (i < 256) {
		if (Opcodes.attributes[i].VALID) continue;
		if (Opcodes.attributes[i].PREFIX) continue;
		code[0] = byte.!(i);
		t.invalid(WasmError.INVALID_OPCODE, code, 1);
	}
}

def test_prefix_ops1(t: CodeValidatorTester) {
	var template: Array<byte> = [
		Opcode.LOCAL_GET.code,
		/* local_pt */0,
		/* prefix_pt */0,
		/* opcode_pt */0
	];
	var local_pt = 1, prefix_pt = 2, opcode_pt = 3;

	t.sig(SigCache.i_i); // for proper local numbering
	var locals = [
		(ValueType.I32, t.addLocal(ValueType.I32)),
		(ValueType.I64, t.addLocal(ValueType.I64)),
		(ValueType.F32, t.addLocal(ValueType.F32)),
		(ValueType.F64, t.addLocal(ValueType.F64))
	];
	for (op in Opcode) {
		if (op.prefix == 0) continue;
		if (op.sig.params == null) continue;
		if (op.sig.params.length != 1) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local_pt] = byte.!(l.1);
			template[prefix_pt] = op.prefix;
			template[opcode_pt] = op.code;
			if (l.0 == op.sig.params[0]) {
				t.valid(template);
			} else {
				var pt = template.length + 7;
				t.TypeError(template, pt);
			}
		}
	}
}

def test_ref_null(t: CodeValidatorTester) {
	t.invalid(WasmError.INVALID_OPCODE, [Opcode.REF_NULL.code, BpTypecon.ExternRef.code], 1);

	t.setExtensions(Extension.REFERENCE_TYPES);

	t.TypeError([Opcode.REF_NULL.code, BpTypecon.ExternRef.code], 3);

	t.sig(SigCache.v_e);
	t.valid([Opcode.REF_NULL.code, BpTypecon.ExternRef.code]);
	t.TypeError([Opcode.REF_NULL.code, BpTypecon.FuncRef.code], 3);

	t.sig(SigCache.v_g);
	t.valid([Opcode.REF_NULL.code, BpTypecon.FuncRef.code]);
	t.TypeError([Opcode.REF_NULL.code, BpTypecon.ExternRef.code], 3);
	t.invalid(WasmError.INVALID_TYPE, [Opcode.REF_NULL.code, BpTypecon.I32.code], 2);
}

def test_ref_is_null(t: CodeValidatorTester) {
	t.invalid(WasmError.INVALID_OPCODE, [Opcode.REF_IS_NULL.code], 1);

	t.setExtensions(Extension.REFERENCE_TYPES);
	t.TypeError([Opcode.REF_IS_NULL.code], 1);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.REF_IS_NULL.code
	];
	t.sig(SigCache.i_i);
	t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
	t.sig(SigCache.e_v);
	t.TypeError(code1, 4);
	t.sig(SigCache.g_i);
	t.valid(code1);
	t.sig(SigCache.e_i);
	t.valid(code1);
}

def test_ref_func(t: CodeValidatorTester) {
	t.invalid(WasmError.INVALID_OPCODE, [Opcode.REF_FUNC.code, 0], 1);

	t.setExtensions(Extension.REFERENCE_TYPES);

	t.invalid(WasmError.OOB_INDEX, [Opcode.REF_FUNC.code, 11], 2);
	var f2 = t.addFunction(SigCache.v_v, [Opcode.END.code]);
	var code1: Array<byte> = [Opcode.REF_FUNC.code, byte.!(f2.0)];
	t.TypeError(code1, 3);
	t.sig(SigCache.v_e);
	t.TypeError(code1, 3);
	t.sig(SigCache.v_g);
	t.valid(code1);
}

def test_data_drop(t: CodeValidatorTester) {
	t.addData(0, [0]);
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.DATA_DROP.prefix, Opcode.DATA_DROP.code, 0];
	t.invalid(WasmError.INVALID_OPCODE, code1, 1);

	t.setExtensions(Extension.BULK_MEMORY);
	t.invalid(WasmError.MISSING_DATA_COUNT, code1, 1);

	t.module.explicit_data_count = 1;
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [Opcode.DATA_DROP.prefix, Opcode.DATA_DROP.code, 1], 3);
}

def test_memory_init(t: CodeValidatorTester) {
	t.addMemory(1, 1);
	t.addData(0, [0]);
	t.module.explicit_data_count = 1;
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.MEMORY_INIT.prefix, Opcode.MEMORY_INIT.code, 0, 0];
	t.invalid(WasmError.INVALID_OPCODE, code1, 1);

	t.setExtensions(Extension.BULK_MEMORY);
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.MEMORY_INIT.prefix, Opcode.MEMORY_INIT.code, 0, 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.MEMORY_INIT.prefix, Opcode.MEMORY_INIT.code, 1, 0
	];
	t.invalid(WasmError.OOB_INDEX, code3, 9);
}

def test_memory_copy(t: CodeValidatorTester) {
	t.addMemory(1, 1);
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.MEMORY_COPY.prefix, Opcode.MEMORY_COPY.code, 0, 0];
	t.invalid(WasmError.INVALID_OPCODE, code1, 1);

	t.setExtensions(Extension.BULK_MEMORY);
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.MEMORY_COPY.prefix, Opcode.MEMORY_COPY.code, 0, 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.MEMORY_COPY.prefix, Opcode.MEMORY_COPY.code, 1, 0
	];
	t.invalid(WasmError.OOB_INDEX, code3, 9);
}

def test_memory_fill(t: CodeValidatorTester) {
	t.addMemory(1, 1);
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.MEMORY_FILL.prefix, Opcode.MEMORY_FILL.code, 0];
	t.invalid(WasmError.INVALID_OPCODE, code1, 1);

	t.setExtensions(Extension.BULK_MEMORY);
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.MEMORY_FILL.prefix, Opcode.MEMORY_FILL.code, 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.MEMORY_FILL.prefix, Opcode.MEMORY_FILL.code, 1
	];
	t.invalid(WasmError.OOB_INDEX, code3, 9);
}

def test_table_init(t: CodeValidatorTester) {
	t.addTable(1, 1, [1]);
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.TABLE_INIT.prefix, Opcode.TABLE_INIT.code, 0, 0];
	t.invalid(WasmError.INVALID_OPCODE, code1, 1);

	t.setExtensions(Extension.REFERENCE_TYPES);
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.TABLE_INIT.prefix, Opcode.TABLE_INIT.code, 0, 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.TABLE_INIT.prefix, Opcode.TABLE_INIT.code, 1, 0
	];
	t.invalid(WasmError.OOB_INDEX, code3, 9);
}

def test_table_copy(t: CodeValidatorTester) {
	t.addTable(1, 1, [0]);
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.TABLE_COPY.prefix, Opcode.TABLE_COPY.code, 0, 0];
	t.invalid(WasmError.INVALID_OPCODE, code1, 1);

	t.setExtensions(Extension.REFERENCE_TYPES);
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.TABLE_COPY.prefix, Opcode.TABLE_COPY.code, 0, 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.TABLE_COPY.prefix, Opcode.TABLE_COPY.code, 1, 0
	];
	t.invalid(WasmError.OOB_INDEX, code3, 9);
}

def test_elem_drop(t: CodeValidatorTester) {
	t.addTable(1, 0, [0]);
	t.sig(SigCache.v_v);
	t.invalid(WasmError.INVALID_OPCODE, [Opcode.ELEM_DROP.prefix, Opcode.ELEM_DROP.code, 0], 1);

	t.setExtensions(Extension.REFERENCE_TYPES);
	t.valid([Opcode.ELEM_DROP.prefix, Opcode.ELEM_DROP.code, 0]);
	t.invalid(WasmError.OOB_INDEX, [Opcode.ELEM_DROP.prefix, Opcode.ELEM_DROP.code, 1], 3);
}

def test_table_get(t: CodeValidatorTester) {
	t.addTable(1, 0, [0]);
	t.sig(SigCache.v_g);
	t.invalid(WasmError.INVALID_OPCODE, [Opcode.I32_CONST.code, 0, Opcode.TABLE_GET.code, 0], 3);
	t.setExtensions(Extension.REFERENCE_TYPES);
	t.sig(SigCache.v_e);
	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.I32_CONST.code, 0, Opcode.TABLE_GET.code, 0], 5);
	t.invalid(WasmError.OOB_INDEX, [Opcode.I32_CONST.code, 0, Opcode.TABLE_GET.code, 1], 4);
}

def test_table_set(t: CodeValidatorTester) {
	t.addTable(1, 0, [0]);
	t.sig(SigCache.g_v);
	var code1: Array<byte> = [Opcode.I32_CONST.code, 0, Opcode.LOCAL_GET.code, 0, Opcode.TABLE_SET.code, 0];
	t.invalid(WasmError.INVALID_OPCODE, code1, 5);
	t.setExtensions(Extension.REFERENCE_TYPES);
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [Opcode.I32_CONST.code, 0, Opcode.LOCAL_GET.code, 0, Opcode.TABLE_SET.code, 2], 6);
	t.sig(SigCache.e_v);
	t.invalid(WasmError.TYPE_MISMATCH, code1, 5);
}

def test_table_grow(t: CodeValidatorTester) {
	t.addTable(1, 1, [0]);
	t.sig(ValueType.Function([ValueType.EXTERNREF, ValueType.I32], SigCache.arr_i));
	var code1: Array<byte> = [Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_GET.code, 1, Opcode.TABLE_GROW.prefix, Opcode.TABLE_GROW.code, 0];
	t.invalid(WasmError.INVALID_OPCODE, code1, 5);
	t.setExtensions(Extension.REFERENCE_TYPES);
	t.TypeError(code1, 5);
	t.sig(ValueType.Function([ValueType.FUNCREF, ValueType.I32], SigCache.arr_i));
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_GET.code, 1, Opcode.TABLE_GROW.prefix, Opcode.TABLE_GROW.code, 1], 7);
}

def test_table_size(t: CodeValidatorTester) {
	t.addTable(3, 0, [0, 0, 0]);
	t.sig(SigCache.v_i);
	var code1: Array<byte> = [Opcode.TABLE_SIZE.prefix, Opcode.TABLE_SIZE.code, 0];
	t.invalid(WasmError.INVALID_OPCODE, code1, 1);
	t.setExtensions(Extension.REFERENCE_TYPES);
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [Opcode.TABLE_SIZE.prefix, Opcode.TABLE_SIZE.code, 1], 3);
	t.sig(SigCache.v_f);
	t.TypeError(code1, 4);
}

def test_table_fill(t: CodeValidatorTester) {
	t.addTable(1, 1, [0]);
	t.sig(ValueType.Function([ValueType.I32, ValueType.EXTERNREF, ValueType.I32], SigCache.arr_v));
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.TABLE_FILL.prefix, Opcode.TABLE_FILL.code, 0
	];
	t.invalid(WasmError.INVALID_OPCODE, code1, 7);
	t.setExtensions(Extension.REFERENCE_TYPES);
	t.TypeError(code1, 7);
	t.sig(ValueType.Function([ValueType.I32, ValueType.FUNCREF, ValueType.I32], SigCache.arr_v));
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.TABLE_FILL.prefix, Opcode.TABLE_FILL.code, 1
	], 9);
}


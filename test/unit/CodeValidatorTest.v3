// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, CodeValidatorTester.new, _);
def X = [
	T("validator/local0", test_local0),
	T("validator/ret0", test_ret0),
	T("validator/ret1", test_ret1),
	T("validator/br_table0", test_br_table0),
	T("validator/if0", test_if0),
	T("validator/if1", test_if1),
	T("validator/simple_ops_v", test_simple_ops_v),
	T("validator/simple_ops_r", test_simple_ops_r),
	T("validator/simple_ops0", test_simple_ops0),
	T("validator/simple_ops1", test_simple_ops1),
	T("validator/simple_ops2", test_simple_ops2),
	()
];

class CodeValidatorTester(t: Tester) extends ModuleBuilder {
	var validator: CodeValidator; // FAST: reuse validator
	new() {
		validator = CodeValidator.new(module);
	}
	def valid(raw: Array<byte>) {
		code(raw);
		match (validator.validate(func)) {
			Ok => ;
			Error(error, pc, msg) => t.fail2("expected success, got error @+%d: %s", pc, msg);
		}
	}
	def invalid(expected: WasmError, raw: Array<byte>, error_pc: int) {
		code(raw);
		match (validator.validate(func)) {
			Ok => t.fail2("expected error %s @+%d, got success", expected.name, error_pc);
			Error(error, pc, msg) => {
				if (error != expected) {
					t.fail3("expected error %s, got %s @+%d\n",
						expected.name, error.name, pc);
				} else if (pc != error_pc) {
					t.fail3("expected error @+%d, got error @+%d: %s", error_pc, pc, msg);
				}
			}
		}
	}
}

def test_local0(t: CodeValidatorTester) {
	t.invalid(WasmError.OOB_INDEX, [Opcode.LOCAL_GET.code, 0], 1);
	t.sig(SigCache.i_i);
	t.valid([Opcode.LOCAL_GET.code, 0]);
}

def test_ret0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([]);
	t.valid([Opcode.RETURN.code]);

	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.I32_CONST.code, 0], 3);
	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.I64_CONST.code, 0], 3);
	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.F32_CONST.code, 0, 0, 0, 0], 6);
	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.F64_CONST.code, 0, 0, 0, 0, 0, 0, 0, 0], 10);
}

def test_ret1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.invalid(WasmError.TYPE_MISMATCH, [], 1);
	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.RETURN.code], 1);

	t.valid([Opcode.I32_CONST.code, 0]);
	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.I64_CONST.code, 0], 3);
	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.F32_CONST.code, 0, 0, 0, 0], 6);
	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.F64_CONST.code, 0, 0, 0, 0, 0, 0, 0, 0], 10);
}

def test_br_table0(t: CodeValidatorTester) {
	var code1: Array<byte> = [
		Opcode.I32_CONST.code, 7,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2, 0, 0, 0];
	t.sig(SigCache.i_i);
	t.valid(code1);

	t.sig(SigCache.f_i);
	t.invalid(WasmError.TYPE_MISMATCH, code1, 5);

	t.sig(SigCache.i_f);
	t.invalid(WasmError.TYPE_MISMATCH, code1, 5);
	// TODO: more br_table tests
}

def test_if0(t: CodeValidatorTester) {
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.EmptyBlock.code,
		Opcode.ELSE.code,
		Opcode.END.code
	];
	t.sig(SigCache.i_v);
	t.valid(code1);
	
	t.sig(SigCache.l_v);
	t.invalid(WasmError.TYPE_MISMATCH, code1, 3);

	var code2: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.EmptyBlock.code,
		Opcode.BR.code, 0,
		Opcode.ELSE.code,
		Opcode.RETURN.code,
		Opcode.END.code
	];
	t.sig(SigCache.i_v);
	t.valid(code2);
	
	t.sig(SigCache.l_v);
	t.invalid(WasmError.TYPE_MISMATCH, code2, 3);

	var code3: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.EmptyBlock.code,
		Opcode.BR.code, 1,
		Opcode.END.code
	];
	t.sig(SigCache.i_v);
	t.valid(code3);
	
	t.sig(SigCache.l_v);
	t.invalid(WasmError.TYPE_MISMATCH, code3, 3);
}

def test_if1(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	t.invalid(WasmError.TYPE_MISMATCH, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.ELSE.code,
		Opcode.END.code
	], 5);

	t.invalid(WasmError.TYPE_MISMATCH, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.ELSE.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.END.code
	], 5);
	
	t.invalid(WasmError.TYPE_MISMATCH, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.ELSE.code,
		Opcode.END.code
	], 8);

	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.UNREACHABLE.code,
		Opcode.ELSE.code,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	]);
	
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 1,
		Opcode.ELSE.code,
		Opcode.LOCAL_GET.code, 1,
		Opcode.END.code
	];
	t.sig(SigCache.ii_i);
	t.valid(code1);
	
	t.sig(TypeDecl.Function(SigCache.arr_if, SigCache.arr_i));
	t.invalid(WasmError.TYPE_MISMATCH, code1, 7);

	var code2: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.F32.code,
		Opcode.UNREACHABLE.code,
		Opcode.ELSE.code,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	];
	t.sig(SigCache.ii_i);
	t.invalid(WasmError.TYPE_MISMATCH, code2, 9);
}

def test_simple_ops_v(t: CodeValidatorTester) {
	var code = Vector<byte>.new();
	for (op in Opcode) {
		if (!Opcodes.isShortOperator[op.code]) continue;
		t.sig(op.sig);
		for (i < op.sig.params.length) {
			code.add(Opcode.LOCAL_GET.code);
			code.add(byte.!(i));
		}
		code.add(op.code);
		t.valid(code.extract());
	}
}

def test_simple_ops_r(t: CodeValidatorTester) {
	var code = Vector<byte>.new();
	var types = [ValueType.I32, ValueType.I64, ValueType.F32, ValueType.F64];
	for (op in Opcode) {
		if (!Opcodes.isShortOperator[op.code]) continue;
		// Test all possible (expected) return types for all simple opcodes.
		for (rt in types) {
			var sig = TypeDecl.Function(op.sig.params, [rt]);
			t.sig(sig);
			for (i < op.sig.params.length) {
				code.add(Opcode.LOCAL_GET.code);
				code.add(byte.!(i));
			}
			code.add(op.code);
			if (op.sig.results.length == 1 && op.sig.results[0] == rt) {
				t.valid(code.extract());
			} else {
				var pt = code.size() + 1;
				t.invalid(WasmError.TYPE_MISMATCH, code.extract(), pt);
			}
		}
	}

}

def test_simple_ops0(t: CodeValidatorTester) {
	var template: Array<byte> = [
		Opcode.LOCAL_GET.code,
		/* local_pt */0,
		/* opcode_pt */0
	];
	var local_pt = 1, opcode_pt = 2;

	t.sig(SigCache.v_i); // for proper local numbering
	var locals = [
		t.addLocal(ValueType.I32),
		t.addLocal(ValueType.I64),
		t.addLocal(ValueType.F32),
		t.addLocal(ValueType.F64)
	];
	for (op in Opcode) {
		if (!Opcodes.isShortOperator[op.code]) continue;
		if (op.sig.params.length != 0) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local_pt] = byte.!(l);
			template[opcode_pt] = op.code;
			var pt = template.length + 9;
			t.invalid(WasmError.TYPE_MISMATCH, template, pt);
		}
	}
}

def test_simple_ops1(t: CodeValidatorTester) {
	var template: Array<byte> = [
		Opcode.LOCAL_GET.code,
		/* local_pt */0,
		/* opcode_pt */0
	];
	var local_pt = 1, opcode_pt = 2;

	t.sig(SigCache.i_i); // for proper local numbering
	var locals = [
		(ValueType.I32, t.addLocal(ValueType.I32)),
		(ValueType.I64, t.addLocal(ValueType.I64)),
		(ValueType.F32, t.addLocal(ValueType.F32)),
		(ValueType.F64, t.addLocal(ValueType.F64))
	];
	for (op in Opcode) {
		if (!Opcodes.isShortOperator[op.code]) continue;
		if (op.sig.params.length != 1) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local_pt] = byte.!(l.1);
			template[opcode_pt] = op.code;
			if (l.0 == op.sig.params[0]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.invalid(WasmError.TYPE_MISMATCH, template, pt);
			}
		}
	}
}

def test_simple_ops2(t: CodeValidatorTester) {
	var template: Array<byte> = [
		Opcode.LOCAL_GET.code,
		/* local0_pt */0,
		Opcode.LOCAL_GET.code,
		/* local1_pt */0,
		/* opcode_pt */0
	];
	var local0_pt = 1, local1_pt = 3, opcode_pt = 4;

	t.sig(SigCache.ii_i); // for proper local numbering
	var locals = [
		(ValueType.I32, t.addLocal(ValueType.I32)),
		(ValueType.I64, t.addLocal(ValueType.I64)),
		(ValueType.F32, t.addLocal(ValueType.F32)),
		(ValueType.F64, t.addLocal(ValueType.F64))
	];
	for (op in Opcode) {
		if (!Opcodes.isShortOperator[op.code]) continue;
		if (op.sig.params.length != 2) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local0_pt] = 0;
			template[local1_pt] = byte.!(l.1);
			template[opcode_pt] = op.code;
			if (l.0 == op.sig.params[1]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.invalid(WasmError.TYPE_MISMATCH, template, pt);
			}

			template[local0_pt] = byte.!(l.1);
			template[local1_pt] = 1;
			template[opcode_pt] = op.code;
			if (l.0 == op.sig.params[0]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.invalid(WasmError.TYPE_MISMATCH, template, pt);
			}
		}
	}
}

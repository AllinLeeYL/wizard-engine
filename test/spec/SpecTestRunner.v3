// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Parses and runs binary WebAssembly spec tests (.bin.wast). Hooks into
// Wizard's main method by installing a function into {wizeng.runSpecTests}.
component SpecTestRunner {
	def trace = StringBuilder.new();
	new() {
		// install the run method in the main entrypoint
		wizeng.runSpecTests = runSpecTests;
	}
	def runSpecTests(args: Array<string>) -> int {
		var count = 0;
		for (a in args) {
			if (a == null) continue;
			if (Strings.endsWith(a, ".wast")) count++;
		}
		if (count == 0 && !wizeng.printVersion) {
			System.puts("wizeng-spec: no input files\n");
			return 3;
		}
		if (count > 1) {
			trace.puts("##>");
			trace.putd(count);
		}
		for (a in args) {
			if (a == null) continue;
			if (Strings.endsWith(a, ".wast")) {
				runTest(a);
			}
		}

		return 0;
	}
	def runTest(filename: string) {
		trace.puts("##+");
		trace.puts(filename);
		trace.puts("\n");
		flush();
		var input = System.fileLoad(filename);
		if (input == null) {
			trace.puts("##-fail: could not load file\n");
			return flush();
		}
		var p = SpecTestParser.new(filename, input);
		p.parseFile();
		if (p.ok) {
			var ip = StInterpreter.new(filename, trace);
			if (ip.run(p.commands)) trace.puts("##-ok\n");
			flush();
		} else {
			trace.put1("##-fail: %s ", filename);
			trace.put3("%d:%d %s\n", p.error_loc.0, p.error_loc.1, p.error_msg);
			return flush();
		}
	}
	def flush() {
		trace.out(Trace.STDOUT);
		trace.reset();
	}
	def renderBinaryModule(data: Array<byte>, pos: int, length: int) {
		trace.puts("(module binary");
		for (i < length) {
			if (i % 16 == 0) {
				if (i > 0) trace.puts("\"");
				trace.puts("\n  \"");
			}
			trace.put1("\\%x", data[pos + i]);
		}
		trace.puts("\")\n");
		flush();
	}
}
def newGlobal(t: ValueType, i: InitExpr, v: Value) -> Global {
	var g = Global.new(GlobalDecl.new(0, t, false, i));
	g.value = v;
	return g;
}
type StModuleResult {
	case Ok(sti: StInstance);
	case Quote(source: string);
	case ParseError(r: BinParserResult);
	case LinkError(msg: string);
	case StartTrap(reason: TrapReason);
}

// Interpreter for spec test commands {StCommand}.
class StInterpreter(filename: string, trace: StringBuilder) {
	def env = StEnv<StInstance>.new();
	def vars = StEnv<StInstance>.new();
	var last_module: StModuleResult;
	var ok = true;
	var loc: (int, int);
	new() {
		// Register the exported module for specification tests
		var sti = StInstance.new(null);
		var sig_f_v = ValueType.Function(SigCache.arr_f, SigCache.arr_v);
		var sig_d_v = ValueType.Function(SigCache.arr_d, SigCache.arr_v);
		var sig_dd_v = ValueType.Function(SigCache.arr_dd, SigCache.arr_v);
		sti.register("print", HostFunction.new(SigCache.v_v, print));
		sti.register("print_i32", HostFunction.new(SigCache.i_v, print));
		sti.register("print_f32", HostFunction.new(sig_f_v, print));
		sti.register("print_f64", HostFunction.new(sig_d_v, print));
		sti.register("print_i32_f32", HostFunction.new(SigCache.if_v, print));
		sti.register("print_f64_f64", HostFunction.new(sig_dd_v, print));
		sti.register("table", FunctionTable.new(TableDecl.new(0, ValueType.FUNCREF, 10, 20)));
		sti.register("memory", Memory.new(MemoryDecl.new(0, 1, 2, false)));
		sti.register("global_i32", newGlobal(ValueType.I32, InitExpr.I32(666), Value.I32(666)));
		sti.register("global_i64", newGlobal(ValueType.I64, InitExpr.I64(666), Value.I64(666)));
		sti.register("global_f32", newGlobal(ValueType.F32, InitExpr.F32(0x44268000), Value.F32(0x44268000)));
		sti.register("global_f64", newGlobal(ValueType.F64, InitExpr.F64(0x4084d00000000000), Value.F64(0x4084d00000000000)));
		env.register("spectest", sti);
	}
	def print(executor: Executor, args: Array<Value>) -> Result {
		trace.puts("called host spectest.print?(");
		for (i < args.length) {
			if (i > 0) trace.puts(", ");
			Values.render(trace, args[i]);
		}
		trace.puts(")\n");
		flush();
		return Result.Value([]);
	}
	def run(commands: Vector<SpecTestCommand>) -> bool {
		for (i < commands.length) {
			if (!ok) break;
			var cmd = commands[i];
			loc = cmd.loc;
			if (Trace.spectest) {
				trace.puts("SpecExecute: ");
				trace.puts(cmd.cmd.name);
				trace.put2(" @ %d:%d", cmd.loc.0, cmd.loc.1);
				trace.ln();
				flush();
			}
			match (cmd.cmd) {
				Module(module) => {
					last_module = doModule(module);
				}
				Register(varname, regname) => {
					var sti = getInstance(varname);
					if (!ok) return false;
					env.register(regname, sti);
				}
				Action(action) => {
					doAction(action);
				}
				AssertReturn(action, expected) => {
					var r = doAction(action);
					var err = false;
					match (r) {
						Value(vals) => err = !matchMultiValue(expected, vals);
						_ => err = true;
					}
					if (err) {
						error(Strings.format2("assert_return expected %q, got %q", renderMultiValue(expected, _), r.render));
					}
				}
				AssertTrap(action, msg) => {
					var r = doAction(action);
					if (!Result.Trap.?(r)) {
						error(Strings.format1("assert_trap expected trap, got %q", r.render));
					}
				}
				AssertExhaustion(action, msg) => {
					var r = doAction(action);
					if (!Result.Trap.?(r)) {
						error(Strings.format1("assert_exhaustion expected trap, got %q", r.render));
					}
				}
				AssertInvalid(module, msg) => {
					var r: BinParserResult;
					var exp = StModuleResult.ParseError(r);
					var got = doModule(module);
					assertModuleResult(exp, got);

				}
				AssertMalformed(module, msg) => {
					var r: BinParserResult;
					var exp = StModuleResult.ParseError(r);
					var got = doModule(module);
					assertModuleResult(exp, got);
				}
				AssertUnlinkable(module, msg) => {
					var exp = StModuleResult.LinkError("");
					var got = doModule(module);
					assertModuleResult(exp, got);
				}
				AssertUninstantiable(module, msg) => {
					var r: TrapReason;
					var exp = StModuleResult.StartTrap(r);
					var got = doModule(module);
					assertModuleResult(exp, got);
				}
			}
		}
		return ok;
	}
	def matchMultiValue(expected: Array<ExpectedValue>, got: Array<Value>) -> bool {
		for (i < expected.length) {
			if (!expected[i].matches(got[i])) return false;
		}
		return true;
	}
	def renderMultiValue(expected: Array<ExpectedValue>, buf: StringBuilder) -> StringBuilder {
		if (expected.length == 1) return expected[0].render(buf);
		buf.puts("[");
		for (i < expected.length) {
			if (i > 0) buf.puts(", ");
			expected[i].render(buf);
		}
		buf.puts("]");
		return buf;
	}
	def assertModuleResult(expected: StModuleResult, got: StModuleResult) {
		if (expected.tag != got.tag) {
			error(Strings.format2("expected %s, got %s", expected.name, got.name));
		}
	}
	def doModule(module: StModule) -> StModuleResult {
		match (module) {
			Binary(varname, bytes) => {
				var r = parseBinary(bytes);
				if (varname != null && StModuleResult.Ok.?(r)) {
					vars.register(varname, StModuleResult.Ok.!(r).sti);
				}
				return r;
			}
			Quote(varname, source) => {
				return StModuleResult.Quote(source);
			}
		}
	}
	def doAction(action: StAction) -> Result {
		match (action) {
			Invoke(varname, funcname, args) => {
				return doInvoke(varname, funcname, args);
			}
			GlobalGet(varname, globalname) => {
				return doGlobalGet(varname, globalname);
			}
		}
	}
	def doInvoke(varname: string, funcname: string, args: Array<Value>) -> Result {
		if (Trace.spectest) {
			trace.put1(" invoke \"%s\"(", funcname);
			for (i < args.length) {
				if (i > 0) trace.puts(", ");
				Values.render(trace, args[i]);
			}
			trace.puts(")");
			trace.ln();
			flush();
		}
		// pop instance
		var sti = getInstance(varname);
		if (!ok) return Result.Break;
		// lookup function
		var exp = sti.lookup(funcname);
		if (exp == null) {
			error(Strings.format1("func \"%s\" not found", funcname));
			return Result.Break;
		}
		if (!WasmFunction.?(exp)) {
			error(Strings.format1("export \"%s\" is not a function", funcname));
			return Result.Break;
		}
		var func = WasmFunction.!(exp);
		// create interpreter
		var interp = Interpreter.new();
		// run interpreter
		return interp.run(10000000, func, args);
	}
	def doGlobalGet(varname: string, globalname: string) -> Result {
		// pop instance
		var sti = getInstance(varname);
		if (!ok) return Result.Break;
		// lookup global
		var exp = sti.lookup(globalname);
		if (exp == null) {
			error(Strings.format1("global \"%s\" not found", globalname));
			return Result.Break;
		}
		if (!Global.?(exp)) {
			error(Strings.format1("export \"%s\" is not a global", globalname));
			return Result.Break;
		}
		var global = Global.!(exp);
		return Result.Value([global.value]);
	}
	def getInstance(varname: string) -> StInstance {
		if (varname == null) {
			match (last_module) {
				Ok(sti) => return sti;
				Quote(source) => {
					error("expected binary module, got quoted module");
				}
				ParseError(r) => {
					var error_msg = BinParserResult.Error.!(r).error_msg;
					error(Strings.format1("expected valid module, got invalid: %s", error_msg));
				}
				LinkError(msg) => {
					error(Strings.format1("expected valid module, got link error: %s", msg));
				}
				StartTrap(reason) => error(Strings.format1("expected valid module, got start trap: %s", reason.name));
			}
			return null;
		}
		var i = vars.lookup(varname);
		if (i == null) error(Strings.format1("module %s not found", varname));
		return i;
	}
	def error(msg: string) -> bool {
		if (!ok) return false;
		ok = false;
		trace.puts("##-fail: ");
		trace.put3("%s @ %d:%d ", filename, loc.0, loc.1);
		trace.puts(msg);
		trace.ln();
		flush();
		return false;
	}
	def parseBinary(bytes: Array<byte>) -> StModuleResult {
		var extensions = wizeng.extensions;
		var limits = Limits.new().set(extensions);
		var mp = BinParser.new(extensions, limits, "test");
		mp.push(bytes, 0, bytes.length);
		var r = mp.finish();
		match (r) {
			Ok(module) => return doInstantiate(module);
			Error => return StModuleResult.ParseError(r);
		}
	}
	def doInstantiate(module: Module) -> StModuleResult {
		var imports = Array<Exportable>.new(module.imports.length);
		for (i < module.imports.length) {
			var imp = module.imports[i];
			var sti = env.lookup(imp.modname);
			if (sti == null) return StModuleResult.LinkError(Strings.format1("import module \"%s\" not found", imp.modname));
			var exp = sti.lookup(imp.name);
			if (exp == null) return StModuleResult.LinkError(Strings.format2("import \"%s\".\"%s\" not found", imp.modname, imp.name));
			imports[i] = exp;
		}
		var i = Instantiator.new(wizeng.extensions, module, imports);
		var r = i.run();
		if (i.trap_reason != TrapReason.NONE) return StModuleResult.StartTrap(i.trap_reason);
		if (!i.err.ok()) return StModuleResult.LinkError(i.err.error_msg);
		if (module.start_function >= 0) {
			var func = r.getFunction(module.start_function);
			var interp = Interpreter.new();
			var result = interp.run(-1, func, []);
			match (result) {
				Break => {
					error("interpreter hit breakpoint");
					return StModuleResult.StartTrap(TrapReason.NONE);
				}
				Value => ; // ignore result(s); should be none
				Trap(reason) => return StModuleResult.StartTrap(reason);
			}
		}
		return StModuleResult.Ok(StInstance.new(r));
	}
	def flush() {
		trace.out(Trace.STDOUT);
		trace.reset();
	}
}

class StEnv<T> {
	def modules = Vector<(string, T)>.new();
	def register(name: string, t: T) {
		modules.put(name, t);
	}
	def lookup(name: string) -> T {
		for (i < modules.length) {
			var m = modules[i];
			if (Strings.equals(m.0, name)) return m.1;
		}
		var d: T;
		return d;
	}
}
class StInstance(instance: Instance) extends StEnv<Exportable> {
	new() {
		if (instance != null) {
			for (i < instance.exports.length) {
				var name = instance.module.exports[i].name;
				var e = instance.exports[i];
				register(name, e);
			}
		}
	}
}


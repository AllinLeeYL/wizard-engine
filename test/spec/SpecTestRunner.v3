
class StEnv<T> {
	def modules = Vector<(string, T)>.new();
	def register(name: string, t: T) {
		modules.add(name, t);
	}
	def lookup(name: string) -> T {
		for (i < modules.length) {
			var m = modules[i];
			if (Strings.equals(m.0, name)) return m.1;
		}
		var d: T;
		return d;
	}
}
class StInstance(instance: Instance) extends StEnv<Exportable> {
	new() {
		if (instance != null) {
			for (i < instance.exports.length) {
				var name = instance.module.exports[i].name;
				var e = instance.exports[i];
				register(name, e);
			}
		}
	}
}

component SpecTestRunner {
	def trace = StringBuffer.new();
	new() {
		// install the run method in the main entrypoint
		wizeng.runSpecTests = runSpecTests;
	}
	def runSpecTests(args: Array<string>) -> int {
		var ran = 0;
		for (a in args) {
			if (a == null) continue;
			if (Strings.endsWith(a, ".wast")) {
				ran++;
				runTest(a);
			}
		}
		if (ran == 0 && !wizeng.printVersion) {
			System.puts("wizeng-spec: no input files\n");
			return 3;
		}

		return 0;
	}
	def runTest(filename: string) {
		trace.puts("+");
		trace.puts(filename);
		trace.puts("\n");
		flush();
		var input = System.fileLoad(filename);
		if (input == null) {
			trace.puts("-fail: could not load file\n");
			return flush();
		}
		var p = SpecTestParser.new(filename, input);
		p.parseFile();
		if (p.ok) {
			var ip = StInterpreter.new(filename, trace);
			if (ip.run(p.commands)) trace.puts("-ok\n");
			flush();
		} else {
			trace.put1("-fail: %s ", filename);
			trace.put3("%d:%d %s\n", p.error_loc.0, p.error_loc.1, p.error_msg);
			return flush();
		}
	}
	def verbose(str: string) {
		if (wizeng.verbose) System.puts(str);
	}
	def flush() {
		trace.out(STDOUT);
		trace.reset();
	}
	def renderBinaryModule(data: Array<byte>, pos: int, length: int) {
		trace.puts("(module binary");
		for (i < length) {
			if (i % 16 == 0) {
				if (i > 0) trace.puts("\"");
				trace.puts("\n  \"");
			}
			trace.put1("\\%x", data[pos + i]);
		}
		trace.puts("\")\n");
		flush();
	}
	def renderQuoteModule(data: Array<byte>, pos: int, length: int) {
		trace.puts("(module quote");
		for (i < length) {
			if (i % 64 == 0) {
				if (i > 0) trace.puts("\"");
				trace.puts("\n  \"");
			}
			var c = data[pos + i];
			if (c == '\n') trace.puts("\\n");
			else if (c == '\t') trace.puts("\\t");
			else if (c == '\'') trace.puts("\\\'");
			else if (c == '\"') trace.puts("\\\"");
			if (c < ' ' || c > 127) {
				var h = (c >> 4) & 0xF, l = c & 0xF;
				trace.put2("\\%c%c", Strings.hexMap_l[h],
						Strings.hexMap_l[l]);
			} else {
				trace.putc(c);
			}
		}
		trace.puts("\")\n");
		flush();
	}
}
def newGlobal(t: ValueType, i: InitExpr, v: Value) -> Global {
	var g = Global.new(GlobalDecl.new(0, t, false, i));
	g.value = v;
	return g;
}
type StModuleResult {
	case Ok(sti: StInstance);
	case ParseError(r: BinParserResult);
	case LinkError(msg: string);
	case StartTrap(reason: TrapReason);
}
class StInterpreter(filename: string, trace: StringBuffer) {
	def env = StEnv<StInstance>.new();
	def vars = StEnv<StInstance>.new();
	var last_module: StModuleResult;
	var ok = true;
	var loc: (int, int);
	new() {
		// Register the exported module for specification tests
		var sti = StInstance.new(null);
		var sig_f_v = TypeDecl.Function(SigCache.arr_f, SigCache.arr_v);
		var sig_d_v = TypeDecl.Function(SigCache.arr_d, SigCache.arr_v);
		var sig_dd_v = TypeDecl.Function(SigCache.arr_dd, SigCache.arr_v);
		sti.register("print", HostFunction.new(SigCache.v_v, print));
		sti.register("print_i32", HostFunction.new(SigCache.i_v, print));
		sti.register("print_f32", HostFunction.new(sig_f_v, print));
		sti.register("print_f64", HostFunction.new(sig_d_v, print));
		sti.register("print_i32_f32", HostFunction.new(SigCache.if_v, print));
		sti.register("print_f64_f64", HostFunction.new(sig_dd_v, print));
		sti.register("table", FunctionTable.new(TableDecl.new(0, ElemType.FuncRef, 10, 20)));
		sti.register("memory", Memory.new(MemoryDecl.new(0, 1, 2, false)));
		sti.register("global_i32", newGlobal(ValueType.I32, InitExpr.I32(666), Value.I32(666)));
		sti.register("global_i64", newGlobal(ValueType.I64, InitExpr.I64(666), Value.I64(666)));
		sti.register("global_f32", newGlobal(ValueType.F32, InitExpr.F32(0x44268000), Value.F32(0x44268000)));
		sti.register("global_f64", newGlobal(ValueType.F64, InitExpr.F64(0x4084d00000000000), Value.F64(0x4084d00000000000)));
		env.register("spectest", sti);
	}
	def print(executor: Executor, args: Array<Value>) -> Array<Value> {
		trace.puts("called host spectest.print?(");
		for (i < args.length) {
			if (i > 0) trace.puts(", ");
			Values.render(trace, args[i]);
		}
		trace.puts(")\n");
		flush();
		return [];
	}
	def run(commands: Vector<SpecTestCommand>) -> bool {
		for (i < commands.length) {
			if (!ok) break;
			var cmd = commands[i];
			loc = cmd.loc;
			if (wizeng.verbose) {
				trace.puts("SpecExecute: ");
				trace.puts(cmd.cmd.name);
				trace.put2(" @ %d:%d", cmd.loc.0, cmd.loc.1);
				trace.ln();
				flush();
			}
			match (cmd.cmd) {
				BinaryModule(varname, bytes) => {
					last_module = doModule(StCommand.BinaryModule.!(cmd.cmd));
				}
				QuoteModule(varname, str) => {
					error("only binary modules allowed here"); // TODO
				}
				Register(varname, regname) => {
					var sti = getInstance(varname);
					if (!ok) return false;
					env.register(regname, sti);
				}
				Action(action) => {
					doAction(action);
				}
				AssertReturn(action, expected) => {
					var r = doAction(action);
				}
				AssertTrap(action, msg) => {
					var r = doAction(action);
				}
				AssertExhaustion(action, msg) => {
					var r = doAction(action);
				}
				AssertInvalid(module, msg) => {
					var r = doModule(module);
				}
				AssertMalformed(module, msg) => {
					// do nothing.
				}
				AssertUnlinkable(module, msg) => {
					var r = doModule(module);
				}
				AssertUninstantiable(module, msg) => {
					var r = doModule(module);
				}
			}
		}
		return true;
	}
	def doModule(module: StCommand.BinaryModule) -> StModuleResult {
		var r = parseBinary(module.bytes);
		if (module.varname != null && StModuleResult.Ok.?(r)) {
			vars.register(module.varname, StModuleResult.Ok.!(r).sti);
		}
		return r;
	}
	def doAction(action: StAction) -> Result {
		match (action) {
			Invoke(varname, funcname, args) => {
				return doInvoke(varname, funcname, args);
			}
			GlobalGet(varname, globalname) => {
				return doGlobalGet(varname, globalname);
			}
		}
	}
	def doInvoke(varname: string, funcname: string, args: Array<Value>) -> Result {
		// pop instance
		var sti = getInstance(varname);
		if (!ok) return Result.Break;
		// lookup function
		var exp = sti.lookup(funcname);
		if (exp == null) {
			error(Strings.format1("func \"%s\" not found", funcname));
			return Result.Break;
		}
		if (!WasmFunction.?(exp)) {
			error(Strings.format1("export \"%s\" is not a function", funcname));
			return Result.Break;
		}
		var func = WasmFunction.!(exp);
		// create interpreter
		var interp = Interpreter.new();
		// run interpreter
		return interp.run(-1, func, args);
	}
	def doGlobalGet(varname: string, globalname: string) -> Result {
		// pop instance
		var sti = getInstance(varname);
		if (!ok) return Result.Break;
		// lookup global
		var exp = sti.lookup(globalname);
		if (exp == null) {
			error(Strings.format1("global \"%s\" not found", globalname));
			return Result.Break;
		}
		if (!Global.?(exp)) {
			error(Strings.format1("export \"%s\" is not a global", globalname));
			return Result.Break;
		}
		var global = Global.!(exp);
		return Result.Value([global.value]);
	}
	def getInstance(varname: string) -> StInstance {
		if (varname == null) {
			match (last_module) {
				Ok(sti) => return sti;
				ParseError(r) => {
					var error_msg = BinParserResult.Error.!(r).error_msg;
					error(Strings.format1("expected valid module, got invalid: %s", error_msg));
				}
				LinkError(msg) => {
					error(Strings.format1("expected valid module, got link error: %s", msg));
				}
				StartTrap(reason) => error(Strings.format1("expected valid module, got start trap: %s", reason.name));
			}
			return null;
		}
		var i = vars.lookup(varname);
		if (i == null) error(Strings.format1("module %s not found", varname));
		return i;
	}
	def error(msg: string) -> bool {
		if (!ok) return false;
		ok = false;
		trace.puts("-fail: ");
		trace.put3("%s @ %d:%d ", filename, loc.0, loc.1);
		trace.puts(msg);
		trace.ln();
		flush();
		return false;
	}
	def parseBinary(bytes: Array<byte>) -> StModuleResult {
		var v = if (wizeng.verbose, Verbosity.VERBOSE, Verbosity.SILENT);
		var extensions: Extension.set;
		var limits = Limits.new();
		var mp = BinParser.new(v, extensions, limits, "test");
		mp.push(bytes, 0, bytes.length);
		var r = mp.finish();
		match (r) {
			Ok(module) => return doInstantiate(module);
			Error => return StModuleResult.ParseError(r);
		}
	}
	def doInstantiate(module: Module) -> StModuleResult {
		var imports = Array<Exportable>.new(module.imports.length);
		for (i < module.imports.length) {
			var imp = module.imports[i];
			var sti = env.lookup(imp.modname);
			if (sti == null) return StModuleResult.LinkError(Strings.format1("import module \"%s\" not found", imp.modname));
			var exp = sti.lookup(imp.name);
			if (exp == null) return StModuleResult.LinkError(Strings.format2("import \"%s\".\"%s\" not found", imp.modname, imp.name));
			imports[i] = exp;
		}
		var i = Instantiator.new(module, imports);
		var r = i.run();
		if (!i.err.ok()) return StModuleResult.LinkError(i.err.error_msg);
		if (module.start_function >= 0) {
			var func = r.getFunction(module.start_function);
			var interp = Interpreter.new();
			var result = interp.run(-1, func, []);
			match (result) {
				Break => {
					error("interpreter hit breakpoint");
					return StModuleResult.StartTrap(TrapReason.NONE);
				}
				Value => ; // ignore result(s); should be none
				Trap(reason) => return StModuleResult.StartTrap(reason);
			}
		}
		return StModuleResult.Ok(StInstance.new(r));
	}
	def flush() {
		trace.out(STDOUT);
		trace.reset();
	}
}
def STDOUT = System.fileWriteK(1, _, _, _);

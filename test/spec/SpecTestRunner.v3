// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Parses textual spec tests. Only supports binary module commands and a few test
// commands. Does not parse the full .wat or .wast formats.
class SpecTestParser(filename: string, data: Array<byte>) {
	private var pos: int;
	private var line: int = 1;
	private var col: int = 1;
	private def strbuf = StringBuffer.new();
	def var commands = Vector<SpecTestCommand>.new();
	def var ok = true;
	def var error_pos = (int.max, int.max);
	def var error_msg: string;

	def parseFile() {
		skip();
		while (ok && more(1)) {
			if (!expect_ch('(')) return;
			parseCommand();
			if (!expect_ch(')')) return;
		}
	}

	def parseMaybeCommands() {
		while (ok && more(1)) {
			if (!ch('(')) return;
			parseCommand();
			if (!expect_ch(')')) return;
		}
	}
	def parseCommand() {
		var pt = (line, col);
		if (kw("module")) parseModule();
		else if (kw("assert_return")) parseAssertReturn();
		else if (kw("assert_trap")) parseAssertTrap();
		else if (kw("assert_exhaustion")) parseAssertExhaustion();
		else if (kw("assert_invalid")) parseAssertInvalid();
		else if (kw("assert_malformed")) parseAssertMalformed();
		else if (kw("assert_unlinkable")) parseAssertUnlinkable();
		else if (kw("invoke")) parseInvoke();
		else if (kw("i32.const")) parseI32Const();
		else if (kw("i64.const")) parseI64Const();
		else if (kw("f32.const")) parseF32Const();
		else if (kw("f64.const")) parseF64Const();
		else error1(pt, "expected valid command", ());
	}
	def parseModule() {
		var pt = (line, col);
		if (kw("binary")) {
			strbuf.reset();
			while (ok && more(1)) {
				if (data[pos] != '\"') break;
				doString();
			}
			if (wizeng.verbose) {
				strbuf.out(SpecTestRunner.renderBinaryModule);
			}
			commands.add(SpecTestCommand.BinaryModule(strbuf.extract()));
		} else if (kw("quote")) {
			strbuf.reset();
			while (ok && more(1)) {
				if (data[pos] != '\"') break;
				doString();
			}
			if (wizeng.verbose) {
				strbuf.out(SpecTestRunner.renderQuotedModule);
			}
			commands.add(SpecTestCommand.QuotedModule(strbuf.extract()));
		} else {
			return error1(pt, "expected binary or quoted module", ());
		}
	}
	def parseAssertReturn() {
		parseMaybeCommands();
		if (!expect_ch(')')) return;
		commands.add(SpecTestCommand.AssertReturn);
	}
	def parseAssertTrap() {
		parseStringCommand(SpecTestCommand.AssertTrap);
	}
	def parseAssertExhaustion() {
		parseStringCommand(SpecTestCommand.AssertExhaustion);
	}
	def parseAssertInvalid() {
		parseStringCommand(SpecTestCommand.AssertInvalid);
	}
	def parseAssertMalformed() {
		parseStringCommand(SpecTestCommand.AssertMalformed);
	}
	def parseAssertUnlinkable() {
		parseStringCommand(SpecTestCommand.AssertUnlinkable);
	}
	def parseInvoke() {
		var funcname = parseString();
		parseMaybeCommands();
		if (!expect_ch(')')) return;
		commands.add(SpecTestCommand.Invoke(funcname));
	}
	def parseI32Const();
	def parseI64Const();
	def parseF32Const();
	def parseF64Const();
	def parseStringCommand(f: string -> SpecTestCommand) {
		parseMaybeCommands();
		if (!ok) return;
		var str = parseString();
		if (!expect_ch(')')) return;
		commands.add(f(str));
	}

	// Parses string characters into {this.strbuf}
	def parseString() -> string {
		strbuf.reset();
		doString();
		return strbuf.extract();
	}
	def doString() {
		var pt = (line, col);
		if (!more(1)) return error1(pt, "expected string, got EOF", ());
		var c = data[pos];
		if (c != '\"') return error1(pt, "expected string starting quote", ());
		pos++;
		col++;
		while (ok && more(1)) {
			var c = data[pos];
			if (c == '\"') return advance(1); // end of string

			if (c < ' ' || c > 127) {
				return error1((line, col), "invalid character 0x%x in string", c);
			}
			if (c == '\\') {
				if (!more(3)) break;
				var h = peek_hex(1), l = peek_hex(2);
				strbuf.putc(byte.!(h << 4 | l));
				pos += 3;
				col += 3;
			} else {
				strbuf.putc(c);
				pos++;
				col++;
			}

		}
		error1((line, col), "unexpected end of string", ());
	}

	def expect_ch(c: byte) -> bool {
		var pt = (line, col);
		if (!ch(c)) error1(pt, "expected \'%c\'", c);
		return true;
	}
	def peek_hex(offset: int) -> int {
		var h = data[pos + offset];
		if (!Strings.isHexChar(h)) {
			error1((line, col + offset), "expected hexadecimal", ());
			return 0;
		}
		return Strings.hexValue(h);
	}
	// Eat the character {c} if it is next in the input, returning {true} if so.
	def ch(c: byte) -> bool {
		if (!more(1)) return false;
		if (data[pos] != c) return false;
		advance(1);
		return true;
	}

	// Eat the keyword {k} if it is next in the input, returning {true} if so.
	def kw(k: Array<byte>) -> bool {
		var l = k.length;
		if (!more(l)) return false;
		for (i < l) {
			if (data[pos + i] != k[i]) return false;
		}
		if (more(1)) {
			var c = data[pos + l];
			if (isKeywordMiddle(c)) return false;
		}
		advance(l);
		return true;
	}

	// Advance by {k} non-whitespace characters.
	def advance(k: int) {
		pos += k;
		col += k;
		skip();
	}
	// Skip whitespace from the current position.
	def skip() {
		while (pos < data.length) {
			var c = data[pos];
			match (c) {
				' ' => {
					col++;
					pos++;
				}
				'\t' => {
					col = (col + 8) & ~7;
					pos++;
				}
				'\n' => {
					col = 1;
					line++;
					pos++;
				}
				';' => {
					var p = pos, d = data;
					while (p++ < d.length && d[p] != '\n') ;
					pos = p;
				}
				_ => return;
			}
		}
	}
	def more(num: int) -> bool {
		return data.length - pos >= num;
	}
	def error1<T>(pos: (int, int), fmt: string, arg: T) {
		ok = false;
		if (pos.0 < error_pos.0 ||
			(pos.0 == error_pos.0 && pos.1 < error_pos.1)) {
			error_pos = pos;
			error_msg = Strings.format1(fmt, arg);
		}
	}
}
def isKeywordMiddle(c: byte) -> bool {
	return 'a' <= c && c <= 'z' ||
		'A' <= c && c <= 'Z' ||
		'0' <= c && c <= '9' ||
		c == '_' ||
		c == '-';
}

type SpecTestCommand {
	case BinaryModule(bytes: Array<byte>);
	case QuotedModule(str: string);
	case Register(varname: string);
	case Invoke(funcname: string);
	case AssertReturn;
	case AssertTrap(msg: string);
	case AssertExhaustion(msg: string);
	case AssertInvalid(msg: string);
	case AssertMalformed(msg: string);
	case AssertUnlinkable(msg: string);
	case Constant(val: Value);
}

type SpecTestValue {
	case Module(r: BinParserResult);
	case WasmValue(val: Value);
	case WasmTrap(reason: TrapReason);
}

component SpecTestRunner {
	def trace = StringBuffer.new();
	new() {
		// install the run method in the main entrypoint
		wizeng.runSpecTests = runSpecTests;
	}
	def runSpecTests(args: Array<string>) -> int {
		var ran = 0;
		for (a in args) {
			if (a == null) continue;
			if (Strings.endsWith(a, ".wast")) {
				ran++;
				runTest(a);
			}
		}
		if (ran == 0 && !wizeng.printVersion) {
			System.puts("wizeng-spec: no input files\n");
			return 3;
		}

		return 0;
	}
	def runTest(filename: string) {
		trace.puts("+");
		trace.puts(filename);
		trace.puts("\n");
		flush();
		var data = System.fileLoad(filename);
		if (data == null) {
			trace.puts("-fail: could not load file\n");
			return flush();
		}
		var p = SpecTestParser.new(filename, data);
		p.parseFile();
		if (!p.ok) {
			trace.put1("-fail: %s ", filename);
			trace.put3("%d:%d %s\n", p.error_pos.0, p.error_pos.1, p.error_msg);
			return flush();
		}
		trace.puts("-ok\n");
		flush();
	}
	def verbose(str: string) {
		if (wizeng.verbose) System.puts(str);
	}
	def flush() {
		trace.out(STDOUT);
		trace.reset();
	}
	def renderBinaryModule(data: Array<byte>, pos: int, length: int) {
		trace.puts("(module binary");
		for (i < length) {
			if (i % 16 == 0) {
				if (i > 0) trace.puts("\"");
				trace.puts("\n  \"");
			}
			trace.put1("\\%x", data[pos + i]);
		}
		trace.puts("\")\n");
		flush();
	}
	def renderQuotedModule(data: Array<byte>, pos: int, length: int) {
		trace.puts("(module quote");
		for (i < length) {
			if (i % 64 == 0) {
				if (i > 0) trace.puts("\"");
				trace.puts("\n  \"");
			}
			var c = data[pos + i];
			if (c == '\n') trace.puts("\\n");
			else if (c == '\t') trace.puts("\\t");
			else if (c == '\'') trace.puts("\\\'");
			else if (c == '\"') trace.puts("\\\"");
			if (c < ' ' || c > 127) {
				var h = (c >> 4) & 0xF, l = c & 0xF;
				trace.put2("\\%c%c", Strings.hexMap_l[h],
						Strings.hexMap_l[l]);
			} else {
				trace.putc(c);
			}
		}
		trace.puts("\")\n");
		flush();
	}
}
def STDOUT = System.fileWriteK(1, _, _, _);

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Parses textual spec tests. Only supports binary module commands and a few test
// commands. Does not parse the full .wat or .wast formats.
class SpecTestParser(filename: string, data: Array<byte>) {
	private var pos: int;
	private var line: int = 1;
	private var col: int = 1;
	private def strbuf = StringBuffer.new();
	def var commands = Vector<SpecTestCommand>.new();
	def var ok = true;
	def var error_loc = (int.max, int.max);
	def var error_msg: string;

	def parseFile() {
		skip();
		parseMaybeCommands();
	}

	def parseMaybeCommands() {
		while (ok && more(1)) {
			if (!ch('(')) return;
			parseCommand();
			if (!expect_ch(')')) return;
		}
	}
	def parseOneCommand() -> SpecTestCommand {
		if (!ch('(')) return null;
		parseCommand();
		if (!expect_ch(')')) return null;
		return if(commands.length > 0, commands[0]);
	}
	def parseCommand() {
		var loc = (line, col);
		if (kw("module")) parseModule(loc);
		else if (kw("assert_return")) parseAssertReturn(loc);
		else if (kw("assert_trap")) parseAssertTrap(loc);
		else if (kw("assert_exhaustion")) parseAssertExhaustion(loc);
		else if (kw("assert_invalid")) parseAssertInvalid(loc);
		else if (kw("assert_malformed")) parseAssertMalformed(loc);
		else if (kw("assert_unlinkable")) parseAssertUnlinkable(loc);
		else if (kw("invoke")) parseInvoke(loc);
		else if (kw("get")) parseGetGlobal(loc);
		else if (kw("i32.const")) parseI32Const(loc);
		else if (kw("i64.const")) parseI64Const(loc);
		else if (kw("f32.const")) parseF32Const(loc);
		else if (kw("f64.const")) parseF64Const(loc);
		else if (kw("register")) parseRegister(loc);
		else error1(loc, "expected valid command", ());
	}
	def parseStrings() -> string {
		var loc = (line, col);
		strbuf.reset();
		if (!more(1) || data[pos] != '\"') error1(loc, "expected string", ());
		while (ok && more(1)) {
			if (data[pos] != '\"') break;
			doString();
		}
		return strbuf.extract();
	}
	def parseVarName() -> string {
		var start = pos;
		if (!more(2) || data[pos] != '$') return null;
		var p = start + 1;
		while (p < data.length) {
			if (!isKeywordMiddle(data[p])) break;
			p++;
		}
		advance(p - start);
		return Arrays.range(data, start, p);
	}
	def parseModule(loc: (int, int)) {
		var varname = parseVarName();
		if (kw("binary")) {
			var bytes = parseStrings();
			cmd(loc, StCommand.BinaryModule(varname, bytes));
		} else if (kw("quote")) {
			var source = parseStrings();
			cmd(loc, StCommand.QuotedModule(varname, source));
		} else {
			return error1(loc, "expected binary or quoted module", ());
		}
	}
	def parseAssertReturn(loc: (int, int)) {
		parseMaybeCommands();
		cmd(loc, StCommand.AssertReturn);
	}
	def parseAssertTrap(loc: (int, int)) {
		parseStringCommand(loc, StCommand.AssertTrap);
	}
	def parseAssertExhaustion(loc: (int, int)) {
		parseStringCommand(loc, StCommand.AssertExhaustion);
	}
	def parseAssertInvalid(loc: (int, int)) {
		parseStringCommand(loc, StCommand.AssertInvalid);
	}
	def parseAssertMalformed(loc: (int, int)) {
		parseStringCommand(loc, StCommand.AssertMalformed);
	}
	def parseAssertUnlinkable(loc: (int, int)) {
		parseStringCommand(loc, StCommand.AssertUnlinkable);
	}
	def parseInvoke(loc: (int, int)) {
		var varname = parseVarName();
		var funcname = parseString();
		parseMaybeCommands();
		cmd(loc, StCommand.Invoke(varname, funcname));
	}
	def parseGetGlobal(loc: (int, int)) {
		var varname = parseVarName();
		var globalname = parseString();
		parseMaybeCommands();
		cmd(loc, StCommand.GetGlobal(varname, globalname));
	}
	def parseI32Const(loc: (int, int)) {
		var c = data[pos], sign = 1u;
		if (c == '-') {
			sign = 0xFFFFFFFFu;
			pos++;
			if (!more(1)) return error1(loc, "expected int32, got EOF", ());
			c = data[pos];
		}
		var val: u32;
		if (c == '0') {
			var x = peek_ch(1);
			if (x == 'x' || x == 'X') {
				val = parseI32Hex(loc);
			}
			else val = parseI32Dec(loc);
		} else {
			val = parseI32Dec(loc);
		}
		cmd(loc, StCommand.Constant(Value.I32(u32.!(sign * val))));
	}
	def parseI32Hex(loc: (int, int)) -> u32 {
		var a = data, i = pos + 2, max = a.length;
		var accum = 0u;
		while (i < max) {
			var v = Strings.hexValue(a[i]);
			if (v < 0 || v > 15) break;
			accum = (accum << 4) + u32.!(v);
			i++;
		}
		var count = i - pos;
		if (count == 2) error1(loc, "expected hexadecimal i32", ());
		if (count > 10) error1(loc, "hexadecimal i32 too long", ());
		pos = i;
		skip();
		return accum;
	}
	def parseI32Dec(loc: (int, int)) -> u32 {
		// Parse a (positive) decimal integer starting at pos.
		var a = data, i = pos, v1 = a[i++];
		if (v1 < '0' || v1 > '9') {
			error1(loc, "expected decimal i32", ());
			return 0;
		}

		var max = a.length, accum = v1 - u32.!('0');
		while (i < max) {
			var d = a[i] - '0';
			if (d < 0 || d > 9) break;
			var n = u64.!(accum) * 10 + d;
			if (n > u32.max) {
				error1(loc, "decimal i32 too large", ());
				return 0;
			}
			accum = u32.!(n);
			i++;
		}
		pos = i;
		skip();
		return accum;
	}
	def parseI64Const(loc: (int, int));
	def parseF32Const(loc: (int, int));
	def parseF64Const(loc: (int, int));
	def parseRegister(loc: (int, int)) {
		var varname = parseVarName();
		var regname = parseString();
		cmd(loc, StCommand.Register(varname, regname));
	}
	def parseStringCommand(loc: (int, int), f: string -> StCommand) {
		parseMaybeCommands();
		if (!ok) return;
		var str = if(peek_ch(0) == '\"', parseString());
		cmd(loc, f(str));
	}

	def parseString() -> string {
		strbuf.reset();
		doString();
		return strbuf.extract();
	}
	def doString() {
		// Parses string characters into {this.strbuf}
		var loc = (line, col);
		if (!more(1)) return error1(loc, "expected string, got EOF", ());
		var c = data[pos];
		if (c != '\"') return error1(loc, "expected string starting quote", ());
		pos++;
		col++;
		while (ok && more(1)) {
			var c = data[pos];
			if (c == '\"') return advance(1); // end of string

			if (c < ' ' || c > 127) {
				return error1((line, col), "invalid character 0x%x in string", c);
			}
			if (c == '\\') {
				if (!more(3)) break;
				var h = peek_hex(1), l = peek_hex(2);
				strbuf.putc(byte.!(h << 4 | l));
				pos += 3;
				col += 3;
			} else {
				strbuf.putc(c);
				pos++;
				col++;
			}

		}
		error1((line, col), "unexpected end of string", ());
	}

	// expect and consume the given character {c}
	def expect_ch(c: byte) -> bool {
		var loc = (line, col);
		if (!ch(c)) error1(loc, "expected \'%c\'", c);
		return true;
	}
	// Peek at the character {offset} ahead, returning -1 if that is EOF.
	def peek_ch(offset: int) -> int {
		if (more(1 + offset)) return data[pos + offset];
		return -1;
	}
	// Peek at the character {offset} ahead, returning its hexadecimal
	// value.
	def peek_hex(offset: int) -> int {
		var h = data[pos + offset];
		if (!Strings.isHexChar(h)) {
			error1((line, col + offset), "expected hexadecimal", ());
			return 0;
		}
		return Strings.hexValue(h);
	}
	// Eat the character {c} if it is next in the input, returning {true} if so.
	def ch(c: byte) -> bool {
		if (!more(1)) return false;
		if (data[pos] != c) return false;
		advance(1);
		return true;
	}

	// Eat the keyword {k} if it is next in the input, returning {true} if so.
	def kw(k: Array<byte>) -> bool {
		var l = k.length;
		if (!more(l)) return false;
		for (i < l) {
			if (data[pos + i] != k[i]) return false;
		}
		if (more(l+1)) {
			var c = data[pos + l];
			if (isKeywordMiddle(c)) return false;
		}
		advance(l);
		return true;
	}

	// Advance by {k} non-whitespace characters, and then skip whitespace.
	def advance(k: int) {
		pos += k;
		col += k;
		skip();
	}
	// Skip whitespace from the current position.
	def skip() {
		while (pos < data.length) {
			var c = data[pos];
			match (c) {
				' ' => {
					col++;
					pos++;
				}
				'\t' => {
					col = (col + 8) & ~7;
					pos++;
				}
				'\n' => {
					col = 1;
					line++;
					pos++;
				}
				';' => {
					var p = pos, d = data;
					while (p++ < d.length && d[p] != '\n') ;
					pos = p;
				}
				_ => return;
			}
		}
	}
	def more(num: int) -> bool {
		return data.length - pos >= num;
	}
	def error1<T>(loc: (int, int), fmt: string, arg: T) {
		ok = false;
		if (loc.0 < error_loc.0 ||
			(loc.0 == error_loc.0 && loc.1 < error_loc.1)) {
			error_loc = loc;
			error_msg = Strings.format1(fmt, arg);
		}
		if (UnitTests.fatal) {
			var msg = StringBuffer.new();
			msg.puts(filename);
			msg.put3(" @ %d:%d %s", error_loc.0, error_loc.1, error_msg);
			printCurrentLine();
			System.error("SpecTestParserError", msg.extract());
		}
	}
	def printCurrentLine() {
		var b = pos - 1;
		while (b >= 0) { // scan backwards to previous newline
			if (data[b] == '\n') { b++; break; }
			b--;
		}
		if (b < 0) b = 0;
		var col = 0;
		while (b < data.length) { // print current line
			var c = data[b];
			if (c == '\n') break;
			if (b < pos) {
				if (c == '\t') col = (col + 8) & ~7;
				else col++;
			}
			System.putc(c);
			b++;
		}
		System.ln();
		for (i < col) System.putc(' '); // print caret pointing to column
		System.putc('^');
		System.ln();
	}
	def cmd(loc: (int, int), cmd: StCommand) {
		commands.add(SpecTestCommand.new(loc, cmd));
	}
}
def isKeywordMiddle(c: byte) -> bool {
	return 'a' <= c && c <= 'z' ||
		'A' <= c && c <= 'Z' ||
		'0' <= c && c <= '9' ||
		c == '_' ||
		c == '-';
}

class SpecTestCommand(loc: (int, int), cmd: StCommand) {
}
type StCommand {
	case BinaryModule(varname: string, bytes: Array<byte>);
	case QuotedModule(varname: string, str: string);
	case Register(varname: string, regname: string);
	case Invoke(varname: string, funcname: string);
	case GetGlobal(varname: string, globalname: string);
	case AssertReturn;
	case AssertTrap(msg: string);
	case AssertExhaustion(msg: string);
	case AssertInvalid(msg: string);
	case AssertMalformed(msg: string);
	case AssertUnlinkable(msg: string);
	case Constant(val: Value);
}

type StValue {
	case Instance(sti: StInstance);
	case InvalidModule(r: BinParserResult);
	case QuotedModule(s: string);
	case UnlinkableModule(m: Module);
	case WasmValue(val: Value);
	case WasmTrap(reason: TrapReason);
}
class StEnv<T> {
	def modules = Vector<(string, T)>.new();
	def register(name: string, t: T) {
		modules.add(name, t);
	}
	def lookup(name: string) -> T {
		for (i < modules.length) {
			var m = modules[i];
			if (Strings.equals(m.0, name)) return m.1;
		}
		var d: T;
		return d;
	}
}
class StInstance(instance: Instance) extends StEnv<Exportable> {
	new() {
		for (i < instance.exports.length) {
			var name = instance.module.exports[i].name;
			var e = instance.exports[i];
			register(name, e);
		}
	}
}

component SpecTestRunner {
	def trace = StringBuffer.new();
	new() {
		// install the run method in the main entrypoint
		wizeng.runSpecTests = runSpecTests;
	}
	def runSpecTests(args: Array<string>) -> int {
		var ran = 0;
		for (a in args) {
			if (a == null) continue;
			if (Strings.endsWith(a, ".wast")) {
				ran++;
				runTest(a);
			}
		}
		if (ran == 0 && !wizeng.printVersion) {
			System.puts("wizeng-spec: no input files\n");
			return 3;
		}

		return 0;
	}
	def runTest(filename: string) {
		trace.puts("+");
		trace.puts(filename);
		trace.puts("\n");
		flush();
		var data = System.fileLoad(filename);
		if (data == null) {
			trace.puts("-fail: could not load file\n");
			return flush();
		}
		var p = SpecTestParser.new(filename, data);
		p.parseFile();
		if (p.ok) {
			var ip = StInterpreter.new(filename, trace);
			if (ip.run(p.commands)) trace.puts("-ok\n");
			flush();
		} else {
			trace.put1("-fail: %s ", filename);
			trace.put3("%d:%d %s\n", p.error_loc.0, p.error_loc.1, p.error_msg);
			return flush();
		}
	}
	def verbose(str: string) {
		if (wizeng.verbose) System.puts(str);
	}
	def flush() {
		trace.out(STDOUT);
		trace.reset();
	}
	def renderBinaryModule(data: Array<byte>, pos: int, length: int) {
		trace.puts("(module binary");
		for (i < length) {
			if (i % 16 == 0) {
				if (i > 0) trace.puts("\"");
				trace.puts("\n  \"");
			}
			trace.put1("\\%x", data[pos + i]);
		}
		trace.puts("\")\n");
		flush();
	}
	def renderQuotedModule(data: Array<byte>, pos: int, length: int) {
		trace.puts("(module quote");
		for (i < length) {
			if (i % 64 == 0) {
				if (i > 0) trace.puts("\"");
				trace.puts("\n  \"");
			}
			var c = data[pos + i];
			if (c == '\n') trace.puts("\\n");
			else if (c == '\t') trace.puts("\\t");
			else if (c == '\'') trace.puts("\\\'");
			else if (c == '\"') trace.puts("\\\"");
			if (c < ' ' || c > 127) {
				var h = (c >> 4) & 0xF, l = c & 0xF;
				trace.put2("\\%c%c", Strings.hexMap_l[h],
						Strings.hexMap_l[l]);
			} else {
				trace.putc(c);
			}
		}
		trace.puts("\")\n");
		flush();
	}
}
class StInterpreter(filename: string, trace: StringBuffer) {
	def env = StEnv<StInstance>.new();
	def vars = StEnv<StInstance>.new();
	def stack = Stack<StValue>.new();
	var ok = true;
	var loc: (int, int);
	def run(commands: Vector<SpecTestCommand>) -> bool {
		for (i < commands.length) {
			var cmd = commands[i];
			loc = cmd.loc;
			if (wizeng.verbose) {
				trace.puts("execute: ");
				trace.puts(cmd.cmd.name);
				trace.put2(" @ %d:%d", cmd.loc.0, cmd.loc.1);
				trace.ln();
				flush();
			}
			match (cmd.cmd) {
				BinaryModule(varname, bytes) => {
					var i = parseBinary(bytes);
					if (varname != null && StValue.Instance.?(i)) {
						vars.register(varname, StValue.Instance.!(i).sti);
					}
					stack.push(i);
				}
				QuotedModule(varname, str) => {
					stack.push(StValue.QuotedModule(str));
				}
				Register(varname, regname) => {
					var sti = getInstance(varname);
					if (!ok) return false;
					env.register(regname, sti.sti);
				}
				Invoke(varname, funcname) => {
					var i = stack.top - 1;
					// count arguments
					while (i >= 0) {
						var v = stack.elems[i];
						if (!StValue.WasmValue.?(v)) break;
						i--;
					}
					// pop arguments
					var arity = stack.top - i - 1;
					var args = Array<Value>.new(arity);
					for (i < arity) {
						args[arity - i - 1] = popV().val;
					}
					// pop instance
					var sti = getInstance(varname);
					if (!ok) return false;
					// lookup function
					var exp = sti.sti.lookup(funcname);
					if (exp == null) return error(Strings.format1("func \"%s\" not found", funcname));
					if (!WasmFunction.?(exp)) return error(Strings.format1("export \"%s\" is not a function", funcname));
					var func = WasmFunction.!(exp);
					// create interpreter
					var interp = Interpreter.new();
					// run interpreter
					var result = interp.run(-1, func, args);
					// unpack result
					match (result) {
						Break => return error("interpreter hit breakpoint");
						Value(vals) => {
							for (v in vals) {
								stack.push(StValue.WasmValue(v));
							}
						}
						Trap(reason) => stack.push(StValue.WasmTrap(reason));
					}
				}
				GetGlobal(varname, globalname) => {
					// pop instance
					var sti = getInstance(varname);
					if (!ok) return false;
					// lookup function
					var exp = sti.sti.lookup(globalname);
					if (exp == null) return error(Strings.format1("global \"%s\" not found", globalname));
					if (!Global.?(exp)) return error(Strings.format1("export \"%s\" is not a global", globalname));
					var global = Global.!(exp);
					stack.push(StValue.WasmValue(global.value));
				}
				AssertReturn => {
					var expected = popV();
					var value = popV();
					if (!ok) return false;
				}
				AssertTrap(msg) => {
					var trap = pop<StValue.WasmTrap>("trap");
				}
				AssertExhaustion(msg) => {
					var result = popR();
				}
				AssertInvalid(msg) => {
					pop<StValue.InvalidModule>("invalid module");
				}
				AssertMalformed(msg) => {
					pop<StValue.QuotedModule>("quoted module");
				}
				AssertUnlinkable(msg) => {
					pop<StValue.UnlinkableModule>("unlinkable module");
				}
				Constant(val) => {
					stack.push(StValue.WasmValue(val));
				}
			}
		}
		return true;
	}
	def getInstance(varname: string) -> StValue.Instance {
		if (varname == null) {
			var sti = popI();
			if (!ok) return StValue.Instance(null);
			stack.push(sti);
		}
		var i = vars.lookup(varname);
		if (i == null) error(Strings.format1("module %s not found", varname));
		return StValue.Instance(i);
	}
	def error(msg: string) -> bool {
		if (!ok) return false;
		ok = false;
		trace.puts("-fail: ");
		trace.put3("%s @ %d:%d ", filename, loc.0, loc.1);
		trace.puts(msg);
		trace.ln();
		flush();
		return false;
	}
	def parseBinary(bytes: Array<byte>) -> StValue {
		var v = if (wizeng.verbose, Verbosity.VERBOSE, Verbosity.SILENT);
		var extensions: Extension.set;
		var limits = Limits.new();
		var mp = ModuleParser.new(v, extensions, limits, "test");
		mp.push(bytes, 0, bytes.length);
		var r = mp.finish();
		match (r) {
			Ok(module) => return doInstantiate(module);
			Error => return StValue.InvalidModule(r);
		}
	}
	def doInstantiate(module: Module) -> StValue {
		var imports = Array<Exportable>.new(module.imports.length);
		for (i < module.imports.length) {
			var imp = module.imports[i];
			var sti = env.lookup(imp.modname);
			if (sti == null) return StValue.UnlinkableModule(module);
			var exp = sti.lookup(imp.name);
			if (exp == null) return StValue.UnlinkableModule(module);
			imports[i] = exp;
		}
		var i = Instantiator.new(module, imports);
		var r = i.run();
		// TODO: invoke start function, if any
		if (i.err.ok()) return StValue.Instance(StInstance.new(r));
		return StValue.UnlinkableModule(module);
	}
	def popV() -> StValue.WasmValue {
		return pop<StValue.WasmValue>("value");
	}
	def popI() -> StValue.Instance {
		return pop<StValue.Instance>("instance");
	}
	def popR() -> StValue {
		var v = pop<StValue>("result");
		if (!ok) return v;
		match (v) {
			WasmValue => return v;
			WasmTrap => return v;
			_ => error(Strings.format1("expected result, found: %s", v.name));
		}
		return v;
	}
	def pop<T>(expected: string) -> T {
		var d: T;
		if (stack.top == 0) {
			error(Strings.format1("expected %s, found empty stack", expected));
			return d;
		}
		var v = stack.pop();
		if (T.?(v)) return T.!(v);
		error(Strings.format2("expected %s, found: %s", expected, v.name));
		return d;
	}
	def renderStValue(buf: StringBuffer, v: StValue) -> StringBuffer {
		buf.puts(v.name);
		return buf;
	}
	def flush() {
		trace.out(STDOUT);
		trace.reset();
	}
}
def STDOUT = System.fileWriteK(1, _, _, _);

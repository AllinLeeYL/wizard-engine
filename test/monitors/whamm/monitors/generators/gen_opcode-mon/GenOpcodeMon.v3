

// def main() {
//     System.puts(Opcode.UNREACHABLE.mnemonic);
//     System.puts("\n");
// }
var TABS = 4;

def main() -> int {
	var fd = System.fileOpen("opcode-mon.wat", false);
    module_start(fd);

    setup(fd);

    var opcodes = Opcode.set.all;
    for (opcode in opcodes) {
        // gen_probe(fd, opcode.mnemonic);
    }

    alloc_func(fd);
    count_func(fd);
    flush_func(fd);

    module_end(fd);
	System.fileClose(fd);
	return 0;
}

def gen_probe(fd: int, opcode_name: string) {
    func_start(fd, "(export \"wasm:opcode:", false);
    write(fd, opcode_name);
    write(fd, "($alloc(fid, pc))\" (param $entry i32)\n");

    writet(fd, 2, "(call $count_probe (local.get $entry))\n");

    func_end(fd);
}

def setup(fd: int) {
    // imports
    writet(fd, 1, "(import \"wizeng\" \"puti\" (func $puti (param i32)))\n");
    writet(fd, 1, "(import \"wizeng\" \"puts\" (func $puts (param i32 i32)))\n\n");
    
    // memory/globals
    writet(fd, 1, "(memory (export \"mem\") 2)   ;; no expansion checks\n");
    writet(fd, 1, "(global $last_entry (mut i32) (i32.const 0))\n\n");

    // data(data (i32.const 0xc00) "func=")
    writet(fd, 1, "(data (i32.const 0xd00) \", pc=\")\n");
    writet(fd, 1, "(data (i32.const 0xe00) \"\\n\")\n");
    writet(fd, 1, "(data (i32.const 0xf00) \", [\")\n");
    writet(fd, 1, "(data (i32.const 0xf10) \",\")\n");
    writet(fd, 1, "(data (i32.const 0xf20) \"]\")\n\n");
}

def alloc_func(fd: int) {
    func_start(fd, "(export \"$alloc\") (param $func i32) (param $pc i32) (result i32)", true);
    writet(fd, 2, "(local $entry i32)\n\n");

    writet(fd, 2, "global.get $last_entry\n");
    writet(fd, 2, "local.set $entry\n\n");

    writet(fd, 2, "local.get $entry\n");
    writet(fd, 2, "local.get $func\n");
    writet(fd, 2, "i32.store\n\n");

    writet(fd, 2, "local.get $entry\n");
    writet(fd, 2, "local.get $pc\n");
    writet(fd, 2, "i32.store offset=4\n\n");

    writet(fd, 2, "local.get $entry\n");
    writet(fd, 2, "i32.const 1\n");
    writet(fd, 2, "i32.store offset=8\n\n");

    writet(fd, 2, "local.get $entry\n");
    writet(fd, 2, "i32.const 20\n");
    writet(fd, 2, "i32.add\n");
    writet(fd, 2, "global.set $last_entry\n\n");

    writet(fd, 2, "local.get $entry\n");

    func_end(fd);
}

def count_func(fd: int) {
    func_start(fd, "$count_probe (param $entry i32)", true);

    writet(fd, 2, "local.get $entry\n");
    writet(fd, 2, "local.get $entry\n");
    writet(fd, 2, "i64.load offset=12  ;; count number of times fired\n");
    writet(fd, 2, "i64.const 1\n");
    writet(fd, 2, "i64.add\n");
    writet(fd, 2, "i64.store offset=12\n");

    func_end(fd);
}

def flush_func(fd: int) {
    func_start(fd, "$flush (export \"wasm:exit\")", true);
    
    writet(fd, 2, "(local $entry i32)\n");
    writet(fd, 2, "(local $options i32)\n");
    writet(fd, 2, "(block $end_loop\n");
    writet(fd, 3, "(loop $loop_entry\n");
    writet(fd, 4, ";; check at the end of memory\n");
    writet(fd, 4, "local.get $entry\n");
    writet(fd, 4, "global.get $last_entry\n");
    writet(fd, 4, "i32.eq\n");
    writet(fd, 4, "br_if $end_loop\n\n");

    writet(fd, 4, "(call $puts (i32.const 0xc00) (i32.const 5))\n");
    writet(fd, 4, "local.get $entry\n");
    writet(fd, 4, "i32.load ;; func\n");
    writet(fd, 4, "call $puti\n");
    writet(fd, 4, "local.get $entry\n");
    writet(fd, 4, "i32.const 4\n");
    writet(fd, 4, "i32.add\n");
    writet(fd, 4, "local.set $entry\n\n");

    writet(fd, 4, "(call $puts (i32.const 0xd00) (i32.const 5))\n");
    writet(fd, 4, "local.get $entry\n");
    writet(fd, 4, "i32.load ;; pc\n");
    writet(fd, 4, "call $puti\n");
    writet(fd, 4, "local.get $entry\n");
    writet(fd, 4, "i32.const 4\n");
    writet(fd, 4, "i32.add\n");
    writet(fd, 4, "local.set $entry\n\n");

    writet(fd, 4, "local.get $entry\n");
    writet(fd, 4, "i32.load ;; number of options\n");
    writet(fd, 4, "local.get $entry\n");
    writet(fd, 4, "i32.const 4\n");
    writet(fd, 4, "i32.add\n");
    writet(fd, 4, "local.set $entry\n\n");

    writet(fd, 4, "local.set $options\n\n");

    writet(fd, 4, "(call $puts (i32.const 0xf00) (i32.const 3))\n\n");

    writet(fd, 4, "(loop $loop_options\n\n");

    writet(fd, 5, "local.get $entry\n");
    writet(fd, 5, "i32.load\n");
    writet(fd, 5, "call $puti\n\n");

    writet(fd, 5, "local.get $entry\n");
    writet(fd, 5, "i32.const 8\n");
    writet(fd, 5, "i32.add\n");
    writet(fd, 5, "local.set $entry\n\n");

    writet(fd, 5, "local.get $options\n");
    writet(fd, 5, "i32.const -1\n");
    writet(fd, 5, "i32.add\n\n");

    writet(fd, 5, "local.tee $options\n\n");

    writet(fd, 5, "i32.eqz\n");
    writet(fd, 5, "(if\n");
    writet(fd, 6, "(then\n");
    writet(fd, 7, "(call $puts (i32.const 0xf20) (i32.const 1))\n");
    writet(fd, 6, ")\n");
    writet(fd, 6, "(else\n");
    writet(fd, 7, "(call $puts (i32.const 0xf10) (i32.const 1))\n");
    writet(fd, 7, "br $loop_options\n");
    writet(fd, 6, ")\n");
    writet(fd, 5, ")\n");
    writet(fd, 4, ")\n\n");

    writet(fd, 4, "(call $puts (i32.const 0xe00) (i32.const 1))\n");
    writet(fd, 4, "br $loop_entry\n");
    writet(fd, 3, ")\n");
    writet(fd, 2, ")");

    func_end(fd);
}

// Functions
def func_start(fd: int, sig: string, nl: bool) {
    sexp_start("func ", 1, false, fd);
    if (sig != null) {
        write(fd, sig);
    }
    if (nl) {
        write(fd, "\n");
    }
}
def func_end(fd: int) {
    sexp_end(1, fd);
}

// Module
def module_start(fd: int) {
    sexp_start("module", 0, true, fd);
}
def module_end(fd: int) {
    sexp_end(0, fd);
}

// Utils
def write(fd: int, str: string) {
	System.fileWriteK(fd, str, 0, str.length);
}
def writet(fd: int, tab: int, str: string) {
    tabs(tab, fd);
	System.fileWriteK(fd, str, 0, str.length);
}
def tabs(tab: int, fd: int) {
    for (i < tab * TABS) {
        write(fd, " ");
    }
}
def sexp_start(name: string, tab: int, nl: bool, fd: int) {
    writet(fd, tab, "(");
    write(fd, name);
    if (nl) {
        write(fd, "\n");
    }
}
def sexp_end(tab: int, fd: int) {
    write(fd, "\n");
    writet(fd, tab, ")\n");
}
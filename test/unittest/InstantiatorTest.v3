// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, InstantiatorTester.new, _);
def X = [
	T("inst:func1", test_func1),
	T("inst:table1", test_table1),
	T("inst:mem1", test_mem1),
	T("inst:mem2", test_mem2),
	T("inst:global1", test_global1),
	T("inst:global2", test_global2),
	T("inst:type1", test_type1),
	T("inst:type2", test_type2),
	T("inst:typesig1", test_typesig1),
	T("inst:typesig2", test_typesig2),
	T("inst:typesig3", test_typesig3),
	T("inst:funcsig1", test_funcsig1),
	()
];

class InstantiatorTester(t: Tester) extends ModuleBuilder {
	def assert_fail(bindings: Array<Exportable>) {
		var error = WasmErrorGen.new("InstantiatorTest.v3");
		var instance = Instantiator.new(extensions, module, bindings, error).run();
		if (instance != null) return t.fail("expected instantiation fail, but passed (non-null instance)");
		if (error.ok()) return t.fail("expected instantiation fail, but passed (no error)");
	}
	def assert_pass(bindings: Array<Exportable>) -> Instance {
		var error = WasmErrorGen.new("InstantiatorTest.v3");
		var instance = Instantiator.new(extensions, module, bindings, error).run();
		if (error.error()) t.fail1("instantiation failed, got %s", error.error_msg);
		if (instance == null) t.fail("instantiation failed, got null");
		return instance;
	}
	def assert_sig(expected_sig: FuncSig, got_sig: FuncSig) {
		if (!got_sig.isAssignableSig(expected_sig)) {
			t.fail(Strings.format2("expected sig %q, got %q", expected_sig.render, got_sig.render));
		}
	}
}

def NONE: Array<Exportable> = [];
def NULL = Array<Exportable>.new(1);
def FUNC: Array<Exportable> = [HostFunction.new(SigCache.v_v, null)];
def TABLE: Array<Exportable> = [Table.new(TableDecl.new(ValueType.EXTERNREF, 0, Max.None))];
def MEMORY: Array<Exportable> = [Memory.new(MemoryDecl.new(0, Max.Set(0), false))];
def GLOBAL: Array<Exportable> = [Global.new(GlobalDecl.new(ValueType.I32, false, InitExpr.I32(0)))];
def TYPE: Array<Exportable> = [HostType.new()];
def BASIC_TYPES = [
	ValueType.I32, ValueType.I64, ValueType.F32, ValueType.F64, ValueType.EXTERNREF, ValueType.FUNCREF
];

def test_func1(t: InstantiatorTester) {
	var sig_decl = SigDecl.new(SigCache.v_v);
	t.module.addDef(sig_decl);
	t.module.addImport("I", "f", FuncDecl.new(sig_decl));

	t.assert_fail(NONE);
	t.assert_fail(NULL);
	t.assert_fail(TABLE);
	t.assert_fail(MEMORY);
	t.assert_fail(GLOBAL);
	t.assert_fail(TYPE);
	t.assert_fail([HostFunction.new(SigCache.v_i, null)]);
	t.assert_fail([HostFunction.new(SigCache.i_i, null)]);

	t.assert_pass([HostFunction.new(SigCache.v_v, null)]);
}

def test_table1(t: InstantiatorTester) {
	t.module.addImport("M", "t", TableDecl.new(ValueType.EXTERNREF, 1, Max.Set(3)));

	t.assert_fail(NONE);
	t.assert_fail(NULL);
	t.assert_fail(FUNC);
	t.assert_fail(MEMORY);
	t.assert_fail(GLOBAL);
	t.assert_fail(TYPE);

	t.assert_fail([Table.new(TableDecl.new(ValueType.FUNCREF, 1, Max.Set(3)))]);
	t.assert_fail([Table.new(TableDecl.new(ValueType.I32, 1, Max.Set(3)))]);
	t.assert_fail([Table.new(TableDecl.new(ValueType.EXTERNREF, 0, Max.Set(3)))]);
	t.assert_fail([Table.new(TableDecl.new(ValueType.EXTERNREF, 1, Max.Set(4)))]);
	t.assert_fail([Table.new(TableDecl.new(ValueType.EXTERNREF, 1, Max.None))]);

	t.assert_pass([Table.new(TableDecl.new(ValueType.EXTERNREF, 1, Max.Set(3)))]);
	t.assert_pass([Table.new(TableDecl.new(ValueType.EXTERNREF, 2, Max.Set(3)))]);
	t.assert_pass([Table.new(TableDecl.new(ValueType.EXTERNREF, 1, Max.Set(2)))]);
}

def test_mem1(t: InstantiatorTester) {
	t.module.addImport("N", "m", MemoryDecl.new(1, Max.Set(3), false));

	t.assert_fail(NONE);
	t.assert_fail(NULL);
	t.assert_fail(FUNC);
	t.assert_fail(TABLE);
	t.assert_fail(GLOBAL);
	t.assert_fail(TYPE);

	t.assert_fail([Memory.new(MemoryDecl.new(0, Max.Set(3), false))]);
	t.assert_fail([Memory.new(MemoryDecl.new(1, Max.Set(4), false))]);
	t.assert_fail([Memory.new(MemoryDecl.new(1, Max.None, false))]);
	t.assert_fail([Memory.new(MemoryDecl.new(1, Max.Set(3), true))]);

	t.assert_pass([Memory.new(MemoryDecl.new(1, Max.Set(3), false))]);
	t.assert_pass([Memory.new(MemoryDecl.new(1, Max.Set(2), false))]);
}

def test_mem2(t: InstantiatorTester) {
	t.module.addImport("N", "m", MemoryDecl.new(1, Max.Set(3), true));

	t.assert_fail([Memory.new(MemoryDecl.new(1, Max.Set(3), false))]);

	t.assert_pass([Memory.new(MemoryDecl.new(1, Max.Set(3), true))]);
	t.assert_pass([Memory.new(MemoryDecl.new(1, Max.Set(2), true))]);
}

def test_global1(t: InstantiatorTester) {
	t.module.addImport("H", "g", GlobalDecl.new(ValueType.I64, false, InitExpr.I64(5)));

	t.assert_fail(NONE);
	t.assert_fail(NULL);
	t.assert_fail(FUNC);
	t.assert_fail(TABLE);
	t.assert_fail(MEMORY);
	t.assert_fail(TYPE);

	t.assert_fail([Global.new(GlobalDecl.new(ValueType.I32, false, InitExpr.I32(55)))]);
	t.assert_fail([Global.new(GlobalDecl.new(ValueType.I64, true, InitExpr.I64(55)))]);

	t.assert_pass([Global.new(GlobalDecl.new(ValueType.I64, false, InitExpr.I64(55)))]);
}

def test_global2(t: InstantiatorTester) {
	t.module.addImport("H", "g", GlobalDecl.new(ValueType.F64, true, InitExpr.F64(5)));

	t.assert_fail([Global.new(GlobalDecl.new(ValueType.I32, false, InitExpr.I32(55)))]);
	t.assert_fail([Global.new(GlobalDecl.new(ValueType.F64, false, InitExpr.I64(55)))]);

	t.assert_pass([Global.new(GlobalDecl.new(ValueType.F64, true, InitExpr.I64(55)))]);
}

def test_type1(t: InstantiatorTester) {
	t.module.addImport("Y", "p", AbsTypeDecl.new(ValueTypes.NONE));

	t.assert_fail(NONE);
	t.assert_fail(NULL);
	t.assert_fail(FUNC);
	t.assert_fail(TABLE);
	t.assert_fail(MEMORY);
	t.assert_fail(GLOBAL);

	t.assert_pass([HostType.new()]);
}

def test_type2(t: InstantiatorTester) {
	var args = Array<Exportable>.new(1);

	for (x in BASIC_TYPES) {
		for (y in BASIC_TYPES) {
			var n = InstantiatorTester.new(t.t);
			n.module.addImport("Q", "r", AbsTypeDecl.new([x]));
			args[0] = ExportedValueType.new(y);
			if (ValueTypes.isAssignable(y, x)) n.assert_pass(args);
			else n.assert_fail(args);
		}
	}

}

def test_typesig1(t: InstantiatorTester) {
	var at = AbsTypeDecl.new(ValueTypes.NONE), ata: Array<ValueType> = [ValueType.Abstract(at)];
	t.module.addImport("Y", "p", at);
	var sig_decl = SigDecl.new(FuncSig.new(ata, ata));
	t.module.addDef(sig_decl);

	var ht = HostType.new();
	var i = t.assert_pass([ht]);
	if (i == null) return;
	var expected_sig = FuncSig.new([ValueType.Host(ht)], [ValueType.Host(ht)]);
	var got_sig = i.sigs[sig_decl.sig_index];
	t.assert_sig(expected_sig, got_sig);
}

def test_typesig2(t: InstantiatorTester) {
	for (x in BASIC_TYPES) {
		for (y in BASIC_TYPES) {
			var n = InstantiatorTester.new(t.t);

			var xt = AbsTypeDecl.new(ValueTypes.NONE);
			var yt = AbsTypeDecl.new(ValueTypes.NONE);
			n.module.addImport("Z", "x", xt);
			n.module.addImport("Z", "y", yt);
			var sig_decl = SigDecl.new(FuncSig.new([ValueType.Abstract(xt)], [ValueType.Abstract(yt)]));
			n.module.addDef(sig_decl);


			var i = n.assert_pass([ExportedValueType.new(x), ExportedValueType.new(y)]);
			if (i == null) return;
			var expected_sig = FuncSig.new([x], [y]);
			var got_sig = i.sigs[sig_decl.sig_index];
			n.assert_sig(expected_sig, got_sig);
		}
	}
}

def test_typesig3(t: InstantiatorTester) {
	for (i < 3) {
		for (j < 3) {
			var n = InstantiatorTester.new(t.t);

			var x = ValueType.FUNCREF;
			var xt = AbsTypeDecl.new(ValueTypes.NONE);
			n.module.addImport("Z", "x", xt);
			var pt = [ValueType.I32, ValueType.I64, ValueType.F32], rt = Arrays.dup(pt);
			pt[i] = ValueType.Abstract(xt);
			rt[j] = ValueType.Abstract(xt);
			var sig_decl = SigDecl.new(FuncSig.new(Arrays.dup(pt), Arrays.dup(rt)));
			n.module.addDef(sig_decl);


			var instance = n.assert_pass([ExportedValueType.new(x)]);
			if (instance == null) return;
			pt[i] = x;
			rt[j] = x;
			var expected_sig = FuncSig.new(Arrays.dup(pt), Arrays.dup(rt));
			var got_sig = instance.sigs[sig_decl.sig_index];
			n.assert_sig(expected_sig, got_sig);
		}
	}
}

def test_funcsig1(t: InstantiatorTester) {
	var at = AbsTypeDecl.new(ValueTypes.NONE), ata: Array<ValueType> = [ValueType.Abstract(at)];
	t.module.addImport("Y", "p", at);
	var sig_decl = SigDecl.new(FuncSig.new(ata, ata));
	t.module.addDef(sig_decl);
	var func_decl = FuncDecl.new(sig_decl);
	t.module.addDef(func_decl);

	var ht = HostType.new();
	var i = t.assert_pass([ht]);
	if (i == null) return;
	var expected_sig = FuncSig.new([ValueType.Host(ht)], [ValueType.Host(ht)]);
	var got_sig = i.sigs[sig_decl.sig_index];
	t.assert_sig(expected_sig, got_sig);
	var got_func = i.functions[func_decl.func_index];
	t.assert_sig(expected_sig, got_func.sig);
}


// TODO: more tests for imported function sig compatibility
// TODO: more tests for table elemtype compatibility
// TODO: more tests for global valtype compatibility

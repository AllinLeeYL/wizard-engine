// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("heap:", _, HeapTypeTester.new, _);
def Z = [
	T("cache", test_cache),
	T("canon0", test_canon0),
	T("canon_i_i", test_canon_i_i),
	()
];

class HeapTypeTester(t: Tester) {

}

def test_cache(t: HeapTypeTester) {
	var cache = HeapTypeCache.new();
	for (sig in [SigCache.i_i, SigCache.v_i]) {
		cache.insert(sig);
	}
	var s = StructDecl.new([StorageType.new(ValueType.I32, Packedness.UNPACKED, true)]);
	cache.insert(s);
	var a = ArrayDecl.new([StorageType.new(ValueType.I32, Packedness.UNPACKED, true)]);
	cache.insert(a);
	t.t.asserti(4, cache.count);
}

def test_canon0(t: HeapTypeTester) {
	var cache = HeapTypeCache.new();
	var comp = HeapTypeComparator.new(cache);
	var vec = Vector<HeapTypeDecl>.new();

	var sigs: Array<HeapTypeDecl> = [
		SigCache.i_i,
		SigCache.v_i,
		SigCache.i_v,
		SigCache.ff_f,
		SigCache.dd_d
	];
	vec.puta(sigs);

	for (i < vec.length) {
		comp.reset(vec, i, 1);
		comp.canon();

		for (j < vec.length) {
			t.t.asserteq(sigs[j], vec[j]);
		}
	}
	t.t.asserti(sigs.length, cache.count);
}

def test_canon_i_i(t: HeapTypeTester) {
	var cache = HeapTypeCache.new();
	var comp = HeapTypeComparator.new(cache);
	var vec = Vector<HeapTypeDecl>.new();

	vec.put(SigCache.i_i);
	for (i < 4) {
		vec.put(SigDecl.new(SigCache.arr_i, SigCache.arr_i));
	}

	for (i < vec.length) {
		comp.reset(vec, i, 1);
		comp.canon();
	}

	for (j < vec.length) {
		t.t.asserteq(SigCache.i_i, vec[j]);
	}
	t.t.asserti(1, cache.count);
}

// TODO: simple structs, arrays
// TODO: complex sigs, structs, arrays
// TODO: recursive sigs, structs, arrays

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("jawa:", _, JawaTester.new, _);
def X = [
	T("strhash", test_strhash),
	T("importcl1", test_importcl1),
	T("importi1", test_importi1),
	T("env1", test_env1),
	T("env2", test_env2),
	T("t_bytearray1", test_t_bytearray1),
	T("t_primarray1", test_t_primarray1),
	T("t_refarray1", test_t_refarray1),
	T("t_refarrayN", test_t_refarrayN),
	T("t_primarrayN", test_t_primarrayN),
	T("f_baload", test_f_baload),
	T("f_xaload", test_f_xaload),
	T("f_bastore", test_f_bastore),
	T("f_xastore", test_f_xastore),
	T("f_bnewarray", test_f_bnewarray),
	T("f_xnewarray", test_f_xnewarray),
	T("f_arraylength1", test_f_arraylength1),
	T("f_arraylength2", test_f_arraylength2),
	T("f_multianewarrayN", test_f_multianewarrayN),
	T("f_invokeinterface", test_f_invokeinterface),
	T("f_invokespecial", test_f_invokespecial),
	T("f_invokestatic", test_f_invokestatic),
	T("f_invokevirtual", test_f_invokevirtual),
	()
];

def NO_METHOD_ATTRS: JawaMethodAttr.set;
def NO_CLASS_ATTRS: JawaClassAttr.set;

def strhash(s: string) -> int {
	return int.view(JawaStrings.of(s).hashCode());
}

def test_strhash(t: JawaTester) {
	// Test Jawa hash matches standardized string hashing algorithm
	t.t.asserti(97, strhash("a"));
	t.t.asserti(2027435274, strhash("agzAFZ09"));
	t.t.asserti(1998497278, strhash("!@#$%^&*()"));
}

def test_importcl1(t: JawaTester) {
	var d = t.env.declareClass(JawaStrings.of("Foo"), t.NO_CLASS_ATTRS, null, []);
	t.importClass("Foo");
	var r = t.process();
	t.assertIsJawaClassType(d, r[0]);
}

def test_importi1(t: JawaTester) {
	var d = t.env.declareInterface(JawaStrings.of("Graz"), []);
	t.importInterface("Graz");
	var r = t.process();
	t.assertIsJawaInterfaceType(d, r[0]);
}

def test_t_bytearray1(t: JawaTester) {
	t.addTypeImport(t.strCode(JawaTypeOpcode.BYTE_ARRAY.code), ValueTypes.NONE);
	var r = t.process();
	t.assertIsJawaArrayType(JawaTypes.BYTE, r[0]);
}

def test_t_primarray1(t: JawaTester) {
	for (c in JawaPrimArrayOpcodes) {
		var n = JawaTester.new(t.t);
		n.importPrimArray(c);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
	}
}

def test_env1(t: JawaTester) {
	var obj = JawaLang.OBJECT;
	var str = JawaLang.STRING;
	t.env.add(obj);
	t.env.add(str);
	t.importClass("jawa/lang/Object");
	t.importClass("jawa/lang/String");
	var r = t.process();
	t.assertIsJawaClassType(JawaLang.OBJECT, r[0]);
	t.assertIsJawaClassType(JawaLang.STRING, r[1]);
}

def test_env2(t: JawaTester) {
	JawaLang.install(t.env);
	t.importClass("jawa/lang/Object");
	t.importClass("jawa/lang/String");
	var r = t.process();
	t.assertIsJawaClassType(JawaLang.OBJECT, r[0]);
	t.assertIsJawaClassType(JawaLang.STRING, r[1]);
}

def test_t_refarray1(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	t.importArrayOf(jlo);
	var r = t.process();
	var elem = t.assertIsJawaClassType(JawaLang.OBJECT, r[0]);
	t.assertIsJawaArrayType(elem, r[1]);
}

def test_arrayN(t: JawaTester, et: AbsTypeDecl, dims: int) {
	t.importMultiArrayOf(et, dims);

	var r = t.process();

	var lastT = JawaType.!(r[et.imp.import_index]);
	for (i < dims) {
		if (lastT == null) return;
		lastT = t.assertIsJawaArrayType(lastT, r[et.imp.import_index + i + 1]);
	}
}

def test_t_refarrayN(t: JawaTester) {
	for (i < 7) {
		var n = JawaTester.new(t.t);
		var et = n.importJawaLangObject();
		test_arrayN(n, et, i);
	}
}

def test_t_primarrayN(t: JawaTester) {
	for (c in JawaPrimArrayOpcodes) {
		for (i < 4) {
			var n = JawaTester.new(t.t);
			var at = n.importPrimArray(c);
			test_arrayN(n, at, i);
		}
	}
}

def test_f_baload(t: JawaTester) {
	var bt = t.addTypeImport(t.strCode(JawaTypeOpcode.BYTE_ARRAY.code), ValueTypes.NONE);
	var sig = SigDecl.new([ValueType.Host(JawaTypes.BYTE_ARRAY), ValueType.I32], SigCache.arr_i);
	t.addFuncImport(t.strCode(JawaFuncOpcode.BALOAD.code), sig);
	var r = t.process();
	t.assertIsJawaArrayType(JawaTypes.BYTE, r[0]);
	t.assertIsFunction(sig, r[1]);
}

def test_f_xaload(t: JawaTester) {
	for (c in JawaPrimArrayOpcodes) {
		if (c == JawaPrimArrayOpcodes.BOOL) continue; // TODO: boolean => BALOAD
		var n = JawaTester.new(t.t);
		var bt = n.importPrimArray(c);
		var sig = SigDecl.new([ValueType.Host(c.arrayType), ValueType.I32], [c.map.valueType]);
		n.addFuncImport(n.strCode(c.xaload.code), sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		t.assertIsFunction(sig, r[1]);
	}
}

def test_f_bastore(t: JawaTester) {
	var bt = t.addTypeImport(t.strCode(JawaTypeOpcode.BYTE_ARRAY.code), ValueTypes.NONE);
	var sig = SigDecl.new([ValueType.Host(JawaTypes.BYTE_ARRAY), ValueType.I32, ValueType.I32], SigCache.arr_v);
	t.addFuncImport(t.strCode(JawaFuncOpcode.BASTORE.code), sig);
	var r = t.process();
	t.assertIsJawaArrayType(JawaTypes.BYTE, r[0]);
	t.assertIsFunction(sig, r[1]);
}

def test_f_xastore(t: JawaTester) {
	for (c in JawaPrimArrayOpcodes) {
		if (c == JawaPrimArrayOpcodes.BOOL) continue; // TODO: boolean => BALOAD
		var n = JawaTester.new(t.t);
		var bt = n.importPrimArray(c);
		var sig = SigDecl.new([ValueType.Host(c.arrayType), ValueType.I32, c.map.valueType], SigCache.arr_v);
		n.addFuncImport(t.strCode(c.xastore.code), sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		t.assertIsFunction(sig, r[1]);
	}
}

def test_f_bnewarray(t: JawaTester) {
	var bt = t.addTypeImport(t.strCode(JawaTypeOpcode.BYTE_ARRAY.code), ValueTypes.NONE);
	var vt = ValueType.Host(JawaTypes.BYTE_ARRAY);
	var sig = SigDecl.new(SigCache.arr_i, [vt]);
	def asm = t.strCodeType(JawaFuncOpcode.NEWARRAY.code, bt);
	t.addFuncImport(asm, sig);
	var r = t.process();
	t.assertIsJawaArrayType(JawaTypes.BYTE, r[0]);
	t.assertIsFunction(sig, r[1]);
}

def test_f_xnewarray(t: JawaTester) {
	for (c in JawaPrimArrayOpcodes) {
		var n = JawaTester.new(t.t);
		var bt = n.importPrimArray(c);
		var vt = ValueType.Host(c.arrayType);
		var sig = SigDecl.new(SigCache.arr_i, [vt]);
		def asm = t.strCodeType(JawaFuncOpcode.NEWARRAY.code, bt);
		n.addFuncImport(asm, sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		t.assertIsFunction(sig, r[1]);
	}
}

def test_f_arraylength1(t: JawaTester) {
	for (c in JawaPrimArrayOpcodes) {
		var n = JawaTester.new(t.t);
		var bt = n.importPrimArray(c);
		var vt = ValueType.Host(c.arrayType);
		var sig = SigDecl.new([vt], SigCache.arr_i);
		def asm = t.strCodeType(JawaFuncOpcode.ARRAYLENGTH.code, bt);
		n.addFuncImport(asm, sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		t.assertIsFunction(sig, r[1]);
	}
}

def test_f_arraylength2(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	var ajlo = t.importArrayOf(jlo);

	var sig = SigDecl.new([ValueType.Abstract(ajlo)], SigCache.arr_i);
	def asm = t.strCodeType(JawaFuncOpcode.ARRAYLENGTH.code, ajlo);
	t.addFuncImport(asm, sig);
	var r = t.process();

	var elem = t.assertIsJawaClassType(JawaLang.OBJECT, r[0]);
	var at = t.assertIsJawaArrayType(elem, r[1]);
	var expected_sig = SigDecl.new([ValueType.Host(at)], SigCache.arr_i);
	t.assertIsFunction(expected_sig, r[2]);
}

def test_f_multianewarrayN(t: JawaTester) {
	for (rank in [1, 2, 3, 7]) {
		for (dims < rank) {
			var n = JawaTester.new(t.t);
			var jlo = n.importJawaLangObject();
			var it = n.importMultiArrayOf(jlo, rank);
			var pair = n.make_multianewarray(it, dims);
			if (pair.0 == null) return;
			if (pair.1 == null) return;
		}
	}
}

def test_f_invokeinterface(t: JawaTester) {
	var intfName = "MyIntf", jintfName = JawaStrings.of(intfName);
	var methodName = "m6", jmethodName = JawaStrings.of(methodName);
	var it = JawaInterfaceType.new(jintfName, []);

	t.env.add(it);

	var pt = [JawaTypes.SHORT, JawaTypes.INT_ARRAY];
	var rt = JawaTypes.DOUBLE;
	var sig = SigDecl.new([ValueType.Host(it),
				ValueType.I32,
				ValueType.Host(JawaTypes.INT_ARRAY)],
				[ValueType.F64]);
	it.instanceMethods = [JawaMethod.new(jmethodName, NO_METHOD_ATTRS, JawaMethodSig.new(pt, rt), null)];

	var it1 = t.importInterface(intfName);
	var str1 = t.strCodeTypeJawaName(JawaFuncOpcode.INVOKEINTERFACE.code, it1, jmethodName);

	var fi = t.addFuncImport(str1, sig);

	var r = t.process();
	t.assertIsJawaInterfaceType(it, r[it1.imp.import_index]);
	var f = t.assertIsFunction(sig, r[fi.imp.import_index]);
}

def test_f_invokespecial(t: JawaTester) {
	var className = "MyCf4", jclassName = JawaStrings.of(className);
	var methodName = "yy", jmethodName = JawaStrings.of(methodName);
	var ct = JawaClassType.new(jclassName, NO_CLASS_ATTRS, null, []);
	ct.boilerplate = [];
	ct.instanceFields = [];


	t.env.add(ct);

	var pt = [JawaTypes.BYTE, JawaTypes.OBJECT, JawaTypes.BYTE_ARRAY];
	var rt = JawaTypes.FLOAT;
	var sig = SigDecl.new([ValueType.Host(ct),
				ValueType.I32,
				ValueType.Host(JawaTypes.OBJECT),
				ValueType.Host(JawaTypes.BYTE_ARRAY)],
				[ValueType.F32]);
	ct.instanceMethods = [JawaMethod.new(jmethodName, NO_METHOD_ATTRS, JawaMethodSig.new(pt, rt), null)];

	var it = t.importClass(className);
	var str1 = t.strCodeTypeJawaName(JawaFuncOpcode.INVOKESPECIAL.code, it, jmethodName);

	var fi = t.addFuncImport(str1, sig);

	var r = t.process();
	t.assertIsJawaClassType(ct, r[it.imp.import_index]);
	var f = t.assertIsFunction(sig, r[fi.imp.import_index]);
}

def test_f_invokestatic(t: JawaTester) {
	var className = "MyCg55", jclassName = JawaStrings.of(className);
	var methodName = "nnn", jmethodName = JawaStrings.of(methodName);
	var ct = JawaClassType.new(jclassName, NO_CLASS_ATTRS, null, []);
	ct.boilerplate = [];
	ct.instanceFields = [];

	var pts = [JawaTypes.BYTE, JawaTypes.INT, JawaTypes.FLOAT, JawaTypes.BYTE_ARRAY, JawaTypes.OBJECT];
	var rts = [JawaTypes.BYTE, JawaTypes.INT, JawaTypes.FLOAT, JawaTypes.BYTE_ARRAY, JawaTypes.OBJECT, JawaTypes.VOID];

	for (pt in pts) {
		for (rt in rts) {
			var n = JawaTester.new(t.t);
			n.env.add(ct);
			ct.staticMethods = [JawaMethod.new(jmethodName, NO_METHOD_ATTRS, JawaMethodSig.new([pt], rt), null)];

			var it = n.importClass(className);
			var str1 = n.strCodeTypeJawaName(JawaFuncOpcode.INVOKESTATIC.code, it, jmethodName);
			var sig = SigDecl.new([pt.valueType()], if(rt.kind == JawaKind.VOID, SigCache.arr_v, [rt.valueType()]));
			var fi = n.addFuncImport(str1, sig);

			var r = n.process();
			n.assertIsJawaClassType(ct, r[it.imp.import_index]);
			var f = n.assertIsFunction(sig, r[fi.imp.import_index]);
		}
	}
}

def test_f_invokevirtual(t: JawaTester) {
	var className = "Tyas", jclassName = JawaStrings.of(className);
	var methodName = "U8i", jmethodName = JawaStrings.of(methodName);
	var ct = JawaClassType.new(jclassName, NO_CLASS_ATTRS, null, []);
	ct.boilerplate = [];
	ct.instanceFields = [];

	var pts: Array<Array<JawaType>> = [
		[],
		[JawaTypes.INT],
		[JawaTypes.FLOAT, JawaTypes.DOUBLE]
	];
	var rt = JawaTypes.LONG;

	for (pt in pts) {
		var n = JawaTester.new(t.t);
		n.env.add(ct);
		ct.instanceMethods = [JawaMethod.new(jmethodName, NO_METHOD_ATTRS, JawaMethodSig.new(pt, rt), null)];

		var it = n.importClass(className);
		var str1 = n.strCodeTypeJawaName(JawaFuncOpcode.INVOKEVIRTUAL.code, it, jmethodName);

		var sig = SigDecl.new(Arrays.map(Arrays.prepend(ct, pt), JawaType.valueType), [ValueType.I64]);
		var fi = n.addFuncImport(str1, sig);

		var r = n.process();
		n.assertIsJawaClassType(ct, r[it.imp.import_index]);
		var f = n.assertIsFunction(sig, r[fi.imp.import_index]);
	}
}

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, JawaTester.new, _);
def X = [
	T("jawa:strhash", test_strhash),
	T("jawa:importcl1", test_importcl1),
	T("jawa:importi1", test_importi1),
	T("jawa:env1", test_env1),
	T("jawa:env2", test_env2),
	T("jawa:t_bytearray1", test_t_bytearray1),
	T("jawa:t_primarray1", test_t_primarray1),
	T("jawa:t_refarray1", test_t_refarray1),
	T("jawa:t_refarrayN", test_t_refarrayN),
	T("jawa:t_primarrayN", test_t_primarrayN),
	T("jawa:f_baload", test_f_baload),
	T("jawa:f_xaload", test_f_xaload),
	T("jawa:f_bastore", test_f_bastore),
	T("jawa:f_xastore", test_f_xastore),
	T("jawa:f_bnewarray", test_f_bnewarray),
	T("jawa:f_xnewarray", test_f_xnewarray),
	T("jawa:f_arraylength1", test_f_arraylength1),
	T("jawa:f_arraylength2", test_f_arraylength2),
	T("jawa:f_multianewarrayN", test_f_multianewarrayN),
	T("jawa:f_invokestatic", test_f_invokestatic),
	()
];

def strhash(s: string) -> int {
	return int.view(JawaStrings.of(s).hashCode());
}

def test_strhash(t: JawaTester) {
	// Test Jawa hash matches standardized string hashing algorithm
	t.t.asserti(97, strhash("a"));
	t.t.asserti(2027435274, strhash("agzAFZ09"));
	t.t.asserti(1998497278, strhash("!@#$%^&*()"));
}

def test_importcl1(t: JawaTester) {
	var d = t.env.declareClass(JawaStrings.of("Foo"), null, []);
	t.importClass("Foo");
	var r = t.process();
	t.assertIsJawaClassType(d, r[0]);
}

def test_importi1(t: JawaTester) {
	var d = t.env.declareInterface(JawaStrings.of("Graz"), []);
	t.importInterface("Graz");
	var r = t.process();
	t.assertIsJawaInterfaceType(d, r[0]);
}

def test_t_bytearray1(t: JawaTester) {
	t.addTypeImport([JawaTypeOpcode.BYTE_ARRAY.code], ValueTypes.NONE);
	var r = t.process();
	t.assertIsJawaArrayType(JawaTypes.BYTE, r[0]);
}

def test_t_primarray1(t: JawaTester) {
	for (c in JawaPrimArrayOpcodes) {
		var n = JawaTester.new(t.t);
		n.importPrimArray(c);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
	}
}

def test_env1(t: JawaTester) {
	var obj = JawaClasses.OBJECT;
	var str = JawaClasses.STRING;
	t.env.add(obj);
	t.env.add(str);
	t.importClass("jawa/lang/Object");
	t.importClass("jawa/lang/String");
	var r = t.process();
	t.assertIsJawaClassType(JawaClasses.OBJECT, r[0]);
	t.assertIsJawaClassType(JawaClasses.STRING, r[1]);
}

def test_env2(t: JawaTester) {
	JawaClasses.add(t.env);
	t.importClass("jawa/lang/Object");
	t.importClass("jawa/lang/String");
	var r = t.process();
	t.assertIsJawaClassType(JawaClasses.OBJECT, r[0]);
	t.assertIsJawaClassType(JawaClasses.STRING, r[1]);
}

def test_t_refarray1(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	t.importArrayOf(jlo);
	var r = t.process();
	var elem = t.assertIsJawaClassType(JawaClasses.OBJECT, r[0]);
	t.assertIsJawaArrayType(elem, r[1]);
}

def test_arrayN(t: JawaTester, et: ImportedType, dims: int) {
	t.importMultiArrayOf(et, dims);

	var r = t.process();

	var lastT = JawaType.!(r[et.import_index]);
	for (i < dims) {
		if (lastT == null) return;
		lastT = t.assertIsJawaArrayType(lastT, r[et.import_index + i + 1]);
	}
}

def test_t_refarrayN(t: JawaTester) {
	for (i < 7) {
		var n = JawaTester.new(t.t);
		var et = n.importJawaLangObject();
		test_arrayN(n, et, i);
	}
}

def test_t_primarrayN(t: JawaTester) {
	for (c in JawaPrimArrayOpcodes) {
		for (i < 4) {
			var n = JawaTester.new(t.t);
			var at = n.importPrimArray(c);
			test_arrayN(n, at, i);
		}
	}
}

def test_f_baload(t: JawaTester) {
	var bt = t.addTypeImport([JawaTypeOpcode.BYTE_ARRAY.code], ValueTypes.NONE);
	var sig = FuncSig.new([ValueType.Host(JawaTypes.BYTE_ARRAY), ValueType.I32], SigCache.arr_i);
	t.addFuncImport([JawaFuncOpcode.BALOAD.code], sig);
	var r = t.process();
	t.assertIsJawaArrayType(JawaTypes.BYTE, r[0]);
	t.assertIsFunction(sig, r[1]);
}

def test_f_xaload(t: JawaTester) {
	for (c in JawaPrimArrayOpcodes) {
		if (c == JawaPrimArrayOpcodes.BOOL) continue; // TODO: boolean => BALOAD
		var n = JawaTester.new(t.t);
		var bt = n.importPrimArray(c);
		var sig = FuncSig.new([ValueType.Host(c.arrayType), ValueType.I32], [c.map.valueType]);
		n.addFuncImport([c.xaload.code], sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		t.assertIsFunction(sig, r[1]);
	}
}

def test_f_bastore(t: JawaTester) {
	var bt = t.addTypeImport([JawaTypeOpcode.BYTE_ARRAY.code], ValueTypes.NONE);
	var sig = FuncSig.new([ValueType.Host(JawaTypes.BYTE_ARRAY), ValueType.I32, ValueType.I32], SigCache.arr_v);
	t.addFuncImport([JawaFuncOpcode.BASTORE.code], sig);
	var r = t.process();
	t.assertIsJawaArrayType(JawaTypes.BYTE, r[0]);
	t.assertIsFunction(sig, r[1]);
}

def test_f_xastore(t: JawaTester) {
	for (c in JawaPrimArrayOpcodes) {
		if (c == JawaPrimArrayOpcodes.BOOL) continue; // TODO: boolean => BALOAD
		var n = JawaTester.new(t.t);
		var bt = n.importPrimArray(c);
		var sig = FuncSig.new([ValueType.Host(c.arrayType), ValueType.I32, c.map.valueType], SigCache.arr_v);
		n.addFuncImport([c.xastore.code], sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		t.assertIsFunction(sig, r[1]);
	}
}

def test_f_bnewarray(t: JawaTester) {
	var bt = t.addTypeImport([JawaTypeOpcode.BYTE_ARRAY.code], ValueTypes.NONE);
	var vt = ValueType.Host(JawaTypes.BYTE_ARRAY);
	var sig = FuncSig.new(SigCache.arr_i, [vt]);
	def str = JawaAsm.new()
		.putc(JawaFuncOpcode.NEWARRAY.code)
		.put_ji4(bt.type_index)
		.extract();
	t.addFuncImport(str, sig);
	var r = t.process();
	t.assertIsJawaArrayType(JawaTypes.BYTE, r[0]);
	t.assertIsFunction(sig, r[1]);
}

def test_f_xnewarray(t: JawaTester) {
	for (c in JawaPrimArrayOpcodes) {
		var n = JawaTester.new(t.t);
		var bt = n.importPrimArray(c);
		var vt = ValueType.Host(c.arrayType);
		var sig = FuncSig.new(SigCache.arr_i, [vt]);
		def str = JawaAsm.new()
			.putc(JawaFuncOpcode.NEWARRAY.code)
			.put_ji4(bt.type_index)
			.extract();
		n.addFuncImport(str, sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		t.assertIsFunction(sig, r[1]);
	}
}

def test_f_arraylength1(t: JawaTester) {
	for (c in JawaPrimArrayOpcodes) {
		var n = JawaTester.new(t.t);
		var bt = n.importPrimArray(c);
		var vt = ValueType.Host(c.arrayType);
		var sig = FuncSig.new([vt], SigCache.arr_i);
		def str = JawaAsm.new()
			.putc(JawaFuncOpcode.ARRAYLENGTH.code)
			.put_ji4(bt.type_index)
			.extract();
		n.addFuncImport(str, sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		t.assertIsFunction(sig, r[1]);
	}
}

def test_f_arraylength2(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	var ajlo = t.importArrayOf(jlo);

	var sig = FuncSig.new([ValueType.Imported(ajlo)], SigCache.arr_i);
	def str = JawaAsm.new()
		.putc(JawaFuncOpcode.ARRAYLENGTH.code)
		.put_ji4(ajlo.type_index)
		.extract();
	t.addFuncImport(str, sig);
	var r = t.process();

	var elem = t.assertIsJawaClassType(JawaClasses.OBJECT, r[0]);
	var at = t.assertIsJawaArrayType(elem, r[1]);
	var expected_sig = FuncSig.new([ValueType.Host(at)], SigCache.arr_i);
	t.assertIsFunction(expected_sig, r[2]);
}

def test_f_multianewarrayN(t: JawaTester) {
	for (rank in [1, 2, 3, 7]) {
		for (dims < rank) {
			var n = JawaTester.new(t.t);
			var jlo = n.importJawaLangObject();
			var it = n.importMultiArrayOf(jlo, rank);
			var pair = n.make_multianewarray(it, dims);
			if (pair.0 == null) return;
			if (pair.1 == null) return;
		}
	}
}

def test_f_invokestatic(t: JawaTester) {
	var className = "MyClass", jclassName = JawaStrings.of(className);
	var methodName = "m1", jmethodName = JawaStrings.of(methodName);
	var ct = JawaClassType.new(jclassName, null, []);
	ct.boilerplate = [];
	ct.instanceFields = [];

	var pts = [JawaTypes.BYTE, JawaTypes.INT, JawaTypes.FLOAT, JawaTypes.BYTE_ARRAY, JawaTypes.OBJECT];
	var rts = [JawaTypes.BYTE, JawaTypes.INT, JawaTypes.FLOAT, JawaTypes.BYTE_ARRAY, JawaTypes.OBJECT, JawaTypes.VOID];

	for (pt in pts) {
		for (rt in rts) {
			var n = JawaTester.new(t.t);
			n.env.add(ct);
			ct.staticMethods = [JawaMethod.new(jmethodName, [pt], rt, null)];

			var it = n.importClass(className);
			var str1 = JawaAsm.new()
				.putc(JawaFuncOpcode.INVOKESTATIC.code)
				.put_ji4(it.type_index)
				.put_jname(jmethodName)
				.extract();
			var sig = FuncSig.new([pt.valueType()], if(rt.kind == JawaKind.VOID, SigCache.arr_v, [rt.valueType()]));
			var fi = n.addFuncImport(str1, sig);

			var r = n.process();
			n.assertIsJawaClassType(ct, r[it.import_index]);
			var f = n.assertIsFunction(sig, r[fi]);
		}
	}
}

// TODO	DEF_CLASS
// TODO	DEF_INTERFACE

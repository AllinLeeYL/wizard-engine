// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, JawaTester.new, _);
def X = [
	T("jawa:strhash", test_strhash),
	T("jawa:importcl1", test_importcl1),
	T("jawa:importi1", test_importi1),
	T("jawa:bytearr1", test_bytearr1),
	T("jawa:primarr1", test_primarr1),
	T("jawa:refarr1", test_refarr1),
	T("jawa:env1", test_env1),
	T("jawa:env2", test_env2),
	T("jawa:f_baload", test_f_baload),
	T("jawa:f_xaload", test_f_xaload),
	T("jawa:f_bastore", test_f_bastore),
	T("jawa:f_xastore", test_f_xastore),
	T("jawa:f_bnewarray", test_f_bnewarray),
	T("jawa:f_xnewarray", test_f_xnewarray),
	T("jawa:f_arraylength", test_f_arraylength),
	()
];

class JawaTester(t: Tester) extends ModuleBuilder {
	def err = WasmErrorGen.new("<JawaTest>");
	def env = JawaEnvironment.new(null);
	def asm = JawaAsm.new();
	def hash(s: string) -> int {
		return int.view(JawaStrings.of(s).hashCode());
	}
	def addImport(modname: string, fldname: string, details: ImportDetails) -> int {
		module.imports.put(ImportDecl.new(modname, fldname, details));
		return module.imports.length - 1;
	}
	def addTypeImport(typename: string, sup: Array<ValueType>) -> int {
		var imported = DefType.Imported(
			ImportedType.new(module.imports.length, module.types.size(), sup));
		var details = ImportDetails.Type(imported);
		module.imports.put(ImportDecl.new("jawa", typename, details));
		module.types.imported.put(imported);
		return module.types.imported.length - 1;
	}
	def addFuncImport(funcname: string, sig: FuncSig) -> int {
		var sig_index = addSig(sig);
		var func = FunctionDecl.new(module.functions.imported.length, sig_index, sig);
		module.functions.imported.put(func);
		var details = ImportDetails.Function(func);
		module.imports.put(ImportDecl.new("jawa", funcname, details));
		return module.functions.imported.length - 1;
	}
	def importClass(name: string) -> int {
		asm.reset();
		asm.putc(JawaTypeOpcode.EXT_CLASS.code);
		asm.put_jstr(JawaStrings.of(name));
		return addTypeImport(asm.extract(), ValueTypes.NONE);
	}
	def addClass(s: string, sup: JawaClass) -> JawaClass {
		var cl = JawaClass.new(JawaStrings.of(s), sup, JawaClasses.NO_INTERFACES);
		env.add(cl);
		return cl;
	}
	def importInterface(name: string) -> int {
		asm.reset();
		asm.putc(JawaTypeOpcode.EXT_INTERFACE.code);
		asm.put_jstr(JawaStrings.of(name));
		return addTypeImport(asm.extract(), ValueTypes.NONE);
	}
	def addInterface(s: string) -> JawaInterface {
		var cl = JawaInterface.new(JawaStrings.of(s), JawaClasses.NO_INTERFACES);
		env.add(cl);
		return cl;
	}
	def process() -> Array<Exportable> {
		var result = Array<Exportable>.new(module.imports.length);
		var jip = JawaImportProcessor.new(err, env, module, result);
		jip.process();
		if (err.error()) {
			t.fail(Strings.format1("expected success, got %s", err.error_msg));
		}
		return result;
	}
	def assertIsJawaType(jt: JawaType, e: Exportable) {
		match (e) {
			r: JawaExportedType => {
				if (r.host.t != jt) t.fail(Strings.format2("expected Jawa type %q, got %q", jt.render, r.host.t.render));
			}
			_ => {
				t.fail("expected ExportedType");
			}
		}
	}
}

class JawaAsm extends StringBuilder {
	def put_jstr(j: JawaString) {
		put_jawa_i2(j.chars.length);
		for (c in j.chars) pututf8(c);
	}
	def put_jawa_i2(v: int) {
		for (j < 2) {
			putc(u7.view(v));
			v = v >> 7;
		}
	}
	def put_jawa_i4(v: int) {
		for (j < 4) {
			putc(u7.view(v));
			v = v >> 7;
		}
	}
}

def test_strhash(t: JawaTester) {
	t.t.asserti(97, t.hash("a"));
	t.t.asserti(2027435274, t.hash("agzAFZ09"));
	t.t.asserti(1998497278, t.hash("!@#$%^&*()"));
}

def test_importcl1(t: JawaTester) {
	var d = t.addClass("Foo", null);
	t.importClass("Foo");
	var r = t.process();
	t.assertIsJawaType(JawaType.Class(d), r[0]);
}

def test_importi1(t: JawaTester) {
	var d = t.addInterface("Graz");
	t.importInterface("Graz");
	var r = t.process();
	t.assertIsJawaType(JawaType.Interface(d), r[0]);
}

def test_bytearr1(t: JawaTester) {
	t.addTypeImport([JawaTypeOpcode.BYTE_ARRAY.code], ValueTypes.NONE);
	var r = t.process();
	t.assertIsJawaType(JawaType.Array(JawaType.BYTE), r[0]);
}

enum JawaPrimArray(type_code: JawaTypeOpcode, xaload: JawaFuncOpcode, xastore: JawaFuncOpcode, t: JawaType, vt: ValueType) {
	BYTE(JawaTypeOpcode.BYTE_ARRAY, JawaFuncOpcode.BALOAD, JawaFuncOpcode.BASTORE, JawaType.BYTE, ValueType.I32),
	BOOL(JawaTypeOpcode.BOOL_ARRAY, JawaFuncOpcode.BALOAD, JawaFuncOpcode.BASTORE, JawaType.BOOL, ValueType.I32),
	CHAR(JawaTypeOpcode.CHAR_ARRAY, JawaFuncOpcode.CALOAD, JawaFuncOpcode.CASTORE, JawaType.CHAR, ValueType.I32),
	SHORT(JawaTypeOpcode.SHORT_ARRAY, JawaFuncOpcode.SALOAD, JawaFuncOpcode.SASTORE, JawaType.SHORT, ValueType.I32),
	INT(JawaTypeOpcode.INT_ARRAY, JawaFuncOpcode.IALOAD, JawaFuncOpcode.IASTORE, JawaType.INT, ValueType.I32),
	LONG(JawaTypeOpcode.LONG_ARRAY, JawaFuncOpcode.LALOAD, JawaFuncOpcode.LASTORE, JawaType.LONG, ValueType.I64),
	FLOAT(JawaTypeOpcode.FLOAT_ARRAY, JawaFuncOpcode.FALOAD, JawaFuncOpcode.LASTORE, JawaType.FLOAT, ValueType.F32),
	DOUBLE(JawaTypeOpcode.DOUBLE_ARRAY, JawaFuncOpcode.DALOAD, JawaFuncOpcode.LASTORE, JawaType.DOUBLE, ValueType.F64)
}

def test_primarr1(t: JawaTester) {
	for (c in JawaPrimArray) {
		var n = JawaTester.new(t.t);
		n.addTypeImport([c.type_code.code], ValueTypes.NONE);
		var r = n.process();
		n.assertIsJawaType(JawaType.Array(c.t), r[0]);
	}
}

def test_env1(t: JawaTester) {
	var obj = JawaClasses.OBJECT; 
	var str = JawaClasses.STRING; 
	t.env.add(obj);
	t.env.add(str);
	t.importClass("jawa/lang/Object");
	t.importClass("jawa/lang/String");
	var r = t.process();
	t.assertIsJawaType(JawaType.Class(obj), r[0]);
	t.assertIsJawaType(JawaType.Class(str), r[1]);
}

def test_env2(t: JawaTester) {
	JawaClasses.add(t.env);
	t.importClass("jawa/lang/Object");
	t.importClass("jawa/lang/String");
	var r = t.process();
	t.assertIsJawaType(JawaType.Class(JawaClasses.OBJECT), r[0]);
	t.assertIsJawaType(JawaType.Class(JawaClasses.STRING), r[1]);
}

def test_refarr1(t: JawaTester) {
	var obj = JawaClasses.OBJECT; 
	t.env.add(obj);
	var index = t.importClass("jawa/lang/Object");
	t.asm.reset();
	t.asm.putc(JawaTypeOpcode.REF_ARRAY.code);
	t.asm.put_jawa_i4(index);
	t.addTypeImport(t.asm.extract(), ValueTypes.NONE);
	var r = t.process();
	var ct = JawaType.Class(obj);
	t.assertIsJawaType(ct, r[0]);
	t.assertIsJawaType(JawaType.Array(ct), r[1]);
}

def test_f_baload(t: JawaTester) {
	var bt = t.addTypeImport([JawaTypeOpcode.BYTE_ARRAY.code], ValueTypes.NONE);
	var sig = FuncSig.new([ValueType.Host(JawaTypes.BYTE_ARRAY.host), ValueType.I32], SigCache.arr_i);
	t.addFuncImport([JawaFuncOpcode.BALOAD.code], sig);
	var r = t.process();
	t.assertIsJawaType(JawaTypes.BYTE_ARRAY.host.t, r[0]);
	t.t.assertT<Exportable, HostFunction>(r[1]);
}

def test_f_xaload(t: JawaTester) {
	for (c in JawaPrimArray) {
		var n = JawaTester.new(t.t);
		var bt = n.addTypeImport([c.type_code.code], ValueTypes.NONE);
		var sig = FuncSig.new([ValueType.Host(JawaTypes.BYTE_ARRAY.host), ValueType.I32], [c.vt]);
		n.addFuncImport([c.xaload.code], sig);
		var r = n.process();
		n.assertIsJawaType(JawaType.Array(c.t), r[0]);
		n.t.assertT<Exportable, HostFunction>(r[1]);
	}
}

def test_f_bastore(t: JawaTester) {
	var bt = t.addTypeImport([JawaTypeOpcode.BYTE_ARRAY.code], ValueTypes.NONE);
	var sig = FuncSig.new([ValueType.Host(JawaTypes.BYTE_ARRAY.host), ValueType.I32, ValueType.I32], SigCache.arr_v);
	t.addFuncImport([JawaFuncOpcode.BASTORE.code], sig);
	var r = t.process();
	t.assertIsJawaType(JawaTypes.BYTE_ARRAY.host.t, r[0]);
	t.t.assertT<Exportable, HostFunction>(r[1]);
}

def test_f_xastore(t: JawaTester) {
	for (c in JawaPrimArray) {
		var n = JawaTester.new(t.t);
		var at = JawaType.Array(c.t);
		var bt = n.addTypeImport([c.type_code.code], ValueTypes.NONE);
		var sig = FuncSig.new([ValueType.Host(JawaHostType.new(at)), ValueType.I32, c.vt], SigCache.arr_v);
		n.addFuncImport([c.xastore.code], sig);
		var r = n.process();
		n.assertIsJawaType(at, r[0]);
		n.t.assertT<Exportable, HostFunction>(r[1]);
	}
}

def test_f_bnewarray(t: JawaTester) {
	var bt = t.addTypeImport([JawaTypeOpcode.BYTE_ARRAY.code], ValueTypes.NONE);
	var vt = ValueType.Host(JawaTypes.BYTE_ARRAY.host);
	var sig = FuncSig.new(SigCache.arr_i, [vt]);
	t.asm.reset();
	t.asm.putc(JawaFuncOpcode.NEWARRAY.code);
	t.asm.put_jawa_i4(bt);
	t.addFuncImport(t.asm.extract(), sig);
	var r = t.process();
	t.assertIsJawaType(JawaTypes.BYTE_ARRAY.host.t, r[0]);
	t.t.assertT<Exportable, HostFunction>(r[1]);
}

def test_f_xnewarray(t: JawaTester) {
	for (c in JawaPrimArray) {
		var n = JawaTester.new(t.t);
		var bt = n.addTypeImport([c.type_code.code], ValueTypes.NONE);
		var vt = ValueType.Host(JawaHostType.new(c.t));
		var sig = FuncSig.new(SigCache.arr_i, [vt]);
		n.asm.reset();
		n.asm.putc(JawaFuncOpcode.NEWARRAY.code);
		n.asm.put_jawa_i4(bt);
		n.addFuncImport(n.asm.extract(), sig);
		var r = n.process();
		n.assertIsJawaType(JawaType.Array(c.t), r[0]);
		n.t.assertT<Exportable, HostFunction>(r[1]);
	}
}

def test_f_arraylength(t: JawaTester) {
	// TODO: arraylength of ref array
	for (c in JawaPrimArray) {
		var n = JawaTester.new(t.t);
		var bt = n.addTypeImport([c.type_code.code], ValueTypes.NONE);
		var vt = ValueType.Host(JawaHostType.new(c.t));
		var sig = FuncSig.new([vt], SigCache.arr_i);
		n.asm.reset();
		n.asm.putc(JawaFuncOpcode.ARRAYLENGTH.code);
		n.asm.put_jawa_i4(bt);
		n.addFuncImport(n.asm.extract(), sig);
		var r = n.process();
		n.assertIsJawaType(JawaType.Array(c.t), r[0]);
		n.t.assertT<Exportable, HostFunction>(r[1]);
	}
}

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT(_, JawaTester.new, _);
def X = [
	T("jawa:strhash", test_strhash),
	T("jawa:importcl1", test_importcl1),
	T("jawa:importi1", test_importi1),
	T("jawa:bytearr1", test_bytearr1),
	T("jawa:primarr1", test_primarr1),
	T("jawa:refarr1", test_refarr1),
	T("jawa:env1", test_env1),
	T("jawa:env2", test_env2),
	T("jawa:f_baload", test_f_baload),
	T("jawa:f_xaload", test_f_xaload),
	T("jawa:f_bastore", test_f_bastore),
	T("jawa:f_xastore", test_f_xastore),
	T("jawa:f_bnewarray", test_f_bnewarray),
	T("jawa:f_xnewarray", test_f_xnewarray),
	T("jawa:f_arraylength1", test_f_arraylength1),
	T("jawa:f_arraylength2", test_f_arraylength2),
	T("jawa:exe_baload", test_exe_baload),
	T("jawa:exe_caload", test_exe_caload),
	T("jawa:exe_daload", test_exe_daload),
	T("jawa:exe_faload", test_exe_faload),
	T("jawa:exe_iaload", test_exe_iaload),
	T("jawa:exe_laload", test_exe_laload),
	T("jawa:exe_saload", test_exe_saload),
	T("jawa:exe_bastore", test_exe_bastore),
	T("jawa:exe_castore", test_exe_castore),
	T("jawa:exe_dastore", test_exe_dastore),
	T("jawa:exe_fastore", test_exe_fastore),
	T("jawa:exe_iastore", test_exe_iastore),
	T("jawa:exe_lastore", test_exe_lastore),
	T("jawa:exe_sastore", test_exe_sastore),
	T("jawa:exe_xnewarray", test_exe_xnewarray),
	T("jawa:exe_arraylength1", test_exe_arraylength1),
	T("jawa:exe_arraylength2", test_exe_arraylength2),
	T("jawa:exe_acmpeq", test_exe_acmpeq),
	T("jawa:exe_acmpne", test_exe_acmpeq),
()
];

class JawaTester(t: Tester) extends ModuleBuilder {
	def err = WasmErrorGen.new("<JawaTest>");
	def env = JawaEnvironment.new(null);
	def asm = JawaAsm.new();
	def hash(s: string) -> int {
		return int.view(JawaStrings.of(s).hashCode());
	}
	def addTypeImport(typename: string, sup: Array<ValueType>) -> ImportedType {
		// TODO: module/type index spaces
		var it = ImportedType.new(module.imports.length, module.types.imported.length, sup);
		var imported = DefType.Imported(it);
		var details = ImportDetails.Type(imported);
		module.imports.put(ImportDecl.new("jawa", typename, details));
		module.types.imported.put(imported);
		return it;
	}
	def addFuncImport(funcname: string, sig: FuncSig) -> int {
		var sig_index = addSig(sig);
		var func = FunctionDecl.new(module.functions.imported.length, sig_index, sig);
		module.functions.imported.put(func);
		var details = ImportDetails.Function(func);
		module.imports.put(ImportDecl.new("jawa", funcname, details));
		return module.functions.imported.length - 1;
	}
	def importClass(name: string) -> ImportedType {
		asm.reset();
		asm.putc(JawaTypeOpcode.EXT_CLASS.code);
		asm.put_jstr(JawaStrings.of(name));
		return addTypeImport(asm.extract(), ValueTypes.NONE);
	}
	def addClass(s: string, sup: JawaClass) -> JawaClass {
		var cl = JawaClass.new(JawaStrings.of(s), sup, JawaClasses.NO_INTERFACES);
		env.add(cl);
		return cl;
	}
	def importInterface(name: string) -> ImportedType {
		asm.reset();
		asm.putc(JawaTypeOpcode.EXT_INTERFACE.code);
		asm.put_jstr(JawaStrings.of(name));
		return addTypeImport(asm.extract(), ValueTypes.NONE);
	}
	def importArrayOf(type_index: int) -> ImportedType {
		asm.reset();
		asm.putc(JawaTypeOpcode.REF_ARRAY.code);
		asm.put_jawa_i4(type_index);
		return addTypeImport(asm.extract(), ValueTypes.NONE);
	}
	def addInterface(s: string) -> JawaInterface {
		var cl = JawaInterface.new(JawaStrings.of(s), JawaClasses.NO_INTERFACES);
		env.add(cl);
		return cl;
	}
	def process() -> Array<Exportable> {
		var result = Array<Exportable>.new(module.imports.length);
		var jip = JawaImportProcessor.new(err, env, module, result);
		jip.process();
		if (err.error()) {
			t.fail(Strings.format1("expected success, got %s", err.error_msg));
		}
		return result;
	}
	def assertIsJawaType(jt: JawaType, e: Exportable) {
		match (e) {
			r: JawaExportedType => {
				if (r.host.t != jt) t.fail(Strings.format2("expected Jawa type %q, got %q", jt.render, r.host.t.render));
			}
			_ => {
				t.fail("expected ExportedType");
			}
		}
	}
	def assertIsJawaObject(r: Result) -> JawaObject {
		if (!Result.Value.?(r)) {
			t.fail(Strings.format1("expected array return, got %q", r.render));
			return null;
		}
		var vr = Result.Value.!(r);
		if (vr.vals.length != 1) {
			t.fail(Strings.format1("expected 1 result value, got %q", r.render));
			return null;
		}
		var val = vr.vals[0];
		if (!Value.ExternRef.?(val)) {
			t.fail(Strings.format1("expected jawa object, got %q", Values.render(_, val)));
			return null;
		}
		var ext = Value.ExternRef.!(val);
		if (!JawaObject.?(ext.val)) {
			t.fail(Strings.format1("expected jawa object, got %q", ext.val.render));
			return null;
		}
		return JawaObject.!(ext.val);
	}
	def assertIsJawaArrayObjectOf<T>(obj: JawaObject) -> JawaArrayObjectOf<T> {
		if (!JawaArrayObjectOf<T>.?(obj)) {
			t.fail(Strings.format1("expected jawa array, got %q", obj.render));
			return null;
		}
		return JawaArrayObjectOf<T>.!(obj);
	}
	def assertIsFunction(expected_sig: FuncSig, e: Exportable) -> Function {
		if (!Function.?(e)) {
			t.fail("expected Function");
			return null;
		}
		var f = Function.!(e);
		if (!f.sig.isAssignableSig(expected_sig)) {
			t.fail(Strings.format2("expected Function of type %q, got %q", expected_sig.render, f.sig.render));
			return null;
		}
		return f;
	}
	def assert_r(expected: Result, got: Result) {
		if (expected.equals(got)) return;
		t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_v(expected: Value, got: Result) {
		assert_r(Result.Value([expected]), got);
	}
	def assert_a<T>(expected: Array<T>, got: Array<T>) {
		if (!assert_length(expected, got)) return;
		for (i < expected.length) {
			if (expected[i] != got[i]) return t.fail(Strings.format1("mismatch at array[%d]", i));
		}
	}
	def assert_da(expected: Array<double>, got: Array<double>) {
		if (!assert_length(expected, got)) return;
		for (i < expected.length) {
			if (u64.view(expected[i]) != u64.view(got[i])) return t.fail(Strings.format1("mismatch at array[%d]", i));
		}
	}
	def assert_fa(expected: Array<float>, got: Array<float>) {
		if (!assert_length(expected, got)) return;
		for (i < expected.length) {
			if (u32.view(expected[i]) != u32.view(got[i])) return t.fail(Strings.format1("mismatch at array[%d]", i));
		}
	}
	def assert_length<T>(expected: Array<T>, got: Array<T>) -> bool {
		if (expected.length != got.length) {
			t.fail(Strings.format2("expected array of %d length, got %d", expected.length, got.length));
			return false;
		}
		return true;
	}
}

def NPE = Result.Trap(TrapReason.ERROR); // TODO: more precise error checking
def AIOBE = Result.Trap(TrapReason.ERROR); // TODO: more precise error checking
def NASE = Result.Trap(TrapReason.ERROR); // TODO: more precise error checking

// Value conversion helpers.
def i_v = Values.i_v;
def l_v = Values.l_v;
def d_v = Value.F64;
def f_v = Value.F32;

def t_r<T>(f: T -> Value, v: T) -> Result { // T -> Value -> Result
	return Result.Value([f(v)]);
}

def i_r = t_r(Values.i_v, _); // i32 -> Result
def d_r = t_r(Value.F64, _);  // double -> Result
def f_r = t_r(Value.F32, _);  // float -> Result
def l_r = t_r(Values.l_v, _); // long -> Result

def vi_vv(v1: Value, v2: int) -> Array<Value> {
	return [v1, i_v(v2)];
}

def rNONE = Result.Value(Values.NONE);

// A helper to emit the import language.
class JawaAsm extends StringBuilder {
	def put_jstr(j: JawaString) {
		put_jawa_i2(j.chars.length);
		for (c in j.chars) pututf8(c);
	}
	def put_jawa_i2(v: int) {
		for (j < 2) {
			putc(u7.view(v));
			v = v >> 7;
		}
	}
	def put_jawa_i4(v: int) {
		for (j < 4) {
			putc(u7.view(v));
			v = v >> 7;
		}
	}
}

def test_strhash(t: JawaTester) {
	t.t.asserti(97, t.hash("a"));
	t.t.asserti(2027435274, t.hash("agzAFZ09"));
	t.t.asserti(1998497278, t.hash("!@#$%^&*()"));
}

def test_importcl1(t: JawaTester) {
	var d = t.addClass("Foo", null);
	t.importClass("Foo");
	var r = t.process();
	t.assertIsJawaType(JawaType.Class(d), r[0]);
}

def test_importi1(t: JawaTester) {
	var d = t.addInterface("Graz");
	t.importInterface("Graz");
	var r = t.process();
	t.assertIsJawaType(JawaType.Interface(d), r[0]);
}

def test_bytearr1(t: JawaTester) {
	t.addTypeImport([JawaTypeOpcode.BYTE_ARRAY.code], ValueTypes.NONE);
	var r = t.process();
	t.assertIsJawaType(JawaType.Array(JawaType.BYTE), r[0]);
}

enum JawaPrimArray(type_code: JawaTypeOpcode, xaload: JawaFuncOpcode, xastore: JawaFuncOpcode, map: JawaPrimTypeMap) {
	BYTE(JawaTypeOpcode.BYTE_ARRAY, JawaFuncOpcode.BALOAD, JawaFuncOpcode.BASTORE, JawaTypes.BYTE_MAP),
	BOOL(JawaTypeOpcode.BOOL_ARRAY, JawaFuncOpcode.BALOAD, JawaFuncOpcode.BASTORE, JawaTypes.BOOL_MAP),
	CHAR(JawaTypeOpcode.CHAR_ARRAY, JawaFuncOpcode.CALOAD, JawaFuncOpcode.CASTORE, JawaTypes.CHAR_MAP),
	SHORT(JawaTypeOpcode.SHORT_ARRAY, JawaFuncOpcode.SALOAD, JawaFuncOpcode.SASTORE, JawaTypes.SHORT_MAP),
	INT(JawaTypeOpcode.INT_ARRAY, JawaFuncOpcode.IALOAD, JawaFuncOpcode.IASTORE, JawaTypes.INT_MAP),
	LONG(JawaTypeOpcode.LONG_ARRAY, JawaFuncOpcode.LALOAD, JawaFuncOpcode.LASTORE, JawaTypes.LONG_MAP),
	FLOAT(JawaTypeOpcode.FLOAT_ARRAY, JawaFuncOpcode.FALOAD, JawaFuncOpcode.FASTORE, JawaTypes.FLOAT_MAP),
	DOUBLE(JawaTypeOpcode.DOUBLE_ARRAY, JawaFuncOpcode.DALOAD, JawaFuncOpcode.DASTORE, JawaTypes.DOUBLE_MAP)
}

def test_primarr1(t: JawaTester) {
	for (c in JawaPrimArray) {
		var n = JawaTester.new(t.t);
		n.addTypeImport([c.type_code.code], ValueTypes.NONE);
		var r = n.process();
		n.assertIsJawaType(c.map.jawaArrayType, r[0]);
	}
}

def test_env1(t: JawaTester) {
	var obj = JawaClasses.OBJECT;
	var str = JawaClasses.STRING;
	t.env.add(obj);
	t.env.add(str);
	t.importClass("jawa/lang/Object");
	t.importClass("jawa/lang/String");
	var r = t.process();
	t.assertIsJawaType(JawaType.Class(obj), r[0]);
	t.assertIsJawaType(JawaType.Class(str), r[1]);
}

def test_env2(t: JawaTester) {
	JawaClasses.add(t.env);
	t.importClass("jawa/lang/Object");
	t.importClass("jawa/lang/String");
	var r = t.process();
	t.assertIsJawaType(JawaType.Class(JawaClasses.OBJECT), r[0]);
	t.assertIsJawaType(JawaType.Class(JawaClasses.STRING), r[1]);
}

def test_refarr1(t: JawaTester) {
	var obj = JawaClasses.OBJECT;
	t.env.add(obj);
	var jlo = t.importClass("jawa/lang/Object");
	t.importArrayOf(jlo.type_index);
	var r = t.process();
	t.assertIsJawaType(JawaType.Class(obj), r[0]);
	t.assertIsJawaType(JawaType.Array(JawaType.Class(obj)), r[1]);
}

def test_f_baload(t: JawaTester) {
	var bt = t.addTypeImport([JawaTypeOpcode.BYTE_ARRAY.code], ValueTypes.NONE);
	var sig = FuncSig.new([JawaTypes.BYTE_MAP.jawaArrayValueType, ValueType.I32], SigCache.arr_i);
	t.addFuncImport([JawaFuncOpcode.BALOAD.code], sig);
	var r = t.process();
	t.assertIsJawaType(JawaTypes.BYTE_ARRAY.host.t, r[0]);
	t.assertIsFunction(sig, r[1]);
}

def test_f_xaload(t: JawaTester) {
	for (c in JawaPrimArray) {
		if (c == JawaPrimArray.BOOL) continue; // TODO: boolean => BALOAD
		var n = JawaTester.new(t.t);
		var bt = n.addTypeImport([c.type_code.code], ValueTypes.NONE);
		var sig = FuncSig.new([c.map.jawaArrayValueType, ValueType.I32], [c.map.valueType]);
		n.addFuncImport([c.xaload.code], sig);
		var r = n.process();
		n.assertIsJawaType(c.map.jawaArrayType, r[0]);
		t.assertIsFunction(sig, r[1]);
	}
}

def test_f_bastore(t: JawaTester) {
	var bt = t.addTypeImport([JawaTypeOpcode.BYTE_ARRAY.code], ValueTypes.NONE);
	var sig = FuncSig.new([JawaTypes.BYTE_MAP.jawaArrayValueType, ValueType.I32, ValueType.I32], SigCache.arr_v);
	t.addFuncImport([JawaFuncOpcode.BASTORE.code], sig);
	var r = t.process();
	t.assertIsJawaType(JawaTypes.BYTE_ARRAY.host.t, r[0]);
	t.assertIsFunction(sig, r[1]);
}

def test_f_xastore(t: JawaTester) {
	for (c in JawaPrimArray) {
		if (c == JawaPrimArray.BOOL) continue; // TODO: boolean => BALOAD
		var n = JawaTester.new(t.t);
		var bt = n.addTypeImport([c.type_code.code], ValueTypes.NONE);
		var sig = FuncSig.new([c.map.jawaArrayValueType, ValueType.I32, c.map.valueType], SigCache.arr_v);
		n.addFuncImport([c.xastore.code], sig);
		var r = n.process();
		n.assertIsJawaType(c.map.jawaArrayType, r[0]);
		t.assertIsFunction(sig, r[1]);
	}
}

def test_f_bnewarray(t: JawaTester) {
	var bt = t.addTypeImport([JawaTypeOpcode.BYTE_ARRAY.code], ValueTypes.NONE);
	var vt = ValueType.Host(JawaTypes.BYTE_ARRAY.host);
	var sig = FuncSig.new(SigCache.arr_i, [vt]);
	t.asm.reset();
	t.asm.putc(JawaFuncOpcode.NEWARRAY.code);
	t.asm.put_jawa_i4(bt.type_index);
	t.addFuncImport(t.asm.extract(), sig);
	var r = t.process();
	t.assertIsJawaType(JawaTypes.BYTE_ARRAY.host.t, r[0]);
	t.assertIsFunction(sig, r[1]);
}

def test_f_xnewarray(t: JawaTester) {
	for (c in JawaPrimArray) {
		var n = JawaTester.new(t.t);
		var bt = n.addTypeImport([c.type_code.code], ValueTypes.NONE);
		var vt = c.map.jawaArrayValueType;
		var sig = FuncSig.new(SigCache.arr_i, [vt]);
		n.asm.reset();
		n.asm.putc(JawaFuncOpcode.NEWARRAY.code);
		n.asm.put_jawa_i4(bt.type_index);
		n.addFuncImport(n.asm.extract(), sig);
		var r = n.process();
		n.assertIsJawaType(c.map.jawaArrayType, r[0]);
		t.assertIsFunction(sig, r[1]);
	}
}

def test_f_arraylength1(t: JawaTester) {
	for (c in JawaPrimArray) {
		var n = JawaTester.new(t.t);
		var bt = n.addTypeImport([c.type_code.code], ValueTypes.NONE);
		var vt = c.map.jawaArrayValueType;
		var sig = FuncSig.new([vt], SigCache.arr_i);
		n.asm.reset();
		n.asm.putc(JawaFuncOpcode.ARRAYLENGTH.code);
		n.asm.put_jawa_i4(bt.type_index);
		n.addFuncImport(n.asm.extract(), sig);
		var r = n.process();
		n.assertIsJawaType(c.map.jawaArrayType, r[0]);
		t.assertIsFunction(sig, r[1]);
	}
}

def test_f_arraylength2(t: JawaTester) {
	var obj = JawaClasses.OBJECT;
	t.env.add(obj);
	var jlo = t.importClass("jawa/lang/Object");
	var ajlo = t.importArrayOf(jlo.type_index);

	var sig = FuncSig.new([ValueType.Imported(ajlo)], SigCache.arr_i);
	t.asm.reset();
	t.asm.putc(JawaFuncOpcode.ARRAYLENGTH.code);
	t.asm.put_jawa_i4(ajlo.type_index);
	t.addFuncImport(t.asm.extract(), sig);
	var r = t.process();

	t.assertIsJawaType(JawaType.Class(obj), r[0]);
	t.assertIsJawaType(JawaType.Array(JawaType.Class(obj)), r[1]);
	var xt = r[1];
	if (ExportedType.?(xt)) { // XXX: perform a substitute on the imported sig instead?
		var vt = ExportedType.!(xt).rep;
		var expected_sig = FuncSig.new([vt], SigCache.arr_i);
		t.assertIsFunction(expected_sig, r[2]);
	}
}

def make_xaload(t: JawaTester, c: JawaPrimArray) -> Function {
	var n = JawaTester.new(t.t);
	var bt = n.addTypeImport([c.type_code.code], ValueTypes.NONE);
	var at = c.map.jawaArrayType;
	var expected_sig = FuncSig.new([c.map.jawaArrayValueType, ValueType.I32], [c.map.valueType]);
	n.addFuncImport([c.xaload.code], expected_sig);
	var r = n.process();
	n.assertIsJawaType(at, r[0]);
	return t.assertIsFunction(expected_sig, r[1]);
}

def test_exe_baload(t: JawaTester) {
	var func = make_xaload(t, JawaPrimArray.BYTE);
	if (func == null) return;
	def run = Interpreter.new().run(100, func, _);
	var array = Value.ExternRef(JawaArrayObjectOf<i8>.new([
		8, 102, -116
	]));

	t.assert_r(NPE, run(vi_vv(Values.EXTERNREF_NULL, 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 3)));
	t.assert_r(AIOBE, run(vi_vv(array, 5)));
	t.assert_r(AIOBE, run(vi_vv(array, 999)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_r(i_r(8), run(vi_vv(array, 0)));
	t.assert_r(i_r(102), run(vi_vv(array, 1)));
	t.assert_r(i_r(-116), run(vi_vv(array, 2)));
}

def test_exe_caload(t: JawaTester) {
	var func = make_xaload(t, JawaPrimArray.CHAR);
	if (func == null) return;
	def run = Interpreter.new().run(100, func, _);
	var array = Value.ExternRef(JawaArrayObjectOf<u16>.new([
		7, 10000, 32767, u16.max
	]));

	t.assert_r(NPE, run(vi_vv(Values.EXTERNREF_NULL, 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 4)));
	t.assert_r(AIOBE, run(vi_vv(array, 5)));
	t.assert_r(AIOBE, run(vi_vv(array, 9991)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_r(i_r(7), run(vi_vv(array, 0)));
	t.assert_r(i_r(10000), run(vi_vv(array, 1)));
	t.assert_r(i_r(32767), run(vi_vv(array, 2)));
	t.assert_r(i_r(65535), run(vi_vv(array, 3)));
}

def test_exe_daload(t: JawaTester) {
	var func = make_xaload(t, JawaPrimArray.DOUBLE);
	if (func == null) return;
	def run = Interpreter.new().run(100, func, _);
	var array = Value.ExternRef(JawaArrayObjectOf<double>.new([
		double.view(0x4021cccccccccccd),
		double.view(0xc073000000000000),
		double.view(0x7ff8000000000000),
		double.view(0x7ff0000000000000)
	]));

	t.assert_r(NPE, run(vi_vv(Values.EXTERNREF_NULL, 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 4)));
	t.assert_r(AIOBE, run(vi_vv(array, 5)));
	t.assert_r(AIOBE, run(vi_vv(array, 9991)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_r(d_r(0x4021cccccccccccd), run(vi_vv(array, 0)));
	t.assert_r(d_r(0xc073000000000000), run(vi_vv(array, 1)));
	t.assert_r(d_r(0x7ff8000000000000), run(vi_vv(array, 2)));
	t.assert_r(d_r(0x7ff0000000000000), run(vi_vv(array, 3)));
}

def test_exe_faload(t: JawaTester) {
	var func = make_xaload(t, JawaPrimArray.FLOAT);
	if (func == null) return;
	def run = Interpreter.new().run(100, func, _);
	var array = Value.ExternRef(JawaArrayObjectOf<float>.new([
		float.view(0x410e6666),
		float.view(0xc3510000),
		float.view(0x7fc00000),
		float.view(0x7f800000)
	]));

	t.assert_r(NPE, run(vi_vv(Values.EXTERNREF_NULL, 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 4)));
	t.assert_r(AIOBE, run(vi_vv(array, 5)));
	t.assert_r(AIOBE, run(vi_vv(array, 9991)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_r(f_r(0x410e6666), run(vi_vv(array, 0)));
	t.assert_r(f_r(0xc3510000), run(vi_vv(array, 1)));
	t.assert_r(f_r(0x7fc00000), run(vi_vv(array, 2)));
	t.assert_r(f_r(0x7f800000), run(vi_vv(array, 3)));
}

def test_exe_iaload(t: JawaTester) {
	var func = make_xaload(t, JawaPrimArray.INT);
	if (func == null) return;
	def run = Interpreter.new().run(100, func, _);
	var array = Value.ExternRef(JawaArrayObjectOf<i32>.new([
		5, 10100, int.min, int.max
	]));

	t.assert_r(NPE, run(vi_vv(Values.EXTERNREF_NULL, 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 4)));
	t.assert_r(AIOBE, run(vi_vv(array, 5)));
	t.assert_r(AIOBE, run(vi_vv(array, 9191)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_r(i_r(5), run(vi_vv(array, 0)));
	t.assert_r(i_r(10100), run(vi_vv(array, 1)));
	t.assert_r(i_r(int.min), run(vi_vv(array, 2)));
	t.assert_r(i_r(int.max), run(vi_vv(array, 3)));
}

def test_exe_laload(t: JawaTester) {
	var func = make_xaload(t, JawaPrimArray.LONG);
	if (func == null) return;
	def run = Interpreter.new().run(100, func, _);
	var array = Value.ExternRef(JawaArrayObjectOf<i64>.new([
		5, 10100, int.min, int.max, long.min, long.max
	]));

	t.assert_r(NPE, run(vi_vv(Values.EXTERNREF_NULL, 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 6)));
	t.assert_r(AIOBE, run(vi_vv(array, 7)));
	t.assert_r(AIOBE, run(vi_vv(array, 9291)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_r(l_r(5), run(vi_vv(array, 0)));
	t.assert_r(l_r(10100), run(vi_vv(array, 1)));
	t.assert_r(l_r(int.min), run(vi_vv(array, 2)));
	t.assert_r(l_r(int.max), run(vi_vv(array, 3)));
	t.assert_r(l_r(long.min), run(vi_vv(array, 4)));
	t.assert_r(l_r(long.max), run(vi_vv(array, 5)));
}

def test_exe_saload(t: JawaTester) {
	var func = make_xaload(t, JawaPrimArray.SHORT);
	if (func == null) return;
	def run = Interpreter.new().run(100, func, _);
	var array = Value.ExternRef(JawaArrayObjectOf<i16>.new([
		6, 10103, -20004, i16.min, i16.max
	]));

	t.assert_r(NPE, run(vi_vv(Values.EXTERNREF_NULL, 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 5)));
	t.assert_r(AIOBE, run(vi_vv(array, 6)));
	t.assert_r(AIOBE, run(vi_vv(array, 9995)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_r(i_r(6), run(vi_vv(array, 0)));
	t.assert_r(i_r(10103), run(vi_vv(array, 1)));
	t.assert_r(i_r(-20004), run(vi_vv(array, 2)));
	t.assert_r(i_r(i16.min), run(vi_vv(array, 3)));
	t.assert_r(i_r(i16.max), run(vi_vv(array, 4)));
}

def make_xastore(t: JawaTester, c: JawaPrimArray) -> Function {
	var n = JawaTester.new(t.t);
	var bt = n.addTypeImport([c.type_code.code], ValueTypes.NONE);
	var at = c.map.jawaArrayType;
	var expected_sig = FuncSig.new([c.map.jawaArrayValueType, ValueType.I32, c.map.valueType], SigCache.arr_v);
	n.addFuncImport([c.xastore.code], expected_sig);
	var r = n.process();
	n.assertIsJawaType(at, r[0]);
	return t.assertIsFunction(expected_sig, r[1]);
}

def test_exe_bastore(t: JawaTester) {
	var func = make_xastore(t, JawaPrimArray.BYTE);
	if (func == null) return;
	def run = Interpreter.new().run(100, func, _);
	var array = JawaArrayObjectOf<i8>.new([
		-1, 2, 11, 123, -109
	]);
	var ref = Value.ExternRef(array), zero = Values.I32_0;

	t.assert_r(NPE, run([Values.EXTERNREF_NULL, zero, zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(29995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	t.assert_r(rNONE, run([ref, i_v(0), zero]));
	t.assert_a<i8>([0, 2, 11, 123, -109], array.elems);

	t.assert_r(rNONE, run([ref, i_v(1), i_v(99)]));
	t.assert_a<i8>([0, 99, 11, 123, -109], array.elems);

	t.assert_r(rNONE, run([ref, i_v(2), i_v(-5)]));
	t.assert_a<i8>([0, 99, -5, 123, -109], array.elems);

	t.assert_r(rNONE, run([ref, i_v(3), i_v(44)]));
	t.assert_a<i8>([0, 99, -5, 44, -109], array.elems);

	t.assert_r(rNONE, run([ref, i_v(4), i_v(i8.max)]));
	t.assert_a<i8>([0, 99, -5, 44, i8.max], array.elems);
}

def test_exe_castore(t: JawaTester) {
	var func = make_xastore(t, JawaPrimArray.CHAR);
	if (func == null) return;
	def run = Interpreter.new().run(100, func, _);
	var array = JawaArrayObjectOf<u16>.new([
		1, 2, 11, 12345, 65535
	]);
	var ref = Value.ExternRef(array), zero = Values.I32_0;

	t.assert_r(NPE, run([Values.EXTERNREF_NULL, zero, zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(29995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	t.assert_r(rNONE, run([ref, i_v(0), zero]));
	t.assert_a<u16>([0, 2, 11, 12345, 65535], array.elems);

	t.assert_r(rNONE, run([ref, i_v(1), i_v(99)]));
	t.assert_a<u16>([0, 99, 11, 12345, 65535], array.elems);

	t.assert_r(rNONE, run([ref, i_v(4), i_v(555)]));
	t.assert_a<u16>([0, 99, 11, 12345, 555], array.elems);

	t.assert_r(rNONE, run([ref, i_v(2), i_v(u16.max)]));
	t.assert_a<u16>([0, 99, 65535, 12345, 555], array.elems);
}

def test_exe_dastore(t: JawaTester) {
	var func = make_xastore(t, JawaPrimArray.DOUBLE);
	if (func == null) return;
	def run = Interpreter.new().run(100, func, _);
	var array = JawaArrayObjectOf<double>.new([
		double.view(0x4021cccccccccccd),
		double.view(0xc073000000000000),
		double.view(0x7ff8000000000000),
		double.view(0x7ff0000000000000),
		double.view(0xc071000456789ABC)
	]);
	var ref = Value.ExternRef(array), zero = Values.F64_0;

	t.assert_r(NPE, run([Values.EXTERNREF_NULL, i_v(0), zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(129995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	t.assert_r(rNONE, run([ref, i_v(0), zero]));
	t.assert_da([
		double.view(0x0000000000000000),
		double.view(0xc073000000000000),
		double.view(0x7ff8000000000000),
		double.view(0x7ff0000000000000),
		double.view(0xc071000456789ABC)], array.elems);

	t.assert_r(rNONE, run([ref, i_v(3), d_v(0x1111222233334444)]));
	t.assert_da([
		double.view(0x0000000000000000),
		double.view(0xc073000000000000),
		double.view(0x7ff8000000000000),
		double.view(0x1111222233334444),
		double.view(0xc071000456789ABC)], array.elems);
}

def test_exe_fastore(t: JawaTester) {
	var func = make_xastore(t, JawaPrimArray.FLOAT);
	if (func == null) return;
	def run = Interpreter.new().run(100, func, _);
	var array = JawaArrayObjectOf<float>.new([
		float.view(0x410e6666),
		float.view(0xc3510000),
		float.view(0x7fc00000),
		float.view(0x7f800000),
		float.view(0xd2110c43)
	]);
	var ref = Value.ExternRef(array), zero = Values.F32_0;

	t.assert_r(NPE, run([Values.EXTERNREF_NULL, i_v(0), zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(129995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	t.assert_r(rNONE, run([ref, i_v(0), zero]));
	t.assert_fa([
		float.view(0x00000000),
		float.view(0xc3510000),
		float.view(0x7fc00000),
		float.view(0x7f800000),
		float.view(0xd2110c43)
	], array.elems);

	t.assert_r(rNONE, run([ref, i_v(3), f_v(0x11223344)]));
	t.assert_fa([
		float.view(0x00000000),
		float.view(0xc3510000),
		float.view(0x7fc00000),
		float.view(0x11223344),
		float.view(0xd2110c43)
	], array.elems);
}

def test_exe_iastore(t: JawaTester) {
	var func = make_xastore(t, JawaPrimArray.INT);
	if (func == null) return;
	def run = Interpreter.new().run(100, func, _);
	var array = JawaArrayObjectOf<i32>.new([
		1, 2, -13, 72345, 6553509
	]);
	var ref = Value.ExternRef(array), zero = Values.I32_0;

	t.assert_r(NPE, run([Values.EXTERNREF_NULL, zero, zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(39995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	t.assert_r(rNONE, run([ref, i_v(0), i_v(555666777)]));
	t.assert_a<i32>([555666777, 2, -13, 72345, 6553509], array.elems);

	t.assert_r(rNONE, run([ref, i_v(1), i_v(997)]));
	t.assert_a<i32>([555666777, 997, -13, 72345, 6553509], array.elems);

	t.assert_r(rNONE, run([ref, i_v(4), i_v(-777888999)]));
	t.assert_a<i32>([555666777, 997, -13, 72345, -777888999], array.elems);

	t.assert_r(rNONE, run([ref, i_v(2), i_v(u16.max)]));
	t.assert_a<i32>([555666777, 997, 65535, 72345, -777888999], array.elems);
}

def test_exe_lastore(t: JawaTester) {
	var func = make_xastore(t, JawaPrimArray.LONG);
	if (func == null) return;
	def run = Interpreter.new().run(100, func, _);
	var array = JawaArrayObjectOf<i64>.new([
		1, 5, -13998744, 72345999888, 6553509998888
	]);
	var ref = Value.ExternRef(array), zero = Values.I64_0;

	t.assert_r(NPE, run([Values.EXTERNREF_NULL, i_v(0), zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(49995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	t.assert_r(rNONE, run([ref, i_v(0), l_v(555666777888999)]));
	t.assert_a<i64>([555666777888999, 5, -13998744, 72345999888, 6553509998888], array.elems);

	t.assert_r(rNONE, run([ref, i_v(1), l_v(-997)]));
	t.assert_a<i64>([555666777888999, -997, -13998744, 72345999888, 6553509998888], array.elems);

	t.assert_r(rNONE, run([ref, i_v(4), l_v(-777888999)]));
	t.assert_a<i64>([555666777888999, -997, -13998744, 72345999888, -777888999], array.elems);

	t.assert_r(rNONE, run([ref, i_v(2), l_v(u16.max)]));
	t.assert_a<i64>([555666777888999, -997, 65535, 72345999888, -777888999], array.elems);
}

def test_exe_sastore(t: JawaTester) {
	var func = make_xastore(t, JawaPrimArray.SHORT);
	if (func == null) return;
	def run = Interpreter.new().run(100, func, _);
	var array = JawaArrayObjectOf<i16>.new([
		-1, 2, 11, 12365, -10988
	]);
	var ref = Value.ExternRef(array), zero = Values.I32_0;

	t.assert_r(NPE, run([Values.EXTERNREF_NULL, zero, zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(99995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	t.assert_r(rNONE, run([ref, i_v(0), zero]));
	t.assert_a<i16>([0, 2, 11, 12365, -10988], array.elems);

	t.assert_r(rNONE, run([ref, i_v(1), i_v(9937)]));
	t.assert_a<i16>([0, 9937, 11, 12365, -10988], array.elems);

	t.assert_r(rNONE, run([ref, i_v(2), i_v(-5)]));
	t.assert_a<i16>([0, 9937, -5, 12365, -10988], array.elems);

	t.assert_r(rNONE, run([ref, i_v(3), i_v(4444)]));
	t.assert_a<i16>([0, 9937, -5, 4444, -10988], array.elems);

	t.assert_r(rNONE, run([ref, i_v(4), i_v(i16.min)]));
	t.assert_a<i16>([0, 9937, -5, 4444, -32768], array.elems);
}

def make_xnewarray(t: JawaTester, c: JawaPrimArray) -> Function {
	var n = JawaTester.new(t.t);
	var bt = n.addTypeImport([c.type_code.code], ValueTypes.NONE);
	var vt = c.map.jawaArrayValueType;
	var sig = FuncSig.new(SigCache.arr_i, [vt]);
	n.asm.reset();
	n.asm.putc(JawaFuncOpcode.NEWARRAY.code);
	n.asm.put_jawa_i4(bt.type_index);
	n.addFuncImport(n.asm.extract(), sig);
	var r = n.process();
	n.assertIsJawaType(c.map.jawaArrayType, r[0]);
	return t.assertIsFunction(sig, r[1]);
}

def test_exe_xnewarrayof<T>(t: JawaTester, c: JawaPrimArray) {
	// XXX(code size): reduce polymorphic duplication of this method
	var i = Interpreter.new();
	var f = make_xnewarray(t, c);
	if (f == null) return;

	t.assert_r(NASE, i.run(100, f, [i_v(-1)]));

	for (len in [0, 1, 5, 257]) {
		var r = i.run(100, f, [i_v(len)]);
		var obj = t.assertIsJawaObject(r);
		if (obj == null) return;
		var array = t.assertIsJawaArrayObjectOf<T>(obj);
		if (array == null) return;
		t.t.asserti(len, array.length());
		t.t.asserti(len, array.elems.length);
	}
}

def test_exe_xnewarray(t: JawaTester) {
	test_exe_xnewarrayof<i8>(t, JawaPrimArray.BYTE);
	test_exe_xnewarrayof<bool>(t, JawaPrimArray.BOOL);
	test_exe_xnewarrayof<u16>(t, JawaPrimArray.CHAR);
	test_exe_xnewarrayof<i16>(t, JawaPrimArray.SHORT);
	test_exe_xnewarrayof<i32>(t, JawaPrimArray.INT);
	test_exe_xnewarrayof<i64>(t, JawaPrimArray.LONG);
	test_exe_xnewarrayof<float>(t, JawaPrimArray.FLOAT);
	test_exe_xnewarrayof<double>(t, JawaPrimArray.DOUBLE);
}

def make_xarraylength(t: JawaTester, c: JawaPrimArray) -> Function {
	var n = JawaTester.new(t.t);
	var bt = n.addTypeImport([c.type_code.code], ValueTypes.NONE);
	var vt = c.map.jawaArrayValueType;
	var sig = FuncSig.new([vt], SigCache.arr_i);
	n.asm.reset();
	n.asm.putc(JawaFuncOpcode.ARRAYLENGTH.code);
	n.asm.put_jawa_i4(bt.type_index);
	n.addFuncImport(n.asm.extract(), sig);
	var r = n.process();
	n.assertIsJawaType(c.map.jawaArrayType, r[0]);
	return t.assertIsFunction(sig, r[1]);
}

def test_exe_arraylength1(t: JawaTester) {
	var i = Interpreter.new();
	for (c in JawaPrimArray) {
		var f = make_xarraylength(t, c);
		if (f == null) return;

		t.assert_r(NPE, i.run(100, f, [Values.EXTERNREF_NULL]));
		for (len in [0, 1, 258]) {
			var obj = c.map.newarray(len);
			t.assert_r(i_r(len), i.run(100, f, [Value.ExternRef(obj)]));
		}
	}
}

def test_exe_arraylength2(t: JawaTester) {
	var obj = JawaClasses.OBJECT;
	t.env.add(obj);
	var jlo = t.importClass("jawa/lang/Object");
	var ajlo = t.importArrayOf(jlo.type_index);

	var sig = FuncSig.new([ValueType.Imported(ajlo)], SigCache.arr_i);
	t.asm.reset();
	t.asm.putc(JawaFuncOpcode.ARRAYLENGTH.code);
	t.asm.put_jawa_i4(ajlo.type_index);
	t.addFuncImport(t.asm.extract(), sig);
	var r = t.process();

	t.assertIsJawaType(JawaType.Class(obj), r[0]);
	t.assertIsJawaType(JawaType.Array(JawaType.Class(obj)), r[1]);
	var xt = r[1];
	if (!ExportedType.?(xt)) return;

	var vt = ExportedType.!(xt).rep; // XXX: do type substitution properly instead?
	var expected_sig = FuncSig.new([vt], SigCache.arr_i);
	var f = t.assertIsFunction(expected_sig, r[2]);
	if (f == null) return;
	var host = JawaHostType.!(ValueType.Host.!(vt).host);

	var i = Interpreter.new();
	for (len in [0, 1, 259]) {
		var obj = JawaRefArrayObject.new(host, Array<JawaObject>.new(len));
		t.assert_r(i_r(len), i.run(100, f, [Value.ExternRef(obj)]));
	}
}

def test_exe_acmpeq(t: JawaTester) {
	var sig = FuncSig.new([ValueType.Host(JawaTypes.OBJECT), ValueType.Host(JawaTypes.OBJECT)], SigCache.arr_i);
	t.addFuncImport([JawaFuncOpcode.ACMPEQ.code], sig);
	var r = t.process();
	var f = t.assertIsFunction(sig, r[0]);
	if (f == null) return;

	def cases: Array<JawaObject> = [
		null,
		JawaArrayObjectOf<i8>.new(Array<i8>.new(2)),
		JawaArrayObjectOf<float>.new(Array<float>.new(2)),
		JawaObject.new()
	];
	var i = Interpreter.new(), TRUE = i_r(1), FALSE = i_r(0);
	for (x < cases.length) {
		var a = Value.ExternRef(cases[x]);
		for (y < cases.length) {
			var b = Value.ExternRef(cases[y]);
			t.assert_r(if(x == y, TRUE, FALSE), i.run(100, f, [a, b]));
		}
	}
}

def test_exe_acmpne(t: JawaTester) {
	var sig = FuncSig.new([ValueType.Host(JawaTypes.OBJECT), ValueType.Host(JawaTypes.OBJECT)], SigCache.arr_i);
	t.addFuncImport([JawaFuncOpcode.ACMPNE.code], sig);
	var r = t.process();
	var f = t.assertIsFunction(sig, r[0]);
	if (f == null) return;

	def cases: Array<JawaObject> = [
		null,
		JawaArrayObjectOf<u16>.new(Array<u16>.new(0)),
		JawaArrayObjectOf<double>.new(Array<double>.new(0)),
		JawaObject.new(),
		JawaObject.new()
	];
	var i = Interpreter.new(), TRUE = i_r(1), FALSE = i_r(0);
	for (x < cases.length) {
		var a = Value.ExternRef(cases[x]);
		for (y < cases.length) {
			var b = Value.ExternRef(cases[y]);
			t.assert_r(if(x != y, TRUE, FALSE), i.run(100, f, [a, b]));
		}
	}
}

// TODO: anewarray
// TODO: multianewarray

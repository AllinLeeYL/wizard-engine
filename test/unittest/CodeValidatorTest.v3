// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("validator:", _, CodeValidatorTester.new, _);
def X = [
	T("local0", test_local0),
	T("local1", test_local1),
	T("localref", test_localref),
	T("globalref", test_globalref),
	T("refparam", test_refparam),
	T("ret0", test_ret0),
	T("ret1", test_ret1),
	T("br0", test_br0),
	T("br_table0", test_br_table0),
	T("br_table1", test_br_table1),
	T("if0", test_if0),
	T("if1", test_if1),
	T("if2", test_if2),
	T("if_end", test_if_end),
	T("if_unr1", test_if_unr1),
	T("if_unr2", test_if_unr2),
	T("select", test_select),
	T("selectn", test_selectn),
	T("selectt", test_selectt),
	T("loop0", test_loop0),
	T("loop_br", test_loop_br),
	T("loopv", test_loopv),
	T("blockp1", test_blockp1),
	T("blockp2", test_blockp2),
	T("blockv2", test_blockv2),
	T("blockinv", test_blockinv),
	T("unterm", test_unterm),
	T("else", test_else0),
	T("simple_ops_v", test_simple_ops_v),
	T("simple_ops_r", test_simple_ops_r),
	T("simple_ops0", test_simple_ops0),
	T("simple_ops1", test_simple_ops1),
	T("simple_ops2", test_simple_ops2),
	T("memindex1", test_memindex1),
	T("memindex2", test_memindex2),
	T("tabindex1", test_tabindex1),
	T("tabindex2", test_tabindex2),
	T("retcall1", test_retcall1),
	T("retcall2", test_retcall2),
	T("invalid1", test_invalid1),
	T("invalid2", test_invalid2),
	T("prefix1", test_prefix_ops1),
	T("ref.null", test_ref_null),
	T("ref.is_null", test_ref_is_null),
	T("ref.func", test_ref_func),
	T("ref.as_non_null", test_ref_as_non_null),
	T("br_on_null", test_br_on_null),
	T("memory.init", test_memory_init),
	T("data.drop", test_data_drop),
	T("memory.copy", test_memory_copy),
	T("memory.fill", test_memory_fill),
	T("table.init", test_table_init),
	T("elem.drop", test_elem_drop),
	T("table.get", test_table_get),
	T("table.set", test_table_set),
	T("table.copy", test_table_copy),
	T("table.grow", test_table_grow),
	T("table.size", test_table_size),
	T("table.fill", test_table_fill),
	T("abs_types0", test_abs_types0),
	T("abs_types1", test_abs_types1),
	T("abs_types2", test_abs_types2),
	T("call_ref0", test_call_ref0),
	T("retcall_ref0", test_retcall_ref0),
	T("func.bind1", test_func_bind1),
	T("func.bind2", test_func_bind2),
	T("let0", test_let0),
	T("let1", test_let1),
	T("ref.eq", test_ref_eq),
	T("struct.new", test_struct_new),
	T("struct.newdef", test_struct_newdef),
	T("struct.get", test_struct_get),
	T("struct.get_su", test_struct_get_su),
	T("struct.set", test_struct_set),
	T("array.new", test_array_new),
	T("array.newdef", test_array_newdef),
	T("array.get", test_array_get),
	T("array.get_su", test_array_get_su),
	T("array.set", test_array_set),
	T("array.len", test_array_len),
	T("i31.new", test_i31_new),
	T("i31.get_su", test_i31_get_su),
	T("rtt.sub1", test_rtt_sub1),
	T("rtt.sub2", testDeclPairs(_, test_rtt_sub0)),
	T("ref.test", testDeclPairs(_, test_ref_test0)),
	T("ref.cast", testDeclPairs(_, test_ref_cast0)),
	T("br_on_cast", testDeclPairs(_, test_br_on_cast0)),
	T("br_on_castb", test_br_on_castb),
	()
];

class CodeValidatorTester(t: Tester) extends ModuleBuilder {
	def err = WasmErrorGen.new("CodeValidatorTest.v3");
	var validator: CodeValidator; // FAST: reuse validator
	new() {
		validator = CodeValidator.new(extensions, Limits.new().set(extensions), module, err);
	}
	def setExtensions(e: Extension.set) {
		extensions = e;
		validator = CodeValidator.new(extensions, Limits.new().set(extensions), module, err);
	}
	def valid(raw: Array<byte>) {
		code(raw);
		err.reset();
		match (validator.validateFunc(func)) {
			Ok => ;
			Error(error, pc, msg) => t.fail2("expected success, got error @+%d: %s", pc, msg);
		}
	}
	def invalid(expected: WasmError, raw: Array<byte>, error_pc: int) {
		code(raw);
		err.reset();
		match (validator.validateFunc(func)) {
			Ok => t.fail2("expected error %s @+%d, got success", expected.name, error_pc);
			Error(error, pc, msg) => {
				if (error != expected) {
					t.fail3("expected error %s, got %s @+%d\n",
						expected.name, error.name, pc);
				} else if (pc != error_pc) {
					t.fail3("expected error location @+%d, got @+%d (%s)", error_pc, pc, msg);
				}
			}
		}
	}
	def TypeError(code: Array<byte>, error_pc: int) {
		invalid(WasmError.TYPE_MISMATCH, code, error_pc);
	}
	def addRefFuncType(nullable: bool, sig: SigDecl) -> ValueType.RefFunc {
		sig = sig.dup();
		addSig(sig);
		return ValueType.RefFunc(nullable, sig);
	}
}

def EB = BpTypecon.EmptyBlock.code;
def ABS_TYPE1 = AbsTypeDecl.new(false, false, []);
def ABS_TYPE2 = AbsTypeDecl.new(false, false, []);

def test_local0(t: CodeValidatorTester) {
	var code1: Array<byte> = [Opcode.LOCAL_GET.code, 0];
	t.invalid(WasmError.OOB_INDEX, code1, 1);
	t.sig(SigCache.i_i);
	t.valid(code1);
}

def test_local1(t: CodeValidatorTester) {
	var code1: Array<byte> = [Opcode.LOCAL_GET.code, 0];
	t.sig(SigCache.i_i);
	t.addLocals(10000000, ValueType.I32);
	t.invalid(WasmError.EXCEEDED_LIMIT, code1, 1);
}

def test_localref(t: CodeValidatorTester) {
	var lg = t.addLocals(1, ValueType.FUNCREF);
	var le = t.addLocals(1, ValueType.EXTERNREF);
	t.sig0([ValueType.FUNCREF, ValueType.EXTERNREF], SigCache.arr_v);
	t.valid([Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_SET.code, byte.!(lg)]);
	t.valid([Opcode.LOCAL_GET.code, 1, Opcode.LOCAL_SET.code, byte.!(le)]);

	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_SET.code, byte.!(le)], 7);
	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.LOCAL_GET.code, 1, Opcode.LOCAL_SET.code, byte.!(lg)], 7);
}

def test_globalref(t: CodeValidatorTester) {
	var lg = byte.!(t.newGlobal(ValueType.FUNCREF, InitExpr.FuncRefNull).global_index);
	var le = byte.!(t.newGlobal(ValueType.EXTERNREF, InitExpr.ExternRefNull).global_index);

	t.sig0([ValueType.FUNCREF, ValueType.EXTERNREF], SigCache.arr_v);
	t.valid([Opcode.LOCAL_GET.code, 0, Opcode.GLOBAL_SET.code, lg]);
	t.valid([Opcode.LOCAL_GET.code, 1, Opcode.GLOBAL_SET.code, le]);

	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.LOCAL_GET.code, 0, Opcode.GLOBAL_SET.code, le], 3);
	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.LOCAL_GET.code, 1, Opcode.GLOBAL_SET.code, lg], 3);
}

def test_refparam(t: CodeValidatorTester) {
	var code1: Array<byte> = [Opcode.LOCAL_GET.code, 0];
	var refs = [ValueType.FUNCREF, ValueType.EXTERNREF];
	for (p in refs) {
		for (r in refs) {
			t.sig0([p], [r]);
			if (p == r) t.valid(code1);
			else t.invalid(WasmError.TYPE_MISMATCH, code1, 3);
		}
	}
}

def test_ret0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([]);
	t.valid([Opcode.RETURN.code]);

	t.TypeError([Opcode.I32_CONST.code, 0], 3);
	t.TypeError([Opcode.I64_CONST.code, 0], 3);
	t.TypeError([Opcode.F32_CONST.code, 0, 0, 0, 0], 6);
	t.TypeError([Opcode.F64_CONST.code, 0, 0, 0, 0, 0, 0, 0, 0], 10);
}

def test_ret1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.TypeError([], 1);
	t.TypeError([Opcode.RETURN.code], 1);

	t.valid([Opcode.I32_CONST.code, 0]);
	t.TypeError([Opcode.I64_CONST.code, 0], 3);
	t.TypeError([Opcode.F32_CONST.code, 0, 0, 0, 0], 6);
	t.TypeError([Opcode.F64_CONST.code, 0, 0, 0, 0, 0, 0, 0, 0], 10);
}

def test_br0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([Opcode.BR.code, 0]);
	t.invalid(WasmError.OOB_LABEL, [Opcode.BR.code, 1], 1);
	t.invalid(WasmError.OOB_LABEL, [
		Opcode.BLOCK.code, EB,
		Opcode.BR.code, 2,
		Opcode.END.code
	], 3);
}

def test_br_table0(t: CodeValidatorTester) {
	var code1: Array<byte> = [
		Opcode.I32_CONST.code, 7,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2, 0, 0, 0];
	t.sig(SigCache.i_i);
	t.valid(code1);

	t.sig(SigCache.f_i);
	t.TypeError(code1, 5);

	t.sig(SigCache.i_f);
	t.TypeError(code1, 5);

	var code2: Array<byte> = [
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 7,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2, 0, 1, 0,
		Opcode.END.code];
	t.sig(SigCache.i_i);
	t.valid(code2);

	t.sig(SigCache.f_i);
	t.TypeError(code2, 7);
}

def test_br_table1(t: CodeValidatorTester) {
	var code1: Array<byte> = [
		Opcode.BLOCK.code, EB,
		Opcode.I32_CONST.code, 8,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2, 0, 1, 0,
		Opcode.END.code];
	t.sig(SigCache.i_i);
	t.TypeError(code1, 7);

	var code2: Array<byte> = [
		Opcode.F32_CONST.code, 0, 0, 0, 0,
		Opcode.LOOP.code, BpTypecon.F32.code,
		Opcode.I32_CONST.code, 9,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2, 0, 1, 0,
		Opcode.END.code];
	t.sig(SigCache.i_i);
	t.TypeError(code2, 12);
}

def test_if0(t: CodeValidatorTester) {
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, EB,
		Opcode.ELSE.code,
		Opcode.END.code
	];
	t.sig(SigCache.i_v);
	t.valid(code1);

	t.sig(SigCache.l_v);
	t.TypeError(code1, 3);

	var code2: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, EB,
		Opcode.BR.code, 0,
		Opcode.ELSE.code,
		Opcode.RETURN.code,
		Opcode.END.code
	];
	t.sig(SigCache.i_v);
	t.valid(code2);

	t.sig(SigCache.l_v);
	t.TypeError(code2, 3);

	var code3: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, EB,
		Opcode.BR.code, 1,
		Opcode.END.code
	];
	t.sig(SigCache.i_v);
	t.valid(code3);

	t.sig(SigCache.l_v);
	t.TypeError(code3, 3);
}

def test_if1(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.ELSE.code,
		Opcode.END.code
	], 5);

	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.ELSE.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.END.code
	], 5);

	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.ELSE.code,
		Opcode.END.code
	], 8);

	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.UNREACHABLE.code,
		Opcode.ELSE.code,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	]);

	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 1,
		Opcode.ELSE.code,
		Opcode.LOCAL_GET.code, 1,
		Opcode.END.code
	];
	t.sig(SigCache.ii_i);
	t.valid(code1);

	t.sig0(SigCache.arr_if, SigCache.arr_i);
	t.TypeError(code1, 7);

	var code2: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.F32.code,
		Opcode.UNREACHABLE.code,
		Opcode.ELSE.code,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	];
	t.sig(SigCache.ii_i);
	t.TypeError(code2, 9);
}

def test_if2(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 5,
		Opcode.END.code
	], 7);
}

def test_if_end(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	var i_i = byte.!(t.addSig(SigCache.i_i));
	var i_f = byte.!(t.addSig(SigCache.i_f));
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, i_i,
		Opcode.END.code
	]);
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, i_i,
		Opcode.DROP.code,
		Opcode.I32_CONST.code, 5,
		Opcode.END.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, i_i,
		Opcode.I32_CONST.code, 5,
		Opcode.END.code
	], 9);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, i_f,
		Opcode.F32_CONST.code, 3, 3, 3, 3,
		Opcode.END.code
	], 12);

}

def test_if_unr1(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	var i_i = byte.!(t.addSig(SigCache.i_i));
	var v_i = byte.!(t.addSig(SigCache.v_i));
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, v_i,
		Opcode.UNREACHABLE.code,
		Opcode.ELSE.code,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	]);
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, i_i,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, v_i,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	], 6);
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, i_i,
		Opcode.UNREACHABLE.code,
		Opcode.I32_CONST.code, 5,
		Opcode.END.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, i_i,
		Opcode.UNREACHABLE.code,
		Opcode.I64_CONST.code, 5,
		Opcode.END.code
	], 10);
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, i_i,
		Opcode.I32_CONST.code, 5,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	]);
}
def test_if_unr2(t: CodeValidatorTester) {
	t.sig(SigCache.i_v);
	var i_i = byte.!(t.addSig(SigCache.i_i));
	var v_i = byte.!(t.addSig(SigCache.v_i));
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, EB,
		Opcode.UNREACHABLE.code,
		Opcode.ELSE.code,
		Opcode.END.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, EB,
		Opcode.UNREACHABLE.code,
		Opcode.I32_CONST.code, 5,
		Opcode.ELSE.code,
		Opcode.END.code
	], 8);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, EB,
		Opcode.I32_CONST.code, 1,
		Opcode.IF.code, EB,
		Opcode.UNREACHABLE.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 5,
		Opcode.ELSE.code,
		Opcode.END.code
	], 13);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, EB,
		Opcode.I32_CONST.code, 5,
		Opcode.I32_CONST.code, 1,
		Opcode.IF.code, EB,
		Opcode.UNREACHABLE.code,
		Opcode.END.code,
		Opcode.ELSE.code,
		Opcode.END.code
	], 13);
}

def test_select(t: CodeValidatorTester) {
	var types = [ValueType.I32, ValueType.I64, ValueType.F32, ValueType.F64];
	var code: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.I32_CONST.code, 1,
		Opcode.SELECT.code
	];
	for (a in types) {
		for (b in types) {
			t.sig0([a, b], [a]);
			if (a == b) t.valid(code);
			else t.TypeError(code, 7);
		}
	}
}

def test_selectn(t: CodeValidatorTester) {
	var types = [ValueType.I32, ValueType.FUNCREF, ValueType.EXTERNREF];
	var code: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.I32_CONST.code, 1,
		Opcode.SELECT.code
	];
	for (a in types) {
		for (b in types) {
			t.sig0([a, b], [a]);
			if (a == b && ValueTypes.isNumeric(a)) t.valid(code);
			else t.TypeError(code, 7);
		}
	}
}

def test_selectt(t: CodeValidatorTester) {
	var cases = [
		(BpTypecon.I32.code, ValueType.I32),
		(BpTypecon.FUNCREF.code, ValueType.FUNCREF),
		(BpTypecon.EXTERNREF.code, ValueType.EXTERNREF)
	];
	var code: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.I32_CONST.code, 1,
		Opcode.SELECT_T.code, 1,
		0 /*tpos*/
	];
	var tpos = 8;
	for (a in cases) {
		code[tpos] = a.0;
		for (b in cases) {
			t.sig0([a.1, b.1], [a.1]);
			if (ValueTypes.isAssignable(b.1, a.1)) t.valid(code);
			else t.TypeError(code, 7);
			t.sig0([b.1, a.1], [a.1]);
			if (ValueTypes.isAssignable(b.1, a.1)) t.valid(code);
			else t.TypeError(code, 7);
			t.sig0([a.1, a.1], [b.1]);
			if (ValueTypes.isAssignable(a.1, b.1)) t.valid(code);
			else t.TypeError(code, 10);
		}
	}
}

def test_loop0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([
		Opcode.LOOP.code, EB,
		Opcode.END.code
	]);
	t.sig(SigCache.v_i);
	t.valid([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.UNREACHABLE.code,
		Opcode.END.code
	]);
	t.sig(SigCache.v_i);
	t.valid([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 0,
		Opcode.END.code
	]);
	t.TypeError([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.I64_CONST.code, 0,
		Opcode.END.code
	], 5);
	t.TypeError([
		Opcode.LOOP.code, BpTypecon.I64.code,
		Opcode.I64_CONST.code, 0,
		Opcode.END.code
	], 6);
}

def test_loop_br(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([
		Opcode.LOOP.code, EB,
		Opcode.BR.code, 0,
		Opcode.END.code
	]);
	t.valid([
		Opcode.LOOP.code, EB,
		Opcode.BR.code, 1,
		Opcode.END.code
	]);
	t.invalid(WasmError.OOB_LABEL, [
		Opcode.LOOP.code, EB,
		Opcode.BR.code, 2,
		Opcode.END.code
	], 3);
	t.sig(SigCache.v_i);
	t.valid([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.BR.code, 0,
		Opcode.END.code
	]);
	t.valid([
		Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 0,
		Opcode.BR.code, 1,
		Opcode.END.code
	]);
}

def test_loopv(t: CodeValidatorTester) {
	var i_v = byte.!(t.addSig(SigCache.i_v));
	var i_i = byte.!(t.addSig(SigCache.i_i));
	var f_f = byte.!(t.addSig(SigCache.f_f));
	var i_f = byte.!(t.addSig(SigCache.i_f));

	t.sig(SigCache.if_v);
	t.TypeError([
		Opcode.LOOP.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 1);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOOP.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 3);
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOOP.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	]);
}

def test_blockp1(t: CodeValidatorTester) {
	var i_v = byte.!(t.addSig(SigCache.i_v));
	var f_v = byte.!(t.newSig(SigCache.arr_f, SigCache.arr_v).sig_index);

	t.sig(SigCache.if_v);
	t.TypeError([
		Opcode.BLOCK.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 1);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 3);
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.BLOCK.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, i_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 3);
	t.valid([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_v,
		Opcode.DROP.code,
		Opcode.END.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.BLOCK.code, f_v,
		Opcode.DROP.code,
		Opcode.END.code
	], 3);
}

def test_blockp2(t: CodeValidatorTester) {
	var i_v = byte.!(t.addSig(SigCache.i_v));
	var f_f = byte.!(t.addSig(SigCache.f_f));
	var f_l = byte.!(t.addSig(SigCache.f_l));

	t.sig(SigCache.if_v);
	t.TypeError([
		Opcode.BLOCK.code, f_f,
		Opcode.END.code
	], 1);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.BLOCK.code, f_f,
		Opcode.END.code,
		Opcode.DROP.code
	], 3);
	t.valid([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_f,
		Opcode.END.code,
		Opcode.DROP.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_f,
		Opcode.DROP.code,
		Opcode.I32_CONST.code, 0,
		Opcode.END.code,
		Opcode.DROP.code
	], 8);
	t.valid([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_l,
		Opcode.DROP.code,
		Opcode.I64_CONST.code, 0,
		Opcode.END.code,
		Opcode.DROP.code
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, f_l,
		Opcode.DROP.code,
		Opcode.I32_CONST.code, 0,
		Opcode.END.code,
		Opcode.DROP.code
	], 8);
}

def test_blockv2(t: CodeValidatorTester) {
	// TODO
}

def test_blockinv(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	t.invalid(WasmError.INVALID_BLOCK_TYPE, [
		Opcode.BLOCK.code, 33,
		Opcode.END.code
	], 2);
}

def test_unterm(t: CodeValidatorTester) {
	t.invalid(WasmError.UNTERMINATED_BODY, [
		Opcode.I32_CONST.code, 0,
		Opcode.IF.code, EB
	], 6);
	t.invalid(WasmError.UNTERMINATED_BODY, [
		Opcode.I32_CONST.code, 0,
		Opcode.IF.code, EB,
		Opcode.ELSE.code
	], 7);
	t.sig(SigCache.v_v);
	t.invalid(WasmError.OOB_LABEL, [Opcode.END.code], 2);
}

def test_else0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.invalid(WasmError.MISMATCHED_ELSE, [Opcode.ELSE.code], 1);

	t.invalid(WasmError.MISMATCHED_ELSE, [
		Opcode.I32_CONST.code, 0,
		Opcode.IF.code, EB,
		Opcode.ELSE.code,
		Opcode.ELSE.code,
		Opcode.END.code
	], 6);

}
def isSimpleOp(op: Opcode) -> bool {
	return op.prefix == 0 && Opcodes.attributes[op.code].SHORT_OP;
}

def test_simple_ops_v(t: CodeValidatorTester) {
	var code = Vector<byte>.new();
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		t.sig(op.sig);
		for (i < op.sig.params.length) {
			code.put(Opcode.LOCAL_GET.code);
			code.put(byte.!(i));
		}
		code.put(op.code);
		t.valid(code.extract());
	}
}

def test_simple_ops_r(t: CodeValidatorTester) {
	var code = Vector<byte>.new();
	var types = [ValueType.I32, ValueType.I64, ValueType.F32, ValueType.F64];
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		// Test all possible (expected) return types for all simple opcodes.
		for (rt in types) {
			t.sig0(op.sig.params, [rt]);
			for (i < op.sig.params.length) {
				code.put(Opcode.LOCAL_GET.code);
				code.put(byte.!(i));
			}
			code.put(op.code);
			if (op.sig.results.length == 1 && op.sig.results[0] == rt) {
				t.valid(code.extract());
			} else {
				var pt = code.length + 1;
				t.TypeError(code.extract(), pt);
			}
		}
	}

}

def test_simple_ops0(t: CodeValidatorTester) {
	var template: Array<byte> = [
		Opcode.LOCAL_GET.code,
		/* local_pt */0,
		/* opcode_pt */0
	];
	var local_pt = 1, opcode_pt = 2;

	t.sig(SigCache.v_i); // for proper local numbering
	var locals = [
		t.addLocal(ValueType.I32),
		t.addLocal(ValueType.I64),
		t.addLocal(ValueType.F32),
		t.addLocal(ValueType.F64)
	];
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		if (op.sig.params.length != 0) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local_pt] = byte.!(l);
			template[opcode_pt] = op.code;
			var pt = template.length + 9;
			t.TypeError(template, pt);
		}
	}
}

def test_simple_ops1(t: CodeValidatorTester) {
	var template: Array<byte> = [
		Opcode.LOCAL_GET.code,
		/* local_pt */0,
		/* opcode_pt */0
	];
	var local_pt = 1, opcode_pt = 2;

	t.sig(SigCache.i_i); // for proper local numbering
	var locals = [
		(ValueType.I32, t.addLocal(ValueType.I32)),
		(ValueType.I64, t.addLocal(ValueType.I64)),
		(ValueType.F32, t.addLocal(ValueType.F32)),
		(ValueType.F64, t.addLocal(ValueType.F64))
	];
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		if (op.sig.params.length != 1) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local_pt] = byte.!(l.1);
			template[opcode_pt] = op.code;
			if (l.0 == op.sig.params[0]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.TypeError(template, pt);
			}
		}
	}
}

def test_simple_ops2(t: CodeValidatorTester) {
	var template: Array<byte> = [
		Opcode.LOCAL_GET.code,
		/* local0_pt */0,
		Opcode.LOCAL_GET.code,
		/* local1_pt */0,
		/* opcode_pt */0
	];
	var local0_pt = 1, local1_pt = 3, opcode_pt = 4;

	t.sig(SigCache.ii_i); // for proper local numbering
	var locals = [
		(ValueType.I32, t.addLocal(ValueType.I32)),
		(ValueType.I64, t.addLocal(ValueType.I64)),
		(ValueType.F32, t.addLocal(ValueType.F32)),
		(ValueType.F64, t.addLocal(ValueType.F64))
	];
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		if (op.sig.params.length != 2) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local0_pt] = 0;
			template[local1_pt] = byte.!(l.1);
			template[opcode_pt] = op.code;
			if (l.0 == op.sig.params[1]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.TypeError(template, pt);
			}

			template[local0_pt] = byte.!(l.1);
			template[local1_pt] = 1;
			template[opcode_pt] = op.code;
			if (l.0 == op.sig.params[0]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.TypeError(template, pt);
			}
		}
	}
}

def test_memindex1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.addMemory(1, Max.Set(1));
	t.valid([
		Opcode.MEMORY_SIZE.code, 0
	]);
	t.valid([
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0
	]);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.MEMORY_SIZE.code, 1
	], 2);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 1
	], 4);

	// expect a zero byte if no multi-memory
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.MEMORY_SIZE.code, 0x80, 0
	], 2);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0x80, 0
	], 4);

	// allow a full LEB if multi-memory
	t.setExtensions(Extension.MULTI_MEMORY);
	t.valid([
		Opcode.MEMORY_SIZE.code, 0x80, 0
	]);
	t.valid([
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0x80, 0
	]);
}

def test_memindex2(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.MEMORY_SIZE.code, 0
	], 2);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0
	], 4);
	// allow a full LEB if multi-memory
	t.setExtensions(Extension.MULTI_MEMORY);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.MEMORY_SIZE.code, 0x80, 0
	], 2);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.MEMORY_GROW.code, 0x80, 0
	], 4);
}

def test_tabindex1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.addTable(1, 1, null);
	t.valid([
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0
	]);
	t.valid([
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0x80, 0
	]);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 1
	], 5);
}

def test_tabindex2(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0
	], 5);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 0x80, 0
	], 5);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 0,
		Opcode.CALL_INDIRECT.code, 0, 1
	], 5);
}

def test_retcall1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	var code1: Array<byte> = [
		Opcode.RETURN_CALL.code, 0
	];
	t.invalid(WasmError.INVALID_OPCODE, code1, 1);

	t.setExtensions(Extension.TAIL_CALL);
	t.valid(code1);

	var f2 = t.newFunction(SigCache.v_v, [Opcode.END.code]);
	t.invalid(WasmError.TYPE_MISMATCH, [
		Opcode.RETURN_CALL.code, byte.!(f2.func_index)
	], 1);
	t.invalid(WasmError.TYPE_MISMATCH, [
		Opcode.RETURN_CALL.code, byte.!(f2.func_index),
		Opcode.I32_CONST.code, 1
	], 1);

	var f3 = t.newFunction(SigCache.v_l, [Opcode.END.code]);
	t.invalid(WasmError.TYPE_MISMATCH, [
		Opcode.RETURN_CALL.code, byte.!(f3.func_index)
	], 1);
	t.invalid(WasmError.TYPE_MISMATCH, [
		Opcode.RETURN_CALL.code, byte.!(f3.func_index),
		Opcode.I32_CONST.code, 2
	], 1);
}

def test_retcall2(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.addTable(1, 1, null);
	var code1: Array<byte> = [
		Opcode.I32_CONST.code, 5,
		Opcode.RETURN_CALL_INDIRECT.code, 0, 0
	];
	t.invalid(WasmError.INVALID_OPCODE, code1, 3);

	t.setExtensions(Extension.TAIL_CALL);
	t.valid(code1);

	var s2 = t.addSig(SigCache.v_v);
	t.invalid(WasmError.TYPE_MISMATCH, [
		Opcode.I32_CONST.code, 5,
		Opcode.RETURN_CALL_INDIRECT.code, byte.view(s2), 0
	], 3);
	t.invalid(WasmError.TYPE_MISMATCH, [
		Opcode.I32_CONST.code, 5,
		Opcode.RETURN_CALL_INDIRECT.code, byte.view(s2), 0,
		Opcode.I32_CONST.code, 2
	], 3);
}

def test_invalid1(t: CodeValidatorTester) {
	t.invalid(WasmError.INVALID_OPCODE, [0xFF], 1);
}

def test_invalid2(t: CodeValidatorTester) {
	var code: Array<byte> = [0];
	for (i < 256) {
		if (Opcodes.attributes[i].VALID) continue;
		if (Opcodes.attributes[i].PREFIX) continue;
		code[0] = byte.!(i);
		t.invalid(WasmError.INVALID_OPCODE, code, 1);
	}
}

def test_prefix_ops1(t: CodeValidatorTester) {
	var template: Array<byte> = [
		Opcode.LOCAL_GET.code,
		/* local_pt */0,
		/* prefix_pt */0,
		/* opcode_pt */0
	];
	var local_pt = 1, prefix_pt = 2, opcode_pt = 3;

	t.sig(SigCache.i_i); // for proper local numbering
	var locals = [
		(ValueType.I32, t.addLocal(ValueType.I32)),
		(ValueType.I64, t.addLocal(ValueType.I64)),
		(ValueType.F32, t.addLocal(ValueType.F32)),
		(ValueType.F64, t.addLocal(ValueType.F64))
	];
	for (op in Opcode) {
		if (op.prefix == 0) continue;
		if (op.prefix == 0xFE) continue; // TODO: prefix for atomics
		if (op.sig == null) continue;
		if (op.sig.params.length != 1) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local_pt] = byte.!(l.1);
			template[prefix_pt] = op.prefix;
			template[opcode_pt] = op.code;
			if (l.0 == op.sig.params[0]) {
				t.valid(template);
			} else {
				var pt = template.length + 7;
				t.TypeError(template, pt);
			}
		}
	}
}

def test_ref_null(t: CodeValidatorTester) {
	t.TypeError([Opcode.REF_NULL.code, BpTypecon.EXTERNREF.code], 3);

	t.sig(SigCache.v_e);
	t.valid([Opcode.REF_NULL.code, BpTypecon.EXTERNREF.code]);
	t.TypeError([Opcode.REF_NULL.code, BpTypecon.FUNCREF.code], 3);

	t.sig(SigCache.v_g);
	t.valid([Opcode.REF_NULL.code, BpTypecon.FUNCREF.code]);
	t.TypeError([Opcode.REF_NULL.code, BpTypecon.EXTERNREF.code], 3);
	t.invalid(WasmError.INVALID_TYPE, [Opcode.REF_NULL.code, BpTypecon.I32.code], 2);
}

def test_ref_is_null(t: CodeValidatorTester) {
	t.TypeError([Opcode.REF_IS_NULL.code], 1);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.REF_IS_NULL.code
	];
	t.sig(SigCache.i_i);
	t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
	t.sig(SigCache.e_v);
	t.TypeError(code1, 4);
	t.sig(SigCache.g_i);
	t.valid(code1);
	t.sig(SigCache.e_i);
	t.valid(code1);
}

def test_ref_func(t: CodeValidatorTester) {
	t.invalid(WasmError.OOB_INDEX, [Opcode.REF_FUNC.code, 11], 2);
	var f2 = t.newFunction(SigCache.v_v, [Opcode.END.code]);
	var code1: Array<byte> = [Opcode.REF_FUNC.code, byte.!(f2.func_index)];
	t.sig(SigCache.v_g);
	t.invalid(WasmError.ILLEGAL_FUNCREF, code1, 1);
	f2.reffed = true;
	t.valid(code1);
	t.sig(SigCache.i_i);
	t.TypeError(code1, 3);
	t.sig(SigCache.v_e);
	t.TypeError(code1, 3);
}

def test_ref_as_non_null(t: CodeValidatorTester) {
	var nft = ValueType.RefFunc(true, SigCache.i_i), ft = ValueType.RefFunc(false, SigCache.i_i);
	t.sig0([nft], [ft]);
	var code1: Array<byte> = [Opcode.LOCAL_GET.code, 0, Opcode.REF_AS_NON_NULL.code];
	t.invalid(WasmError.INVALID_OPCODE, code1, 3);

	t.setExtensions(Extension.FUNCTION_REFERENCES);
	t.valid(code1);
	t.sig(SigCache.i_i);
	t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
	t.sig0([nft], SigCache.arr_i);
	t.invalid(WasmError.TYPE_MISMATCH, code1, 4);
}

def test_br_on_null(t: CodeValidatorTester) {
	var nft = ValueType.RefFunc(true, SigCache.i_i), ft = ValueType.RefFunc(false, SigCache.i_i);
	t.sig0([nft], [ft]);
	var code1: Array<byte> = [Opcode.LOCAL_GET.code, 0, Opcode.BR_ON_NULL.code, 0];
	t.invalid(WasmError.INVALID_OPCODE, code1, 3);

	t.setExtensions(Extension.FUNCTION_REFERENCES);
	t.invalid(WasmError.TYPE_MISMATCH, code1, 3);
	t.valid([
		Opcode.BLOCK.code, EB,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_ON_NULL.code, 0,
		Opcode.BR.code, 1,
		Opcode.END.code,
		Opcode.UNREACHABLE.code
	]);

	t.sig(SigCache.i_i);
	t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
}

def test_data_drop(t: CodeValidatorTester) {
	t.addData(0, [0]);
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.DATA_DROP.prefix, Opcode.DATA_DROP.code, 0];
	t.invalid(WasmError.MISSING_DATA_COUNT, code1, 1);

	t.module.explicit_data_count = 1;
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [Opcode.DATA_DROP.prefix, Opcode.DATA_DROP.code, 1], 3);
}

def test_memory_init(t: CodeValidatorTester) {
	t.addMemory(1, Max.Set(1));
	t.addData(0, [0]);
	t.module.explicit_data_count = 1;
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.MEMORY_INIT.prefix, Opcode.MEMORY_INIT.code, 0, 0];
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.MEMORY_INIT.prefix, Opcode.MEMORY_INIT.code, 0, 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.MEMORY_INIT.prefix, Opcode.MEMORY_INIT.code, 1, 0
	];
	t.invalid(WasmError.OOB_INDEX, code3, 9);
}

def test_memory_copy(t: CodeValidatorTester) {
	t.addMemory(1, Max.Set(1));
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.MEMORY_COPY.prefix, Opcode.MEMORY_COPY.code, 0, 0];
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.MEMORY_COPY.prefix, Opcode.MEMORY_COPY.code, 0, 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.MEMORY_COPY.prefix, Opcode.MEMORY_COPY.code, 1, 0
	];
	t.invalid(WasmError.OOB_INDEX, code3, 9);
}

def test_memory_fill(t: CodeValidatorTester) {
	t.addMemory(1, Max.Set(1));
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.MEMORY_FILL.prefix, Opcode.MEMORY_FILL.code, 0];
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.MEMORY_FILL.prefix, Opcode.MEMORY_FILL.code, 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.MEMORY_FILL.prefix, Opcode.MEMORY_FILL.code, 1
	];
	t.invalid(WasmError.OOB_INDEX, code3, 9);
}

def test_table_init(t: CodeValidatorTester) {
	t.addTable(1, 1, [1]);
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.TABLE_INIT.prefix, Opcode.TABLE_INIT.code, 0, 0];
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.TABLE_INIT.prefix, Opcode.TABLE_INIT.code, 0, 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.TABLE_INIT.prefix, Opcode.TABLE_INIT.code, 1, 0
	];
	t.invalid(WasmError.OOB_INDEX, code3, 9);
}

def test_table_copy(t: CodeValidatorTester) {
	t.addTable(1, 1, [0]);
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.TABLE_COPY.prefix, Opcode.TABLE_COPY.code, 0, 0];
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.TABLE_COPY.prefix, Opcode.TABLE_COPY.code, 0, 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		Opcode.I32_CONST.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_CONST.code, 2,
		Opcode.TABLE_COPY.prefix, Opcode.TABLE_COPY.code, 1, 0
	];
	t.invalid(WasmError.OOB_INDEX, code3, 9);
}

def test_elem_drop(t: CodeValidatorTester) {
	t.addTable(1, 0, [0]);
	t.sig(SigCache.v_v);

	t.valid([Opcode.ELEM_DROP.prefix, Opcode.ELEM_DROP.code, 0]);
	t.invalid(WasmError.OOB_INDEX, [Opcode.ELEM_DROP.prefix, Opcode.ELEM_DROP.code, 1], 3);
}

def test_table_get(t: CodeValidatorTester) {
	t.addTable(1, 0, [0]);
	t.sig(SigCache.v_g);
	t.sig(SigCache.v_e);
	t.invalid(WasmError.TYPE_MISMATCH, [Opcode.I32_CONST.code, 0, Opcode.TABLE_GET.code, 0], 5);
	t.invalid(WasmError.OOB_INDEX, [Opcode.I32_CONST.code, 0, Opcode.TABLE_GET.code, 1], 4);
}

def test_table_set(t: CodeValidatorTester) {
	t.addTable(1, 0, [0]);
	t.sig(SigCache.g_v);
	var code1: Array<byte> = [Opcode.I32_CONST.code, 0, Opcode.LOCAL_GET.code, 0, Opcode.TABLE_SET.code, 0];
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [Opcode.I32_CONST.code, 0, Opcode.LOCAL_GET.code, 0, Opcode.TABLE_SET.code, 2], 6);
	t.sig(SigCache.e_v);
	t.invalid(WasmError.TYPE_MISMATCH, code1, 5);
}

def test_table_grow(t: CodeValidatorTester) {
	t.addTable(1, 1, [0]);
	t.sig0([ValueType.EXTERNREF, ValueType.I32], SigCache.arr_i);
	var code1: Array<byte> = [Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_GET.code, 1, Opcode.TABLE_GROW.prefix, Opcode.TABLE_GROW.code, 0];
	t.TypeError(code1, 5);
	t.sig0([ValueType.FUNCREF, ValueType.I32], SigCache.arr_i);
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_GET.code, 1, Opcode.TABLE_GROW.prefix, Opcode.TABLE_GROW.code, 1], 7);
}

def test_table_size(t: CodeValidatorTester) {
	t.addTable(3, 0, [0, 0, 0]);
	t.sig(SigCache.v_i);
	var code1: Array<byte> = [Opcode.TABLE_SIZE.prefix, Opcode.TABLE_SIZE.code, 0];
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [Opcode.TABLE_SIZE.prefix, Opcode.TABLE_SIZE.code, 1], 3);
	t.sig(SigCache.v_f);
	t.TypeError(code1, 4);
}

def test_table_fill(t: CodeValidatorTester) {
	t.addTable(1, 1, [0]);
	t.sig0([ValueType.I32, ValueType.EXTERNREF, ValueType.I32], SigCache.arr_v);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.TABLE_FILL.prefix, Opcode.TABLE_FILL.code, 0
	];
	t.TypeError(code1, 7);
	t.sig0([ValueType.I32, ValueType.FUNCREF, ValueType.I32], SigCache.arr_v);
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.TABLE_FILL.prefix, Opcode.TABLE_FILL.code, 1
	], 9);
}

def test_abs_types0(t: CodeValidatorTester) {
	var t1 = ValueType.Abstract(ABS_TYPE1);
	var t2 = ValueType.Abstract(ABS_TYPE2);

	var code1: Array<byte> = [Opcode.LOCAL_GET.code, 0];

	var T = [t1, t2];
	for (i < T.length) {
		for (j < T.length) {
			t.sig0([T[i]], [T[j]]);
			if (i == j) {
				t.valid(code1);
			} else {
				t.TypeError(code1, 3);
			}
		}
	}
}

def test_abs_types1(t: CodeValidatorTester) {
	var t1 = ValueType.Abstract(ABS_TYPE1);
	var t2 = ValueType.Abstract(AbsTypeDecl.new(false, false, [t1]));

	var code1: Array<byte> = [Opcode.LOCAL_GET.code, 0];

	var T = [t1, t2];
	for (i < T.length) {
		for (j < T.length) {
			t.sig0([T[i]], [T[j]]);
			if (i >= j) {
				t.valid(code1);
			} else {
				t.TypeError(code1, 3);
			}
		}
	}
}

def test_abs_types2(t: CodeValidatorTester) {
	var code1: Array<byte> = [Opcode.REF_NULL.code, BpTypecon.EXTERNREF.code];

	for (has_default in [false, true]) {
		for (is_externref in [false, true]) {
			var abs = AbsTypeDecl.new(has_default, is_externref, []);
			var t1 = ValueType.Abstract(abs);
			t.sig0(SigCache.arr_v, [ValueType.Abstract(abs)]);
			if (has_default && is_externref) t.valid(code1);
			else t.TypeError(code1, 3);
		}
	}
}

def test_call_ref0(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	var ref_v_v = ValueType.RefFunc(false, SigCache.v_v);
	var ref_i_i = ValueType.RefFunc(false, SigCache.i_i);
	var code1: Array<byte> = [Opcode.CALL_REF.code];
	t.invalid(WasmError.INVALID_OPCODE, code1, 1);

	t.setExtensions(Extension.FUNCTION_REFERENCES);
	t.TypeError(code1, 1);

	var code2: Array<byte> = [Opcode.LOCAL_GET.code, 0, Opcode.CALL_REF.code];
	t.TypeError(code2, 3);
	t.sig0([ref_v_v], SigCache.arr_v);
	t.valid(code2);

	t.sig0([ref_i_i], SigCache.arr_v);
	t.TypeError(code2, 3);

	var code3: Array<byte> = [Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_GET.code, 1, Opcode.CALL_REF.code];
	t.sig0([ValueType.I32, ref_i_i], SigCache.arr_v);
	t.TypeError(code3, 6);
	t.sig0([ValueType.I32, ref_i_i], SigCache.arr_i);
	t.valid(code3);
	t.sig0([ValueType.F32, ref_i_i], SigCache.arr_i);
	t.TypeError(code3, 5);
}

def test_retcall_ref0(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	var ref_v_v = ValueType.RefFunc(false, SigCache.v_v);
	var ref_i_i = ValueType.RefFunc(false, SigCache.i_i);
	var ref_i_v = ValueType.RefFunc(false, SigCache.i_v);
	var ref_i_l = ValueType.RefFunc(false, SigCache.i_l);
	var code1: Array<byte> = [Opcode.RETURN_CALL_REF.code];
	t.invalid(WasmError.INVALID_OPCODE, code1, 1);

	t.setExtensions(Extension.FUNCTION_REFERENCES);
	t.TypeError(code1, 1);

	var code2: Array<byte> = [Opcode.LOCAL_GET.code, 0, Opcode.RETURN_CALL_REF.code];
	t.TypeError(code2, 3);
	t.sig0([ref_v_v], SigCache.arr_v);
	t.valid(code2);

	t.sig0([ref_i_i], SigCache.arr_v);
	t.TypeError(code2, 3);

	var code3: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.RETURN_CALL_REF.code
	];
	t.sig0([ValueType.I32, ref_i_i], SigCache.arr_v);
	t.TypeError(code3, 5);
	t.sig0([ValueType.I32, ref_i_i], SigCache.arr_i);
	t.valid(code3);
	t.sig0([ValueType.F32, ref_i_i], SigCache.arr_i);
	t.TypeError(code3, 5);

	var code4: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.RETURN_CALL_REF.code,
		Opcode.I32_CONST.code, 1
	];
	t.sig0([ValueType.I32, ref_i_i], SigCache.arr_i);
	t.valid(code4);
	t.sig0([ValueType.F64, ref_i_i], SigCache.arr_i);
	t.TypeError(code4, 5);  // invalid param to call

	for (ftype in [ref_i_i, ref_i_v, ref_i_l]) {
		t.sig0([ValueType.F32, ftype], SigCache.arr_i);
		t.TypeError(code4, 5); // return type mismatch
	}
}

def test_func_bind1(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	var ref_v_v = t.addRefFuncType(false, SigCache.v_v);
	var ref_i_i = t.addRefFuncType(false, SigCache.i_i);
	var ref_i_v = t.addRefFuncType(false, SigCache.i_v);
	var ref_i_l = t.addRefFuncType(false, SigCache.i_l);
	var ref_l_v = t.addRefFuncType(false, SigCache.l_v);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.FUNC_BIND.code, byte.view(ref_v_v.sig.sig_index)
	];
	t.invalid(WasmError.INVALID_OPCODE, code1, 3);

	t.setExtensions(Extension.FUNCTION_REFERENCES);
	t.TypeError(code1, 3);
	t.sig0([ref_v_v], [ref_v_v]);
	t.valid(code1);

	var code2: Array<byte> = [
		Opcode.I32_CONST.code, 22,
		Opcode.LOCAL_GET.code, 0,
		Opcode.FUNC_BIND.code, byte.view(ref_v_v.sig.sig_index)
	];
	t.TypeError(code2, 7);
	t.sig0([ref_l_v], [ref_v_v]);
	t.TypeError(code2, 5);
	t.sig0([ref_i_v], [ref_v_v]);
	t.valid(code2);
}

def test_func_bind2(t: CodeValidatorTester) {
	t.setExtensions(Extension.FUNCTION_REFERENCES);
	def max = 4;
	def sigs = Array<SigDecl>.new(max);
	for (i < max) {
		var params = Array<ValueType>.new(i);
		for (j < i) params[j] = ValueType.I32;
		var sig = sigs[i] = SigDecl.new(params, SigCache.arr_l);
		t.addSig(sig);
	}

	var code = Vector<byte>.new();
	for (i = 1; i < max; i++) {
		var fsig = sigs[i];
		for (j = 0; j <= i; j++) {
			var tsig = sigs[i - j];
			code.resize(0);
			for (p < j) {
				code.put(Opcode.I32_CONST.code);
				code.put(4);
			}
			code.put(Opcode.LOCAL_GET.code);
			code.put(0);
			code.put(Opcode.FUNC_BIND.code);
			code.put(byte.view(tsig.sig_index));

			t.sig0([ValueType.RefFunc(false, fsig)], [ValueType.RefFunc(false, tsig)]);
			t.valid(code.extract());
		}
	}

}

def test_let0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [
		Opcode.LET.code, EB, 0, Opcode.END.code
	];
	t.invalid(WasmError.INVALID_OPCODE, code1, 1);
	t.setExtensions(Extension.FUNCTION_REFERENCES);
	t.valid(code1);

	var code2: Array<byte> = [
		Opcode.LET.code, BpTypecon.I32.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.END.code
	];
	t.TypeError(code2, 7);
	t.sig(SigCache.i_i);
	t.valid(code2);
}

def test_let1(t: CodeValidatorTester) {
	t.setExtensions(Extension.FUNCTION_REFERENCES);
	t.sig(SigCache.l_v);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LET.code, EB, 1, 1, BpTypecon.I32.code,
		Opcode.END.code
	];
	t.TypeError(code1, 3);
	t.sig(SigCache.i_v);
	t.valid(code1);

	for (i in [byte.view(0), byte.view(1)]) {
		t.sig(SigCache.i_v);
		t.TypeError([
			Opcode.LOCAL_GET.code, 0,
			Opcode.LET.code, EB, 1, 1, BpTypecon.I32.code,
			Opcode.LOCAL_GET.code, i,
			Opcode.END.code
		], 10);

		t.sig(SigCache.i_i);
		t.valid([
			Opcode.LOCAL_GET.code, 0,
			Opcode.LET.code, BpTypecon.I32.code, 1, 1, BpTypecon.I32.code,
			Opcode.LOCAL_GET.code, i,
			Opcode.END.code
		]);
	}
}

def unpackedT = StorageType.new(_, Packedness.UNPACKED, _);

def heapIndexByte(ht: HeapTypeDecl) -> byte {
	match (ht) {
		x: StructDecl => return byte.!(x.struct_index);
		x: ArrayDecl => return byte.!(x.array_index);
		x: SigDecl => return byte.!(x.sig_index);
	}
	return 0;
}

def test_ref_eq(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var st = t.newStruct([unpackedT(ValueType.F32, true)]);
	var cases = [
		ValueType.I32, ValueType.F32, ValueType.RefStruct(false, st), ValueType.ANYREF
	];
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.REF_EQ.code
	];
	// TODO: test externref and funcref
	for (x in cases) {
		for (y in cases) {
			t.sig0([x, y], SigCache.arr_i);
			if (!ValueTypes.isAssignable(x, ValueType.ANYREF)) t.TypeError(code1, 5);
			else if (!ValueTypes.isAssignable(y, ValueType.ANYREF)) t.TypeError(code1, 5);
			else t.valid(code1);
		}
	}
}

def test_struct_new(t: CodeValidatorTester) {
	var st = t.newStruct([unpackedT(ValueType.F32, true)]);
	t.sig(SigCache.d_d);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.STRUCT_NEW.prefix,
		Opcode.STRUCT_NEW.code,
		heapIndexByte(st)
	];
	t.invalid(WasmError.INVALID_OPCODE, code1, 3);
	t.setExtensions(Extension.GC);
	t.TypeError(code1, 3);
	t.sig(SigCache.f_f);
	t.TypeError(code1, 6);
	t.sig0(SigCache.arr_f, [ValueType.RefStruct(false, st)]);
	t.valid(code1);

	t.invalid(WasmError.OOB_INDEX, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.STRUCT_NEW.prefix,
		Opcode.STRUCT_NEW.code,
		byte.view(t.module.heaptypes.length) // oob
	], 5);

	var ft = t.addSig(SigCache.ff_i);
	t.invalid(WasmError.ILLEGAL_TYPE, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.STRUCT_NEW.prefix,
		Opcode.STRUCT_NEW.code,
		byte.view(ft) // func type reference
	], 5);
}

def test_struct_newdef(t: CodeValidatorTester) {
	var cases = [
		(ValueType.F64, true),
		(ValueType.RefFunc(true, SigCache.v_v), true),
		(ValueType.RefFunc(false, SigCache.i_i), false)
	];

	t.setExtensions(Extension.GC);
	for (c in cases) {
		var st = t.newStruct([unpackedT(c.0, true)]);
		var code1: Array<byte> = [
			Opcode.STRUCT_NEW_DEFAULT_WITH_RTT.prefix,
			Opcode.STRUCT_NEW_DEFAULT_WITH_RTT.code,
			heapIndexByte(st)
		];

		if (c.1) {
			t.sig(SigCache.d_d);
			t.TypeError(code1, 1);
			t.sig0(SigCache.arr_v, [ValueType.RefStruct(false, st)]);
			t.TypeError(code1, 1);
			t.sig0([ValueType.Rtt(1, st)], [ValueType.RefStruct(false, st)]);
			t.valid([
				Opcode.LOCAL_GET.code, 0,
				Opcode.STRUCT_NEW_DEFAULT_WITH_RTT.prefix,
				Opcode.STRUCT_NEW_DEFAULT_WITH_RTT.code,
				heapIndexByte(st)
			]);
		} else {
			t.sig(SigCache.d_d);
			t.invalid(WasmError.ILLEGAL_TYPE, code1, 1);
			t.sig0(SigCache.arr_v, [ValueType.RefStruct(false, st)]);
			t.invalid(WasmError.ILLEGAL_TYPE, code1, 1);
		}
	}
}

def test_struct_get(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var st = StructDecl.new([unpackedT(ValueType.I32, true), unpackedT(ValueType.F32, true)]);
	t.module.addDecl(st);

	t.sig0([ValueType.RefStruct(false, st)], SigCache.arr_i);
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.STRUCT_GET.prefix, Opcode.STRUCT_GET.code, heapIndexByte(st), 0
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.STRUCT_GET.prefix, Opcode.STRUCT_GET.code, heapIndexByte(st), 1
	], 7);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.STRUCT_GET.prefix, Opcode.STRUCT_GET.code, heapIndexByte(st), 2
	], 6);
}

def test_struct_get_su(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	for (packing in Packedness) {
		var st = t.newStruct([StorageType.new(ValueType.I32, packing, true)]);
		t.sig0([ValueType.RefStruct(false, st)], SigCache.arr_i);

		for (opcode in [Opcode.STRUCT_GET_S, Opcode.STRUCT_GET_U, Opcode.STRUCT_GET]) {
			var code1: Array<byte> = [
				Opcode.LOCAL_GET.code, 0,
				opcode.prefix, opcode.code, heapIndexByte(st), 0
			];
			var ok = (packing == Packedness.UNPACKED) == (opcode == Opcode.STRUCT_GET);
			if (ok) t.valid(code1);
			else t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
		}
	}
}

def test_struct_set(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var st = t.newStruct([unpackedT(ValueType.I32, true), unpackedT(ValueType.I32, false)]);

	t.sig0([ValueType.RefStruct(false, st)], SigCache.arr_v);
	t.valid([
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.STRUCT_SET.prefix, Opcode.STRUCT_SET.code, heapIndexByte(st), 0
	]);
	t.TypeError([
		Opcode.LOCAL_GET.code, 0,
		Opcode.I64_CONST.code, 1,
		Opcode.STRUCT_SET.prefix, Opcode.STRUCT_SET.code, heapIndexByte(st), 0
	], 5);
	t.invalid(WasmError.ILLEGAL_ASSIGNMENT, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.STRUCT_SET.prefix, Opcode.STRUCT_SET.code, heapIndexByte(st), 1
	], 5);
	t.invalid(WasmError.OOB_INDEX, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.STRUCT_SET.prefix, Opcode.STRUCT_SET.code, heapIndexByte(st), 2
	], 6);
}

def test_array_new(t: CodeValidatorTester) {
	var at = t.newArray([unpackedT(ValueType.F64, true)]);
	t.sig(SigCache.f_f);
	var code1: Array<byte> = [
		Opcode.I32_CONST.code, 6,
		Opcode.LOCAL_GET.code, 0,
		Opcode.ARRAY_NEW.prefix,
		Opcode.ARRAY_NEW.code,
		heapIndexByte(at)
	];
	t.invalid(WasmError.INVALID_OPCODE, code1, 5);
	t.setExtensions(Extension.GC);
	t.TypeError(code1, 5);
	t.sig(SigCache.d_d);
	t.TypeError(code1, 8);
	t.sig0(SigCache.arr_d, [ValueType.RefArray(false, at)]);
	t.valid(code1);

	t.invalid(WasmError.OOB_INDEX, [
		Opcode.I32_CONST.code, 7,
		Opcode.LOCAL_GET.code, 0,
		Opcode.ARRAY_NEW.prefix,
		Opcode.ARRAY_NEW.code,
		byte.view(t.module.heaptypes.length) // oob
	], 7);

	var ft = t.addSig(SigCache.dd_i);
	t.invalid(WasmError.ILLEGAL_TYPE, [
		Opcode.I32_CONST.code, 8,
		Opcode.LOCAL_GET.code, 0,
		Opcode.ARRAY_NEW.prefix,
		Opcode.ARRAY_NEW.code,
		byte.view(ft) // func type reference
	], 7);
}

def test_array_newdef(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var cases = [
		(ValueType.F64, true),
		(ValueType.RefFunc(true, SigCache.v_v), true),
		(ValueType.RefFunc(false, SigCache.i_i), false)
	];

	for (c in cases) {
		var at = t.newArray([unpackedT(c.0, true)]);
		var code1: Array<byte> = [
			Opcode.I32_CONST.code, 5,
			Opcode.ARRAY_NEW_DEFAULT_WITH_RTT.prefix,
			Opcode.ARRAY_NEW_DEFAULT_WITH_RTT.code,
			heapIndexByte(at)
		];

		if (c.1) {
			t.sig(SigCache.d_d);
			t.TypeError(code1, 3);
			t.sig0(SigCache.arr_v, [ValueType.RefArray(false, at)]);
			t.sig0([ValueType.Rtt(1, at)], [ValueType.RefArray(false, at)]);
			t.valid([
				Opcode.I32_CONST.code, 5,
				Opcode.LOCAL_GET.code, 0,
				Opcode.ARRAY_NEW_DEFAULT_WITH_RTT.prefix,
				Opcode.ARRAY_NEW_DEFAULT_WITH_RTT.code,
				heapIndexByte(at)
			]);
		} else {
			t.sig(SigCache.d_d);
			t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
			t.sig0(SigCache.arr_v, [ValueType.RefArray(false, at)]);
			t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
		}
	}
}

def test_array_get(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var at = t.newArray([unpackedT(ValueType.I64, true)]);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 3,
		Opcode.ARRAY_GET.prefix, Opcode.ARRAY_GET.code, heapIndexByte(at)
	];
	t.sig(SigCache.f_f);
	t.TypeError(code1, 5);
	t.sig(SigCache.i_i);
	t.TypeError(code1, 5);
	t.sig0([ValueType.RefArray(false, at)], SigCache.arr_i);
	t.TypeError(code1, 8);
	t.sig0([ValueType.RefArray(false, at)], SigCache.arr_l);
	t.valid(code1);
}

def test_array_get_su(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	for (packing in Packedness) {
		var at = t.newArray([StorageType.new(ValueType.I32, packing, true)]);
		t.sig0([ValueType.RefArray(false, at)], SigCache.arr_i);
		for (opcode in [Opcode.ARRAY_GET_S, Opcode.ARRAY_GET_U, Opcode.ARRAY_GET]) {
			var code1: Array<byte> = [
				Opcode.LOCAL_GET.code, 0,
				Opcode.I32_CONST.code, 11,
				opcode.prefix, opcode.code, heapIndexByte(at), 0
			];
			var ok = (packing == Packedness.UNPACKED) == (opcode == Opcode.ARRAY_GET);
			if (ok) t.valid(code1);
			else t.invalid(WasmError.ILLEGAL_TYPE, code1, 5);
		}
	}
}

def test_array_set(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var at = t.newArray([unpackedT(ValueType.F32, true)]);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 3,
		Opcode.LOCAL_GET.code, 1,
		Opcode.ARRAY_SET.prefix, Opcode.ARRAY_SET.code, heapIndexByte(at)
	];
	t.sig(SigCache.ff_f);
	t.TypeError(code1, 7);
	t.sig(SigCache.ii_i);
	t.TypeError(code1, 7);
	t.sig0([ValueType.RefArray(false, at), ValueType.I32], SigCache.arr_i);
	t.TypeError(code1, 7);
	t.sig0([ValueType.RefArray(false, at), ValueType.F32], SigCache.arr_f);
	t.TypeError(code1, 10);
	t.sig0([ValueType.RefArray(false, at), ValueType.F32], SigCache.arr_v);
	t.valid(code1);
}

def test_array_len(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var at = t.newArray([unpackedT(ValueType.F64, true)]);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.ARRAY_LEN.prefix, Opcode.ARRAY_LEN.code, heapIndexByte(at)
	];
	t.sig(SigCache.f_f);
	t.TypeError(code1, 3);
	t.sig(SigCache.i_i);
	t.TypeError(code1, 3);
	t.sig0([ValueType.RefArray(false, at)], SigCache.arr_d);
	t.TypeError(code1, 6);
	t.sig0([ValueType.RefArray(false, at)], SigCache.arr_i);
	t.valid(code1);
}

def test_i31_new(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.I31_NEW.prefix, Opcode.I31_NEW.code
	];
	t.sig(SigCache.i_i);
	t.TypeError(code1, 5);
	t.sig(SigCache.f_i);
	t.TypeError(code1, 3);
	t.sig0(SigCache.arr_i, [ValueType.I31REF]);
	t.valid(code1);
	t.sig0(SigCache.arr_i, [ValueType.ANYREF]);
	t.valid(code1);
}

def test_i31_get_su(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	for (opcode in [Opcode.I31_GET_S, Opcode.I31_GET_U]) {
		var code1: Array<byte> = [
			Opcode.LOCAL_GET.code, 0,
			opcode.prefix, opcode.code
		];
		t.sig(SigCache.i_i);
		t.TypeError(code1, 3);
		t.sig(SigCache.f_i);
		t.TypeError(code1, 3);
		t.sig0([ValueType.I31REF], SigCache.arr_i);
		t.valid(code1);
		t.sig0([ValueType.ANYREF], SigCache.arr_i);
		t.TypeError(code1, 3);
	}
}

def testDeclPairs(t: CodeValidatorTester,
	test: (CodeValidatorTester, HeapTypeDecl, ValueType, HeapTypeDecl, ValueType) -> void) {
	var decls = [
		t.newStruct([]),
		t.newStruct([unpackedT(ValueType.I32, false)]),
		t.newStruct([unpackedT(ValueType.I64, false)]),
		t.newArray([unpackedT(ValueType.F32, true)]),
		t.newSig(SigCache.arr_v, SigCache.arr_v)
	];
	var types = Arrays.map(decls, ValueTypes.ref(false, _));
	for (i < decls.length) {
		for (j < decls.length) {
			test(t, decls[i], types[i], decls[j], types[j]);
		}
	}
}


def test_rtt_sub1(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var d1 = t.newStruct([]);
	var d2 = t.newStruct([unpackedT(ValueType.I32, false)]);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.RTT_SUB.prefix, Opcode.RTT_SUB.code, 1,
			heapIndexByte(d1), heapIndexByte(d2)
	];
	t.sig(SigCache.i_i);
	t.TypeError(code1, 3);
	t.sig0([ValueType.Rtt(1, d1)], SigCache.arr_i);
	t.TypeError(code1, 8);
	t.sig0([ValueType.Rtt(1, d1)], [ValueType.Rtt(3, d1)]);
	t.TypeError(code1, 8);
	t.sig0([ValueType.Rtt(2, d1)], [ValueType.Rtt(2, d2)]);
	t.TypeError(code1, 3);
	t.sig0([ValueType.Rtt(1, d1)], [ValueType.Rtt(2, d2)]);
	t.valid(code1);
}

def test_rtt_sub0(t: CodeValidatorTester, di: HeapTypeDecl, dit: ValueType, dj: HeapTypeDecl, djt: ValueType) {
	t.setExtensions(Extension.GC);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.RTT_SUB.prefix, Opcode.RTT_SUB.code, 1,
			heapIndexByte(di), heapIndexByte(dj)
	];
	t.sig0([ValueType.Rtt(1, di)], [ValueType.Rtt(2, dj)]);
	if (ValueTypes.isAssignableHeap(dj, di)) {
		t.valid(code1);
		t.sig0([ValueType.Rtt(2, di)], [ValueType.Rtt(2, dj)]);
		t.TypeError(code1, 3);
		t.sig0([ValueType.Rtt(1, di)], [ValueType.Rtt(3, dj)]);
		t.TypeError(code1, 8);
	} else {
		t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
	}
}

def test_ref_test0(t: CodeValidatorTester, di: HeapTypeDecl, dit: ValueType, dj: HeapTypeDecl, djt: ValueType) {
	t.setExtensions(Extension.GC);
	var djrtt = ValueType.Rtt(2, dj);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.REF_TEST.prefix, Opcode.REF_TEST.code,
			heapIndexByte(di), heapIndexByte(dj)
	];
	if (ValueTypes.isAssignableHeap(dj, di)) {
		t.sig0([dit, djrtt], SigCache.arr_i);
		t.valid(code1);
		t.sig0([dit, ValueType.I32], SigCache.arr_i);
		t.TypeError(code1, 5);
		t.sig0([ValueType.I32, djrtt], SigCache.arr_i);
		t.TypeError(code1, 5);
	} else {
		t.sig0([dit, djrtt], SigCache.arr_i);
		t.invalid(WasmError.ILLEGAL_TYPE, code1, 5);
	}
}

def test_ref_cast0(t: CodeValidatorTester, di: HeapTypeDecl, dit: ValueType, dj: HeapTypeDecl, djt: ValueType) {
	t.setExtensions(Extension.GC);
	var djrtt = ValueType.Rtt(2, dj);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.REF_CAST.prefix, Opcode.REF_CAST.code,
			heapIndexByte(di), heapIndexByte(dj)
	];
	var arr_djt = [djt];
	if (ValueTypes.isAssignableHeap(dj, di)) {
		t.sig0([dit, djrtt], arr_djt);
		t.valid(code1);
		t.sig0([dit, ValueType.I32], arr_djt);
		t.TypeError(code1, 5);
		t.sig0([ValueType.I32, djrtt], arr_djt);
		t.TypeError(code1, 5);
	} else {
		t.sig0([dit, djrtt], arr_djt);
		t.invalid(WasmError.ILLEGAL_TYPE, code1, 5);
	}
}

def test_br_on_cast0(t: CodeValidatorTester, di: HeapTypeDecl, dit: ValueType, dj: HeapTypeDecl, djt: ValueType) {
	t.setExtensions(Extension.GC);
	var djrtt = ValueType.Rtt(2, dj);
	var code1: Array<byte> = [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.BR_ON_CAST.prefix, Opcode.BR_ON_CAST.code, 0,
			heapIndexByte(di), heapIndexByte(dj),
		Opcode.UNREACHABLE.code
	];
	if (ValueTypes.isAssignableHeap(dj, di)) {
		t.sig0([dit, djrtt], SigCache.arr_v);
		t.valid(code1);
		t.sig0([dit, ValueType.I32], SigCache.arr_v);
		t.TypeError(code1, 5);
		t.sig0([ValueType.I32, djrtt], SigCache.arr_v);
		t.TypeError(code1, 5);
	} else {
		t.sig0([dit, djrtt], SigCache.arr_v);
		t.invalid(WasmError.ILLEGAL_TYPE, code1, 5);
	}
}

def test_br_on_castb(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var st1 = t.newStruct([]);
	var st2 = t.newStruct([unpackedT(ValueType.F32, true)]);
	var st1t = ValueType.RefStruct(false, st1);
	var st2t = ValueType.RefStruct(false, st2);

	for (opcode in [Opcode.NOP, Opcode.DROP, Opcode.UNREACHABLE]) {
		var code1: Array<byte> = [
			Opcode.BLOCK.code, BpTypecon.RefT.code, heapIndexByte(st2),
			Opcode.LOCAL_GET.code, 0,
			Opcode.LOCAL_GET.code, 1,
			Opcode.BR_ON_CAST.prefix, Opcode.BR_ON_CAST.code, 0,
				heapIndexByte(st1), heapIndexByte(st2),
			opcode.code, // drop, nop, or unreachable
			Opcode.END.code
		];

		var st2rtt = ValueType.Rtt(2, st2);
		t.sig0([st1t, st2rtt], [st2t]);
		if (opcode == Opcode.NOP) {
			t.TypeError(code1, 14); // wrong type
		} else if (opcode == Opcode.DROP) {
			t.TypeError(code1, 14); // no value for fallthrough
		} else {
			t.valid(code1);
			t.sig0([st1t, st2rtt], SigCache.arr_v);
			t.TypeError(code1, 15);
		}
	}
}

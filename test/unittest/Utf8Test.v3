// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.register;
def X = [
	T("utf8:ok", test_ok),
	T("utf8:overlong", test_overlong),
	T("utf8:err1", test_err1),
	T("utf8:err2", test_err2),
	T("utf8:err3", test_err3),
	T("utf8:illegal", test_illegal),
	T("utf8:encode1", test_encode1),
	T("utf8:encode2", test_encode2),
	T("utf8:encode3", test_encode3),
	T("utf8:encode4", test_encode4),
	T("utf8:encodeinv", test_encodeinv),
	()
];

def assert_utf8(ok: bool, t: Tester, str: string) {
	var err = Utf8.findError(str);
	var got = err < 0;
	if (got == ok) return;
	if (ok) t.fail1("expected valid UTF-8, got error @+%d", err);
	else t.fail("expected invalid UTF-8, but passed");
}

def test_ok(t: Tester) {
	def p = assert_utf8(true, t, _);

	p([0xed, 0x9f, 0xbf]);
	p([0xee, 0x80, 0x80]);
	p([0xef, 0xbf, 0xbd]);
	p([0xf4, 0x8f, 0xbf, 0xbf]);
	p([0xef, 0xbf, 0xbe]);
	p([0xef, 0xbf, 0xbf]);
}

def test_overlong(t: Tester) {
	def n = assert_utf8(false, t, _);

	n([0xc0]);
	n([0xc1]);

	n([0xc0, 0xaf]);
	n([0xe0, 0x80, 0xaf]);
	n([0xf0, 0x80, 0x80, 0xaf]);
	n([0xf8, 0x80, 0x80, 0x80, 0xaf]);
	n([0xfc, 0x80, 0x80, 0x80, 0x80, 0xaf]);

	n([0xc1, 0xbf]);
	n([0xe0, 0x9f, 0xbf]);
	n([0xf0, 0x8f, 0xbf, 0xbf]);
	n([0xf8, 0x87, 0xbf, 0xbf, 0xbf]);
	n([0xfc, 0x83, 0xbf, 0xbf, 0xbf, 0xbf]);

	n([0xc0, 0x80]);
	n([0xe0, 0x80, 0x80]);
	n([0xf0, 0x80, 0x80, 0x80]);
	n([0xf8, 0x80, 0x80, 0x80, 0x80]);
	n([0xfc, 0x80, 0x80, 0x80, 0x80, 0x80]);
}

def test_err1(t: Tester) {
	def n = assert_utf8(false, t, _);
	n([0xfe]);
	n([0xff]);
	n([0xfe, 0xfe, 0xff, 0xff]);
}

def test_err2(t: Tester) {
	def n = assert_utf8(false, t, _);

	n([0xed, 0xa0, 0x80]);
	n([0xed, 0xad, 0xbf]);
	n([0xed, 0xae, 0x80]);
	n([0xed, 0xaf, 0xbf]);
	n([0xed, 0xb0, 0x80]);
	n([0xed, 0xbe, 0x80]);
	n([0xed, 0xbf, 0xbf]);
}

def test_err3(t: Tester) {
	def n = assert_utf8(false, t, _);

	n([0xed, 0xa0, 0x80, 0xed, 0xb0, 0x80]);
	n([0xed, 0xa0, 0x80, 0xed, 0xbf, 0xbf]);
	n([0xed, 0xad, 0xbf, 0xed, 0xb0, 0x80]);
	n([0xed, 0xad, 0xbf, 0xed, 0xbf, 0xbf]);
	n([0xed, 0xae, 0x80, 0xed, 0xb0, 0x80]);
	n([0xed, 0xae, 0x80, 0xed, 0xbf, 0xbf]);
	n([0xed, 0xaf, 0xbf, 0xed, 0xb0, 0x80]);
	n([0xed, 0xaf, 0xbf, 0xed, 0xbf, 0xbf]);
}

def test_illegal(t: Tester) {
	def n = assert_utf8(false, t, _);

	n([0xf5]);
	n([0xf6]);
	n([0xf7]);
	n([0xf8]);
	n([0xf9]);
	n([0xfa]);
	n([0xfb]);
	n([0xfc]);
	n([0xfd]);
	n([0xfe]);
	n([0xff]);
	n([0xf4, 0x90, 0x80, 0x80]);
}

def TEST_BUFFER = Array<byte>.new(5);

def assert_enc(t: Tester, codepoint: u32, expected: Array<byte>) {
	for (pos < 2) {
		var got = Utf8.encode(codepoint, TEST_BUFFER, pos);
		if (got != expected.length) {
			return t.fail2("expected %d byte encoding, got %d", expected.length, got);
		}
		for (i < expected.length) {
			var e = expected[i], g = TEST_BUFFER[i+pos];
			if (g != e) {
				var msg = Strings.format3("expected encoding[%d] = 0x%x, got 0x%x", i, e, g);
				return t.fail(msg);
			}
		}
	}
}

def test_encode1(t: Tester) {
	assert_enc(t, 0x00, [0x00]);
	assert_enc(t, 0x41, [0x41]);
	assert_enc(t, 0x7F, [0x7F]);
}

def test_encode2(t: Tester) {
	assert_enc(t, 0x00F6, [0xC3, 0xB6]);
	assert_enc(t, 0x0416, [0xD0, 0x96]);
	assert_enc(t, 0x0080, "\xC2\x80");
	assert_enc(t, 0x05CA, "\xD7\x8A");
	assert_enc(t, 0x07FF, "\xDF\xBF");
}

def test_encode3(t: Tester) {
	assert_enc(t, 0x20AC, [0xE2, 0x82, 0xAC]);
	assert_enc(t, 0x2C3C, "\xE2\xB0\xBC");
	assert_enc(t, 0x0800, "\xE0\xA0\x80");
	assert_enc(t, 0x3333, "\xe3\x8c\xb3");
}

def test_encode4(t: Tester) {
	assert_enc(t, 0x1D11E, [0xF0, 0x9D, 0x84, 0x9E]);
	assert_enc(t, 0x010000, "\xF0\x90\x80\x80");
	assert_enc(t, 0x01D306, "\xF0\x9D\x8C\x86");
	assert_enc(t, 0x10FFF, "\xF0\x90\xBF\xBF");
	assert_enc(t, 0x15FFF, "\xf0\x95\xbf\xbf");
	assert_enc(t, 0x65FC9, "\xf1\xa5\xbf\x89");
	assert_enc(t, 0xaaaaa, "\xf2\xaa\xaa\xaa");
	assert_enc(t, 0x33333, "\xf0\xb3\x8c\xb3");
}

def test_encodeinv(t: Tester) {
	assert_enc(t, 0xD800, []);
	assert_enc(t, 0xDFFF, []);
	assert_enc(t, 0x110000, []);
}

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.register;
def X = [
	T("types:prims", test_prims),
	T("types:funcs", test_funcs),
	T("types:nullfuncs1", test_nullfuncs1),
	T("types:nullfuncs2", test_nullfuncs2),
	T("types:imported0", test_imported0),
	T("types:imported1", test_imported1),
	T("types:imported2", test_imported2),
	T("types:funcvar0", test_funcvar0),
	T("types:funcvar1", test_funcvar1),
	T("types:funcvar2", test_funcvar2),
	T("types:lub1", test_lub1),
	T("types:lub2", test_lub2),
	T("types:funclub1", test_funclub1),
	T("types:funclub2", test_funclub2),
	T("types:funclub3", test_funclub3),
	()
];

def PRIMS = [ValueType.I32, ValueType.I64, ValueType.F32, ValueType.F64, ValueType.VEC128];
def TERMS = [ValueType.I32, ValueType.I64, ValueType.F32, ValueType.F64, ValueType.VEC128, ValueType.FUNCREF, ValueType.EXTERNREF];

def test_prims(t: Tester) {
	for (i < PRIMS.length) {
		for (j < PRIMS.length) {
			t.assertz(i == j, ValueTypes.isAssignable(PRIMS[i], PRIMS[j]));
		}
	}
}

def func_x_v(t: ValueType) -> ValueType.RefFunc {
	return ValueType.RefFunc(false, FuncSig.new([t], SigCache.arr_v));
}

def func_v_x(t: ValueType) -> ValueType.RefFunc {
	return ValueType.RefFunc(false, FuncSig.new(SigCache.arr_v, [t]));
}

def nullfunc_x_v(t: ValueType) -> ValueType.RefFunc {
	return ValueType.RefFunc(true, FuncSig.new([t], SigCache.arr_v));
}

def nullfunc_v_x(t: ValueType) -> ValueType.RefFunc {
	return ValueType.RefFunc(true, FuncSig.new(SigCache.arr_v, [t]));
}

def test_funcs(t: Tester) {
	for (i < PRIMS.length) {
		for (j < PRIMS.length) {
			{
				var fi = func_x_v(PRIMS[i]);
				var fj = func_x_v(PRIMS[j]);
				t.assertz(i == j, ValueTypes.isAssignable(fi, fj));
			}

			{
				var fi = func_v_x(PRIMS[i]);
				var fj = func_v_x(PRIMS[j]);
				t.assertz(i == j, ValueTypes.isAssignable(fi, fj));
			}
		}
	}

}

def test_nullfuncs1(t: Tester) {
	for (i < PRIMS.length) {
		for (j < PRIMS.length) {
			{
				var fi = func_x_v(PRIMS[i]);
				var fj = nullfunc_x_v(PRIMS[j]);
				t.assertz(i == j, ValueTypes.isAssignable(fi, fj));
			}

			{
				var fi = func_v_x(PRIMS[i]);
				var fj = nullfunc_v_x(PRIMS[j]);
				t.assertz(i == j, ValueTypes.isAssignable(fi, fj));
			}
		}
	}

}

def test_nullfuncs2(t: Tester) {
	for (i < PRIMS.length) {
		for (j < PRIMS.length) {
			{
				var fi = nullfunc_x_v(PRIMS[i]);
				var fj = nullfunc_x_v(PRIMS[j]);
				t.assertz(i == j, ValueTypes.isAssignable(fi, fj));
			}

			{
				var fi = nullfunc_v_x(PRIMS[i]);
				var fj = nullfunc_v_x(PRIMS[j]);
				t.assertz(i == j, ValueTypes.isAssignable(fi, fj));
			}
		}
	}

}

def IMPORTED_TYPE1 = AbsTypeDecl.new([]);
def IMPORTED_TYPE2 = AbsTypeDecl.new([]);
def IMPORTED_TYPE3 = AbsTypeDecl.new([ValueType.Abstract(IMPORTED_TYPE1)]);

def test_imported0(t: Tester) {
	var t1 = IMPORTED_TYPE1;
	var t2 = IMPORTED_TYPE2;

	// Assignability between different imported types
	var T = [t1, t2];
	for (i < T.length) {
		for (j < T.length) {
			t.assertz(i == j, T[i].isAssignableTo(ValueType.Abstract(T[j])));
		}
	}
	// Assignability between imported type and primitives
	for (i < T.length) {
		for (j < PRIMS.length) {
			t.assertz(false, T[i].isAssignableTo(PRIMS[j]));
		}
	}
	// Assignability between imported type and extern ref
	for (i < T.length) {
		t.assertz(true, T[i].isAssignableTo(ValueType.EXTERNREF));
		t.assertz(false, T[i].isAssignableTo(ValueType.FUNCREF));
	}
	for (i < T.length) {
		var ext = ValueType.Abstract(T[i]);
		t.assertz(false, ValueTypes.isAssignable(ValueType.EXTERNREF, ext));
		t.assertz(false, ValueTypes.isAssignable(ValueType.FUNCREF, ext));
		t.assertz(true, ValueTypes.isAssignable(ext, ValueType.EXTERNREF));
		t.assertz(false, ValueTypes.isAssignable(ext, ValueType.FUNCREF));
	}
}

def test_imported1(t: Tester) {
	var t1 = IMPORTED_TYPE1;
	var t2 = IMPORTED_TYPE2;

	var T = [t1, t2];
	// Assignability between imported type and functions of primitives
	for (i < T.length) {
		for (j < PRIMS.length) {
			var fj = func_x_v(PRIMS[j]);
			t.assertz(false, T[i].isAssignableTo(fj));
			fj = func_v_x(PRIMS[j]);
			t.assertz(false, T[i].isAssignableTo(fj));
		}
	}
	// Assignability between imported type and functions of imported type
	for (i < T.length) {
		for (j < T.length) {
			var fj = func_x_v(ValueType.Abstract(T[j]));
			t.assertz(false, T[j].isAssignableTo(fj));
			fj = func_v_x(ValueType.Abstract(T[j]));
			t.assertz(false, T[j].isAssignableTo(fj));
		}
	}
}

def test_imported2(t: Tester) {
	var t1 = IMPORTED_TYPE1;
	var t2 = IMPORTED_TYPE3;
	// Assignability between different imported types
	var T = [t1, t2];
	for (i < T.length) {
		for (j < T.length) {
			t.assertz(i >= j, T[i].isAssignableTo(ValueType.Abstract(T[j])));
		}
	}
}

def check_variance(t: Tester, a: ValueType, b: ValueType) {
	var ab = ValueTypes.isAssignable(a, b);
	var ba = ValueTypes.isAssignable(b, a);

	var f_a_v = func_x_v(a), f_b_v = func_x_v(b);
	var f_v_a = func_v_x(a), f_v_b = func_v_x(b);

	// covariance
	t.assertz(ab, ValueTypes.isAssignable(f_v_a, f_v_b));
	t.assertz(ba, ValueTypes.isAssignable(f_v_b, f_v_a));

	// contravariance
	t.assertz(ba, ValueTypes.isAssignable(f_a_v, f_b_v));
	t.assertz(ab, ValueTypes.isAssignable(f_b_v, f_a_v));

	// arity problems
	t.assertz(false, ValueTypes.isAssignable(f_a_v, f_v_a));
	t.assertz(false, ValueTypes.isAssignable(f_a_v, f_v_b));
	t.assertz(false, ValueTypes.isAssignable(f_b_v, f_v_a));
	t.assertz(false, ValueTypes.isAssignable(f_b_v, f_v_b));

	t.assertz(false, ValueTypes.isAssignable(f_v_a, f_a_v));
	t.assertz(false, ValueTypes.isAssignable(f_v_b, f_a_v));
	t.assertz(false, ValueTypes.isAssignable(f_v_a, f_b_v));
	t.assertz(false, ValueTypes.isAssignable(f_v_b, f_b_v));
}

def test_funcvar0(t: Tester) {
	var T = [ValueType.I32, ValueType.I64, ValueType.F32, ValueType.F64, ValueType.EXTERNREF, ValueType.FUNCREF];
	for (a in T) {
		for (b in T) {
			check_variance(t, a, b);
		}
	}
}

def test_funcvar1(t: Tester) {
	var t1 = IMPORTED_TYPE1;
	var t2 = IMPORTED_TYPE3;
	var t3 = IMPORTED_TYPE2;

	var T = [ValueType.Abstract(t1), ValueType.Abstract(t2), ValueType.Abstract(t3), ValueType.EXTERNREF, ValueType.FUNCREF];
	for (a in T) {
		for (b in T) {
			check_variance(t, a, b);
		}
	}
}

def test_funcvar2(t: Tester) {
	var f = func_x_v(ValueType.I32), nf = nullfunc_x_v(ValueType.I32);
	check_variance(t, f, nf);

	var t1 = IMPORTED_TYPE1;
	var t2 = IMPORTED_TYPE3;
	var T = [ValueType.Abstract(t1), ValueType.Abstract(t2)];
	for (a in T) {
		for (b in T) {
			var f = func_x_v(a), nf = nullfunc_x_v(b);
			check_variance(t, f, nf);
		}
	}
}

def assert_lub(t: Tester, expected: ValueType, x: ValueType, y: ValueType) {
	for (p in [(x, y), (y, x)]) { // should be commutative
		var r = ValueTypes.leastUpperBound(p);
		if (!r.0) t.fail1("expected least upper bound %q, got none", expected.render);
		if (!ValueTypes.isEquivalent(expected, r.1)) {
			t.fail2("expected least upper bound %q, got %q", expected.render, r.1.render);
		}
	}
}

def assert_no_lub(t: Tester, x: ValueType, y: ValueType) {
	var r = ValueTypes.leastUpperBound(x, y);
	if (r.0) t.fail1("expected no least upper bound, got %q", r.1.render);
}

def test_lub1(t: Tester) {
	for (x in TERMS) {
		for (y in TERMS) {
			if (x == y) assert_lub(t, x, x, y);
			else assert_no_lub(t, x, y);
		}
	}
}

def test_lub2(t: Tester) {
	var FUNCS = [
		ValueType.RefFunc(false, SigCache.v_v),
		ValueType.RefFunc(true, SigCache.i_i)
	];
	for (f in FUNCS) {
		for (x in TERMS) {
			if (x == ValueType.FUNCREF) {
				assert_lub(t, x, x, f);
			} else {
				assert_no_lub(t, x, f);
				assert_no_lub(t, f, x);
			}
		}
	}
}

def test_funclub1(t: Tester) {
	for (x in TERMS) {
		var sig = FuncSig.new([x], SigCache.arr_v);
		var rft = ValueType.RefFunc(false, sig);
		var rnft = ValueType.RefFunc(true, sig);
		assert_lub(t, rnft, rnft, rnft);
		assert_lub(t, rnft, rnft, rft);
		assert_lub(t, rft, rft, rft);
	}
}

def test_funclub2(t: Tester) {
	var PT = [SigCache.arr_v, SigCache.arr_i, [ValueType.F32, ValueType.F64]];
	for (pt in PT) {
		for (rt in PT) {
			var sig = FuncSig.new(pt, rt);
			var rft = ValueType.RefFunc(false, sig);
			var rnft = ValueType.RefFunc(true, sig);
			assert_lub(t, rnft, rnft, rnft);
			assert_lub(t, rnft, rft, rnft);
			assert_lub(t, rft, rft, rft);
		}
	}
}

def check_func_lub(t: Tester, a: ValueType, b: ValueType) {
	var r = ValueTypes.leastUpperBound(a, b);

	var rft_a = ValueType.RefFunc(false, FuncSig.new(SigCache.arr_v, [a]));
	var rft_b = ValueType.RefFunc(false, FuncSig.new(SigCache.arr_v, [b]));
	var rnft_a = ValueType.RefFunc(true, FuncSig.new(SigCache.arr_v, [a]));
	var rnft_b = ValueType.RefFunc(true, FuncSig.new(SigCache.arr_v, [b]));

	var rft_u: ValueType;
	var rnft_u: ValueType;

	if (r.0) {
		rft_u = ValueType.RefFunc(false, FuncSig.new(SigCache.arr_v, [r.1]));
		rnft_u = ValueType.RefFunc(true, FuncSig.new(SigCache.arr_v, [r.1]));
	} else {
		rft_u = ValueType.FUNCREF;
		rnft_u = ValueType.FUNCREF;
	}

	assert_lub(t, rft_u, rft_a, rft_b);
	assert_lub(t, rnft_u, rft_a, rnft_b);
	assert_lub(t, rnft_u, rnft_a, rnft_b);
}

def test_funclub3(t: Tester) {
	var rft = ValueType.RefFunc(false, SigCache.v_v);
	var rnft = ValueType.RefFunc(true, SigCache.v_v);

	check_func_lub(t, ValueType.I32, ValueType.I32);
	check_func_lub(t, ValueType.F32, ValueType.F64);
	check_func_lub(t, rft, rnft);
}

// TODO: check lub of subtyping in host types, abstract types
// TODO: check glb (contravariance) of function types

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.register;
def X = [
	T("types:prims", test_prims),
	T("types:funcs", test_funcs),
	T("types:nullfuncs1", test_nullfuncs1),
	T("types:nullfuncs2", test_nullfuncs2),
	T("types:imported0", test_imported0),
	T("types:imported1", test_imported1),
	T("types:imported2", test_imported2),
	T("types:funcvar0", test_funcvar0),
	T("types:funcvar1", test_funcvar1),
	T("types:funcvar2", test_funcvar2),
	()
];

def PRIMS = [ValueType.I32, ValueType.I64, ValueType.F32, ValueType.F64];

def test_prims(t: Tester) {
	for (i < PRIMS.length) {
		for (j < PRIMS.length) {
			t.assertz(i == j, ValueTypes.isAssignable(PRIMS[i], PRIMS[j]));
		}
	}
}

def func_x_v(t: ValueType) -> ValueType.RefFunc {
	return ValueType.RefFunc(FuncSig.new([t], SigCache.arr_v));
}

def func_v_x(t: ValueType) -> ValueType.RefFunc {
	return ValueType.RefFunc(FuncSig.new(SigCache.arr_v, [t]));
}

def nullfunc_x_v(t: ValueType) -> ValueType.RefNullFunc {
	return ValueType.RefNullFunc(FuncSig.new([t], SigCache.arr_v));
}

def nullfunc_v_x(t: ValueType) -> ValueType.RefNullFunc {
	return ValueType.RefNullFunc(FuncSig.new(SigCache.arr_v, [t]));
}

def test_funcs(t: Tester) {
	for (i < PRIMS.length) {
		for (j < PRIMS.length) {
			{
				var fi = func_x_v(PRIMS[i]);
				var fj = func_x_v(PRIMS[j]);
				t.assertz(i == j, ValueTypes.isAssignable(fi, fj));
			}

			{
				var fi = func_v_x(PRIMS[i]);
				var fj = func_v_x(PRIMS[j]);
				t.assertz(i == j, ValueTypes.isAssignable(fi, fj));
			}
		}
	}

}

def test_nullfuncs1(t: Tester) {
	for (i < PRIMS.length) {
		for (j < PRIMS.length) {
			{
				var fi = func_x_v(PRIMS[i]);
				var fj = nullfunc_x_v(PRIMS[j]);
				t.assertz(i == j, ValueTypes.isAssignable(fi, fj));
			}

			{
				var fi = func_v_x(PRIMS[i]);
				var fj = nullfunc_v_x(PRIMS[j]);
				t.assertz(i == j, ValueTypes.isAssignable(fi, fj));
			}
		}
	}

}

def test_nullfuncs2(t: Tester) {
	for (i < PRIMS.length) {
		for (j < PRIMS.length) {
			{
				var fi = nullfunc_x_v(PRIMS[i]);
				var fj = nullfunc_x_v(PRIMS[j]);
				t.assertz(i == j, ValueTypes.isAssignable(fi, fj));
			}

			{
				var fi = nullfunc_v_x(PRIMS[i]);
				var fj = nullfunc_v_x(PRIMS[j]);
				t.assertz(i == j, ValueTypes.isAssignable(fi, fj));
			}
		}
	}

}

def IMPORTED_TYPE1 = ImportedType.new(0, 0, []);
def IMPORTED_TYPE2 = ImportedType.new(1, 1, []);
def IMPORTED_TYPE3 = ImportedType.new(2, 2, [ValueType.Imported(IMPORTED_TYPE1)]);

def test_imported0(t: Tester) {
	var t1 = IMPORTED_TYPE1;
	var t2 = IMPORTED_TYPE2;

	// Assignability between different imported types
	var T = [t1, t2];
	for (i < T.length) {
		for (j < T.length) {
			t.assertz(i == j, T[i].isAssignableTo(ValueType.Imported(T[j])));
		}
	}
	// Assignability between imported type and primitives
	for (i < T.length) {
		for (j < PRIMS.length) {
			t.assertz(false, T[i].isAssignableTo(PRIMS[j]));
		}
	}
	// Assignability between imported type and extern ref
	for (i < T.length) {
		t.assertz(true, T[i].isAssignableTo(ValueType.EXTERNREF));
		t.assertz(false, T[i].isAssignableTo(ValueType.FUNCREF));
	}
	for (i < T.length) {
		var ext = ValueType.Imported(T[i]);
		t.assertz(false, ValueTypes.isAssignable(ValueType.EXTERNREF, ext));
		t.assertz(false, ValueTypes.isAssignable(ValueType.FUNCREF, ext));
		t.assertz(true, ValueTypes.isAssignable(ext, ValueType.EXTERNREF));
		t.assertz(false, ValueTypes.isAssignable(ext, ValueType.FUNCREF));
	}
}

def test_imported1(t: Tester) {
	var t1 = IMPORTED_TYPE1;
	var t2 = IMPORTED_TYPE2;

	var T = [t1, t2];
	// Assignability between imported type and functions of primitives
	for (i < T.length) {
		for (j < PRIMS.length) {
			var fj = func_x_v(PRIMS[j]);
			t.assertz(false, T[i].isAssignableTo(fj));
			fj = func_v_x(PRIMS[j]);
			t.assertz(false, T[i].isAssignableTo(fj));
		}
	}
	// Assignability between imported type and functions of imported type
	for (i < T.length) {
		for (j < T.length) {
			var fj = func_x_v(ValueType.Imported(T[j]));
			t.assertz(false, T[j].isAssignableTo(fj));
			fj = func_v_x(ValueType.Imported(T[j]));
			t.assertz(false, T[j].isAssignableTo(fj));
		}
	}
}

def test_imported2(t: Tester) {
	var t1 = IMPORTED_TYPE1;
	var t2 = IMPORTED_TYPE3;
	// Assignability between different imported types
	var T = [t1, t2];
	for (i < T.length) {
		for (j < T.length) {
			t.assertz(i >= j, T[i].isAssignableTo(ValueType.Imported(T[j])));
		}
	}
}

def assert_variance(t: Tester, a: ValueType, b: ValueType) {
	var ab = ValueTypes.isAssignable(a, b);
	var ba = ValueTypes.isAssignable(b, a);

	var f_a_v = func_x_v(a), f_b_v = func_x_v(b);
	var f_v_a = func_v_x(a), f_v_b = func_v_x(b);

	// covariance
	t.assertz(ab, ValueTypes.isAssignable(f_v_a, f_v_b));
	t.assertz(ba, ValueTypes.isAssignable(f_v_b, f_v_a));

	// contravariance
	t.assertz(ba, ValueTypes.isAssignable(f_a_v, f_b_v));
	t.assertz(ab, ValueTypes.isAssignable(f_b_v, f_a_v));

	// arity problems
	t.assertz(false, ValueTypes.isAssignable(f_a_v, f_v_a));
	t.assertz(false, ValueTypes.isAssignable(f_a_v, f_v_b));
	t.assertz(false, ValueTypes.isAssignable(f_b_v, f_v_a));
	t.assertz(false, ValueTypes.isAssignable(f_b_v, f_v_b));

	t.assertz(false, ValueTypes.isAssignable(f_v_a, f_a_v));
	t.assertz(false, ValueTypes.isAssignable(f_v_b, f_a_v));
	t.assertz(false, ValueTypes.isAssignable(f_v_a, f_b_v));
	t.assertz(false, ValueTypes.isAssignable(f_v_b, f_b_v));
}

def test_funcvar0(t: Tester) {
	var T = [ValueType.I32, ValueType.I64, ValueType.F32, ValueType.F64, ValueType.EXTERNREF, ValueType.FUNCREF];
	for (a in T) {
		for (b in T) {
			assert_variance(t, a, b);
		}
	}
}

def test_funcvar1(t: Tester) {
	var t1 = IMPORTED_TYPE1;
	var t2 = IMPORTED_TYPE3;
	var t3 = IMPORTED_TYPE2;

	var T = [ValueType.Imported(t1), ValueType.Imported(t2), ValueType.Imported(t3), ValueType.EXTERNREF, ValueType.FUNCREF];
	for (a in T) {
		for (b in T) {
			assert_variance(t, a, b);
		}
	}
}

def test_funcvar2(t: Tester) {
	var f = func_x_v(ValueType.I32), nf = nullfunc_x_v(ValueType.I32);
	assert_variance(t, f, nf);

	var t1 = IMPORTED_TYPE1;
	var t2 = IMPORTED_TYPE3;
	var T = [ValueType.Imported(t1), ValueType.Imported(t2)];
	for (a in T) {
		for (b in T) {
			var f = func_x_v(a), nf = nullfunc_x_v(b);
			assert_variance(t, f, nf);
		}
	}
}

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("interp:", _, InterpreterTester.new, _);
def X: Array<Value>;
def NONE = BpTypecon.EmptyBlock.code;

// Registers a "unop" opcode test
def reg1<X, Z>(opcode: Opcode,
		f: (Tester, Opcode, Array<(Z, X)>) -> void,
		cases: Array<(Z, X)>) {
	var buf = StringBuilder.new();
	buf.put1("interp:%s", opcode.mnemonic);
	UnitTests.register(buf.extract(), f(_, opcode, cases));
}

// Registers a "binop" opcode test
def reg2<I, R>(opcode: Opcode,
		f: (Tester, Opcode, Array<((I, I), R)>) -> void,
		cases: Array<((I, I), R)>) {
	var buf = StringBuilder.new();
	buf.put1("interp:%s", opcode.mnemonic);
	UnitTests.register(buf.extract(), f(_, opcode, cases));
}

// Runs a "unop" opcode test
def test_x_z<X, Z>(t: Tester, opcode: Opcode, sig: SigDecl,
	cases: Array<(Z, X)>,
	xv: X -> Value, zv: Z -> Value) {
	def i = InterpreterTester.new(t);
	i.sig(sig);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_GET.code, 1, opcode.code]);
	for (c in cases) {
		i.assert_v([xv(c.1)], zv(c.0));
	}
}
// Runs a "binop" opcode test that returns values
def test_xy_z<X, Y, Z>(t: Tester, opcode: Opcode, sig: SigDecl,
	cases: Array<((X, Y), Z)>,
	xv: X -> Value, yv: Y -> Value, zv: Z -> Value) {
	def i = InterpreterTester.new(t);
	i.sig(sig);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_GET.code, 1, opcode.code]);
	for (c in cases) {
		i.assert_v([xv(c.0.0), yv(c.0.1)], zv(c.1));
	}
}
// Runs a "binop" opcode test that may generate traps
def test_xy_r<X, Y>(t: Tester, opcode: Opcode, sig: SigDecl,
	cases: Array<((X, Y), Result)>,
	xv: X -> Value, yv: Y -> Value) {
	def i = InterpreterTester.new(t);
	i.sig(sig);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_GET.code, 1, opcode.code]);
	for (c in cases) {
		i.assert_r([xv(c.0.0), yv(c.0.1)], c.1);
	}
}
def T_u_u = reg1(_, test_x_z(_, _, SigCache.i_i, _, Values.u_v, Values.u_v), _);
def T_w_w = reg1(_, test_x_z(_, _, SigCache.l_l, _, Values.w_v, Values.w_v), _);
def T_w_u = reg1(_, test_x_z(_, _, SigCache.l_i, _, Values.w_v, Values.u_v), _);

def T_ii_i = reg2(_, test_xy_z(_, _, SigCache.ii_i, _, Values.i_v, Values.i_v, Values.i_v), _);
def T_uu_u = reg2(_, test_xy_z(_, _, SigCache.ii_i, _, Values.u_v, Values.u_v, Values.u_v), _);
def T_ii_r = reg2(_, test_xy_r(_, _, SigCache.ii_i, _, Values.i_v, Values.i_v), _);
def T_ll_l = reg2(_, test_xy_z(_, _, SigCache.ll_l, _, Values.l_v, Values.l_v, Values.l_v), _);
def T_ll_r = reg2(_, test_xy_r(_, _, SigCache.ll_l, _, Values.l_v, Values.l_v), _);
def T_ww_w = reg2(_, test_xy_z(_, _, SigCache.ll_l, _, Values.w_v, Values.w_v, Values.w_v), _);
def T_ll_u = reg2(_, test_xy_z(_, _, SigCache.ll_i, _, Values.l_v, Values.l_v, Values.u_v), _);


def i_r(val: i32) -> Result {
	return Result.Value([Value.I32(u32.!(val))]);
}
def u_r(val: u32) -> Result {
	return Result.Value([Value.I32(val)]);
}
def l_r(val: i64) -> Result {
	return Result.Value([Value.I64(u64.!(val))]);
}
def w_r(val: u64) -> Result {
	return Result.Value([Value.I64(val)]);
}

//===========================================================
// Begin registration of all tests
//===========================================================
def Z = [
	T("unreachable", test_unreachable),
	T("nop", test_nop),
	T("block", test_block),
	T("loop", test_loop),
	T("if0", test_if0),
	T("if1", test_if1),
	T("br0", test_br0),
	T("br1", test_br1),
	T("br2", test_br2),
	T("br_if", test_br_if),
	T("br_table0", test_br_table0),
	T("br_table1", test_br_table1),
	T("br_table2", test_br_table2),
	T("return", test_return),
	T("call1", test_call1),
	T("call2", test_call2),
	T("callN", test_callN),
	T("call_indirect", test_call_indirect),
	T("rcall1", test_rcall1),
	T("rcall2", test_rcall2),
	T("rcallN", test_rcallN),
	T("rcall_indirect", test_rcall_indirect),
	T("drop", test_drop),
	T("select", test_select),
	T("selectt", test_selectt),
	T("locals1", test_locals1),
	T("locals2", test_locals2),
	T("params", test_params),
	T("globals", test_globals),
	T("const", test_const),
	T("load8", test_load8),
	T("load16", test_load16),
	T("load32", test_load32),
	T("load64", test_load64),
	T("load_oob0", test_load_oob0),
	T("load_oob1", test_load_oob1),
	T("store8", test_store8),
	T("store16", test_store16),
	T("store32", test_store32),
	T("store64", test_store64),
	T("store_oob0", test_store_oob0),
	T("store_oob1", test_store_oob1),
	T("memory_size", test_memory_size),
	T("memory_grow1", test_memory_grow1),
	T("memory_grow2", test_memory_grow2),
	T("stack_overflow", test_stack_overflow),
	T("sign_ext", test_sign_ext),
	T("reinterpret", test_reinterpret),
	T("invalid", test_invalid),
	T("ref.null", test_ref_null),
	T("ref.is_null", test_ref_is_null),
	T("ref.func", test_ref_func),
	T("memory.init", test_memory_init),
	T("data.drop", test_data_drop),
	T("memory.copy", test_memory_copy),
	T("memory.fill", test_memory_fill),
	T("table.init", test_table_init),
	T("elem.drop", test_elem_drop),
	T("table.get", test_table_get),
	T("table.set", test_table_set),
	T("table.copy", test_table_copy),
	T("table.grow1", test_table_grow1),
	T("table.grow2", test_table_grow2),
	T("table.size", test_table_size),
	T("table.fill", test_table_fill),
	T("host_tail_call1", test_host_tail_call1),
	T("host_tail_call2", test_host_tail_call2),
	T("struct.new", test_struct_new),
	T("struct.new_with_rtt", test_struct_new_with_rtt),
	T("struct.new_default_with_rtt", test_struct_new_default_with_rtt),
	T("struct.get", test_struct_get),
	T("struct.get_su", test_struct_get_su),
	T("struct.set", test_struct_set),
	T("array.new", test_array_new),
	T("array.new_with_rtt", test_array_new_with_rtt),
	T("array.new_default_with_rtt", test_array_new_default_with_rtt),
	T("array.get", test_array_get),
	T("array.get_su", test_array_get_su),
	T("array.set", test_array_set),
	T("array.len", test_array_len),
	T("i31.new", test_i31_new),
	T("i31.get_s", test_i31_get_s),
	T("i31.get_u", test_i31_get_u),
	T("rtt.canon", test_rtt_canon),
	T("rtt.sub", test_rtt_sub),
	T("ref.test", test_ref_test),
	T("ref.cast", test_ref_cast),
	T("br_on_cast", test_br_on_cast),
	T("abstype_default", test_abstype_default),

	T_u_u(Opcode.I32_EQZ, [
		(1, 0),
		(0, 0xFACEDEAD),
		(0, 1)]),
	T_ii_i(Opcode.I32_EQ, [
		((0, 0), 1),
		((0xFACEDEAD, 0xFACEDEAD), 1),
		((0xEACEEACE, 0xFACEEACE), 0)]),
	T_ii_i(Opcode.I32_NE, [
		((99, 99), 0),
		((0xFAEEDEAD, 0xFACEDEAD), 1),
		((0xFACEEACE, 0xFACEEACE), 0)]),
	T_ii_i(Opcode.I32_LT_S, [
		((55, 54), 0),
		((55, 55), 0),
		((55, 56), 1),
		((-56, -55), 1),
		((-55, 56), 1)]),
	T_ii_i(Opcode.I32_LT_U, [
		((55, 54), 0),
		((55, 55), 0),
		((55, 56), 1),
		((-56, -55), 1),
		((-55, 56), 0)]),
	T_ii_i(Opcode.I32_GT_S, [
		((55, 54), 1),
		((55, 55), 0),
		((55, 56), 0),
		((-56, -55), 0),
		((-55, 56), 0)]),
	T_ii_i(Opcode.I32_GT_U, [
		((55, 54), 1),
		((55, 55), 0),
		((55, 56), 0),
		((-56, -55), 0),
		((-55, 56), 1)]),
	T_ii_i(Opcode.I32_LE_S, [
		((55, 54), 0),
		((55, 55), 1),
		((55, 56), 1),
		((-56, -55), 1),
		((-55, 56), 1)]),
	T_ii_i(Opcode.I32_LE_U, [
		((55, 54), 0),
		((55, 55), 1),
		((55, 56), 1),
		((-56, -55), 1),
		((-55, 56), 0)]),
	T_ii_i(Opcode.I32_GE_S, [
		((55, 54), 1),
		((55, 55), 1),
		((55, 56), 0),
		((-56, -55), 0),
		((-55, 56), 0)]),
	T_ii_i(Opcode.I32_GE_U, [
		((55, 54), 1),
		((55, 55), 1),
		((55, 56), 0),
		((-56, -55), 0),
		((-55, 56), 1)]),

	T_w_u(Opcode.I64_EQZ, [
		(1, 0),
		(0, 0xFACEDEAD),
		(0, 0x00300000000),
		(0, 1)]),
	T_ll_u(Opcode.I64_EQ, [
		((0, 0), 1),
		((0xFACEDEAD, 0xFACEDEAD), 1),
		((0x10000000FACEDEAD, 0x20000000FACEDEAD), 0),
		((0xEACEEACE, 0xFACEEACE), 0)]),
	T_ll_u(Opcode.I64_NE, [
		((99, 99), 0),
		((0xFAEEDEAD55, 0xFACEDEAD55), 1),
		((0xFACEEACE11223344, 0xFACEEACE11223344), 0)]),
	T_ll_u(Opcode.I64_LT_S, [
		((55000000000, 54000000000), 0),
		((55000000000, 55000000000), 0),
		((55000000000, 56000000000), 1),
		((-56000000000, -55000000000), 1),
		((-55000000000, 56000000000), 1)]),
	T_ll_u(Opcode.I64_LT_U, [
		((55111111111, 54111111111), 0),
		((55111111111, 55111111111), 0),
		((55111111111, 56111111111), 1),
		((-56111111111, -55111111111), 1),
		((-55111111111, 56111111111), 0)]),
	T_ll_u(Opcode.I64_GT_S, [
		((55222222222, 54222222222), 1),
		((55222222222, 55222222222), 0),
		((55222222222, 56222222222), 0),
		((-56222222222, -55222222222), 0),
		((-55222222222, 56222222222), 0)]),
	T_ll_u(Opcode.I64_GT_U, [
		((55333333333, 54333333333), 1),
		((55333333333, 55333333333), 0),
		((55333333333, 56333333333), 0),
		((-56333333333, -55333333333), 0),
		((-55333333333, 56333333333), 1)]),
	T_ll_u(Opcode.I64_LE_S, [
		((55444444444, 54444444444), 0),
		((55444444444, 55444444444), 1),
		((55444444444, 56444444444), 1),
		((-56444444444, -55444444444), 1),
		((-55444444444, 56444444444), 1)]),
	T_ll_u(Opcode.I64_LE_U, [
		((55555555555, 54555555555), 0),
		((55555555555, 55555555555), 1),
		((55555555555, 56555555555), 1),
		((-56555555555, -55555555555), 1),
		((-55555555555, 56555555555), 0)]),
	T_ll_u(Opcode.I64_GE_S, [
		((55666666666, 54666666666), 1),
		((55666666666, 55666666666), 1),
		((55666666666, 56666666666), 0),
		((-56666666666, -55666666666), 0),
		((-55666666666, 56666666666), 0)]),
	T_ll_u(Opcode.I64_GE_U, [
		((55777777777, 54777777777), 1),
		((55777777777, 55777777777), 1),
		((55777777777, 56777777777), 0),
		((-56777777777, -55777777777), 0),
		((-55777777777, 56777777777), 1)]),

	T_u_u(Opcode.I32_CLZ, [
		(32, 0),
		(16, 0x8000),
		(0, 0x80000000),
		(31, 1)]),
	T_u_u(Opcode.I32_CTZ, [
		(32, 0),
		(15, 0x8000),
		(31, 0x80000000),
		(0, 1)]),
	T_u_u(Opcode.I32_POPCNT, [
		(0, 0),
		(1, 1),
		(4, 0xF),
		(32, 0xFFFFFFFF)]),
	T_ii_i(Opcode.I32_ADD, [
		((4312, 9921), 14233),
		((0xffff0000, 0x00010000), 0x00000000),
		((0x0fff0000, 0x00010000), 0x10000000),
		((0xffff0000, 0x0000ffff), 0xffffffff)]),
	T_ii_i(Opcode.I32_SUB, [
		((76324872, 7623891), 68700981),
		((0, 1), 0xFFFFFFFF),
		((444, 444), 0)]),
	T_ii_i(Opcode.I32_MUL, [
		((8122, 67), 544174),
		((0xffff0000, 0), 0),
		((0x87234878, 0x1124783), 0x80975D68)]),
	T_ii_r(Opcode.I32_DIV_S, [
		((99, 3), u_r(33)),
		((99, -3), i_r(-33)),
		((1, 0), Result.Trap(TrapReason.DIV_BY_ZERO)),
		((i32.min, -1), Result.Trap(TrapReason.DIV_UNREPRESENTABLE))]),
	T_ii_r(Opcode.I32_DIV_U, [
		((99, 3), u_r(33)),
		((99, -3), u_r(0)),
		((1, 0), Result.Trap(TrapReason.DIV_BY_ZERO)),
		((0x80000000, 0xFFFFFFFF), u_r(0))]),
	T_ii_r(Opcode.I32_REM_S, [
		((99, 10), u_r(9)),
		((107, -10), i_r(7)),
		((-107, -10), i_r(-7)),
		((-107, 10), i_r(-7)),
		((1, 0), Result.Trap(TrapReason.REM_BY_ZERO)),
		((5559823, 1), u_r(0)),
		((0x80000000, 0xFFFFFFFF), u_r(0))]),
	T_ii_r(Opcode.I32_REM_U, [
		((13338, 10), u_r(8)),
		((99, -3), u_r(99)),
		((1, 0), Result.Trap(TrapReason.REM_BY_ZERO)),
		((555, 1), u_r(0)),
		((0x80000000, 0xFFFFFFFF), u_r(0x80000000))]),
	T_uu_u(Opcode.I32_AND, [
		((0xFFFFF000, 0x000FFFFF), 0x000FF000)]),
	T_uu_u(Opcode.I32_OR, [
		((0x0FFFF000, 0x000FFFFF), 0x0FFFFFFF)]),
	T_uu_u(Opcode.I32_XOR, [
		((0x0FFFF000, 0x000FFFFF), 0x0FF00FFF)]),
	T_uu_u(Opcode.I32_SHL, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0xFFFFFFFF, 31), 0x80000000),
		((0x000FF000, 36), 0x00FF0000)]),
	T_uu_u(Opcode.I32_SHR_S, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0x0FFFFFFF, 27), 0x00000001),
		((0xFFFFFF00, 4), 0xFFFFFFF0),
		((0x000FF000, 36), 0x0000FF00)]),
	T_uu_u(Opcode.I32_SHR_U, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0xFFFFFFFF, 31), 0x00000001),
		((0x000FF000, 36), 0x0000FF00)]),
	T_uu_u(Opcode.I32_ROTL, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0xABCD0123, 36), 0xBCD0123A)]),
	T_uu_u(Opcode.I32_ROTR, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0xABCD0123, 36), 0x3ABCD012)]),

	T_w_w(Opcode.I64_CLZ, [
		(64, 0),
		(48, 0x8000),
		(32, 0x80000000),
		(0, 0x8000000000000000),
		(63, 1)]),
	T_w_w(Opcode.I64_CTZ, [
		(64, 0),
		(15, 0x8000),
		(31, 0x80000000),
		(63, 0x8000000000000000),
		(0, 1)]),
	T_w_w(Opcode.I64_POPCNT, [
		(0, 0),
		(1, 1),
		(4, 0xF),
		(8, 0xF00000000F0),
		(32, 0x3333333333333333),
		(64, 0xFFFFFFFFFFFFFFFF),
		(32, 0xFFFFFFFF)]),
	T_ww_w(Opcode.I64_ADD, [
		((4312000111000, 9921111000111), 14233111111111),
		((0xffff0000, 0x00010000), 0x100000000),
		((0x0fff0000, 0x00010000), 0x10000000),
		((0xffff0000, 0x0000ffff), 0xffffffff)]),
	T_ll_l(Opcode.I64_SUB, [
		((76324872010101, 7623891010101), 68700981000000),
		((0, 1), -1),
		((4449988776655, 4449988776655), 0)]),
	T_ww_w(Opcode.I64_MUL, [
		((8122000, 67000), 544174000000),
		((0xffff0000, 0), 0),
		((0x87234878, 0x1124783), 0x90C98380975D68)]),
	T_ll_r(Opcode.I64_DIV_S, [
		((99, 3), w_r(33)),
		((99, -3), l_r(-33)),
		((1, 0), Result.Trap(TrapReason.DIV_BY_ZERO)),
		((i64.min, -1), Result.Trap(TrapReason.DIV_UNREPRESENTABLE))]),
	T_ll_r(Opcode.I64_DIV_U, [
		((99, 3), w_r(33)),
		((99, -3), w_r(0)),
		((1, 0), Result.Trap(TrapReason.DIV_BY_ZERO)),
		((i64.min, -1), w_r(0))]),
	T_ll_r(Opcode.I64_REM_S, [
		((99, 10), w_r(9)),
		((107, -10), l_r(7)),
		((-107, -10), l_r(-7)),
		((-107, 10), l_r(-7)),
		((1, 0), Result.Trap(TrapReason.REM_BY_ZERO)),
		((5559823, 1), w_r(0)),
		((i64.min, -1), w_r(0))]),
	T_ll_r(Opcode.I64_REM_U, [
		((13338, 10), w_r(8)),
		((99, -3), w_r(99)),
		((1, 0), Result.Trap(TrapReason.REM_BY_ZERO)),
		((555, 1), w_r(0)),
		((0x80000000u, -1), w_r(0x80000000u))]),
	T_ww_w(Opcode.I64_AND, [
		((0xFFFFFFFFFF00FF00, 0xFF00FF00FFFFFFFF), 0xFF00FF00FF00FF00)]),
	T_ww_w(Opcode.I64_OR, [
		((0x0FFFFFFFF0000000, 0x0000000FFFFFFFFF), 0x0FFFFFFFFFFFFFFF)]),
	T_ww_w(Opcode.I64_XOR, [
		((0xFFFFFFFFFF00FF00, 0xFF00FF00FFFFFFFF), 0x00FF00FF00FF00FF)]),
	T_ww_w(Opcode.I64_SHL, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 64), 0x000FF000),
		((0x000FF000, 32), 0x000FF00000000000),
		((0xFFFFFFFF, 31), 0x7FFFFFFF80000000),
		((0x000FF000, 68), 0x00FF0000),
		((0x000FF000, 36), 0x00FF000000000000)]),
	T_ww_w(Opcode.I64_SHR_S, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 64), 0x000FF000),
		((0x000FF00000000000, 32), 0x000FF000),
		((0x0FFFFFFF, 27), 0x00000001),
		((0xFFFFFFFFFFFFFF00, 4), 0xFFFFFFFFFFFFFFF0),
		((0x000FF000, 68), 0x0000FF00)]),
	T_ww_w(Opcode.I64_SHR_U, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF00011223344, 32), 0x000FF000),
		((0x000FF000, 64), 0x000FF000),
		((0xFFFFFFFFFFFFFFFF, 63), 0x00000001),
		((0x000FF000, 68), 0x0000FF00)]),
	T_ww_w(Opcode.I64_ROTL, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF00000000000, 32), 0x000FF000),
		((0x000FF000, 64), 0x000FF000),
		((0x0123456789ABCDEF, 68), 0x123456789ABCDEF0)]),
	T_ww_w(Opcode.I64_ROTR, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF00000000000),
		((0x000FF000, 64), 0x000FF000),
		((0x0123456789ABCDEF, 68), 0xF0123456789ABCDE)]),
	()
];


class InterpreterTester(t: Tester) extends ModuleBuilder {
	var limit = 1000;
	var max_call_depth = 100;

	def timeout(t: int) -> this {
		limit = t;
	}
	def codev(raw: Array<byte>) -> this {
		code(raw);
		var v = CodeValidator.new(extensions, Limits.new().set(extensions), module, WasmErrorGen.new(module.filename));
		var r = v.validateFunc(func);
		match (r) {
			Ok => ;
			Error(error, pc, msg) => t.fail2("invalid code @+%d: %s", pc, msg);
		}
	}
	def run(args: Array<Value>) -> (Instance, Result) {
		var instance = Instantiator.new(extensions, module, [], WasmErrorGen.new("InterpreterTest.v3")).run();
		var f = instance.functions[0];
		var i = Interpreter.new();
		i.max_call_depth = max_call_depth;
		var buf: StringBuilder;
		if (Trace.interpreter) {
			buf = StringBuilder.new();
			buf.puts("run ");
			Values.renderVals(buf, args);
			buf.ln();
			System.puts(buf.extract());
		}
		var r = i.run(limit, f, args);
		if (Trace.interpreter) {
			buf.put1(" -> %q\n", r.render);
			System.puts(buf.extract());
		}
		return (instance, r);
	}
	def assert_u32(args: Array<Value>, expected: u32) {
		assert_v(args, Value.I32(expected));
	}
	def assert_u64(args: Array<Value>, expected: u64) {
		assert_v(args, Value.I64(expected));
	}
	def assert_f32(args: Array<Value>, expected: u32) {
		assert_v(args, Value.F32(expected));
	}
	def assert_f64(args: Array<Value>, expected: u64) {
		assert_v(args, Value.F64(expected));
	}
	def assert_i_i(arg: u32, expected: u32) {
		assert_u32([Value.I32(arg)], expected);
	}
	def assert_i(expected: u32) {
		assert_u32(X, expected);
	}
	def assert_l_l(arg: u64, expected: u64) {
		assert_u64([Value.I64(arg)], expected);
	}
	def assert_i_l(arg: u32, expected: u64) {
		assert_u64([Value.I32(arg)], expected);
	}
	def assert_ii_i(args: (u32, u32), expected: u32) {
		assert_u32([Value.I32(args.0), Value.I32(args.1)], expected);
	}
	def assert_mem(args: Array<Value>, offset: u32, expected: Array<byte>) {
		var tr = run(args), instance = tr.0, r = tr.1;
		checkNop(r);
		var data = instance.memories[0].data;
		for (i < expected.length) {
			var addr = int.!(offset) + i;
			var got = data[addr];
			if (expected[i] != got) return t.fail3("expected mem[%x] = %x, got %x", addr, expected[i], got);
		}
	}
	def assert_ftable(args: Array<Value>, offset: u32, expected: Array<FuncDecl>) {
		var tr = run(args), instance = tr.0, r = tr.1;
		checkNop(r);
		var elems = instance.tables[0].elems;
		for (i < expected.length) {
			var addr = int.!(offset) + i;
			var exp = expected[i];
			var got = Value.FuncRef.!(elems[addr]).val;
			if (exp == null) {
				if (got != null) return t.fail1("expected table[%d] == null", addr);
			} else {
				if (!WasmFunction.?(got)) return t.fail2("expected table[%d] : WasmFunction%s ", addr, if(got == null, ", got null", ""));
				var wgot = WasmFunction.!(got);
				if (exp != wgot.decl) return t.fail3("expected table[%d] = #%d, got #%d", addr, expected[i].func_index, wgot.decl.func_index);
			}
		}
	}
	def assert_r(args: Array<Value>, expected: Result) {
		assert_req(run(args).1, expected);
	}
	def assert_req(got: Result, expected: Result) {
		if (!expected.equals(got)) t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_v(args: Array<Value>, expected: Value) {
		assert_r(args, Result.Value([expected]));
	}
	def assert_g(args: Array<Value>, findex: int) {
		var r = run(args), instance = r.0, got = r.1;
		var expected = Result.Value([Value.FuncRef(instance.functions[findex])]);
		if (expected.equals(got)) return;
		t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_trap(args: Array<Value>, expected: TrapReason) {
		assert_r(args, Result.Trap(expected));
	}
	def assert_nop(args: Array<Value>) {
		var r = run(args);
		checkNop(r.1);
	}
	def assert_val1<V>(got: Result, kind: string) -> (bool, V) {
		match (got) {
			Value(vals) => if (vals.length == 1) {
				var v = vals[0];
				if (V.?(v)) return (true, V.!(v));
			}
			_ => ;
		}
		t.fail2("expected 1 %s value, got %q", kind, got.render);
		var d: V;
		return (false, d);
	}
	def assert_struct(got: Result, expected_struct: StructDecl, rtt: Value.Rtt, fields: Array<Value>) {
		var r = assert_val1<Value.Ref>(got, "struct"), ok = r.0, hr = r.1;
		if (!ok) return;
		if (!HeapStruct.?(hr.val)) return t.fail1("expected struct, got %q", got.render);
		var obj = HeapStruct.!(hr.val);
		if (obj.decl != expected_struct) return t.fail2("expected heap %q, got %q",
			expected_struct.render, obj.decl.render);
		if (obj.rtt != rtt) return t.fail2("expected rtt %q, got %q", rtt.render, obj.rtt.render);
		t.assertar("fields", fields, obj.vals, Value.render);
	}
	def assert_array(got: Result, expected_array: ArrayDecl, rtt: Value.Rtt, elems: Array<Value>) {
		var r = assert_val1<Value.Ref>(got, "array"), ok = r.0, hr = r.1;
		if (!ok) return;
		if (!HeapArray.?(hr.val)) return t.fail1("expected array, got %q", got.render);
		var obj = HeapArray.!(hr.val);
		if (obj.decl != expected_array) return t.fail2("expected heap %q, got %q",
			expected_array.render, obj.decl.render);
		if (obj.rtt != rtt) return t.fail2("expected rtt %q, got %q", rtt.render, obj.rtt.render);
		t.assertar("elements", elems, obj.vals, Value.render);
	}
	def assert_rtt(got: Result, decl: HeapTypeDecl, supers: Array<Value.Rtt>) {
		var r = assert_val1<Value.Rtt>(got, "rtt"), ok = r.0, rtt = r.1;
		if (!ok) return;
		if (rtt.heaptype != decl) return t.fail2("expected rtt %q, got %q", decl.render, rtt.heaptype.render);
		var expected_len = 1 + supers.length;
		if (rtt.supers.length != expected_len) {
			return t.fail2("expected rtt %d, got %d", expected_len, rtt.supers.length);
		}
		for (i < rtt.supers.length) {
			var expected = if(i < supers.length, supers[i], rtt);
			if (rtt.supers[i] != expected) t.fail3("expected rtt[%d] %q, got %q",
					i, expected, rtt.supers[i].render);
		}
	}
	def checkNop(r: Result) {
		match (r) {
			Break => t.fail("unexpected breakpoint");
			Trap(reason) => t.fail1("unexpected trap: %s", reason.name);
			Value(vals) => {
				var len = if(vals != null, vals.length);
				if (len > 0) t.fail1("expected no values, got %d value(s)", len);
			}
		}
	}
}

//===========================================================
// Begin actual tests
//===========================================================
def test_unreachable(i: InterpreterTester) {
	i.code([Opcode.UNREACHABLE.code]).assert_trap(X, TrapReason.UNREACHABLE);
}

def test_nop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([Opcode.NOP.code]).assert_nop(X);
}

def test_block(i: InterpreterTester) {
	i.sig(SigCache.v_v);
	i.code([Opcode.BLOCK.code, NONE,
		Opcode.END.code]);
	i.assert_nop(X);

	i.sig(SigCache.i_i);
	i.code([Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.END.code]);
	i.assert_i_i(9, 9);
	i.assert_i_i(7, 7);

	i.sig(SigCache.l_l);
	i.code([Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.END.code]);
	i.assert_l_l(9, 9);
	i.assert_l_l(7, 7);
}

def test_loop(i: InterpreterTester) {
	i.sig(SigCache.v_v);
	i.code([Opcode.LOOP.code, NONE, Opcode.END.code]);
	i.assert_nop(X);

	i.sig(SigCache.i_i);
	i.codev([Opcode.LOOP.code, NONE,
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_SUB.code,
		Opcode.LOCAL_TEE.code, 0,
		Opcode.BR_IF.code, 0,
		Opcode.END.code,
		Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(1, 0);
	i.assert_i_i(5, 0);

	i.codev([Opcode.LOOP.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_SUB.code,
		Opcode.LOCAL_TEE.code, 0,
		Opcode.BR_IF.code, 0,
		Opcode.END.code]);
	i.assert_i_i(1, 1);
	i.assert_i_i(5, 1);
}

// TODO: test loops with fall through values
// TODO: test loops with arguments

def test_if0(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, NONE,
		Opcode.I32_CONST.code, 11,
		Opcode.RETURN.code,
		Opcode.ELSE.code,
		Opcode.I32_CONST.code, 22,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.UNREACHABLE.code]);
	i.assert_i_i(9, 11);
	i.assert_i_i(0, 22);
	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, NONE,
		Opcode.I32_CONST.code, 33,
		Opcode.LOCAL_SET.code, 0,
		Opcode.ELSE.code,
		Opcode.I32_CONST.code, 44,
		Opcode.LOCAL_SET.code, 0,
		Opcode.END.code,
		Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(7, 33);
	i.assert_i_i(0, 44);

	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, NONE,
		Opcode.I32_CONST.code, 13,
		Opcode.LOCAL_SET.code, 0,
		Opcode.END.code,
		Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(7, 13);
	i.assert_i_i(0, 0);
}
def test_if1(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 17,
		Opcode.ELSE.code,
		Opcode.I32_CONST.code, 27,
		Opcode.END.code]);
	i.assert_i_i(6, 17);
	i.assert_i_i(0, 27);

	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 18,
		Opcode.BR.code, 0,
		Opcode.ELSE.code,
		Opcode.I32_CONST.code, 28,
		Opcode.BR.code, 0,
		Opcode.END.code]);
	i.assert_i_i(4, 18);
	i.assert_i_i(0, 28);
}
def test_br0(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.LOCAL_GET.code, 0, Opcode.BR.code, 0]);
	i.assert_i_i(3, 3);
	i.assert_i_i(9, 9);

	i.sig(SigCache.ii_i);
	i.codev([Opcode.LOCAL_GET.code, 1, Opcode.LOCAL_GET.code, 0, Opcode.BR.code, 0]);
	i.assert_ii_i((7, 11), 7);
	i.assert_ii_i((5, 99), 5);
}
def test_br1(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR.code, 0,
		Opcode.END.code]);
	i.assert_i_i(37, 37);
	i.assert_i_i(94, 94);

	i.sig(SigCache.ii_i);
	i.codev([Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR.code, 0,
		Opcode.END.code,
		Opcode.RETURN.code]);
	i.assert_ii_i((71, 11), 71);
	i.assert_ii_i((52, 99), 52);
}
def test_br2(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([
		Opcode.I32_CONST.code, 9,
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 5,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR.code, 0,
		Opcode.END.code,
		Opcode.I32_ADD.code]);
	i.assert_i_i(37, 46);
	i.assert_i_i(94, 103);
}
def test_br_if(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.I32_CONST.code, 7,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_IF.code, 0,
		Opcode.DROP.code,
		Opcode.I32_CONST.code, 8]);
	i.assert_i_i(11, 7);
	i.assert_i_i(0, 8);

	i.sig(SigCache.i_i);
	i.codev([Opcode.BLOCK.code, NONE,
		Opcode.I32_CONST.code, 9,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_IF.code, 1,
		Opcode.DROP.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 5]);
	i.assert_i_i(17, 9);
	i.assert_i_i(0, 5);
}
def test_br_table0(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.I32_CONST.code, 7,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2,
		0, 0, 0,
		Opcode.UNREACHABLE.code]);
	i.assert_i_i(0, 7);
	i.assert_i_i(1, 7);
	i.assert_i_i(2, 7);
	i.assert_i_i(3, 7);
	i.assert_i_i(4, 7);
	i.assert_i_i(0xFFFFFFFF, 7);

	i.codev([Opcode.BLOCK.code, NONE,
		Opcode.BLOCK.code, NONE,
		Opcode.BLOCK.code, NONE,
		Opcode.BLOCK.code, NONE,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2,
		0, 2, 1,
		Opcode.UNREACHABLE.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 16,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 17,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 18,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.UNREACHABLE.code
		]);
	i.assert_i_i(0, 16);
	i.assert_i_i(1, 18);
	i.assert_i_i(2, 17);
	i.assert_i_i(3, 17);
	i.assert_i_i(4, 17);
	i.assert_i_i(0xFFFFFFFF, 17);
}
def test_br_table1(i: InterpreterTester) {
	i.sig(SigCache.ii_i);

	i.codev([Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2,
		0, 2, 1,
		Opcode.UNREACHABLE.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 16,
		Opcode.I32_ADD.code,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 17,
		Opcode.I32_ADD.code,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 18,
		Opcode.I32_ADD.code,
		Opcode.RETURN.code,
		Opcode.END.code
		]);
	i.assert_ii_i((0, 0), 16);
	i.assert_ii_i((0, 10), 26);
	i.assert_ii_i((1, 0), 18);
	i.assert_ii_i((1, 20), 38);
	i.assert_ii_i((2, 0), 17);
	i.assert_ii_i((2, 30), 47);
	i.assert_ii_i((3, 0), 17);
	i.assert_ii_i((3, 40), 57);
	i.assert_ii_i((4, 0), 17);
	i.assert_ii_i((4, 50), 67);
	i.assert_ii_i((0xFFFFFFFF, 0), 17);
	i.assert_ii_i((0xFFFFFFFF, 60), 77);
}
def test_br_table2(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.codev([
		Opcode.I32_CONST.code, 9,
		Opcode.BLOCK.code, BpTypecon.I32.code,
		Opcode.I32_CONST.code, 42,
		Opcode.I32_CONST.code, 42,
		Opcode.I32_CONST.code, 42,
		Opcode.I32_CONST.code, 5,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 0, 0,
		Opcode.END.code,
		Opcode.I32_ADD.code]);
	i.assert_i_i(0, 14);
	i.assert_i_i(1, 14);
	i.assert_i_i(444, 14);
}
def test_return(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([Opcode.RETURN.code]).assert_nop(X);
	i.sig(SigCache.v_v).code([Opcode.I32_CONST.code, 0,
				  Opcode.RETURN.code]).assert_nop(X);
	i.sig(SigCache.v_i).code([Opcode.I32_CONST.code, 9,
				  Opcode.RETURN.code]).assert_i(9);
	i.sig(SigCache.v_i).code([Opcode.I32_CONST.code, 7,
				  Opcode.I32_CONST.code, 13,
				  Opcode.RETURN.code]).assert_i(13);
}
def test_call1(i: InterpreterTester) {
	var f17 = byte.!(i.newFunction(SigCache.v_i, [Opcode.I32_CONST.code, 17]).func_index);
	var f18 = byte.!(i.newFunction(SigCache.v_i, [Opcode.I32_CONST.code, 18]).func_index);
	var f19 = byte.!(i.newFunction(SigCache.v_i, [Opcode.I32_CONST.code, 19]).func_index);
	i.code([Opcode.CALL.code, f17]).assert_i(17);
	i.code([Opcode.CALL.code, f18]).assert_i(18);
	i.code([Opcode.CALL.code, f19]).assert_i(19);
}
def test_call2(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	var f1 = byte.!(i.newFunction(SigCache.i_i, [Opcode.LOCAL_GET.code, 0]).func_index);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.CALL.code, f1]);
	i.assert_i_i(197, 197);
	i.assert_i_i(36, 36);
	i.assert_i_i(31337, 31337);

	i.sig(SigCache.ii_i);
	var f2 = byte.!(i.newFunction(SigCache.ii_i, [Opcode.LOCAL_GET.code, 0]).func_index);
	var f3 = byte.!(i.newFunction(SigCache.ii_i, [Opcode.LOCAL_GET.code, 1]).func_index);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.CALL.code, f2]);
	i.assert_ii_i((22, 33), 22);
	i.assert_ii_i((44, 55), 44);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
	Opcode.CALL.code, f3]);
	i.assert_ii_i((77, 88), 88);
	i.assert_ii_i((88, 99), 99);
}
def test_callN(i: InterpreterTester) {
	var I = ValueType.I32;
	var sig_iiiii_i = SigDecl.new([I, I, I, I, I], [I]);
	i.sig(sig_iiiii_i);
	for (j < byte.!(5)) {
		var body = [Opcode.LOCAL_GET.code, j];
		var fx = byte.!(i.newFunction(sig_iiiii_i, body).func_index);
		i.codev([Opcode.LOCAL_GET.code, 0,
			Opcode.LOCAL_GET.code, 1,
			Opcode.LOCAL_GET.code, 2,
			Opcode.LOCAL_GET.code, 3,
			Opcode.LOCAL_GET.code, 4,
			Opcode.CALL.code, fx]);
		var args: Array<Value> = [Value.I32(j + 100u),
				Value.I32(j + 200u),
				Value.I32(j + 300u),
				Value.I32(j + 400u),
				Value.I32(j + 500u)];
		var result = args[j];
		i.assert_v(args, result);
	}
}
def test_call_indirect(i: InterpreterTester) {
	i.sig(SigCache.ii_i);
	var f1 = i.newFunction(SigCache.i_i, [Opcode.I32_CONST.code, 11]);
	var f2 = i.newFunction(SigCache.i_i, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 22,
		Opcode.I32_ADD.code
	]);
	var f3 = i.newFunction(SigCache.v_v, []);
	i.addTable(7, 0, [f1.func_index, f2.func_index, f3.func_index, f1.func_index, f2.func_index, f3.func_index]);
	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.CALL_INDIRECT.code, byte.!(f1.sig.sig_index), 0]);
	i.assert_ii_i((0, 0), 11);
	i.assert_ii_i((0, 1), 22);
	i.assert_ii_i((44, 1), 66);
	i.assert_ii_i((0, 3), 11);
	i.assert_ii_i((0, 4), 22);
	i.assert_ii_i((49, 4), 71);
	i.assert_trap([Value.I32(0), Value.I32(2)], TrapReason.FUNC_SIG_MISMATCH);
	i.assert_trap([Value.I32(0), Value.I32(5)], TrapReason.FUNC_SIG_MISMATCH);
	i.assert_trap([Value.I32(0), Value.I32(6)], TrapReason.FUNC_INVALID);
	i.assert_trap([Value.I32(0), Value.I32(7)], TrapReason.FUNC_INVALID);
}

def test_rcall1(i: InterpreterTester) {
	var f17 = byte.!(i.newFunction(SigCache.v_i, [Opcode.I32_CONST.code, 17]).func_index);
	var f18 = byte.!(i.newFunction(SigCache.v_i, [Opcode.I32_CONST.code, 18]).func_index);
	var f19 = byte.!(i.newFunction(SigCache.v_i, [Opcode.I32_CONST.code, 19]).func_index);
	i.code([Opcode.RETURN_CALL.code, f17]).assert_i(17);
	i.code([Opcode.RETURN_CALL.code, f18]).assert_i(18);
	i.code([Opcode.RETURN_CALL.code, f19]).assert_i(19);
}
def test_rcall2(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	var f1 = byte.!(i.newFunction(SigCache.i_i, [Opcode.LOCAL_GET.code, 0]).func_index);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.RETURN_CALL.code, f1]);
	i.assert_i_i(197, 197);
	i.assert_i_i(36, 36);
	i.assert_i_i(31337, 31337);

	i.sig(SigCache.ii_i);
	var f2 = byte.!(i.newFunction(SigCache.ii_i, [Opcode.LOCAL_GET.code, 0]).func_index);
	var f3 = byte.!(i.newFunction(SigCache.ii_i, [Opcode.LOCAL_GET.code, 1]).func_index);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.RETURN_CALL.code, f2,
		Opcode.UNREACHABLE.code]);
	i.assert_ii_i((22, 33), 22);
	i.assert_ii_i((44, 55), 44);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.RETURN_CALL.code, f3,
		Opcode.UNREACHABLE.code]);
	i.assert_ii_i((77, 88), 88);
	i.assert_ii_i((88, 99), 99);
}
def test_rcallN(i: InterpreterTester) {
	var I = ValueType.I32;
	var sig_iiiii_i = SigDecl.new([I, I, I, I, I], [I]);
	i.extensions |= Extension.TAIL_CALL;
	i.sig(sig_iiiii_i);
	for (j < byte.!(5)) {
		var body = [Opcode.LOCAL_GET.code, j];
		var fx = byte.!(i.newFunction(sig_iiiii_i, body).func_index);
		i.codev([Opcode.LOCAL_GET.code, 0,
			Opcode.LOCAL_GET.code, 1,
			Opcode.LOCAL_GET.code, 2,
			Opcode.LOCAL_GET.code, 3,
			Opcode.LOCAL_GET.code, 4,
			Opcode.RETURN_CALL.code, fx,
			Opcode.UNREACHABLE.code]);
		var args: Array<Value> = [Value.I32(j + 100u),
				Value.I32(j + 200u),
				Value.I32(j + 300u),
				Value.I32(j + 400u),
				Value.I32(j + 500u)];
		var result = args[j];
		i.assert_v(args, result);
	}
}
def test_rcall_indirect(i: InterpreterTester) {
	i.sig(SigCache.ii_i);
	i.extensions |= Extension.TAIL_CALL;
	var f1 = i.newFunction(SigCache.i_i, [Opcode.I32_CONST.code, 11]);
	var f2 = i.newFunction(SigCache.i_i, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 22,
		Opcode.I32_ADD.code
	]);
	var f3 = i.newFunction(SigCache.v_v, []);
	i.addTable(7, 0, [f1.func_index, f2.func_index, f3.func_index, f1.func_index, f2.func_index, f3.func_index]);
	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.RETURN_CALL_INDIRECT.code, byte.!(f1.sig.sig_index), 0,
		Opcode.UNREACHABLE.code]);
	i.assert_ii_i((0, 0), 11);
	i.assert_ii_i((0, 1), 22);
	i.assert_ii_i((44, 1), 66);
	i.assert_ii_i((0, 3), 11);
	i.assert_ii_i((0, 4), 22);
	i.assert_ii_i((49, 4), 71);
	i.assert_trap([Value.I32(0), Value.I32(2)], TrapReason.FUNC_SIG_MISMATCH);
	i.assert_trap([Value.I32(0), Value.I32(5)], TrapReason.FUNC_SIG_MISMATCH);
	i.assert_trap([Value.I32(0), Value.I32(6)], TrapReason.FUNC_INVALID);
	i.assert_trap([Value.I32(0), Value.I32(7)], TrapReason.FUNC_INVALID);
}

def test_drop(i: InterpreterTester) {
	i.sig(SigCache.v_v).code([Opcode.I32_CONST.code, 0, Opcode.DROP.code])
		.assert_nop(X);
	i.sig(SigCache.v_i).code([Opcode.I32_CONST.code, 3,
				  Opcode.DROP.code,
				  Opcode.I32_CONST.code, 11])
		.assert_i(11);
	i.sig(SigCache.v_i).code([Opcode.I32_CONST.code, 4,
				  Opcode.I32_CONST.code, 5,
				  Opcode.DROP.code])
		.assert_i(4);
}
def test_select(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.code([Opcode.I32_CONST.code, 11,
		Opcode.I32_CONST.code, 22,
		Opcode.LOCAL_GET.code, 0,
		Opcode.SELECT.code]);
	i.assert_i_i(1, 11);
	i.assert_i_i(108, 11);
	i.assert_i_i(0, 22);

	i.sig(SigCache.l_l);
	i.code([Opcode.I64_CONST.code, 33,
		Opcode.I64_CONST.code, 44,
		Opcode.LOCAL_GET.code, 0,
		Opcode.SELECT.code]);
	i.assert_u64([Value.I32(1)], 33);
	i.assert_u64([Value.I32(109)], 33);
	i.assert_u64([Value.I32(0)], 44);

	i.sig(SigCache.f_f);
	i.code([Opcode.F32_CONST.code, 0x11, 0x22, 0x33, 0x44,
		Opcode.F32_CONST.code, 0x55, 0x66, 0x77, 0x88,
		Opcode.LOCAL_GET.code, 0,
		Opcode.SELECT.code]);
	i.assert_f32([Value.I32(1)], 0x44332211);
	i.assert_f32([Value.I32(66)], 0x44332211);
	i.assert_f32([Value.I32(0)], 0x88776655);

	i.sig(SigCache.d_d);
	i.code([Opcode.F64_CONST.code, 0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,
		Opcode.F64_CONST.code, 0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,
		Opcode.LOCAL_GET.code, 0,
		Opcode.SELECT.code]);
	i.assert_f64([Value.I32(1)], 0x8877665544332211);
	i.assert_f64([Value.I32(66)], 0x8877665544332211);
	i.assert_f64([Value.I32(0)], 0x0807060504030201);
}
def test_selectt(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	i.sig0([ValueType.EXTERNREF, ValueType.EXTERNREF, ValueType.I32], SigCache.arr_e);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.SELECT_T.code, 1, BpTypecon.EXTERNREF.code]);
	var v1: Value = Value.Ref(HostObject.new());
	var v2: Value = Value.Ref(HostObject.new());
	i.assert_v([v1, v2, Value.I32(0)], v2);
	i.assert_v([v1, v2, Value.I32(1)], v1);

	// Multi-value select
	var v3: Value = Value.Ref(HostObject.new());
	var v4: Value = Value.Ref(HostObject.new());
	i.sig0(
		[ValueType.EXTERNREF, ValueType.EXTERNREF, ValueType.EXTERNREF, ValueType.EXTERNREF, ValueType.I32],
		[ValueType.EXTERNREF, ValueType.EXTERNREF]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.LOCAL_GET.code, 3,
		Opcode.LOCAL_GET.code, 4,
		Opcode.SELECT_T.code, 2, BpTypecon.EXTERNREF.code, BpTypecon.EXTERNREF.code]);
	i.assert_r([v1, v2, v3, v4, Value.I32(0)], Result.Value([v3, v4]));
	i.assert_r([v1, v2, v3, v4, Value.I32(1)], Result.Value([v1, v2]));
}

def test_locals1(i: InterpreterTester) {
	i.sig(SigCache.i_i).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(11, 11);

	var i1 = byte.!(i.addLocal(ValueType.I32));
	i.code([Opcode.LOCAL_GET.code, i1]);
	i.assert_i_i(17, 0);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_SET.code, i1,
		Opcode.LOCAL_GET.code, i1]);
	i.assert_i_i(19, 19);

	var i2 = byte.!(i.addLocal(ValueType.I32));
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_SET.code, i1,
		Opcode.LOCAL_GET.code, i2]);
	i.assert_i_i(23, 0);
}
def test_locals2(i: InterpreterTester) {
	var l1 = byte.!(i.addLocal(ValueType.I64));
	i.sig(SigCache.v_l).code([
		Opcode.LOCAL_GET.code, l1
	]);
	i.assert_u64(X, 0);

	var f1 = byte.!(i.addLocal(ValueType.F32));
	i.sig(SigCache.v_f).code([
		Opcode.LOCAL_GET.code, f1
	]);
	i.assert_f32(X, 0);

	var d1 = byte.!(i.addLocal(ValueType.F64));
	i.sig(SigCache.v_d).code([
		Opcode.LOCAL_GET.code, d1
	]);
	i.assert_f64(X, 0);
}
def test_params(i: InterpreterTester) {
	i.sig(SigCache.i_i).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(13, 13);
	i.assert_i_i(9991, 9991);

	i.sig(SigCache.l_l).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_u64([Value.I64(137)], 137);
	i.assert_u64([Value.I64(999145)], 999145);

	i.sig(SigCache.f_f).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_f32([Value.F32(137u)], 137u);
	i.assert_f32([Value.F32(999145u)], 999145u);

	i.sig(SigCache.d_d).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_f64([Value.F64(137u)], 137u);
	i.assert_f64([Value.F64(999145u)], 999145u);

	i.sig(SigCache.ii_i).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_ii_i((12, 15), 12);
	i.assert_ii_i((9791, 66), 9791);

	i.sig(SigCache.ii_i).code([Opcode.LOCAL_GET.code, 1]);
	i.assert_ii_i((12, 157), 157);
	i.assert_ii_i((9791, 8791), 8791);
}
def test_globals(i: InterpreterTester) {
	var index = byte.!(i.newGlobal(ValueType.I32, InitExpr.I32(34)).global_index);
	i.code([Opcode.GLOBAL_GET.code, index]).assert_i(34);
	i.code([Opcode.I32_CONST.code, 44,
		Opcode.GLOBAL_SET.code, index,
		Opcode.GLOBAL_GET.code, index]).assert_i(44);

	index = byte.!(i.newGlobal(ValueType.I64, InitExpr.I64(55)).global_index);
	i.code([Opcode.GLOBAL_GET.code, index]).assert_u64(X, 55);
}

def test_const(i: InterpreterTester) {
	i.code([Opcode.I32_CONST.code, 1]).assert_i(1);
	i.code([Opcode.I32_CONST.code, 33]).assert_i(33);
	i.code([Opcode.I32_CONST.code, 0xA7, 0x7F]).assert_i(u32.!(-89));
	i.code([Opcode.I32_CONST.code, 0x70]).assert_i(u32.!(-16));
	i.code([Opcode.I32_CONST.code, 0xA7, 0xF0, 0xF1, 0xF2,
		0x0E]).assert_i(3999037479u);

	i.code([Opcode.I64_CONST.code, 1]).assert_u64(X, 1);
	i.code([Opcode.I64_CONST.code, 33]).assert_u64(X, 33);
	i.code([Opcode.I64_CONST.code, 0x70]).assert_u64(X, u64.!(-16));
	i.code([Opcode.I64_CONST.code, 0x81, 0x82, 0x83, 0x84,
		0x85, 0x86, 0x87, 0x88, 0x09]).assert_u64(X, 653052939803345153);

	i.code([Opcode.F32_CONST.code, 0x44, 0x33, 0x22, 0x11]).assert_f32(X, 0x11223344);
	i.code([Opcode.F32_CONST.code, 0x66, 0x77, 0x88, 0x99]).assert_f32(X, 0x99887766);
}

def test_load8(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.addMemory(1, Max.Set(1));
	i.addData(4, [0xF0, 0xF1]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD8_U.code, 0, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(3, 0);
	i.assert_i_i(4, 0xF0);
	i.assert_i_i(5, 0xF1);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD8_S.code, 0, 2]);
	i.assert_i_i(0, 0);
	i.assert_i_i(1, 0);
	i.assert_i_i(2, 0xFFFFFFF0);
	i.assert_i_i(3, 0xFFFFFFF1);

	i.sig(SigCache.i_l);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD8_U.code, 0, 1]);
	i.assert_i_l(0, 0);
	i.assert_i_l(3, 0xF0);
	i.assert_i_l(4, 0xF1);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD8_S.code, 0, 3]);
	i.assert_i_l(0, 0);
	i.assert_i_l(1, 0xFFFFFFFFFFFFFFF0);
	i.assert_i_l(2, 0xFFFFFFFFFFFFFFF1);
}
def test_load16(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.addMemory(1, Max.Set(1));
	i.addData(8, [0xF2, 0xF3, 0xCC, 0xDD]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD16_U.code, 0, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(3, 0);
	i.assert_i_i(8, 0xF3F2);
	i.assert_i_i(9, 0xCCF3);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD16_S.code, 0, 2]);
	i.assert_i_i(0, 0);
	i.assert_i_i(4, 0);
	i.assert_i_i(6, 0xFFFFF3F2);
	i.assert_i_i(7, 0xFFFFCCF3);

	i.sig(SigCache.i_l);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD16_U.code, 0, 1]);
	i.assert_i_l(0, 0);
	i.assert_i_l(7, 0xF3F2);
	i.assert_i_l(9, 0xDDCC);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD16_S.code, 0, 3]);
	i.assert_i_l(0, 0);
	i.assert_i_l(5, 0xFFFFFFFFFFFFF3F2);
	i.assert_i_l(7, 0xFFFFFFFFFFFFDDCC);
}
def test_load32(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.addMemory(1, Max.Set(1));
	i.addData(10, [0xF5, 0xF6, 0xAA, 0xBB, 0xCC, 0xDD]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD.code, 0, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(6, 0);
	i.assert_i_i(10, 0xBBAAF6F5);
	i.assert_i_i(12, 0xDDCCBBAA);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD.code, 0, 8]);
	i.assert_i_i(0, 0xF6F50000);
	i.assert_i_i(6, 0x0000DDCC);

	i.sig(SigCache.i_l);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD32_U.code, 0, 1]);
	i.assert_i_l(0, 0);
	i.assert_i_l(8, 0xAAF6F500);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD32_S.code, 0, 3]);
	i.assert_i_l(0, 0);
	i.assert_i_l(7, 0xFFFFFFFFBBAAF6F5);
	i.assert_i_l(9, 0xFFFFFFFFDDCCBBAA);
}
def test_load64(i: InterpreterTester) {
	i.sig(SigCache.i_l);
	i.addMemory(1, Max.Set(1));
	i.addData(12, [0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD.code, 0, 0]);
	i.assert_i_l(0, 0);
	i.assert_i_l(3, 0);
	i.assert_i_l(12, 0x8877665544332211);
	i.assert_i_l(13, 0x0088776655443322);
}
def test_load_oob0(i: InterpreterTester) {
	i.addMemory(0, Max.Set(0));
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD.code, 0, 0]);
	i.assert_r([Value.I32(0)], Result.Trap(TrapReason.MEM_OUT_OF_BOUNDS));
}
def test_load_oob1(i: InterpreterTester) {
	i.addMemory(1, Max.Set(1));
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD.code, 0, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(65532, 0);
	i.assert_r([Value.I32(65533)], Result.Trap(TrapReason.MEM_OUT_OF_BOUNDS));
}
def test_store8(i: InterpreterTester) {
	i.addMemory(1, Max.Set(1));
	i.sig0(SigCache.arr_i, SigCache.arr_v);
	i.addData(5, [0x99, 0x88, 0x77]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 3,
		Opcode.I32_STORE8.code, 0, 2]);
	i.assert_mem([Value.I32(3)], 4, [0,    3, 0x88, 0x77, 0]);
	i.assert_mem([Value.I32(4)], 4, [0, 0x99,    3, 0x77, 0]);
	i.assert_mem([Value.I32(5)], 4, [0, 0x99, 0x88,    3, 0]);
	i.assert_mem([Value.I32(6)], 4, [0, 0x99, 0x88, 0x77, 3]);
}
def test_store16(i: InterpreterTester) {
	i.addMemory(1, Max.Set(1));
	i.sig(SigCache.i_v);
	i.addData(11, [0x99, 0x88, 0x77]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 0x83, 0x08,
		Opcode.I32_STORE16.code, 0, 7]);
	i.assert_mem([Value.I32(4)], 10, [0,    3,    4, 0x77, 0, 0]);
	i.assert_mem([Value.I32(5)], 10, [0, 0x99,    3,    4, 0, 0]);
	i.assert_mem([Value.I32(6)], 10, [0, 0x99, 0x88,    3, 4, 0]);
	i.assert_mem([Value.I32(7)], 10, [0, 0x99, 0x88, 0x77, 3, 4]);
}
def test_store32(i: InterpreterTester) {
	i.addMemory(1, Max.Set(1));
	i.sig(SigCache.i_v);
	i.addData(19, [0x99, 0x88, 0x77, 0x66, 0x55]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 0x91, 0xC4, 0xCC, 0xA1, 0x04,
		Opcode.I32_STORE.code, 0, 9]);
	i.assert_mem([Value.I32(10)], 18, [0, 0x11, 0x22, 0x33, 0x44, 0x55, 0, 0]);
	i.assert_mem([Value.I32(11)], 18, [0, 0x99, 0x11, 0x22, 0x33, 0x44, 0, 0]);
	i.assert_mem([Value.I32(12)], 18, [0, 0x99, 0x88, 0x11, 0x22, 0x33, 0x44, 0]);
}
def test_store64(i: InterpreterTester) {
	i.addMemory(1, Max.Set(1));
	i.sig0([ValueType.I32, ValueType.I64], SigCache.arr_v);
	i.addData(33, [0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.I64_STORE.code, 0, 22]);
	i.assert_mem([Value.I32(12), Value.I64(0x0807060504030201)], 32, [0, 0x99, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]);
	i.assert_mem([Value.I32(14), Value.I64(0xA8B7C6D5E4F30201)], 32, [0, 0x99, 0x88, 0x77, 0x01, 0x02, 0xF3, 0xE4, 0xD5, 0xC6, 0xB7, 0xA8]);
}
def test_store_oob0(i: InterpreterTester) {
	i.addMemory(0, Max.Set(0));
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 5,
		Opcode.I32_STORE.code, 0, 0,
		Opcode.I32_CONST.code, 3]);
	i.assert_r([Value.I32(0)], Result.Trap(TrapReason.MEM_OUT_OF_BOUNDS));
}
def test_store_oob1(i: InterpreterTester) {
	i.addMemory(1, Max.Set(1));
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 5,
		Opcode.I32_STORE.code, 0, 0,
		Opcode.I32_CONST.code, 42]);
	i.assert_i_i(0, 42);
	i.assert_i_i(65532, 42);
	i.assert_r([Value.I32(65533)], Result.Trap(TrapReason.MEM_OUT_OF_BOUNDS));
}
def test_memory_size(i: InterpreterTester) {
	i.addMemory(0, Max.Set(0));
	i.sig(SigCache.v_i);
	i.code([Opcode.MEMORY_SIZE.code, 0]);
	i.assert_i(0);

	i.addMemory(2, Max.Set(2));
	i.sig(SigCache.v_i);
	i.code([Opcode.MEMORY_SIZE.code, 1]);
	i.assert_i(2);
}
def test_memory_grow1(i: InterpreterTester) {
	i.addMemory(0, Max.Set(5));
	i.sig(SigCache.i_i);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.MEMORY_GROW.code, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(1, 0);
	i.assert_i_i(5, 0);
	i.assert_i_i(6, 0xFFFFFFFF);

	i.addMemory(1, Max.Set(2));
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.MEMORY_GROW.code, 1]);
	i.assert_i_i(0, 1);
	i.assert_i_i(1, 1);
	i.assert_i_i(2, 0xFFFFFFFF);
}

def test_memory_grow2(i: InterpreterTester) {
	i.addMemory(0, Max.None);
	i.sig(SigCache.i_i);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.MEMORY_GROW.code, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(1, 0);
	i.assert_i_i(EngineLimits.limit_memory_pages + 1, 0xFFFFFFFF);
}

def test_stack_overflow(i: InterpreterTester) {
	i.code([Opcode.CALL.code, 0]);
	i.max_call_depth = 10;
	i.assert_trap([Value.I32(0), Value.I32(2)], TrapReason.STACK_OVERFLOW);
}

def test_sign_ext(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I32_EXTEND8_S.code]);
	i.assert_i_i(0, 0);
	i.assert_i_i(1, 1);
	i.assert_i_i(127, 127);
	i.assert_i_i(0x80, 0xFFFFFF80);
	i.assert_i_i(0x100, 0);

	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I32_EXTEND16_S.code]);
	i.assert_i_i(0, 0);
	i.assert_i_i(1, 1);
	i.assert_i_i(127, 127);
	i.assert_i_i(0x82, 0x82);
	i.assert_i_i(0x8030, 0xFFFF8030);
	i.assert_i_i(0x10000, 0);

	i.sig(SigCache.l_l);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I64_EXTEND8_S.code]);
	i.assert_l_l(0, 0);
	i.assert_l_l(1, 1);
	i.assert_l_l(127, 127);
	i.assert_l_l(0x87, 0xFFFFFFFFFFFFFF87);
	i.assert_l_l(0x300, 0);

	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I64_EXTEND16_S.code]);
	i.assert_l_l(0, 0);
	i.assert_l_l(1, 1);
	i.assert_l_l(0x7FFF, 0x7FFF);
	i.assert_l_l(0x19a, 0x19a);
	i.assert_l_l(0x8720, 0xFFFFFFFFFFFF8720);
	i.assert_l_l(0x50000, 0);

	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I64_EXTEND32_S.code]);
	i.assert_l_l(0, 0);
	i.assert_l_l(1, 1);
	i.assert_l_l(0x7FFF, 0x7FFF);
	i.assert_l_l(0x7FFF1234, 0x7FFF1234);
	i.assert_l_l(0x19a, 0x19a);
	i.assert_l_l(0x8720abcd, 0xFFFFFFFF8720abcd);
}

def test_reinterpret(i: InterpreterTester) {
	for (bits in [0x11223344u, 0x55662233u]) {
		i.sig(SigCache.f_i);
		i.code([Opcode.LOCAL_GET.code, 0, Opcode.I32_REINTERPRET_F32.code]);
		i.assert_r([Value.F32(bits)], Result.Value([Value.I32(bits)]));

		i.sig(SigCache.i_f);
		i.code([Opcode.LOCAL_GET.code, 0, Opcode.F32_REINTERPRET_I32.code]);
		i.assert_r([Value.I32(bits)], Result.Value([Value.F32(bits)]));
	}
	for (bits in [0x1122334455667788u, 0x5566223344117799u]) {
		i.sig(SigCache.d_l);
		i.code([Opcode.LOCAL_GET.code, 0, Opcode.I64_REINTERPRET_F64.code]);
		i.assert_r([Value.F64(bits)], Result.Value([Value.I64(bits)]));

		i.sig(SigCache.l_d);
		i.code([Opcode.LOCAL_GET.code, 0, Opcode.F64_REINTERPRET_I64.code]);
		i.assert_r([Value.I64(bits)], Result.Value([Value.F64(bits)]));
	}
}

def test_invalid(i: InterpreterTester) {
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0, 0x1E]);
	i.assert_r([Values.i_v(33)], Result.Trap(TrapReason.ERROR));

	for (page in Opcodes.code_pages) {
		i.code([Opcode.LOCAL_GET.code, 0, page.prefix, 0xFF]);
		i.assert_r([Values.i_v(37)], Result.Trap(TrapReason.ERROR));
	}
}

// TODO: tests for multi-value block, if, loop
// TODO: tests for multi-value return
// TODO: tests for block, if, loop with value args
// TODO: lots more tests for br_table
// TODO: tests for multi_memory

def test_ref_null(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	i.sig(SigCache.v_e);
	i.code([Opcode.REF_NULL.code, BpTypecon.EXTERNREF.code]);
	i.assert_v(X, Values.REF_NULL);
	i.code([Opcode.REF_NULL.code, BpTypecon.FUNCREF.code]);
	i.assert_v(X, Values.FUNCREF_NULL);
}

def test_ref_is_null(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	// externs
	i.sig(SigCache.e_i);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.REF_IS_NULL.code]);
	i.assert_v([Values.REF_NULL], Values.I32_1);
	i.assert_v([Value.Ref(null)], Values.I32_1);
	i.assert_v([Value.Ref(HostObject.new())], Values.I32_0);
	// funcs
	i.sig(SigCache.g_i);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.REF_IS_NULL.code]);
	i.assert_v([Values.FUNCREF_NULL], Values.I32_1);
	i.assert_v([Value.FuncRef(Function.new(SigCache.i_i))], Values.I32_0);
}

def test_ref_func(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	i.sig(SigCache.v_g);
	i.code([Opcode.REF_FUNC.code, 0]);
	i.assert_g(X, 0);
}

def test_memory_init(i: InterpreterTester) {
	i.extensions |= Extension.BULK_MEMORY;
	i.sig(SigCache.iii_v);
	i.addMemory(1, Max.Set(1));
	i.addPassiveData([11, 22, 33, 44, 55]);
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.MEMORY_INIT.prefix, Opcode.MEMORY_INIT.code, 0, 0
	]);
	i.assert_mem(uuu(0, 0, 5), 0, [11, 22, 33, 44, 55]);
	i.assert_mem(uuu(0, 1, 3), 0, [22, 33, 44, 0]);
	i.assert_mem(uuu(1, 2, 3), 0, [0, 33, 44, 55, 0]);
	i.assert_trap(uuu(65533, 0, 4), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(65535, 0, 2), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(1, 0, 6), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(1, 2, 5), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0xFFFFFFF0, 3, 4), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0xFFFFFFF0, 3, 0xF0), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 0xFFFFFFF0, 0xF0), TrapReason.MEM_OUT_OF_BOUNDS);
}

def test_data_drop(i: InterpreterTester) {
	i.extensions |= Extension.BULK_MEMORY;
	i.sig(SigCache.v_v);
	i.addMemory(1, Max.Set(1));
	i.addData(0, [0]);
	i.code([Opcode.DATA_DROP.prefix, Opcode.DATA_DROP.code, 0]);
	var t = i.run(X), instance = t.0;
	if (instance.dropped_data[0] != true) i.t.fail("expected dropped data[0]");
}

def uuu(a: u32, b: u32, c: u32) -> Array<Value> {
	return [Value.I32(a), Value.I32(b), Value.I32(c)];
}

def test_memory_copy(i: InterpreterTester) {
	i.extensions |= Extension.BULK_MEMORY;
	i.sig(SigCache.iii_v);
	i.addMemory(1, Max.Set(1));
	var init: Array<byte> = [33, 44, 55];
	i.addData(3, init);
	i.code([Opcode.MEMORY_COPY.prefix, Opcode.MEMORY_COPY.code, 0, 0]);
	i.assert_mem(uuu(0, 0, 0), 3, init);
	i.assert_mem(uuu(0, 2, 5), 0, [0, 33, 44, 55, 0, 55, 0]);
	i.assert_mem(uuu(7, 3, 3), 0, [0, 0, 0, 33, 44, 55, 0, 33, 44, 55]);
	i.assert_mem(uuu(65533, 3, 3), 65533, [33, 44, 55]);
	i.assert_trap(uuu(65533, 3, 4), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(65535, 3, 2), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 65533, 4), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 65535, 2), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0xFFFFFFF0, 3, 4), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0xFFFFFFF0, 3, 0xF0), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 0xFFFFFFF0, 0xF0), TrapReason.MEM_OUT_OF_BOUNDS);
}


def test_memory_fill(i: InterpreterTester) {
	i.extensions |= Extension.BULK_MEMORY;
	i.sig(SigCache.iii_v);
	i.addMemory(1, Max.Set(1));
	i.code([Opcode.MEMORY_FILL.prefix, Opcode.MEMORY_FILL.code, 0]);
	i.assert_mem(uuu(0, 0, 0), 0, [0]);
	i.assert_mem(uuu(3, 77, 2), 0, [0, 0, 0, 77, 77, 0]);
	i.assert_mem(uuu(4, 99, 4), 0, [0, 0, 0, 0, 99, 99, 99, 99, 0]);
	i.assert_mem(uuu(65536, 99, 0), 0, []);
	i.assert_trap(uuu(65536, 91, 1), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(65535, 92, 2), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(65537, 93, 1), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(65537, 94, 0xFFFFFFF0), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0xFFFFFFF0, 95, 0xF0), TrapReason.MEM_OUT_OF_BOUNDS);
}

def test_table_init(i: InterpreterTester) {
	var f2 = i.newFunction(SigCache.v_v, [Opcode.END.code]);
	var f3 = i.newFunction(SigCache.v_v, [Opcode.END.code]);
	var f4 = i.newFunction(SigCache.v_v, [Opcode.END.code]);
	var f5 = i.newFunction(SigCache.v_v, [Opcode.END.code]);
	i.extensions |= Extension.REFERENCE_TYPES;
	i.sig(SigCache.iii_v);
	i.addTable(6, 0, null);
	i.addPassiveElems([f2.func_index, f3.func_index, f4.func_index, f5.func_index]);
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.TABLE_INIT.prefix, Opcode.TABLE_INIT.code, 0, 0
	]);
	i.assert_ftable(uuu(0, 0, 0), 0, []);
	i.assert_ftable(uuu(0, 0, 1), 0, [f2]);
	i.assert_ftable(uuu(2, 2, 1), 2, [f4]);
	i.assert_ftable(uuu(0, 0, 4), 0, [f2, f3, f4, f5]);
	i.assert_trap(uuu(0, 0, 5), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0, 1, 4), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 0, 4), TrapReason.TABLE_OUT_OF_BOUNDS);
}

def test_elem_drop(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	i.sig(SigCache.v_v);
	i.addTable(1, 0, [0]);
	i.code([Opcode.ELEM_DROP.prefix, Opcode.ELEM_DROP.code, 0]);
	var t = i.run(X), instance = t.0;
	if (instance.dropped_elems[0] != true) i.t.fail("expected dropped elems[0]");
}

def test_table_get(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	var f2 = i.newFunction(SigCache.v_v, [Opcode.END.code]);
	var f3 = i.newFunction(SigCache.v_v, [Opcode.END.code]);
	i.addTable(3, 0, [0, f2.func_index, f3.func_index]);
	i.sig0(SigCache.arr_i, [ValueType.FUNCREF]);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.TABLE_GET.code, 0]);
	i.assert_g([Value.I32(0)], 0);
	i.assert_g([Value.I32(1)], f2.func_index);
	i.assert_g([Value.I32(2)], f3.func_index);
	i.assert_trap([Value.I32(3)], TrapReason.TABLE_INDEX_OUT_OF_BOUNDS);
}

def test_table_set(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	var f2 = i.newFunction(SigCache.v_v, [Opcode.END.code]);
	var f3 = i.newFunction(SigCache.v_v, [Opcode.END.code]);
	i.addTable(3, 0, [0, f2.func_index, f3.func_index]);
	i.sig0([ValueType.I32, ValueType.FUNCREF], SigCache.arr_v);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_GET.code, 1, Opcode.TABLE_SET.code, 0]);

	var gv1 = Value.FuncRef(WasmFunction.new(null, f3));
	var t = i.run([Value.I32(1), gv1]), instance = t.0;
	var got = instance.tables[0].elems[1];
	if (gv1 != got) i.t.fail("wrong table[1] value");

	i.assert_trap([Value.I32(3), gv1], TrapReason.TABLE_INDEX_OUT_OF_BOUNDS);
}

def test_table_copy(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	var f2 = i.newFunction(SigCache.v_v, [Opcode.END.code]);
	var f3 = i.newFunction(SigCache.v_v, [Opcode.END.code]);
	i.addTable(6, 0, []);
	i.addTable(3, 0, [0, f2.func_index, f3.func_index]);

	i.sig(SigCache.iii_v);
	i.code([Opcode.TABLE_COPY.prefix, Opcode.TABLE_COPY.code, 0, 1]);
	i.assert_ftable(uuu(0, 0, 1), 0, [i.func, null, null]);
	i.assert_ftable(uuu(1, 2, 1), 0, [null, f3, null]);
	i.assert_ftable(uuu(3, 0, 3), 0, [null, null, null, i.func, f2, f3]);

	i.assert_trap(uuu(65533, 3, 4), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(65535, 3, 2), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 65533, 4), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 65535, 2), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0xFFFFFFF0, 3, 4), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0xFFFFFFF0, 3, 0xF0), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 0xFFFFFFF0, 0xF0), TrapReason.TABLE_OUT_OF_BOUNDS);
}

def test_table_grow1(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	i.addTableOfSize(3, Max.Set(5));
	i.sig0([ValueType.I32, ValueType.FUNCREF], SigCache.arr_i);
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.TABLE_GROW.prefix, Opcode.TABLE_GROW.code, 0
	]);
	var n = Values.FUNCREF_NULL;
	i.assert_v([n, Value.I32(1)], Value.I32(3));
	i.assert_v([n, Value.I32(2)], Value.I32(3));
	i.assert_v([n, Value.I32(3)], Value.I32(0xFFFFFFFF));

	i.sig0([ValueType.I32, ValueType.FUNCREF], SigCache.arr_v);
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.TABLE_GROW.prefix, Opcode.TABLE_GROW.code, 0,
		Opcode.DROP.code
	]);
	var fv = Value.FuncRef(WasmFunction.new(null, i.func));
	i.assert_ftable([fv, Value.I32(1)], 0, [null, null, null, i.func]);
	i.assert_ftable([fv, Value.I32(2)], 0, [null, null, null, i.func, i.func]);
}

def test_table_grow2(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	i.addTableOfSize(3, Max.None);
	i.sig0([ValueType.I32, ValueType.FUNCREF], SigCache.arr_i);
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.TABLE_GROW.prefix, Opcode.TABLE_GROW.code, 0
	]);
	var n = Values.FUNCREF_NULL;
	i.assert_v([n, Value.I32(EngineLimits.limit_table_size + 1)], Value.I32(0xFFFFFFFF));
}

def test_table_size(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	i.addTable(3, 0, [0, 0, 0]);
	i.sig(SigCache.v_i);
	i.code([Opcode.TABLE_SIZE.prefix, Opcode.TABLE_SIZE.code, 0]);
	i.assert_i(3);
}

def uvu(a: u32, b: Value, c: u32) -> Array<Value> {
	return [Value.I32(a), b, Value.I32(c)];
}

def test_table_fill(i: InterpreterTester) {
	i.extensions |= Extension.REFERENCE_TYPES;
	i.sig(SigCache.iii_v);
	i.addTable(6, 0, []);
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.TABLE_FILL.prefix, Opcode.TABLE_FILL.code, 0
	]);
	var f1 = Value.FuncRef(WasmFunction.new(null, i.func));
	i.assert_ftable(uvu(0, f1, 0), 0, [null]);
	i.assert_ftable(uvu(1, f1, 1), 0, [null, i.func]);
	i.assert_ftable(uvu(3, f1, 2), 0, [null, null, null, i.func, i.func]);
	i.assert_ftable(uvu(4, f1, 2), 0, [null, null, null, null, i.func, i.func]);
	i.assert_trap(uvu(5, f1, 2), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uvu(6, f1, 1), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uvu(65536, f1, 1), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uvu(65535, f1, 2), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uvu(65537, f1, 1), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uvu(65537, f1, 0xFFFFFFF0), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uvu(0xFFFFFFF0, f1, 0xF0), TrapReason.TABLE_OUT_OF_BOUNDS);
}

def test_host_tail_call1(t: InterpreterTester) {
	t.sig(SigCache.i_i);
	t.code([Opcode.LOCAL_GET.code, 0, Opcode.I32_CONST.code, 5, Opcode.I32_ADD.code]);
	var instance = Instantiator.new(t.extensions, t.module, [], WasmErrorGen.new("InterpreterTest.v3")).run();
	var f = instance.functions[0];

	def fw = HostResult.TailCall(f, _);
	def hf = HostFunctionN.new(null, SigCache.i_i, fw);

	var i = Interpreter.new();
	t.assert_req(i.run(10, hf, [Value.I32(44)]), Result.Value([Value.I32(49)]));
	t.assert_req(i.run(10, hf, [Value.I32(999)]), Result.Value([Value.I32(1004)]));
}

def add(args: Array<Value>) -> HostResult {
	var a = Values.v_u(args[0]);
	var b = Values.v_u(args[1]);
	return HostResult.Value1(Value.I32(a + b));
}

def test_host_tail_call2(t: InterpreterTester) {
	def fw = HostResult.TailCall(HostFunctionN.new(null, SigCache.ii_i, add), _);
	def hf = HostFunctionN.new(null, SigCache.ii_i, fw);

	var i = Interpreter.new();
	t.assert_req(i.run(10, hf, [Value.I32(44), Value.I32(66)]), Result.Value([Value.I32(110)]));
	t.assert_req(i.run(10, hf, [Value.I32(909), Value.I32(90)]), Result.Value([Value.I32(999)]));
}

def heapIndexByte(ht: HeapTypeDecl) -> byte { // XXX: factor out commonality with CodeValidatorTest
	match (ht) {
		x: StructDecl => return byte.!(x.struct_index);
		x: ArrayDecl => return byte.!(x.array_index);
		x: SigDecl => return byte.!(x.sig_index);
	}
	return 0;
}

def I32_FIELD = StorageType.new(ValueType.I32, Packedness.UNPACKED, true);

def test_struct_new(t: InterpreterTester) {
	var st = t.newStruct([I32_FIELD]);
	t.extensions |= Extension.GC;
	t.sig0(SigCache.arr_i, [ValueType.RefStruct(false, st)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.STRUCT_NEW.prefix,
		Opcode.STRUCT_NEW.code,
		heapIndexByte(st)
	]);
	for (i in [666u, 777u, 0x88776655u]) {
		var vals: Array<Value> = [Value.I32(i)];
		t.assert_struct(t.run(vals).1, st, Values.RTT_ANYREF, vals);
	}
}

def test_struct_new_with_rtt(t: InterpreterTester) {
	var st = t.newStruct([I32_FIELD]);
	t.extensions |= Extension.GC;
	t.sig0([ValueType.I32, ValueType.Rtt(1, st)], [ValueType.RefStruct(false, st)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.STRUCT_NEW_WITH_RTT.prefix,
		Opcode.STRUCT_NEW_WITH_RTT.code,
		heapIndexByte(st)
	]);
	for (i in [616u, 727u, 0x88716655u]) {
		var rtt = Value.Rtt(st, []);
		t.assert_struct(t.run([Value.I32(i), rtt]).1, st, rtt, [Value.I32(i)]);
	}
}

def test_struct_new_default_with_rtt(t: InterpreterTester) {
	var st = t.newStruct([
		I32_FIELD,
		StorageType.new(ValueType.F32, Packedness.UNPACKED, true),
		StorageType.new(ValueType.F64, Packedness.UNPACKED, true)
	]);
	t.extensions |= Extension.GC;
	t.sig0([ValueType.Rtt(1, st)], [ValueType.RefStruct(false, st)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.STRUCT_NEW_DEFAULT_WITH_RTT.prefix,
		Opcode.STRUCT_NEW_DEFAULT_WITH_RTT.code,
		heapIndexByte(st)
	]);
	for (i < 2) {
		var rtt = Value.Rtt(st, []);
		t.assert_struct(t.run([rtt]).1, st, rtt, [Values.I32_0, Values.F32_0, Values.F64_0]);
	}
}

def test_struct_get(t: InterpreterTester) {
	var st = t.newStruct([
		I32_FIELD,
		I32_FIELD,
		I32_FIELD
	]);
	t.extensions |= Extension.GC;
	t.sig0([ValueType.RefStruct(false, st)], SigCache.arr_i);
	var obj = HeapStruct.new(st, Values.RTT_ANYREF, [Value.I32(99), Value.I32(98), Value.I32(97)]);
	for (f < st.field_types.length) {
		t.codev([
			Opcode.LOCAL_GET.code, 0,
			Opcode.STRUCT_GET.prefix, Opcode.STRUCT_GET.code,
			heapIndexByte(st), byte.view(f)
		]);
		for (i in [366u, 2777u, 0x18776655u]) {
			obj.vals[f] = Value.I32(i);
			t.assert_v([Value.Ref(obj)], Values.u_v(i));
		}
	}
}

def unpackI32(val: u32, packing: Packedness, signed: bool) -> u32 {
	var shift: u5 = if(packing == Packedness.PACKED_I8, 24, 16);
	val = val << shift;
	return if(signed, u32.view(i32.view(val) >> shift), val >> shift);
}

def test_struct_get_su(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	var st = t.newStruct([
		StorageType.new(ValueType.I32, Packedness.PACKED_I8, true),
		StorageType.new(ValueType.I32, Packedness.PACKED_I16, true)
	]);
	t.sig0([ValueType.RefStruct(false, st)], SigCache.arr_i);

	var vals: Array<u32> = [0x87, 0x9765];
	var obj = HeapStruct.new(st, Values.RTT_ANYREF, [Value.I32(vals[0]), Value.I32(vals[1])]);
	for (f < 2) {
		var shift: u5 = if(f == 0, 24, 16);
		for (opcode in [Opcode.STRUCT_GET_S, Opcode.STRUCT_GET_U]) {
			t.codev([
				Opcode.LOCAL_GET.code, 0,
				opcode.prefix, opcode.code,
				heapIndexByte(st), byte.view(f)
			]);
			var expected = unpackI32(vals[f], st.field_types[f].packing, opcode == Opcode.STRUCT_GET_S);
			t.assert_req(t.run([Value.Ref(obj)]).1, u_r(expected));
		}
	}
}

def test_struct_set(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	var st = t.newStruct([
		I32_FIELD,
		I32_FIELD,
		I32_FIELD
	]);
	t.sig0([ValueType.RefStruct(false, st), ValueType.I32], SigCache.arr_v);
	var obj = HeapStruct.new(st, Values.RTT_ANYREF, [Value.I32(99), Value.I32(98), Value.I32(97)]);
	for (f < st.field_types.length) {
		t.codev([
			Opcode.LOCAL_GET.code, 0,
			Opcode.LOCAL_GET.code, 1,
			Opcode.STRUCT_SET.prefix, Opcode.STRUCT_SET.code,
			heapIndexByte(st), byte.view(f)
		]);
		for (i in [366u, 2777u, 0x18776655u]) {
			var prev = Arrays.dup(obj.vals);
			var got = t.run([Value.Ref(obj), Values.u_v(i)]).1;
			t.assert_req(got, Result.Value([]));
			prev[f] = Values.u_v(i);
			t.t.assertar("fields", prev, obj.vals, Value.render);
		}
	}
}

def test_array_new(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	var at = t.newArray([I32_FIELD]);
	t.sig0(SigCache.arr_i, [ValueType.RefArray(false, at)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.ARRAY_NEW.prefix, Opcode.ARRAY_NEW.code, heapIndexByte(at)
	]);
	for (i < 5u) {
		var v = Value.I32(i);
		var r = t.run([v]);
		var expected = Array<Value>.new(int.view(i));
		for (j < i) expected[j] = v;
		t.assert_array(r.1, at, Values.RTT_ANYREF, expected);
	}
}

def test_array_new_with_rtt(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	var at = t.newArray([
		StorageType.new(ValueType.I64, Packedness.UNPACKED, true)
	]);
	t.sig0([ValueType.I32, ValueType.I64, ValueType.Rtt(1, at)], [ValueType.RefArray(false, at)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.ARRAY_NEW_WITH_RTT.prefix, Opcode.ARRAY_NEW_WITH_RTT.code, heapIndexByte(at)
	]);
	var rtt = Value.Rtt(at, []);
	for (i < 5u) {
		var v = Value.I64(i);
		var r = t.run([Value.I32(i), v, rtt]);
		var expected = Array<Value>.new(int.view(i));
		for (j < i) expected[j] = v;
		t.assert_array(r.1, at, rtt, expected);
	}
}

def test_array_new_default_with_rtt(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	var at = t.newArray([
		StorageType.new(ValueType.F32, Packedness.UNPACKED, true)
	]);
	t.sig0([ValueType.I32, ValueType.Rtt(1, at)], [ValueType.RefArray(false, at)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.ARRAY_NEW_DEFAULT_WITH_RTT.prefix, Opcode.ARRAY_NEW_DEFAULT_WITH_RTT.code, heapIndexByte(at)
	]);
	var rtt = Value.Rtt(at, []);
	for (i < 5u) {
		var r = t.run([Value.I32(i), rtt]);
		var expected = Array<Value>.new(int.view(i));
		for (j < i) expected[j] = Values.F32_0;
		t.assert_array(r.1, at, rtt, expected);
	}
}

def test_array_get(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	var at = t.newArray([
		StorageType.new(ValueType.F64, Packedness.UNPACKED, true)
	]);
	t.sig0([ValueType.RefArray(false, at), ValueType.I32], SigCache.arr_d);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.ARRAY_GET.prefix, Opcode.ARRAY_GET.code, heapIndexByte(at)
	]);
	for (len < 5) {
		var elems = Array<Value>.new(len);
		var obj = Value.Ref(HeapArray.new(at, Values.RTT_ANYREF, elems));
		for (j < len) elems[j] = Value.F64(0x99u + u32.view(len));

		for (i < len) {
			var r = t.run([obj, Value.I32(u32.view(i))]);
			t.assert_req(r.1, Result.Value([elems[i]]));
		}
		t.assert_trap([obj, Value.I32(99)], TrapReason.ARRAY_INDEX_OOB);
		t.assert_trap([obj, Value.I32(0x80000000u)], TrapReason.ARRAY_INDEX_OOB);
		t.assert_trap([obj, Value.I32(u32.max)], TrapReason.ARRAY_INDEX_OOB);
	}
	t.assert_trap([Value.Ref(null), Values.I32_0], TrapReason.NULL_DEREF);
}

def test_array_get_su(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	for (packing in [Packedness.PACKED_I8, Packedness.PACKED_I16]) {
		var at = t.newArray([
			StorageType.new(ValueType.I32, packing, true)
		]);

		t.sig0([ValueType.RefArray(false, at), ValueType.I32], SigCache.arr_i);
		for (opcode in [Opcode.ARRAY_GET_S, Opcode.ARRAY_GET_U]) {
			t.codev([
				Opcode.LOCAL_GET.code, 0,
				Opcode.LOCAL_GET.code, 1,
				opcode.prefix, opcode.code, heapIndexByte(at)
			]);
			for (len < 5) {
				var elems = Array<Value>.new(len);
				var obj = Value.Ref(HeapArray.new(at, Values.RTT_ANYREF, elems));
				for (j < len) elems[j] = Value.I32(0xFF7Fu + u32.view(j));

				for (i < len) {
					var r = t.run([obj, Value.I32(u32.view(i))]);
					var expected = unpackI32(Values.v_u(elems[i]), packing, opcode == Opcode.ARRAY_GET_S);
					t.assert_req(r.1, Result.Value([Value.I32(expected)]));
				}
				t.assert_trap([obj, Value.I32(99)], TrapReason.ARRAY_INDEX_OOB);
				t.assert_trap([obj, Value.I32(0x80000000u)], TrapReason.ARRAY_INDEX_OOB);
				t.assert_trap([obj, Value.I32(u32.max)], TrapReason.ARRAY_INDEX_OOB);
			}
			t.assert_trap([Value.Ref(null), Values.I32_0], TrapReason.NULL_DEREF);
		}
	}
}

def test_array_set(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	var at = t.newArray([
		StorageType.new(ValueType.F64, Packedness.UNPACKED, true)
	]);
	t.sig0([ValueType.RefArray(false, at), ValueType.I32, ValueType.F64], SigCache.arr_v);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.ARRAY_SET.prefix, Opcode.ARRAY_SET.code, heapIndexByte(at)
	]);
	var obj = HeapArray.new(at, Values.RTT_ANYREF, [Value.F64(0x99999), Value.F64(55)]);
	var ref = Value.Ref(obj);
	for (i < obj.vals.length) {
		for (v in [366u, 2777u, 0x18776655u]) {
			var prev = Arrays.dup(obj.vals);
			var got = t.run([ref, Value.I32(u32.view(i)), Value.F64(v)]).1;
			t.assert_req(got, Result.Value([]));
			prev[i] = Value.F64(v);
			t.t.assertar("elems", prev, obj.vals, Value.render);
		}
	}
	t.assert_trap([ref, Value.I32(99), Values.F64_0], TrapReason.ARRAY_INDEX_OOB);
	t.assert_trap([Value.Ref(null), Values.I32_0, Values.F64_0], TrapReason.NULL_DEREF);
}

def test_array_len(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	var at = t.newArray([
		StorageType.new(ValueType.F64, Packedness.UNPACKED, true)
	]);
	t.sig0([ValueType.RefArray(false, at)], SigCache.arr_i);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.ARRAY_LEN.prefix, Opcode.ARRAY_LEN.code, heapIndexByte(at)
	]);
	for (i < 5) {
		var obj = Value.Ref(HeapArray.new(at, Values.RTT_ANYREF, Array<Value>.new(i)));
		var r = t.run([obj]);
		t.assert_req(r.1, i_r(i));
	}
	t.assert_trap([Value.Ref(null)], TrapReason.NULL_DEREF);
}

def test_i31_new(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	t.sig0(SigCache.arr_i, [ValueType.I31REF]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.I31_NEW.prefix, Opcode.I31_NEW.code
	]);
	for (v in [0x8u, 0x99u, 0x12345678u, 0x87654321u]) {
		t.assert_v([Value.I32(v)], Value.I31(u31.view(v)));
	}
}

def test_i31_get_s(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	t.sig0([ValueType.I31REF], SigCache.arr_i);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.I31_GET_S.prefix, Opcode.I31_GET_S.code
	]);
	for (v in [0x8u, 0x99u, 0x12345678u, 0x80000000u, 0xF7654321u]) {
		var ext = (i32.view(v) << 1) >> 1;
		t.assert_v([Value.I31(u31.view(v))], Value.I32(u32.view(ext)));
	}
}

def test_i31_get_u(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	t.sig0([ValueType.I31REF], SigCache.arr_i);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.I31_GET_U.prefix, Opcode.I31_GET_U.code
	]);
	for (v in [0x8u, 0x99u, 0x12345678u, 0x80000000u, 0xF7654321u]) {
		var ext = (u32.view(v) << 1) >> 1;
		t.assert_v([Value.I31(u31.view(v))], Value.I32(u32.view(ext)));
	}
}

def test_rtt_canon(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	// TODO
}

def test_rtt_sub(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	var st1 = t.newStruct([]);
	var st2 = t.newStruct([I32_FIELD]);
	for (n < 3) {
		t.sig0([ValueType.Rtt(n, st1)], [ValueType.Rtt(n+1, st2)]);
		t.codev([
			Opcode.LOCAL_GET.code, 0,
			Opcode.RTT_SUB.prefix, Opcode.RTT_SUB.code, byte.view(n), heapIndexByte(st1), heapIndexByte(st2)
		]);
		var sup = Value.Rtt(st1, Array<Value.Rtt>.new(n));
		for (i < sup.supers.length) sup.supers[i] = sup;
		var r1 = t.run([sup]).1;
		t.assert_rtt(r1, st2, sup.supers);
		var r2 = t.run([sup]).1;
		t.assert_rtt(r2, st2, sup.supers);
		if (r1 == r2) return t.t.fail("rtt should be fresh");
	}
}

class RttTestVals(t: InterpreterTester) {
	def st1 = t.newStruct([]);
	def st2 = t.newStruct([I32_FIELD]);
	def rtt1 = Value.Rtt(st1, []);
	def rtt2a = Values.subRtt(rtt1, st2);
	def rtt2b = Values.subRtt(rtt1, st2);

	def o1 = Value.Ref(HeapStruct.new(st1, rtt1, []));
	def o2a = Value.Ref(HeapStruct.new(st2, rtt2a, [Values.I32_0]));
	def o2b = Value.Ref(HeapStruct.new(st2, rtt2b, [Values.I32_0]));
}

def test_ref_test(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	var x = RttTestVals.new(t);
	t.sig0([ValueType.RefStruct(false, x.st1), ValueType.Rtt(2, x.st2)], SigCache.arr_i);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.REF_TEST.prefix, Opcode.REF_TEST.code, heapIndexByte(x.st1), heapIndexByte(x.st2)
	]);

	t.assert_v([Values.REF_NULL, x.rtt2a], Values.I32_0);
	t.assert_v([Values.REF_NULL, x.rtt2b], Values.I32_0);
	t.assert_v([x.o1, x.rtt2a], Values.I32_0);
	t.assert_v([x.o1, x.rtt2b], Values.I32_0);

	t.assert_v([x.o2a, x.rtt2a], Values.I32_1);
	t.assert_v([x.o2a, x.rtt2b], Values.I32_0);

	t.assert_v([x.o2b, x.rtt2a], Values.I32_0);
	t.assert_v([x.o2b, x.rtt2b], Values.I32_1);
}

def test_ref_cast(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	var x = RttTestVals.new(t);
	t.sig0([ValueType.RefStruct(false, x.st1), ValueType.Rtt(2, x.st2)], [ValueType.RefStruct(false, x.st2)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.REF_CAST.prefix, Opcode.REF_CAST.code, heapIndexByte(x.st1), heapIndexByte(x.st2)
	]);

	var fail = TrapReason.FAILED_CAST;
	t.assert_trap([Values.REF_NULL, x.rtt2a], fail);
	t.assert_trap([Values.REF_NULL, x.rtt2b], fail);
	t.assert_trap([x.o1, x.rtt2a], fail);
	t.assert_trap([x.o1, x.rtt2b], fail);

	t.assert_v([x.o2a, x.rtt2a], x.o2a);
	t.assert_trap([x.o2a, x.rtt2b], fail);

	t.assert_trap([x.o2b, x.rtt2a], fail);
	t.assert_v([x.o2b, x.rtt2b], x.o2b);
}

def test_br_on_cast(t: InterpreterTester) {
	t.extensions |= Extension.GC;
	def x = RttTestVals.new(t);

	t.sig0([ValueType.RefStruct(false, x.st1), ValueType.Rtt(2, x.st2)], [ValueType.RefStruct(false, x.st2)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.BR_ON_CAST.prefix, Opcode.BR_ON_CAST.code, 0,
			heapIndexByte(x.st1), heapIndexByte(x.st2),
		Opcode.UNREACHABLE.code
	]);
	var fail = TrapReason.UNREACHABLE;
	t.assert_trap([Values.REF_NULL, x.rtt2a], fail);
	t.assert_trap([Values.REF_NULL, x.rtt2b], fail);
	t.assert_trap([x.o1, x.rtt2a], fail);
	t.assert_trap([x.o1, x.rtt2b], fail);

	t.assert_v([x.o2a, x.rtt2a], x.o2a);
	t.assert_trap([x.o2a, x.rtt2b], fail);

	t.assert_trap([x.o2b, x.rtt2a], fail);
	t.assert_v([x.o2b, x.rtt2b], x.o2b);
}

def test_abstype_default(t: InterpreterTester) {
	var cases = [
		(ValueType.I32, Values.I32_0),
		(ValueType.F32, Values.F32_0),
		(ValueType.ANYREF, Values.REF_NULL),
		(ValueType.EXTERNREF, Values.REF_NULL)
	];
	for (c in cases) {
		var abs = AbsTypeDecl.new(true, c.0 == ValueType.EXTERNREF, []);
		var n = InterpreterTester.new(t.t);
		n.extensions |= Extension.TYPE_IMPORTS;
		n.module.addImport("foo", "bar", [], abs);

		var at = ValueType.Abstract(abs);
		n.addLocal(at);
		n.sig0(SigCache.arr_v, [at]);
		n.code([
			Opcode.LOCAL_GET.code, 0
		]);

		var err = WasmErrorGen.new("InterpreterTester.v3");
		var instance = Instantiator.new(n.extensions, n.module, [ExportedValueType.new(null, c.0)], err).run();
		n.t.assertz(false, err.error());
		if (instance == null) return n.t.fail("instantiation failed");

		var f = instance.functions[0];
		var i = Interpreter.new();
		n.assert_req(i.run(10, f, []), Result.Value([c.1]));
	}
}

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("jawa:ivt:", _, JawaTester.new, _);
def X = [
	T("vtable1", test_vtable1),
	T("vtable2", test_vtable2),
	T("vtableov1", test_vtableov1),
	T("vtableov2", test_vtableov2),
	T("ivt1", test_ivt1),
	T("ivt2", test_ivt2),
	T("ivt3", test_ivt3),
	T("overload_ret", test_overload_ret),
	T("overload1", test_overload1),
	T("overload2", test_overload2),
	T("final1", test_final1),
	()
];

def IA = JawaStrings.of("IA"), IB = JawaStrings.of("IB");
def CX = JawaStrings.of("CX"), CY = JawaStrings.of("CY"), CZ = JawaStrings.of("CZ"), CW = JawaStrings.of("CW");
def M = JawaStrings.of("M"), N = JawaStrings.of("N"), P = JawaStrings.of("P");

def NO_METHOD_ATTRS: JawaMethodAttr.set;
def newMethod = JawaMethod.new(_, NO_METHOD_ATTRS, _, _, null);

def test_vtable1(t: JawaTester) {
	def ct = JawaClassType.new(CX, null, []);
	var m1 = newMethod(M, [], JawaTypes.VOID);
	var m2 = newMethod(N, [], JawaTypes.VOID);
	ct.instanceMethods = [m1, m2];

	t.assertVTable([m1, m2], ct);
}

def test_vtable2(t: JawaTester) {
	def cx = JawaClassType.new(CX, null, []);
	var xm = newMethod(M, [], JawaTypes.VOID);
	var xn = newMethod(N, [], JawaTypes.VOID);
	cx.instanceMethods = [xm, xn];
	t.assertVTable([xm, xn], cx);

	def cy = JawaClassType.new(CY, cx, []);
	var ym = newMethod(M, [], JawaTypes.VOID);
	cy.instanceMethods = [ym];
	t.assertVTable([ym, xn], cy);

	def cz = JawaClassType.new(CZ, cy, []);
	var zn = newMethod(N, [], JawaTypes.VOID);
	var zp = newMethod(P, [], JawaTypes.VOID);
	cz.instanceMethods = [zn, zp];
	t.assertVTable([ym, zn, zp], cz);

	def cw = JawaClassType.new(CW, cz, []);
	var wm = newMethod(M, [], JawaTypes.VOID);
	var wp = newMethod(P, [], JawaTypes.VOID);
	cw.instanceMethods = [wm, wp];
	t.assertVTable([wm, zn, wp], cw);
}

def test_vtableov1(t: JawaTester) {
	def ct = JawaClassType.new(CX, null, []);
	var m1 = newMethod(M, [], JawaTypes.VOID);
	var m2 = newMethod(M, [JawaTypes.INT], JawaTypes.VOID);
	var m3 = newMethod(N, [JawaTypes.INT], JawaTypes.VOID);

	ct.instanceMethods = [m1, m2, m3];

	t.assertVTable([m1, m2, m3], ct);
}

def test_vtableov2(t: JawaTester) {
	def cx = JawaClassType.new(CX, null, []);
	var m1 = newMethod(M, [], JawaTypes.VOID);
	var m3 = newMethod(N, [JawaTypes.INT], JawaTypes.BYTE);
	var m2 = newMethod(M, [JawaTypes.INT], JawaTypes.VOID);
	cx.instanceMethods = [m1, m3, m2];

	t.assertVTable([m1, m3, m2], cx);

	def cy = JawaClassType.new(CX, cx, []);
	var om1 = newMethod(M, [], JawaTypes.VOID);
	var om2 = newMethod(M, [JawaTypes.INT], JawaTypes.VOID);
	cy.instanceMethods = [om2, om1];

	t.assertVTable([om1, m3, om2], cy);
}

def test_ivt1(t: JawaTester) {
	def ia = JawaInterfaceType.new(IA, []);
	var am = newMethod(M, [], JawaTypes.VOID);
	ia.instanceMethods = [am];

	def cx = JawaClassType.new(CX, null, [ia]);
	var xm = newMethod(M, [], JawaTypes.VOID);
	var xn = newMethod(N, [], JawaTypes.VOID);
	cx.instanceMethods = [xm, xn];
	t.assertVTable([xm, xn], cx);
	t.assertITable((ia, [0]), cx);
}

def test_ivt2(t: JawaTester) {
	def ia = JawaInterfaceType.new(IA, []);
	var am = newMethod(M, [], JawaTypes.VOID);
	var an = newMethod(N, [], JawaTypes.VOID);
	ia.instanceMethods = [am, an];

	def cx = JawaClassType.new(CX, null, [ia]);
	var xm = newMethod(M, [], JawaTypes.VOID);
	var xn = newMethod(N, [], JawaTypes.VOID);
	var xp = newMethod(P, [], JawaTypes.VOID);
	cx.instanceMethods = [xm, xp, xn];
	t.assertVTable([xm, xp, xn], cx);
	t.assertITable((ia, [0, 2]), cx);

	def cy = JawaClassType.new(CY, cx, []);
	cy.instanceMethods = [];
	t.assertVTable([xm, xp, xn], cy);
	t.assertITable((ia, [0, 2]), cy);
}

def test_ivt3(t: JawaTester) {
	def ia = JawaInterfaceType.new(IA, []);
	var am = newMethod(M, [], JawaTypes.VOID);
	var an = newMethod(N, [], JawaTypes.VOID);
	ia.instanceMethods = [am, an];

	def cx = JawaClassType.new(CX, null, [ia]);
	var xm = newMethod(M, [], JawaTypes.VOID);
	var xn = newMethod(N, [], JawaTypes.VOID);
	var xp = newMethod(P, [], JawaTypes.VOID);
	cx.instanceMethods = [xm, xp, xn];
	t.assertVTable([xm, xp, xn], cx);
	t.assertITable((ia, [0, 2]), cx);

	def cy = JawaClassType.new(CY, cx, []);
	cy.instanceMethods = [];
	t.assertVTable([xm, xp, xn], cy);
	t.assertITable((ia, [0, 2]), cy);
}

def test_overload_ret(t: JawaTester) {
 	def RETURN_TYPES = [JawaTypes.VOID, JawaTypes.BYTE, JawaTypes.INT, JawaTypes.BYTE_ARRAY, JawaTypes.OBJECT];

	for (x in RETURN_TYPES) {
		for (y in RETURN_TYPES) {
			var mx = newMethod(M, [], x);
			var my = newMethod(M, [], y);
			var expected = if(x.isAssignableToH(y), JawaOverride.YES, JawaOverride.ERR_BECAUSE_RETURN);
			t.assertOverride(expected, mx, my);
		}
	}
}

def test_overload1(t: JawaTester) {
	def m = newMethod(M, _, JawaTypes.VOID);
	var param_i: Array<JawaType> = [JawaTypes.INT];
	var param_v: Array<JawaType> = [];

	t.assertOverride(JawaOverride.NO_BECAUSE_PARAMS, m(param_v), m(param_i));
	t.assertOverride(JawaOverride.NO_BECAUSE_PARAMS, m(param_i), m(param_v));
	t.assertOverride(JawaOverride.NO_BECAUSE_PARAMS, m([JawaTypes.INT, JawaTypes.INT]), m(param_i));
	t.assertOverride(JawaOverride.NO_BECAUSE_PARAMS, m([JawaTypes.FLOAT]), m([JawaTypes.FLOAT, JawaTypes.INT]));
}

def test_overload2(t: JawaTester) {
 	def PARAM_TYPES = [JawaTypes.BYTE, JawaTypes.INT, JawaTypes.BYTE_ARRAY, JawaTypes.OBJECT];

	for (x in PARAM_TYPES) {
		for (y in PARAM_TYPES) {
			var mx = newMethod(M, [x], JawaTypes.VOID);
			var my = newMethod(M, [y], JawaTypes.VOID);
			var expected = if(x == y, JawaOverride.YES, JawaOverride.NO_BECAUSE_PARAMS);
			t.assertOverride(expected, mx, my);
		}
	}
}

def test_final1(t: JawaTester) {
	var none: JawaMethodAttr.set;
	var final: JawaMethodAttr.set = JawaMethodAttr.FINAL;

	var param_i: Array<JawaType> = [JawaTypes.INT];
	var param_v: Array<JawaType> = [];

	def m = JawaMethod.new(M, _, _, JawaTypes.VOID, null);

	t.assertOverride(JawaOverride.ERR_BECAUSE_FINAL, m(none, param_i), m(final, param_i));
	t.assertOverride(JawaOverride.NO_BECAUSE_PARAMS, m(none, param_v), m(final, param_i));
	t.assertOverride(JawaOverride.YES, m(final, param_i), m(none, param_i));
}
// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class JawaTester(t: Tester) extends ModuleBuilder {
	def err = WasmErrorGen.new("<JawaTest>");
	def env = JawaEnvironment.new(null);
	private def asm = JawaAsm.new();
	def hash(s: string) -> int {
		return int.view(JawaStrings.of(s).hashCode());
	}
	def addTypeImport(typename: string, sup: Array<ValueType>) -> ImportedType {
		var it = ImportedType.new(module.imports.length, module.types.length, sup);
		var imported = DefType.Imported(it);
		var details = ImportDetails.Type(imported);
		module.imports.put(ImportDecl.new("jawa", typename, details));
		module.types.put(imported);
		return it;
	}
	def addFuncImport(funcname: string, sig: FuncSig) -> int {
		var sig_index = addSig(sig);
		var func = FunctionDecl.new(module.functions.imported.length, sig_index, sig);
		module.functions.imported.put(func);
		var details = ImportDetails.Function(func);
		module.imports.put(ImportDecl.new("jawa", funcname, details));
		return module.functions.imported.length - 1;
	}
	def importClass(name: string) -> ImportedType {
		def str = asm.reset()
			.putc(JawaTypeOpcode.EXT_CLASS.code)
			.put_jstr(JawaStrings.of(name))
			.extract();
		return addTypeImport(str, ValueTypes.NONE);
	}
	def importJawaLangObject() -> ImportedType {
		env.add(JawaClasses.OBJECT);
		return importClass("jawa/lang/Object");
	}
	def importPrimArray(c: JawaPrimArrayOpcodes) -> ImportedType {
		return addTypeImport([c.type_code.code], ValueTypes.NONE);
	}
	def addClass(s: string, sup: JawaClass) -> JawaClass {
		var cl = JawaClass.new(JawaStrings.of(s), sup, JawaClasses.NO_INTERFACES);
		env.add(cl);
		return cl;
	}
	def importInterface(name: string) -> ImportedType {
		def str = asm.reset()
			.putc(JawaTypeOpcode.EXT_INTERFACE.code)
			.put_jstr(JawaStrings.of(name))
			.extract();
		return addTypeImport(str, ValueTypes.NONE);
	}
	def importArrayOf(it: ImportedType) -> ImportedType {
		def str = asm.reset()
			.putc(JawaTypeOpcode.REF_ARRAY.code)
			.put_jawa_i4(it.type_index)
			.extract();
		return addTypeImport(str, ValueTypes.NONE);
	}
	def importMultiArrayOf(it: ImportedType, rank: int) -> ImportedType {
		var last = it;
		for (i < rank) last = importArrayOf(last);
		return last;
	}
	def addInterface(s: string) -> JawaInterface {
		var cl = JawaInterface.new(JawaStrings.of(s), JawaClasses.NO_INTERFACES);
		env.add(cl);
		return cl;
	}
	def process() -> Array<Exportable> {
		var result = Array<Exportable>.new(module.imports.length);
		var jip = JawaImportProcessor.new(err, env, module, result);
		jip.process();
		if (err.error()) {
			t.fail(Strings.format1("Jawa import processing failed: %s", err.error_msg));
		}
		return result;
	}
	def assertIsJawaClassType(decl: JawaClass, e: Exportable) -> JawaClassType {
		match (e) {
			r: JawaClassType => if (decl == null || r.decl == decl) return r;
			_ => ;
		}
		var exp = JawaClassType.new(decl);
		t.fail(Strings.format2("expected jawa class %q, got %q", safeRender(decl), safeRender(e)));
		return exp;
	}
	def assertIsJawaInterfaceType(decl: JawaInterface, e: Exportable) -> JawaInterfaceType {
		match (e) {
		r: JawaInterfaceType => if (decl == null || r.decl == decl) return r;
			_ => ;
		}
		var exp = JawaInterfaceType.new(decl);
		t.fail(Strings.format2("expected jawa interface %q, got %q", safeRender(decl), safeRender(e)));
		return exp;
	}
	def assertIsJawaArrayType(elem: JawaType, e: Exportable) -> JawaArrayType {
		match (e) {
			r: JawaArrayType => if (elem == null || r.elem == elem) return r;
			_ => ;
		}
		var exp = JawaArrayType.new(elem);
		t.fail(Strings.format2("expected jawa array of %q, got %q", safeRender(elem), safeRender(e)));
		return exp;
	}
	def assertIsJawaObject(r: Result) -> JawaObject {
		if (!Result.Value.?(r)) {
			t.fail(Strings.format1("expected array return, got %q", r.render));
			return null;
		}
		var vr = Result.Value.!(r);
		if (vr.vals.length != 1) {
			t.fail(Strings.format1("expected 1 result value, got %q", r.render));
			return null;
		}
		var val = vr.vals[0];
		if (!Value.ExternRef.?(val)) {
			t.fail(Strings.format1("expected jawa object, got %q", Values.render(_, val)));
			return null;
		}
		var ext = Value.ExternRef.!(val);
		if (!JawaObject.?(ext.val)) {
			t.fail(Strings.format1("expected jawa object, got %q", safeRender(ext.val)));
			return null;
		}
		return JawaObject.!(ext.val);
	}
	def assertIsJawaArrayObjectOf<T>(obj: JawaObject) -> JawaArrayObjectOf<T> {
		if (!JawaArrayObjectOf<T>.?(obj)) {
			t.fail(Strings.format1("expected jawa array, got %q", safeRender(obj)));
			return null;
		}
		return JawaArrayObjectOf<T>.!(obj);
	}
	def assertIsJawaArrayObject(obj: JawaObject) -> JawaArrayObject {
		if (!JawaArrayObject.?(obj)) {
			t.fail(Strings.format1("expected jawa array, got %q", safeRender(obj)));
			return null;
		}
		return JawaArrayObject.!(obj);
	}
	def assertIsJawaRefArrayObject(obj: JawaObject) -> JawaRefArrayObject {
		if (!JawaRefArrayObject.?(obj)) {
			t.fail(Strings.format1("expected jawa ref array, got %q", safeRender(obj)));
			return null;
		}
		return JawaRefArrayObject.!(obj);
	}
	def assertIsFunction(expected_sig: FuncSig, e: Exportable) -> Function {
		if (!Function.?(e)) {
			t.fail("expected Function");
			return null;
		}
		var f = Function.!(e);
		if (!f.sig.isAssignableSig(expected_sig)) {
			t.fail(Strings.format2("expected Function of type %q, got %q", expected_sig.render, safeRender(f.sig)));
			return null;
		}
		return f;
	}
	def assert_r(expected: Result, got: Result) {
		if (expected.equals(got)) return;
		t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_v(expected: Value, got: Result) {
		assert_r(Result.Value([expected]), got);
	}
	def assert_a<T>(expected: Array<T>, got: Array<T>) {
		if (!assert_length(expected, got)) return;
		for (i < expected.length) {
			if (expected[i] != got[i]) return t.fail(Strings.format1("mismatch at array[%d]", i));
		}
	}
	def assert_da(expected: Array<double>, got: Array<double>) {
		if (!assert_length(expected, got)) return;
		for (i < expected.length) {
			if (u64.view(expected[i]) != u64.view(got[i])) return t.fail(Strings.format1("mismatch at array[%d]", i));
		}
	}
	def assert_fa(expected: Array<float>, got: Array<float>) {
		if (!assert_length(expected, got)) return;
		for (i < expected.length) {
			if (u32.view(expected[i]) != u32.view(got[i])) return t.fail(Strings.format1("mismatch at array[%d]", i));
		}
	}
	def assert_length<T>(expected: Array<T>, got: Array<T>) -> bool {
		if (expected.length != got.length) {
			t.fail(Strings.format2("expected array of %d length, got %d", expected.length, got.length));
			return false;
		}
		return true;
	}
	def dumpTypes() {
		var buf = StringBuilder.new();
		for (i < module.types.length) {
			buf.reset().put1("types[%d] = ", i);
			match (module.types[i]) {
				Function(sig) => buf.put1("sig %q\n", sig.render);
				Imported(it) => buf.put1("import %q\n", it.render);
			}
			buf.out(Trace.STDOUT);
		}
	}
	def safeRender<T>(t: T) -> StringBuilder -> StringBuilder {
		var d: T;
		if (t == d) return Strings.puts("<null>");
		if (Exportable.?(t)) return Exportable.!(t).render;
		if (FuncSig.?(t)) return FuncSig.!(t).render;
		if (HostObject.?(t)) return HostObject.!(t).render;
		if (JawaCompound.?(t)) return JawaCompound.!(t).name.render;
		return Strings.puts("<?>");
	}
	// Helpers for specific, complex bytecodes.
	def make_xaload(c: JawaPrimArrayOpcodes) -> Function {
		var n = JawaTester.new(t);
		var bt = n.importPrimArray(c);
		var expected_sig = FuncSig.new([ValueType.Host(c.arrayType), ValueType.I32], [c.map.valueType]);
		n.addFuncImport([c.xaload.code], expected_sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		return assertIsFunction(expected_sig, r[1]);
	}
	def make_xastore(c: JawaPrimArrayOpcodes) -> Function {
		var n = JawaTester.new(t);
		var bt = n.importPrimArray(c);
		var expected_sig = FuncSig.new([ValueType.Host(c.arrayType), ValueType.I32, c.map.valueType], SigCache.arr_v);
		n.addFuncImport([c.xastore.code], expected_sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		return assertIsFunction(expected_sig, r[1]);
	}
	def make_xnewarray(c: JawaPrimArrayOpcodes) -> Function {
		var n = JawaTester.new(t);
		var bt = n.importPrimArray(c);
		var sig = FuncSig.new(SigCache.arr_i, [ValueType.Host(c.arrayType)]);
		def str = n.asm.reset()
			.putc(JawaFuncOpcode.NEWARRAY.code)
			.put_jawa_i4(bt.type_index)
			.extract();
		n.addFuncImport(str, sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		return assertIsFunction(sig, r[1]);
	}
	def make_xarraylength(c: JawaPrimArrayOpcodes) -> Function {
		var n = JawaTester.new(t);
		var bt = n.importPrimArray(c);
		var sig = FuncSig.new([ValueType.Host(c.arrayType)], SigCache.arr_i);
		def str = n.asm.reset()
			.putc(JawaFuncOpcode.ARRAYLENGTH.code)
			.put_jawa_i4(bt.type_index)
			.extract();
		n.addFuncImport(str, sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		return assertIsFunction(sig, r[1]);
	}
	def make_multianewarray(it: ImportedType, dims: int) -> (JawaArrayType, Function) {
		var param_types = Array<ValueType>.new(dims);
		for (i < dims) param_types[i] = ValueType.I32;

		var sig = FuncSig.new(param_types, [ValueType.Imported(it)]);
		asm.reset()
			.putc(JawaFuncOpcode.MULTIANEWARRAY.code)
			.put_jawa_i4(dims)
			.put_jawa_i4(it.type_index);
		addFuncImport(asm.extract(), sig);
		var r = process();

		var xt = r[it.import_index];
		if (!JawaArrayType.?(xt)) {
			t.fail(Strings.format1("expected array type, got %q", safeRender(xt)));
			return (null, null);
		}
		var at = JawaArrayType.!(xt);
		var expected_sig = FuncSig.new(param_types, [ValueType.Host(at)]);
		return (at, assertIsFunction(expected_sig, r[it.import_index + 1]));
	}

}

// A helper to emit the import language.
class JawaAsm extends StringBuilder {
	def put_jstr(j: JawaString) -> this {
		put_jawa_i2(j.chars.length);
		for (c in j.chars) pututf8(c);
	}
	def put_jawa_i2(v: int) -> this {
		for (j < 2) {
			putc(u7.view(v));
			v = v >> 7;
		}
	}
	def put_jawa_i4(v: int) -> this {
		for (j < 4) {
			putc(u7.view(v));
			v = v >> 7;
		}
	}
}

enum JawaPrimArrayOpcodes(type_code: JawaTypeOpcode, xaload: JawaFuncOpcode, xastore: JawaFuncOpcode, arrayType: JawaArrayType, map: JawaPrimMapping) {
	BYTE(JawaTypeOpcode.BYTE_ARRAY, JawaFuncOpcode.BALOAD, JawaFuncOpcode.BASTORE, JawaTypes.BYTE_ARRAY, JawaTypes.BYTE_MAPPING),
	BOOL(JawaTypeOpcode.BOOL_ARRAY, JawaFuncOpcode.BALOAD, JawaFuncOpcode.BASTORE, JawaTypes.BOOL_ARRAY, JawaTypes.BOOL_MAPPING),
	CHAR(JawaTypeOpcode.CHAR_ARRAY, JawaFuncOpcode.CALOAD, JawaFuncOpcode.CASTORE, JawaTypes.CHAR_ARRAY, JawaTypes.CHAR_MAPPING),
	SHORT(JawaTypeOpcode.SHORT_ARRAY, JawaFuncOpcode.SALOAD, JawaFuncOpcode.SASTORE, JawaTypes.SHORT_ARRAY, JawaTypes.SHORT_MAPPING),
	INT(JawaTypeOpcode.INT_ARRAY, JawaFuncOpcode.IALOAD, JawaFuncOpcode.IASTORE, JawaTypes.INT_ARRAY, JawaTypes.INT_MAPPING),
	LONG(JawaTypeOpcode.LONG_ARRAY, JawaFuncOpcode.LALOAD, JawaFuncOpcode.LASTORE, JawaTypes.LONG_ARRAY, JawaTypes.LONG_MAPPING),
	FLOAT(JawaTypeOpcode.FLOAT_ARRAY, JawaFuncOpcode.FALOAD, JawaFuncOpcode.FASTORE, JawaTypes.FLOAT_ARRAY, JawaTypes.FLOAT_MAPPING),
	DOUBLE(JawaTypeOpcode.DOUBLE_ARRAY, JawaFuncOpcode.DALOAD, JawaFuncOpcode.DASTORE, JawaTypes.DOUBLE_ARRAY, JawaTypes.DOUBLE_MAPPING)
}

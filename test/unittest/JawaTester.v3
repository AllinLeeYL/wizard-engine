// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class JawaTester(t: Tester) extends ModuleBuilder {
	def err = WasmErrorGen.new("<JawaTest>");
	def env = JawaEnvironment.new(null);
	private def asm = JawaAsm.new();

	def addTypeImport(typename: string, sup: Array<ValueType>) -> AbsType {
		var it = AbsType.new(module.imports.length, module.abstypes.length, sup);
		var details = ImportDetails.Type(it);
		module.imports.put(ImportDecl.new("jawa", typename, details));
		module.abstypes.put(it);
		return it;
	}
	def addFuncImport(funcname: string, sig: FuncSig) -> int {
		var sig_index = addSig(sig);
		var func = FuncDecl.new(true, module.functions.length, sig_index, sig);
		module.functions.put(func);
		var details = ImportDetails.Function(func);
		var import_index = module.imports.length;
		module.imports.put(ImportDecl.new("jawa", funcname, details));
		return import_index;
	}
	def addGlobalImport(name: string, vt: ValueType) -> int {
		var global = GlobalDecl.new(module.globals.length, vt, false, InitExpr.I32(0));
		module.globals.put(global);
		var details = ImportDetails.Global(global);
		var import_index = module.imports.length;
		module.imports.put(ImportDecl.new("jawa", name, details));
		return import_index;
	}
	def importClass(name: string) -> AbsType {
		def str = asm.reset()
			.putc(JawaTypeOpcode.EXT_CLASS.code)
			.put_jname(JawaStrings.of(name))
			.extract();
		return addTypeImport(str, ValueTypes.NONE);
	}
	def importJawaLangObject() -> AbsType {
		env.add(JawaClasses.OBJECT);
		return importClass("jawa/lang/Object");
	}
	def importPrimArray(c: JawaPrimArrayOpcodes) -> AbsType {
		return addTypeImport([c.type_code.code], ValueTypes.NONE);
	}
	def importInterface(name: string) -> AbsType {
		def str = asm.reset()
			.putc(JawaTypeOpcode.EXT_INTERFACE.code)
			.put_jname(JawaStrings.of(name))
			.extract();
		return addTypeImport(str, ValueTypes.NONE);
	}
	def importArrayOf(it: AbsType) -> AbsType {
		def str = asm.reset()
			.putc(JawaTypeOpcode.REF_ARRAY.code)
			.put_ji4(it.type_index)
			.extract();
		return addTypeImport(str, ValueTypes.NONE);
	}
	def importMultiArrayOf(it: AbsType, rank: int) -> AbsType {
		var last = it;
		for (i < rank) last = importArrayOf(last);
		return last;
	}
	def declareClass(name: string, sup: AbsType, intfs: Array<AbsType>) -> AbsType {
		if (sup == null) sup = importJawaLangObject();
		var jname = JawaStrings.of(name);
		var cmd = asm.reset()
			.putc(JawaTypeOpcode.DECL_CLASS.code)
			.put_jname(jname)
			.put_ji4(sup.type_index)
			.put_ji4(intfs.length);
		var its = Array<AbsType>.new(intfs.length);
		var constraints = Array<ValueType>.new(intfs.length + 1);
		constraints[0] = ValueType.Imported(sup);
		for (i < intfs.length) {
			var it = intfs[i];
			cmd.put_ji4(it.type_index);
			constraints[i + 1] = ValueType.Imported(it);
		}
		return addTypeImport(cmd.extract(), constraints);
	}
	def declareInterface(name: string, intfs: Array<AbsType>) -> AbsType {
		var jname = JawaStrings.of(name);
		var cmd = asm.reset()
			.putc(JawaTypeOpcode.DECL_INTERFACE.code)
			.put_jname(jname)
			.put_ji4(intfs.length);
		var its = Array<AbsType>.new(intfs.length);
		var constraints = Array<ValueType>.new(intfs.length);
		for (i < intfs.length) {
			var it = intfs[i];
			cmd.put_ji4(it.type_index);
			constraints[i] = ValueType.Imported(it);
		}
		return addTypeImport(cmd.extract(), constraints);
	}
	def defineClass(it: AbsType,
		instanceFields: Array<(JawaString, JawaTypeRef)>,
		instanceMethods: Array<(JawaString, JawaSigRef, FuncDecl)>,
		staticFields: Array<(JawaString, JawaTypeRef)>,
		staticMethods: Array<(JawaString, JawaSigRef, FuncDecl)>) {
		var cmd = asm.reset()
			.putc(JawaCommandOpcode.DEF_CLASS.code)
			.put_ji4(it.type_index);

		cmd.put_ji4(instanceFields.length);
		for (f in instanceFields) cmd.put_field_decl(f);

		cmd.put_ji4(instanceMethods.length);
		for (m in instanceMethods) cmd.put_method_def(m);

		cmd.put_ji4(staticFields.length);
		for (f in staticFields) cmd.put_field_decl(f);

		cmd.put_ji4(staticMethods.length);
		for (m in staticMethods) cmd.put_method_def(m);

		module.imports.put(ImportDecl.new("jawa", cmd.extract(), ImportDetails.Command));
	}
	def defineInterface(it: AbsType,
		instanceMethods: Array<(JawaString, JawaSigRef)>) {
		var cmd = asm.reset()
			.putc(JawaCommandOpcode.DEF_INTERFACE.code)
			.put_ji4(it.type_index);

		cmd.put_ji4(instanceMethods.length);
		for (m in instanceMethods) cmd.put_method_decl(m);

		module.imports.put(ImportDecl.new("jawa", cmd.extract(), ImportDetails.Command));
	}

	// Runs the import processor and produces the imports.
	def process() -> Array<Exportable> {
		var binder = ImportBinder.new(module, err);
		var jip = JawaImportProcessor.new(env, binder);
		binder.process();
		if (err.error()) {
			t.fail(Strings.format1("Jawa import processing failed: %s", err.error_msg));
		}
		return binder.bindings;
	}
	def assertProcessFails() {
		var binder = ImportBinder.new(module, err);
		var jip = JawaImportProcessor.new(env, binder);
		binder.process();
		if (!err.error()) t.fail("expected jawa import processing to fail, but passed");
	}

	// Assertion helpers
	def assertIsJawaClassType(exp: JawaClassType, e: Exportable) -> JawaClassType {
		if (exp == null && JawaClassType.?(e)) return JawaClassType.!(e);
		if (exp == e) return exp;
		t.fail(Strings.format2("expected jawa class %q, got %q", safeRender(exp), safeRender(e)));
		return null;
	}
	def assertIsJawaClassTypeWithName(name: JawaString, e: Exportable) -> JawaClassType {
		if (JawaClassType.?(e)) {
			var ct = JawaClassType.!(e);
			if (!name.equals(ct.name)) {
				t.fail(Strings.format2("expected jawa class with name %q, got %q", name.render, ct.name.render));
				return null;
			}
			return ct;
		}
		t.fail(Strings.format2("expected jawa class %q, got %q", name.render, safeRender(e)));
		return null;
	}
	def assertIsJawaInterfaceType(exp: JawaInterfaceType, e: Exportable) -> JawaInterfaceType {
		if (exp == null && JawaInterfaceType.?(e)) return JawaInterfaceType.!(e);
		if (exp == e) return exp;
		t.fail(Strings.format2("expected jawa interface %q, got %q", safeRender(exp), safeRender(e)));
		return null;
	}
	def assertIsJawaInterfaceTypeWithName(name: JawaString, e: Exportable) -> JawaInterfaceType {
		if (JawaInterfaceType.?(e)) {
			var ct = JawaInterfaceType.!(e);
			if (!name.equals(ct.name)) {
				t.fail(Strings.format2("expected jawa interface with name %q, got %q", name.render, ct.name.render));
				return null;
			}
			return ct;
		}
		t.fail(Strings.format2("expected jawa interface %q, got %q", name.render, safeRender(e)));
		return null;
	}
	def assertIsJawaArrayType(elem: JawaType, e: Exportable) -> JawaArrayType {
		if (elem == null && JawaArrayType.?(e)) return JawaArrayType.!(e);
		match (e) {
			r: JawaArrayType => if (r.elem == elem) return r;
			_ => ;
		}
		t.fail(Strings.format2("expected jawa array of %q, got %q", safeRender(elem), safeRender(e)));
		return null;
	}
	def assertIsJawaObject(r: Result) -> JawaObject {
		if (!Result.Value.?(r)) {
			t.fail(Strings.format1("expected array return, got %q", r.render));
			return null;
		}
		var vr = Result.Value.!(r);
		if (vr.vals.length != 1) {
			t.fail(Strings.format1("expected 1 result value, got %q", r.render));
			return null;
		}
		var val = vr.vals[0];
		if (!Value.ExternRef.?(val)) {
			t.fail(Strings.format1("expected jawa object, got %q", Values.render(_, val)));
			return null;
		}
		var ext = Value.ExternRef.!(val);
		if (!JawaObject.?(ext.val)) {
			t.fail(Strings.format1("expected jawa object, got %q", safeRender(ext.val)));
			return null;
		}
		return JawaObject.!(ext.val);
	}
	def assertIsJawaInstanceObject(ct: JawaClassType, r: Result) -> JawaInstanceObject {
		var obj = assertIsJawaObject(r);
		if (obj == null) return null;
		if (!JawaInstanceObject.?(obj)) {
			t.fail(Strings.format2("expected jawa instance object of type %q, got %q", safeRender(ct), safeRender(obj)));
			return null;
		}
		var iobj = JawaInstanceObject.!(obj);
		if (iobj.clazz != ct) {
			t.fail(Strings.format2("expected jawa instance object of type %q, got %q", safeRender(ct), safeRender(obj)));
			return null;
		}
		return iobj;
	}
	def assertIsJawaArrayObjectOf<T>(obj: JawaObject) -> JawaArrayObjectOf<T> {
		if (!JawaArrayObjectOf<T>.?(obj)) {
			t.fail(Strings.format1("expected jawa array, got %q", safeRender(obj)));
			return null;
		}
		return JawaArrayObjectOf<T>.!(obj);
	}
	def assertIsJawaArrayObject(obj: JawaObject) -> JawaArrayObject {
		if (!JawaArrayObject.?(obj)) {
			t.fail(Strings.format1("expected jawa array, got %q", safeRender(obj)));
			return null;
		}
		return JawaArrayObject.!(obj);
	}
	def assertIsJawaRefArrayObject(obj: JawaObject) -> JawaRefArrayObject {
		if (!JawaRefArrayObject.?(obj)) {
			t.fail(Strings.format1("expected jawa ref array, got %q", safeRender(obj)));
			return null;
		}
		return JawaRefArrayObject.!(obj);
	}
	def assertIsFunction(expected_sig: FuncSig, e: Exportable) -> Function {
		if (!Function.?(e)) {
			t.fail(Strings.format1("expected Function, got %q", safeRender(e)));
			return null;
		}
		var f = Function.!(e);
		if (!f.sig.isAssignableSig(expected_sig)) {
			t.fail(Strings.format2("expected Function of type %q, got %q", expected_sig.render, safeRender(f.sig)));
			return null;
		}
		return f;
	}
	def assertIsJawaField(fields: Array<JawaField>, index: int, name: JawaString, typ: JawaType) -> JawaField {
		if (fields == null) {
			t.fail("expected non-null fields");
			return null;
		}
		if (index >= fields.length) {
			t.fail2("expected at least %d fields, got %d", index+1, fields.length);
			return null;
		}
		var f = fields[index];
		if (!name.equals(f.name)) {
			t.fail2("expected field name \"%q\", got \"%q\"", name.render, f.name.render);
			return null;
		}
		if (typ != f.typ) {
			t.fail2("expected field type \"%q\", got \"%q\"", typ.render, f.typ.render);
			return null;
		}
		return f;
	}
	def assertIsJawaMethod(methods: Array<JawaMethod>, index: int, name: JawaString, params: Array<JawaType>, ret: JawaType) -> JawaMethod {
		if (methods == null) {
			t.fail("expected non-null methods");
			return null;
		}
		if (index >= methods.length) {
			t.fail2("expected at least %d methods, got %d", index+1, methods.length);
			return null;
		}
		var m = methods[index];
		if (!name.equals(m.name)) {
			t.fail2("expected field name \"%q\", got \"%q\"", name.render, m.name.render);
			return null;
		}
		if (ret != m.ret) {
			t.fail2("expected field rete \"%q\", got \"%q\"", ret.render, m.ret.render);
			return null;
		}
		return m;
	}
	def assert_r(expected: Result, got: Result) {
		if (expected.equals(got)) return;
		t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_v(expected: Value, got: Result) {
		assert_r(Result.Value([expected]), got);
	}
	def assert_a<T>(expected: Array<T>, got: Array<T>) {
		if (!assert_length(expected, got)) return;
		for (i < expected.length) {
			if (expected[i] != got[i]) return t.fail(Strings.format1("mismatch at array[%d]", i));
		}
	}
	def assert_da(expected: Array<double>, got: Array<double>) {
		if (!assert_length(expected, got)) return;
		for (i < expected.length) {
			if (u64.view(expected[i]) != u64.view(got[i])) return t.fail(Strings.format1("mismatch at array[%d]", i));
		}
	}
	def assert_fa(expected: Array<float>, got: Array<float>) {
		if (!assert_length(expected, got)) return;
		for (i < expected.length) {
			if (u32.view(expected[i]) != u32.view(got[i])) return t.fail(Strings.format1("mismatch at array[%d]", i));
		}
	}
	def assert_length<T>(expected: Array<T>, got: Array<T>) -> bool {
		if (expected.length != got.length) {
			t.fail(Strings.format2("expected array of %d length, got %d", expected.length, got.length));
			return false;
		}
		return true;
	}
	def dumpTypes() {
		var buf = TraceBuilder.new();
		for (i < module.abstypes.length) {
			buf.put2("types[%d] = import %q", i, module.abstypes[i].render);
			buf.outln();
		}
	}
	def safeRender<T>(t: T) -> StringBuilder -> StringBuilder {
		var d: T;
		if (t == d) return Strings.puts("<null>");
		if (Exportable.?(t)) return Exportable.!(t).render;
		if (FuncSig.?(t)) return FuncSig.!(t).render;
		if (HostObject.?(t)) return HostObject.!(t).render;
		return Strings.puts("<?>");
	}

	// Helpers for specific, complex bytecodes.
	def make_xaload(c: JawaPrimArrayOpcodes) -> Function {
		var n = JawaTester.new(t);
		var bt = n.importPrimArray(c);
		var expected_sig = FuncSig.new([ValueType.Host(c.arrayType), ValueType.I32], [c.map.valueType]);
		n.addFuncImport([c.xaload.code], expected_sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		return assertIsFunction(expected_sig, r[1]);
	}
	def make_xastore(c: JawaPrimArrayOpcodes) -> Function {
		var n = JawaTester.new(t);
		var bt = n.importPrimArray(c);
		var expected_sig = FuncSig.new([ValueType.Host(c.arrayType), ValueType.I32, c.map.valueType], SigCache.arr_v);
		n.addFuncImport([c.xastore.code], expected_sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		return assertIsFunction(expected_sig, r[1]);
	}
	def make_xnewarray(c: JawaPrimArrayOpcodes) -> Function {
		var n = JawaTester.new(t);
		var bt = n.importPrimArray(c);
		var sig = FuncSig.new(SigCache.arr_i, [ValueType.Host(c.arrayType)]);
		def str = n.asm.reset()
			.putc(JawaFuncOpcode.NEWARRAY.code)
			.put_ji4(bt.type_index)
			.extract();
		n.addFuncImport(str, sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		return assertIsFunction(sig, r[1]);
	}
	def make_xarraylength(c: JawaPrimArrayOpcodes) -> Function {
		var n = JawaTester.new(t);
		var bt = n.importPrimArray(c);
		var sig = FuncSig.new([ValueType.Host(c.arrayType)], SigCache.arr_i);
		def str = n.asm.reset()
			.putc(JawaFuncOpcode.ARRAYLENGTH.code)
			.put_ji4(bt.type_index)
			.extract();
		n.addFuncImport(str, sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		return assertIsFunction(sig, r[1]);
	}
	def make_multianewarray(it: AbsType, dims: int) -> (JawaArrayType, Function) {
		var param_types = Array<ValueType>.new(dims);
		for (i < dims) param_types[i] = ValueType.I32;

		var sig = FuncSig.new(param_types, [ValueType.Imported(it)]);
		asm.reset()
			.putc(JawaFuncOpcode.MULTIANEWARRAY.code)
			.put_ji4(dims)
			.put_ji4(it.type_index);
		addFuncImport(asm.extract(), sig);
		var r = process();

		var xt = r[it.import_index];
		if (!JawaArrayType.?(xt)) {
			t.fail(Strings.format1("expected array type, got %q", safeRender(xt)));
			return (null, null);
		}
		var at = JawaArrayType.!(xt);
		var expected_sig = FuncSig.new(param_types, [ValueType.Host(at)]);
		return (at, assertIsFunction(expected_sig, r[it.import_index + 1]));
	}

}

// A helper to emit the import language.
class JawaAsm extends StringBuilder {
	def put_jname(j: JawaString) -> this {
		put_ji2(j.chars.length);
		for (c in j.chars) pututf8(c);
	}
	def put_jstr(j: JawaString) -> this {
		put_ji4(j.chars.length);
		for (c in j.chars) pututf8(c);
	}
	def put_ji2(v: int) -> this {
		for (j < 2) {
			putc(u7.view(v));
			v = v >> 7;
		}
	}
	def put_ji4(v: int) -> this {
		for (j < 4) {
			putc(u7.view(v));
			v = v >> 7;
		}
	}
	def put_field_decl(name: JawaString, t: JawaTypeRef) -> this {
		put_jname(name);
		put_jtref(t);
	}
	def put_method_decl(name: JawaString, sig: JawaSigRef) -> this {
		put_jname(name);
		put_jtsig(sig);
	}
	def put_method_def(name: JawaString, sig: JawaSigRef, func: FuncDecl) -> this {
		put_jname(name);
		put_jtsig(sig);
		put_ji4(func.index);
	}
	def put_jtref(t: JawaTypeRef) -> this {
		match (t) {
			Void => putc(Utf8.TWO_BYTE_MASK).putc('V');
			Prim(t) => putc(Utf8.TWO_BYTE_MASK).putc(t.char);
			Imported(t) => put_ji4(t.type_index);
		}
	}
	def put_jtsig(sig: JawaSigRef) -> this {
		put_ji2(sig.params.length);
		for (p in sig.params) put_jtref(p);
		put_jtref(sig.result);
	}
}
type JawaTypeRef {
	case Void;
	case Prim(t: JawaPrimType);
	case Imported(t: AbsType);
}
class JawaSigRef(params: Array<JawaTypeRef>, result: JawaTypeRef) {
}

enum JawaPrimArrayOpcodes(type_code: JawaTypeOpcode, xaload: JawaFuncOpcode, xastore: JawaFuncOpcode, arrayType: JawaArrayType, map: JawaPrimMapping) {
	BYTE(JawaTypeOpcode.BYTE_ARRAY, JawaFuncOpcode.BALOAD, JawaFuncOpcode.BASTORE, JawaTypes.BYTE_ARRAY, JawaTypes.BYTE_MAPPING),
	BOOL(JawaTypeOpcode.BOOL_ARRAY, JawaFuncOpcode.BALOAD, JawaFuncOpcode.BASTORE, JawaTypes.BOOL_ARRAY, JawaTypes.BOOL_MAPPING),
	CHAR(JawaTypeOpcode.CHAR_ARRAY, JawaFuncOpcode.CALOAD, JawaFuncOpcode.CASTORE, JawaTypes.CHAR_ARRAY, JawaTypes.CHAR_MAPPING),
	SHORT(JawaTypeOpcode.SHORT_ARRAY, JawaFuncOpcode.SALOAD, JawaFuncOpcode.SASTORE, JawaTypes.SHORT_ARRAY, JawaTypes.SHORT_MAPPING),
	INT(JawaTypeOpcode.INT_ARRAY, JawaFuncOpcode.IALOAD, JawaFuncOpcode.IASTORE, JawaTypes.INT_ARRAY, JawaTypes.INT_MAPPING),
	LONG(JawaTypeOpcode.LONG_ARRAY, JawaFuncOpcode.LALOAD, JawaFuncOpcode.LASTORE, JawaTypes.LONG_ARRAY, JawaTypes.LONG_MAPPING),
	FLOAT(JawaTypeOpcode.FLOAT_ARRAY, JawaFuncOpcode.FALOAD, JawaFuncOpcode.FASTORE, JawaTypes.FLOAT_ARRAY, JawaTypes.FLOAT_MAPPING),
	DOUBLE(JawaTypeOpcode.DOUBLE_ARRAY, JawaFuncOpcode.DALOAD, JawaFuncOpcode.DASTORE, JawaTypes.DOUBLE_ARRAY, JawaTypes.DOUBLE_MAPPING)
}

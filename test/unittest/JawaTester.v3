// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class JawaTester(t: Tester) extends ModuleBuilder {
	def err = WasmErrorGen.new("<JawaTest>");
	def env = JawaEnvironment.new(null);
	private def asm = JawaAsm.new();

	new() {
		extensions |= (Extension.REPEAT_SECTIONS | Extension.TYPE_IMPORTS
				| Extension.REFERENCE_TYPES | Extension.BULK_MEMORY);
	}

	def addTypeImport(typename: string, sup: Array<ValueType>) -> AbsTypeDecl {
		var it = AbsTypeDecl.new(sup);
		module.addImport("jawa", typename, Modules.NO_IMPORT_ARGS, it);
		return it;
	}
	def addFuncImport(funcname: string, sig: FuncSig) -> FuncDecl {
		var sig_decl = SigDecl.new(sig);
		module.addDef(sig_decl);
		var func = FuncDecl.new(sig_decl);
		module.addImport("jawa", funcname, Modules.NO_IMPORT_ARGS, func);
		return func;
	}
	def addGlobalImport(name: string, vt: ValueType) -> int {
		var global = GlobalDecl.new(vt, false, InitExpr.I32(0));
		module.addImport("jawa", name, Modules.NO_IMPORT_ARGS, global);
		return global.imp.import_index;
	}
	def importClass(name: string) -> AbsTypeDecl {
		def str = asm.reset()
			.putc(JawaTypeOpcode.EXT_CLASS.code)
			.put_jname(JawaStrings.of(name))
			.extract();
		return addTypeImport(str, ValueTypes.NONE);
	}
	def importJawaLangObject() -> AbsTypeDecl {
		env.add(JawaLang.OBJECT);
		return importClass("jawa/lang/Object");
	}
	def importPrimArray(c: JawaPrimArrayOpcodes) -> AbsTypeDecl {
		return addTypeImport([c.type_code.code], ValueTypes.NONE);
	}
	def importInterface(name: string) -> AbsTypeDecl {
		def str = asm.reset()
			.putc(JawaTypeOpcode.EXT_INTERFACE.code)
			.put_jname(JawaStrings.of(name))
			.extract();
		return addTypeImport(str, ValueTypes.NONE);
	}
	def importArrayOf(it: AbsTypeDecl) -> AbsTypeDecl {
		def str = asm.reset()
			.putc(JawaTypeOpcode.REF_ARRAY.code)
			.put_ji4(it.abstype_index)
			.extract();
		return addTypeImport(str, ValueTypes.NONE);
	}
	def importMultiArrayOf(it: AbsTypeDecl, rank: int) -> AbsTypeDecl {
		var last = it;
		for (i < rank) last = importArrayOf(last);
		return last;
	}
	def declareClass(name: string, sup: AbsTypeDecl, intfs: Array<AbsTypeDecl>) -> AbsTypeDecl {
		if (sup == null) sup = importJawaLangObject();
		var jname = JawaStrings.of(name);
		var cmd = asm.reset()
			.putc(JawaTypeOpcode.DECL_CLASS.code)
			.put_jname(jname)
			.put_ji4(sup.abstype_index)
			.put_ji4(intfs.length);
		var its = Array<AbsTypeDecl>.new(intfs.length);
		var constraints = Array<ValueType>.new(intfs.length + 1);
		constraints[0] = ValueType.Abstract(sup);
		for (i < intfs.length) {
			var it = intfs[i];
			cmd.put_ji4(it.abstype_index);
			constraints[i + 1] = ValueType.Abstract(it);
		}
		return addTypeImport(cmd.extract(), constraints);
	}
	def declareInterface(name: string, intfs: Array<AbsTypeDecl>) -> AbsTypeDecl {
		var jname = JawaStrings.of(name);
		var cmd = asm.reset()
			.putc(JawaTypeOpcode.DECL_INTERFACE.code)
			.put_jname(jname)
			.put_ji4(intfs.length);
		var its = Array<AbsTypeDecl>.new(intfs.length);
		var constraints = Array<ValueType>.new(intfs.length);
		for (i < intfs.length) {
			var it = intfs[i];
			cmd.put_ji4(it.abstype_index);
			constraints[i] = ValueType.Abstract(it);
		}
		return addTypeImport(cmd.extract(), constraints);
	}
	def defineClass(it: AbsTypeDecl,
		instanceFields: Array<(JawaString, JawaTypeRef)>,
		instanceMethods: Array<(JawaString, JawaSigRef, FuncDecl)>,
		staticFields: Array<(JawaString, JawaTypeRef)>,
		staticMethods: Array<(JawaString, JawaSigRef, FuncDecl)>) {
		var cmd = asm.reset()
			.putc(JawaCommandOpcode.DEF_CLASS.code)
			.put_ji4(it.abstype_index);

		cmd.put_ji4(instanceFields.length);
		for (f in instanceFields) cmd.put_field_decl(f);

		cmd.put_ji4(instanceMethods.length);
		for (m in instanceMethods) cmd.put_method_def(m);

		cmd.put_ji4(staticFields.length);
		for (f in staticFields) cmd.put_field_decl(f);

		cmd.put_ji4(staticMethods.length);
		for (m in staticMethods) cmd.put_method_def(m);

		module.addImport("jawa", cmd.extract(), Modules.NO_IMPORT_ARGS, ImportCommandDecl.new());
	}
	def defineInterface(it: AbsTypeDecl,
		instanceMethods: Array<(JawaString, JawaSigRef)>) {
		var cmd = asm.reset()
			.putc(JawaCommandOpcode.DEF_INTERFACE.code)
			.put_ji4(it.abstype_index);

		cmd.put_ji4(instanceMethods.length);
		for (m in instanceMethods) cmd.put_method_decl(m);

		module.addImport("jawa", cmd.extract(), Modules.NO_IMPORT_ARGS, ImportCommandDecl.new());
	}

	// Runs the import processor and produces the imports.
	def process() -> Array<Exportable> {
		var bindings = Array<Exportable>.new(module.imports.length);
		var i = Instantiator.new(Extension.set.all, module, bindings, err);
		var jip = JawaImportProcessor.new(env, i);
		i.run();
		if (err.error()) {
			t.fail(Strings.format1("Jawa import processing failed: %s", err.error_msg));
		}
		return bindings;
	}
	// Runs the import processor and produces the imports.
	def instantiate() -> Instance {
		var bindings = Array<Exportable>.new(module.imports.length);
		var i = Instantiator.new(Extension.set.all, module, bindings, err);
		var jip = JawaImportProcessor.new(env, i);
		var instance = i.run();
		if (err.error()) {
			t.fail(Strings.format1("Jawa import processing failed: %s", err.error_msg));
		}
		return instance;
	}
	def assertProcessFails() {
		var bindings = Array<Exportable>.new(module.imports.length);
		var i = Instantiator.new(Extension.set.all, module, bindings, err);
		var jip = JawaImportProcessor.new(env, i);
		i.run();
		if (!err.error()) t.fail("expected jawa import processing to fail, but passed");
	}
	def buildIVT(ct: JawaClassType) -> bool {
		var err = ErrorGen.new();
		ct.buildTables(err);
		if (err.error()) t.fail1("got IVT building error: %s", err.error_msg);
		return err.ok();
	}
	def assertBuildIVTFails(ct: JawaClassType) {
		var err = ErrorGen.new();
		ct.buildTables(err);
		if (err.ok()) t.fail("expected IVT building error, but passed");
	}
	def assertVTable(expected: Array<JawaMethod>, ct: JawaClassType) {
		if (ct.vtable == null) buildIVT(ct);
		var got = ct.vtable;
		if (got == null) {
			return t.fail1("expected vtable of length %d, got null", expected.length);
		}
		if (got.length != expected.length) {
			return t.fail2("expected vtable of length %d, got %d", expected.length, got.length);
		}
		for (i < expected.length) {
			var em = expected[i];
			if (em != got[i]) {
				return t.fail3("expected vtable[%d] == \"%q\", got \"%q\"", i, em.name.render, got[i].name.render);
			}
			if (em.vtable_index != i) {
				return t.fail3("expected \"%q\".vtable_index == %d, got %d", em.name.render, i, em.vtable_index);
			}
		}
	}
	def assertITable(expected: (JawaInterfaceType, Array<int>), ct: JawaClassType) {
		if (ct.itable == null) buildIVT(ct);
		var im = expected.0.instanceMethods;
		for (i < im.length) {
			var j = im[i].itable_index;
			if (j != i) return t.fail2("expected itable index == %d, got %d", i, j);
		}
		var got: (JawaInterfaceType, Array<int>);
		for (l = ct.itable; l != null; l = l.tail) {
			got = ct.itable.head;
			if (got.0 == expected.0) break;
		}
		if (got.0 == null) {
			return t.fail1("could not find itable for %q", expected.0.render);
		}
		var e = expected.1, g = got.1;
		if (g.length != e.length) {
			return t.fail2("expected itable of length %d, got %d", e.length, g.length);
		}
		for (i < e.length) {
			if (e[i] != g[i]) {
				return t.fail3("expected itable[%d] == %d, got %d", i, e[i], g[i]);
			}
		}
	}
	def assertOverride(expected: JawaOverride, m: JawaMethod, pm: JawaMethod) {
		var got = m.override(pm);
		if (expected != got) t.fail2("expected override = %s, got %s", expected.name, got.name);
	}

	// Assertion helpers
	def assertIsJawaClassType(exp: JawaClassType, e: Exportable) -> JawaClassType {
		if (exp == null && JawaClassType.?(e)) return JawaClassType.!(e);
		if (exp == e) return exp;
		t.fail(Strings.format2("expected jawa class %q, got %q", safeRender(exp), safeRender(e)));
		return null;
	}
	def assertIsJawaClassTypeWithName(name: JawaString, e: Exportable) -> JawaClassType {
		if (JawaClassType.?(e)) {
			var ct = JawaClassType.!(e);
			if (!name.equals(ct.name)) {
				t.fail(Strings.format2("expected jawa class with name %q, got %q", name.render, ct.name.render));
				return null;
			}
			return ct;
		}
		t.fail(Strings.format2("expected jawa class %q, got %q", name.render, safeRender(e)));
		return null;
	}
	def assertIsJawaInterfaceType(exp: JawaInterfaceType, e: Exportable) -> JawaInterfaceType {
		if (exp == null && JawaInterfaceType.?(e)) return JawaInterfaceType.!(e);
		if (exp == e) return exp;
		t.fail(Strings.format2("expected jawa interface %q, got %q", safeRender(exp), safeRender(e)));
		return null;
	}
	def assertIsJawaInterfaceTypeWithName(name: JawaString, e: Exportable) -> JawaInterfaceType {
		if (JawaInterfaceType.?(e)) {
			var ct = JawaInterfaceType.!(e);
			if (!name.equals(ct.name)) {
				t.fail(Strings.format2("expected jawa interface with name %q, got %q", name.render, ct.name.render));
				return null;
			}
			return ct;
		}
		t.fail(Strings.format2("expected jawa interface %q, got %q", name.render, safeRender(e)));
		return null;
	}
	def assertIsJawaArrayType(elem: JawaType, e: Exportable) -> JawaArrayType {
		if (elem == null && JawaArrayType.?(e)) return JawaArrayType.!(e);
		match (e) {
			r: JawaArrayType => if (r.elem == elem) return r;
			_ => ;
		}
		t.fail(Strings.format2("expected jawa array of %q, got %q", safeRender(elem), safeRender(e)));
		return null;
	}
	def assertIsJawaObject(r: Result) -> JawaObject {
		if (!Result.Value.?(r)) {
			t.fail(Strings.format1("expected array return, got %q", r.render));
			return null;
		}
		var vr = Result.Value.!(r);
		if (vr.vals.length != 1) {
			t.fail(Strings.format1("expected 1 result value, got %q", r.render));
			return null;
		}
		var val = vr.vals[0];
		if (!Value.ExternRef.?(val)) {
			t.fail(Strings.format1("expected jawa object, got %q", Values.render(_, val)));
			return null;
		}
		var ext = Value.ExternRef.!(val);
		if (!JawaObject.?(ext.val)) {
			t.fail(Strings.format1("expected jawa object, got %q", safeRender(ext.val)));
			return null;
		}
		return JawaObject.!(ext.val);
	}
	def assertIsJawaInstanceObject(ct: JawaClassType, r: Result) -> JawaInstanceObject {
		var obj = assertIsJawaObject(r);
		if (obj == null) return null;
		if (!JawaInstanceObject.?(obj)) {
			t.fail(Strings.format2("expected jawa instance object of type %q, got %q", safeRender(ct), safeRender(obj)));
			return null;
		}
		var iobj = JawaInstanceObject.!(obj);
		if (iobj.clazz != ct) {
			t.fail(Strings.format2("expected jawa instance object of type %q, got %q", safeRender(ct), safeRender(obj)));
			return null;
		}
		return iobj;
	}
	def assertIsJawaArrayObjectOf<T>(obj: JawaObject) -> JawaArrayObjectOf<T> {
		if (!JawaArrayObjectOf<T>.?(obj)) {
			t.fail(Strings.format1("expected jawa array, got %q", safeRender(obj)));
			return null;
		}
		return JawaArrayObjectOf<T>.!(obj);
	}
	def assertIsJawaArrayObject(obj: JawaObject) -> JawaArrayObject {
		if (!JawaArrayObject.?(obj)) {
			t.fail(Strings.format1("expected jawa array, got %q", safeRender(obj)));
			return null;
		}
		return JawaArrayObject.!(obj);
	}
	def assertIsJawaRefArrayObject(obj: JawaObject) -> JawaRefArrayObject {
		if (!JawaRefArrayObject.?(obj)) {
			t.fail(Strings.format1("expected jawa ref array, got %q", safeRender(obj)));
			return null;
		}
		return JawaRefArrayObject.!(obj);
	}
	def assertIsFunction(expected_sig: FuncSig, e: Exportable) -> Function {
		if (!Function.?(e)) {
			t.fail(Strings.format1("expected Function, got %q", safeRender(e)));
			return null;
		}
		var f = Function.!(e);
		if (!f.sig.isAssignableSig(expected_sig)) {
			t.fail(Strings.format2("expected Function of type %q, got %q", expected_sig.render, safeRender(f.sig)));
			return null;
		}
		return f;
	}
	def assertIsJawaField(fields: Array<JawaField>, index: int, name: JawaString, typ: JawaType) -> JawaField {
		if (fields == null) {
			t.fail("expected non-null fields");
			return null;
		}
		if (index >= fields.length) {
			t.fail2("expected at least %d fields, got %d", index+1, fields.length);
			return null;
		}
		var f = fields[index];
		if (!name.equals(f.name)) {
			t.fail2("expected field name \"%q\", got \"%q\"", name.render, f.name.render);
			return null;
		}
		if (typ != f.typ) {
			t.fail2("expected field type \"%q\", got \"%q\"", typ.render, f.typ.render);
			return null;
		}
		return f;
	}
	def assertIsJawaMethod(methods: Array<JawaMethod>, index: int, name: JawaString, params: Array<JawaType>, ret: JawaType) -> JawaMethod {
		if (methods == null) {
			t.fail("expected non-null methods");
			return null;
		}
		if (index >= methods.length) {
			t.fail2("expected at least %d methods, got %d", index+1, methods.length);
			return null;
		}
		var m = methods[index];
		if (!name.equals(m.name)) {
			t.fail2("expected field name \"%q\", got \"%q\"", name.render, m.name.render);
			return null;
		}
		if (ret != m.ret) {
			t.fail2("expected field rete \"%q\", got \"%q\"", ret.render, m.ret.render);
			return null;
		}
		return m;
	}
	def assert_r(expected: Result, got: Result) {
		if (expected.equals(got)) return;
		t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_v(expected: Value, got: Result) {
		assert_r(Result.Value([expected]), got);
	}
	def assert_a<T>(expected: Array<T>, got: Array<T>) {
		if (!assert_length(expected, got)) return;
		for (i < expected.length) {
			if (expected[i] != got[i]) return t.fail(Strings.format1("mismatch at array[%d]", i));
		}
	}
	def assert_da(expected: Array<double>, got: Array<double>) {
		if (!assert_length(expected, got)) return;
		for (i < expected.length) {
			if (u64.view(expected[i]) != u64.view(got[i])) return t.fail(Strings.format1("mismatch at array[%d]", i));
		}
	}
	def assert_fa(expected: Array<float>, got: Array<float>) {
		if (!assert_length(expected, got)) return;
		for (i < expected.length) {
			if (u32.view(expected[i]) != u32.view(got[i])) return t.fail(Strings.format1("mismatch at array[%d]", i));
		}
	}
	def assert_length<T>(expected: Array<T>, got: Array<T>) -> bool {
		if (expected.length != got.length) {
			t.fail(Strings.format2("expected array of %d length, got %d", expected.length, got.length));
			return false;
		}
		return true;
	}
	def safeRender<T>(t: T) -> StringBuilder -> StringBuilder {
		var d: T;
		if (t == d) return Strings.puts("<null>");
		if (Exportable.?(t)) return Exportable.!(t).render;
		if (FuncSig.?(t)) return FuncSig.!(t).render;
		if (HostObject.?(t)) return HostObject.!(t).render;
		return Strings.puts("<?>");
	}
	def strCodeType(code: byte, it: AbsTypeDecl) -> string {
		return asm.reset()
			.putc(code)
			.put_ji4(it.abstype_index)
			.extract();
	}
	def strCodeTypeName(code: byte, it: AbsTypeDecl, name: string) -> string {
		return asm.reset()
			.putc(code)
			.put_ji4(it.abstype_index)
			.put_jname(JawaStrings.of(name))
			.extract();
	}
	def strCodeTypeJawaName(code: byte, it: AbsTypeDecl, jname: JawaString) -> string {
		return asm.reset()
			.putc(code)
			.put_ji4(it.abstype_index)
			.put_jname(jname)
			.extract();
	}


	// Helpers for specific, complex bytecodes.
	def make_xaload(c: JawaPrimArrayOpcodes) -> Function {
		var n = JawaTester.new(t);
		var bt = n.importPrimArray(c);
		var expected_sig = FuncSig.new([ValueType.Host(c.arrayType), ValueType.I32], [c.map.valueType]);
		n.addFuncImport([c.xaload.code], expected_sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		return assertIsFunction(expected_sig, r[1]);
	}
	def make_xastore(c: JawaPrimArrayOpcodes) -> Function {
		var n = JawaTester.new(t);
		var bt = n.importPrimArray(c);
		var expected_sig = FuncSig.new([ValueType.Host(c.arrayType), ValueType.I32, c.map.valueType], SigCache.arr_v);
		n.addFuncImport([c.xastore.code], expected_sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		return assertIsFunction(expected_sig, r[1]);
	}
	def make_xnewarray(c: JawaPrimArrayOpcodes) -> Function {
		var n = JawaTester.new(t);
		var bt = n.importPrimArray(c);
		var sig = FuncSig.new(SigCache.arr_i, [ValueType.Host(c.arrayType)]);
		def str = n.asm.reset()
			.putc(JawaFuncOpcode.NEWARRAY.code)
			.put_ji4(bt.abstype_index)
			.extract();
		n.addFuncImport(str, sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		return assertIsFunction(sig, r[1]);
	}
	def make_xarraylength(c: JawaPrimArrayOpcodes) -> Function {
		var n = JawaTester.new(t);
		var bt = n.importPrimArray(c);
		var sig = FuncSig.new([ValueType.Host(c.arrayType)], SigCache.arr_i);
		def str = n.asm.reset()
			.putc(JawaFuncOpcode.ARRAYLENGTH.code)
			.put_ji4(bt.abstype_index)
			.extract();
		n.addFuncImport(str, sig);
		var r = n.process();
		n.assertIsJawaArrayType(c.arrayType.elem, r[0]);
		return assertIsFunction(sig, r[1]);
	}
	def make_multianewarray(it: AbsTypeDecl, dims: int) -> (JawaArrayType, Function) {
		var param_types = Array<ValueType>.new(dims);
		for (i < dims) param_types[i] = ValueType.I32;

		var sig = FuncSig.new(param_types, [ValueType.Abstract(it)]);
		asm.reset()
			.putc(JawaFuncOpcode.MULTIANEWARRAY.code)
			.put_ji4(dims)
			.put_ji4(it.abstype_index);
		addFuncImport(asm.extract(), sig);
		var r = process();

		var xt = r[it.imp.import_index];
		if (!JawaArrayType.?(xt)) {
			t.fail(Strings.format1("expected array type, got %q", safeRender(xt)));
			return (null, null);
		}
		var at = JawaArrayType.!(xt);
		var expected_sig = FuncSig.new(param_types, [ValueType.Host(at)]);
		return (at, assertIsFunction(expected_sig, r[it.imp.import_index + 1]));
	}

}

// A helper to emit the import language.
class JawaAsm extends StringBuilder {
	def put_jname(j: JawaString) -> this {
		put_ji2(j.chars.length);
		for (c in j.chars) pututf8(c);
	}
	def put_jstr(j: JawaString) -> this {
		put_ji4(j.chars.length);
		for (c in j.chars) pututf8(c);
	}
	def put_ji2(v: int) -> this {
		for (j < 2) {
			putc(u7.view(v));
			v = v >> 7;
		}
	}
	def put_ji4(v: int) -> this {
		for (j < 4) {
			putc(u7.view(v));
			v = v >> 7;
		}
	}
	def put_field_decl(name: JawaString, t: JawaTypeRef) -> this {
		put_jname(name);
		put_jtref(t);
	}
	def put_method_decl(name: JawaString, sig: JawaSigRef) -> this {
		put_jname(name);
		put_jtsig(sig);
	}
	def put_method_def(name: JawaString, sig: JawaSigRef, func: FuncDecl) -> this {
		put_jname(name);
		put_jtsig(sig);
		put_ji4(func.func_index);
	}
	def put_jtref(t: JawaTypeRef) -> this {
		match (t) {
			Void => putc(Utf8.TWO_BYTE_MASK).putc('V');
			Prim(t) => putc(Utf8.TWO_BYTE_MASK).putc(t.char);
			Abstract(t) => put_ji4(t.abstype_index);
		}
	}
	def put_jtsig(sig: JawaSigRef) -> this {
		put_ji2(sig.params.length);
		for (p in sig.params) put_jtref(p);
		put_jtref(sig.result);
	}
}
type JawaTypeRef {
	case Void;
	case Prim(t: JawaPrimType);
	case Abstract(t: AbsTypeDecl);
	def putInto(v: Vector<ValueType>) -> Vector<ValueType> {
		match (this) {
			Void => ;
			Prim(t) => v.put(t.valueType());
			Abstract(it) => v.put(ValueType.Abstract(it));
		}
		return v;
	}
}
class JawaSigRef(params: Array<JawaTypeRef>, result: JawaTypeRef) {
}

enum JawaPrimArrayOpcodes(type_code: JawaTypeOpcode, xaload: JawaFuncOpcode, xastore: JawaFuncOpcode, arrayType: JawaArrayType, map: JawaPrimMapping) {
	BYTE(JawaTypeOpcode.BYTE_ARRAY, JawaFuncOpcode.BALOAD, JawaFuncOpcode.BASTORE, JawaTypes.BYTE_ARRAY, JawaTypes.BYTE_MAPPING),
	BOOL(JawaTypeOpcode.BOOL_ARRAY, JawaFuncOpcode.BALOAD, JawaFuncOpcode.BASTORE, JawaTypes.BOOL_ARRAY, JawaTypes.BOOL_MAPPING),
	CHAR(JawaTypeOpcode.CHAR_ARRAY, JawaFuncOpcode.CALOAD, JawaFuncOpcode.CASTORE, JawaTypes.CHAR_ARRAY, JawaTypes.CHAR_MAPPING),
	SHORT(JawaTypeOpcode.SHORT_ARRAY, JawaFuncOpcode.SALOAD, JawaFuncOpcode.SASTORE, JawaTypes.SHORT_ARRAY, JawaTypes.SHORT_MAPPING),
	INT(JawaTypeOpcode.INT_ARRAY, JawaFuncOpcode.IALOAD, JawaFuncOpcode.IASTORE, JawaTypes.INT_ARRAY, JawaTypes.INT_MAPPING),
	LONG(JawaTypeOpcode.LONG_ARRAY, JawaFuncOpcode.LALOAD, JawaFuncOpcode.LASTORE, JawaTypes.LONG_ARRAY, JawaTypes.LONG_MAPPING),
	FLOAT(JawaTypeOpcode.FLOAT_ARRAY, JawaFuncOpcode.FALOAD, JawaFuncOpcode.FASTORE, JawaTypes.FLOAT_ARRAY, JawaTypes.FLOAT_MAPPING),
	DOUBLE(JawaTypeOpcode.DOUBLE_ARRAY, JawaFuncOpcode.DALOAD, JawaFuncOpcode.DASTORE, JawaTypes.DOUBLE_ARRAY, JawaTypes.DOUBLE_MAPPING)
}

class JawaClassBuilder(t: JawaTester, name: string, parent: AbsTypeDecl, interfaces: Array<AbsTypeDecl>) {
	private def instanceFields = Vector<(JawaString, JawaTypeRef)>.new();
	private def instanceMethods = Vector<(JawaString, JawaSigRef, FuncDecl)>.new();
	private def staticFields = Vector<(JawaString, JawaTypeRef)>.new();
	private def staticMethods = Vector<(JawaString, JawaSigRef, FuncDecl)>.new();
	def var it: AbsTypeDecl;
	def var at: ValueType.Abstract;
	def var arr_at: Array<ValueType>;
	private var defined = false;

	new() {
		it = t.declareClass(name, parent, interfaces);
		at = ValueType.Abstract(it);
		arr_at = [at];
	}

	def addInstanceField(name: string, t: JawaTypeRef) -> this {
		checkNotDefined();
		instanceFields.put(JawaStrings.of(name), t);
		checkFieldType(t);
	}
	def addInstanceMethod(name: string, pt: Array<JawaTypeRef>, rt: JawaTypeRef, impl: FuncDecl) -> this {
		checkNotDefined();
		instanceMethods.put(JawaStrings.of(name), JawaSigRef.new(pt, rt), impl);
	}
	def addStaticField(name: string, t: JawaTypeRef) -> this {
		checkNotDefined();
		staticFields.put(JawaStrings.of(name), t);
		checkFieldType(t);
	}
	def addStaticMethod(name: string, pt: Array<JawaTypeRef>, rt: JawaTypeRef, impl: FuncDecl) -> this {
		checkNotDefined();
		staticMethods.put(JawaStrings.of(name), JawaSigRef.new(pt, rt), impl);
	}
	def define() {
		checkNotDefined();
		defined = true;
		t.defineClass(it,
			instanceFields.copy(),
			instanceMethods.copy(),
			staticFields.copy(),
			staticMethods.copy()
		);
	}

	def NEW() -> FuncDecl {
		checkDefined();
		var str = t.strCodeType(JawaFuncOpcode.NEW.code, it);
		return t.addFuncImport(str, FuncSig.new(SigCache.arr_v, arr_at));
	}
	def GETFIELD(name: string) -> FuncDecl {
		checkDefined();
		var str = t.strCodeTypeName(JawaFuncOpcode.GETFIELD.code, it, name);
		var vt = getFieldType(instanceFields, name);
		return t.addFuncImport(str, FuncSig.new(arr_at, [vt]));
	}
	def GETSTATIC(name: string) -> FuncDecl {
		checkDefined();
		var str = t.strCodeTypeName(JawaFuncOpcode.GETSTATIC.code, it, name);
		var vt = getFieldType(staticFields, name);
		return t.addFuncImport(str, FuncSig.new(SigCache.arr_v, [vt]));
	}
	def PUTFIELD(name: string) -> FuncDecl {
		checkDefined();
		var str = t.strCodeTypeName(JawaFuncOpcode.PUTFIELD.code, it, name);
		var vt = getFieldType(instanceFields, name);
		return t.addFuncImport(str, FuncSig.new([at, vt], SigCache.arr_v));
	}
	def PUTSTATIC(name: string) -> FuncDecl {
		checkDefined();
		var str = t.strCodeTypeName(JawaFuncOpcode.PUTSTATIC.code, it, name);
		var vt = getFieldType(staticFields, name);
		return t.addFuncImport(str, FuncSig.new([vt], SigCache.arr_v));
	}
	def INVOKESTATIC(name: string) -> FuncDecl {
		checkDefined();
		var str = t.strCodeTypeName(JawaFuncOpcode.INVOKESTATIC.code, it, name);
		var sig = getMethodSig(false, name);
		return t.addFuncImport(str, sig);
	}
	def INVOKESPECIAL(name: string) -> FuncDecl {
		checkDefined();
		var str = t.strCodeTypeName(JawaFuncOpcode.INVOKESPECIAL.code, it, name);
		var sig = getMethodSig(true, name);
		return t.addFuncImport(str, sig);
	}
	def INVOKEVIRTUAL(name: string) -> FuncDecl {
		checkDefined();
		var str = t.strCodeTypeName(JawaFuncOpcode.INVOKEVIRTUAL.code, it, name);
		var sig = getMethodSig(true, name);
		return t.addFuncImport(str, sig);
	}

	def getFieldType(v: Vector<(JawaString, JawaTypeRef)>, name: string) -> ValueType {
		var jname = JawaStrings.of(name);
		for (i < v.length) {
			var t = v[i];
			if (jname.equals(t.0)) return t.1.putInto(Vector.new())[0];
		}
		System.error("InternalTestError", Strings.format1("field %s not found", name));
		return ValueType.I32;
	}

	def getMethodSig(instance: bool, name: string) -> FuncSig {
		var v = if(instance, instanceMethods, staticMethods);
		var jname = JawaStrings.of(name);
		for (i < v.length) {
			var t = v[i];
			if (jname.equals(t.0)) {
				var params = Vector<ValueType>.new();
				var results = Vector<ValueType>.new();
				if (instance) params.put(at);
				for (p in t.1.params) p.putInto(params);
				t.1.result.putInto(results);
				return FuncSig.new(params.extract(), results.extract());
			}
		}
		System.error("InternalTestError", Strings.format1("method %s not found", name));
		return SigCache.v_v;
	}

	def checkNotDefined() {
		if (defined) System.error("InternalTestError", "class is already defined");
	}
	def checkDefined() {
		if (!defined) System.error("InternalTestError", "class is not yet defined");
	}
	def checkFieldType(t: JawaTypeRef) {
		if (t == JawaTypeRef.Void) System.error("InternalTestError", "jawa field cannot be void type");
	}
}

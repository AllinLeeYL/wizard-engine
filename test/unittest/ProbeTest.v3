// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("probe:", _, ProbeTester.new, _);
def X = [
	T("count0g", test_count_0g),
	T("count_loop", test_count_loop),
	T("loop_rm", test_loop_rm),
	T("enable0i", test_enable_0i),
	T("enable1g", test_enable_1g),
	T("remove0i", test_remove_0i),
	T("remove1i", test_remove_1i),
	T("remove2i", test_remove_2i),
	()
];

class ProbeTester extends DebugTester {
	new(t: Tester) super(t) { }

	def codev(raw: Array<byte>) -> this {
		code(raw);
		var v = CodeValidator.new(extensions, Limits.new().set(extensions), module, ErrorGen.new(module.filename));
		var r = v.validateFunc(func);
		match (r) {
			Ok => ;
			Error(error, pc, msg) => t.fail2("invalid code @+%d: %s", pc, msg);
		}
	}
	def stdCode() {
		sig(SigCache.v_i);
		code([
			Opcode.I32_CONST.code, 22,
			Opcode.I32_CONST.code, 33,
			Opcode.I32_SUB.code
		]);
	}
	def loopCode() {
		sig(SigCache.i_i);
		codev([Opcode.LOOP.code, BpTypeCode.EmptyBlock.code,
			Opcode.LOCAL_GET.code, 0,
			Opcode.I32_CONST.code, 1,
			Opcode.I32_SUB.code,
			Opcode.LOCAL_TEE.code, 0,
			Opcode.BR_IF.code, 0,
			Opcode.END.code,
			Opcode.LOCAL_GET.code, 0]);
	}
	def assert_count(expected: int, p: CountProbe) {
		if (p.count != expected) return t.fail2("expected count = %d, got %d", expected, p.count);
	}
	def assert_countr(min: int, max: int, p: CountProbe) {
		if (p.count < min || p.count > max) return t.fail3("expected count in [%d, %d], got %d", min, max, p.count);
	}
}

def test_count_0g(t: ProbeTester) {
	t.stdCode();
	var p = CountProbe.new();
	var i = t.interp();
	i.probes.add(p);
	var got = i.run(t.f, []);
	var expected = Result.Value([Values.i_v(-11)]);
	if (!expected.equals(got)) return t.t.fail2("expected result = %q, got %q", expected.render, got.render);
	t.assert_countr(4, 6, p);
}

def test_count_loop(t: ProbeTester) {
	t.loopCode();
	var p = CountProbe.new();
	var i = t.interp();
	t.module.insertProbeAt(t.func.func_index, 3, p);
	i.run(t.f, [Values.i_v(4)]);
	t.assert_count(4, p);
}

def test_loop_rm(t: ProbeTester) {
	t.loopCode();
	var p1 = CountProbe.new(), p2 = CountProbe.new();
	var i = t.interp();
	t.module.insertProbeAt(t.func.func_index, 3, p1);
	t.module.insertProbeAt(t.func.func_index, 3, ClosureProbe.new(t.module.removeProbeAt, (t.func.func_index, 3, p1)));
	t.module.insertProbeAt(t.func.func_index, 5, p2);
	i.run(t.f, [Values.i_v(4)]);
	t.assert_count(1, p1);
	t.assert_count(4, p2);
}

class CountProbe extends Probe {
	var count = 0;
	def fire(func: WasmFunction, offset: int) -> Resumption {
		count++;
		return Resumption.Continue;
	}
}

class ClosureProbe<P, R>(f: P -> R, param: P) extends Probe {
	def fire(func: WasmFunction, offset: int) -> Resumption {
		f(param);
		return Resumption.Continue;
	}
}

def test_enable_0i(t: ProbeTester) {
	t.stdCode();
	var p = CountProbe.new();
	t.module.insertProbeAt(t.func.func_index, 1, ClosureProbe.new(t.module.insertProbeAt, (t.func.func_index, 3, p)));
	var i = t.interp();
	i.run(t.f, []);
	t.assert_count(1, p);
}

def test_enable_1g(t: ProbeTester) {
	t.stdCode();
	var p = CountProbe.new();
	var i = t.interp();
	i.probes.add(ClosureProbe.new(t.module.insertProbeAt, (t.func.func_index, 3, p)));
	i.run(t.f, []);
	if (p.count < 1) t.t.fail("expected probe to fire");
}

def test_remove_0i(t: ProbeTester) {
	t.stdCode();
	var p = CountProbe.new();
	t.module.insertProbeAt(t.func.func_index, 1, p);
	var i = t.interp();

	i.run(t.f, []);
	t.assert_count(1, p);

	t.module.removeProbeAt(t.func.func_index, 1, p);
	i.run(t.f, []);
	t.assert_count(1, p);
}

def test_remove_1i(t: ProbeTester) {
	t.stdCode();
	var p = CountProbe.new();
	t.module.insertProbeAt(t.func.func_index, 1, ClosureProbe.new(t.module.removeProbeAt, (t.func.func_index, 1, p)));
	t.module.insertProbeAt(t.func.func_index, 1, p);
	var i = t.interp();

	i.run(t.f, []);
	t.assert_count(1, p);

	i.run(t.f, []);
	t.assert_count(1, p);
}

def test_remove_2i(t: ProbeTester) {
	t.stdCode();
	var p = CountProbe.new();
	t.module.insertProbeAt(t.func.func_index, 1, p);
	t.module.insertProbeAt(t.func.func_index, 1, ClosureProbe.new(t.module.removeProbeAt, (t.func.func_index, 1, p)));
	var i = t.interp();

	i.run(t.f, []);
	t.assert_count(1, p);

	i.run(t.f, []);
	t.assert_count(1, p);
}
// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("jawa:err:", _, JawaTester.new, _);
def X = [
	T("reftype", test_err_reftype),
	T("noimm", test_err_noimm),
	T("class1", test_err_class1),
	T("class2", test_err_class2),
	T("intf1", test_err_intf1),
	T("sigR", test_err_sigR),
	T("sigP", test_err_sigP),
	()
];

def RETURN_TYPES = Arrays.prepend(JawaTypeRef.Void,
	Arrays.map<JawaPrimType, JawaTypeRef>(JawaTypes.PRIMITIVES, JawaTypeRef.Prim));

def test_err_reftype(t: JawaTester) {
	for (op in JawaFuncOpcode) {
		// TODO
		for (jt in RETURN_TYPES) {
			var n = JawaTester.new(t.t);
			var asm = JawaAsm.new()
				.putc(op.code)
				.put_type_ref(jt);
			var it = n.addFuncImport(asm, SigCache.i_i); // sig doesn't matter
			n.assertProcessFails();
		}
	}
}

def test_err_noimm(t: JawaTester) {
	for (op in JawaFuncOpcode) {
		if (op.imm == JawaImmKind.NONE) continue;
		var n = JawaTester.new(t.t);
		var it = n.addFuncImport(t.strCode(op.code), SigCache.i_i); // sig doesn't matter
		n.assertProcessFails();
	}
	for (op in JawaTypeOpcode) {
		if (op.imm == JawaImmKind.NONE) continue;
		var n = JawaTester.new(t.t);
		var it = n.addTypeImport(t.strCode(op.code), []); // constraints don't matter
		n.assertProcessFails();
	}
	for (op in JawaGlobalOpcode) {
		if (op.imm == JawaImmKind.NONE) continue;
		var n = JawaTester.new(t.t);
		var it = n.addGlobalImport(t.strCode(op.code), ValueType.I32); // type doesn't matter
		n.assertProcessFails();
	}

}

def test_err_class1(t: JawaTester) {
	var name = "Zonk", jname = JawaStrings.of(name);
	var it1 = t.declareClass(name, t.NO_CLASS_ATTRS, null, []);
	var it2 = t.defineClass(it1,
		[], // instance fields
		[], // instance methods
		[], // static fields
		[]  // static methods
	);
	var it3 = t.defineClass(it1,
		[], // instance fields
		[], // instance methods
		[], // static fields
		[]  // static methods
	);

	t.assertProcessFails(); // error: redefinition

}

def test_err_class2(t: JawaTester) {
	var name = "Nek", jname = JawaStrings.of(name);
	var fieldName = "F", jfieldName = JawaStrings.of(fieldName);
	for (order in [[0, 1], [1, 0]]) {
		var n = JawaTester.new(t.t);
		var it1 = n.declareClass(name, n.NO_CLASS_ATTRS, null, []);

		for (o in order) {
			if (o == 0) {
				var str1 = n.strCodeTypeJawaName(JawaFuncOpcode.GETSTATIC.code, it1, jfieldName);
				var fi = n.addFuncImport(str1, SigDecl.new(SigCache.arr_v, [ValueType.I32]));
			} else {
				var it2 = n.defineClass(it1,
					[], // instance fields
					[], // instance methods
					[(jfieldName, n.NO_FIELD_ATTRS, JawaTypeRef.Prim(JawaTypes.INT))], // static fields
					[]  // static methods
				);
			}
		}
		if (order[0] == 0) n.assertProcessFails();  // getstatic before class is defined
		else n.process();
	}
}

def test_err_intf1(t: JawaTester) {
	var name = "iKol", jname = JawaStrings.of(name);
	var it1 = t.declareInterface(name, []);
	var it2 = t.defineInterface(it1,
		[] // instance methods
	);
	var it3 = t.defineInterface(it1,
		[] // instance methods
	);

	t.assertProcessFails();
}

def test_err_sigR(t: JawaTester) {
	var ts = t.t;
	for (x in RETURN_TYPES) {
		for (y in RETURN_TYPES) {
			var n = JawaTester.new(ts);
			var name = "iYut", jname = JawaStrings.of(name);
			var m1 = "m1", jm1 = JawaStrings.of(m1);
			var it1 = n.declareClass(name, t.NO_CLASS_ATTRS, null, []);

			var rt = if(y != JawaTypeRef.Void, [JawaTypeRef.Prim.!(y).t.valueType()], SigCache.arr_v);
			var m1d = n.addFunction(SigDecl.new(SigCache.arr_v, rt), []);

			var it2 = n.defineClass(it1,
				[], // instance fields
				[], // instance methods
				[], // static fields
				[(jm1, n.NO_METHOD_ATTRS, JawaSigRef.new([], x), m1d)]  // static methods
			);

			var ok = x == y;
			match (x) {
				Prim(xt) => match (y) {
					Prim(yt) => ok = xt.valueType() == yt.valueType();
					_ => ;
				}
				_ => ;
			}
			if (ok) n.process();
			else n.assertProcessFails();
		}
	}
}

def test_err_sigP(t: JawaTester) {
	var ts = t.t;
	for (x in JawaTypes.PRIMITIVES) {
		for (y in JawaTypes.PRIMITIVES) {
			var n = JawaTester.new(ts);
			var name = "eWut", jname = JawaStrings.of(name);
			var m1 = "m1", jm1 = JawaStrings.of(m1);
			var it1 = n.declareClass(name, t.NO_CLASS_ATTRS, null, []);

			var m1d = n.addFunction(SigDecl.new([y.valueType()], SigCache.arr_v), []);

			var it2 = n.defineClass(it1,
				[], // instance fields
				[], // instance methods
				[], // static fields
				[(jm1, n.NO_METHOD_ATTRS, JawaSigRef.new([JawaTypeRef.Prim(x)], JawaTypeRef.Void), m1d)]  // static methods
			);

			var ok = x.valueType() == y.valueType();
			if (ok) n.process();
			else n.assertProcessFails();
		}
	}
}

/*
TODO AALOAD
  - not a ref array
  - improper sig
TODO AASTORE
TODO ACMPEQ
TODO ANEWARRAY
TODO ARRAYLENGTH
TODO ATHROW
TODO BALOAD
TODO BASTORE
TODO CALOAD
TODO CASTORE
TODO CHECKCAST
TODO DALOAD
TODO DASTORE
TODO DCMPG
TODO DCMPL
TODO DREM
TODO FALOAD
TODO FASTORE
TODO FCMPG
TODO FCMPL
TODO FREM
TODO GETFIELD
TODO GETSTATIC
TODO IALOAD
TODO IASTORE
TODO INSTANCEOF
TODO INVOKEDYNAMIC
TODO INVOKEINTERFACE
TODO INVOKESPECIAL
TODO INVOKESTATIC
TODO INVOKEVIRTUAL
TODO LALOAD
TODO LASTORE
TODO MONITORENTER
TODO MONITOREXIT
TODO MULTIANEWARRAY
TODO NEW
TODO NEWARRAY
TODO ISNULL
TODO PUTFIELD
TODO PUTSTATIC
TODO SALOAD
TODO SASTORE

*/

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("jawa:err:", _, JawaTester.new, _);
def X = [
	T("simple", test_err_simple),
	T("noimm", test_err_noimm),
	T("class1", test_err_class1),
	T("class2", test_err_class2),
	T("intf1", test_err_intf1),
	T("sigR", test_err_sigR),
	T("sigP", test_err_sigP),
	()
];

def RETURN_TYPES = Arrays.prepend(JawaTypeRef.Void,
	Arrays.map<JawaPrimType, JawaTypeRef>(JawaTypes.PRIMITIVES, JawaTypeRef.Prim));

def test_simple_func(u: Tester, op: JawaFuncOpcode, sig: SigDecl) {
	{
		var t = JawaTester.new(u);
		var f = t.addFuncImport(t.strCode(op.code), sig);
		var r = t.process();
		t.assertIsFunction(sig, r[f.imp.import_index]);
	}
	{
		var other = if(sig.results.length > 0, SigDecl.new(sig.params, SigCache.arr_v), SigDecl.new(sig.params, SigCache.arr_i));
		var t = JawaTester.new(u);
		var f = t.addFuncImport(t.strCode(op.code), other); // wrong signature
		t.assertProcessFails();
	}
	if (false) { // TODO: fail on extraneous bytes
		var t = JawaTester.new(u);
		var f = t.addFuncImport(JawaAsm.new().putc(op.code).putc(0xFF), sig); // extraneous bytes
		t.assertProcessFails();
	}
	if (false) { // TODO: fail on extraneous import args
		var t = JawaTester.new(u);
		var asm = t.strCode(op.code);
		var jlo = t.importJawaLangObject();
		asm.args.put(jlo);
		var f = t.addFuncImport(asm, sig); // extraneous import arg
		t.assertProcessFails();
	}
}

def sig_ji_i(t: JawaType) -> SigDecl {
	return SigDecl.new([ValueType.Host(t), ValueType.I32], SigCache.arr_i);
}

def sig_jii_v(t: JawaType) -> SigDecl {
	return SigDecl.new([ValueType.Host(t), ValueType.I32, ValueType.I32], SigCache.arr_v);
}

def test_err_simple(t: JawaTester) {
	def T = test_simple_func(t.t, _, _);
	T(JawaFuncOpcode.ACMPEQ, JawaSigCache.oo_i);
// TODO	T(JawaFuncOpcode.ATHROW, JawaSigCache.o_v);
	T(JawaFuncOpcode.BALOAD, sig_ji_i(JawaTypes.BYTE_ARRAY));
	T(JawaFuncOpcode.BASTORE, sig_jii_v(JawaTypes.BYTE_ARRAY));
	T(JawaFuncOpcode.CALOAD, sig_ji_i(JawaTypes.CHAR_ARRAY));
	T(JawaFuncOpcode.CASTORE, sig_jii_v(JawaTypes.CHAR_ARRAY));
	T(JawaFuncOpcode.DALOAD, SigDecl.new([ValueType.Host(JawaTypes.DOUBLE_ARRAY), ValueType.I32], SigCache.arr_d));
	T(JawaFuncOpcode.DASTORE, SigDecl.new([ValueType.Host(JawaTypes.DOUBLE_ARRAY), ValueType.I32, ValueType.F64], SigCache.arr_v));
	T(JawaFuncOpcode.DCMPG, SigCache.dd_i);
	T(JawaFuncOpcode.DCMPL, SigCache.dd_i);
	T(JawaFuncOpcode.DREM, SigCache.dd_d);
	T(JawaFuncOpcode.FALOAD, SigDecl.new([ValueType.Host(JawaTypes.FLOAT_ARRAY), ValueType.I32], SigCache.arr_f));
	T(JawaFuncOpcode.FASTORE, SigDecl.new([ValueType.Host(JawaTypes.FLOAT_ARRAY), ValueType.I32, ValueType.F32], SigCache.arr_v));
	T(JawaFuncOpcode.FCMPG, SigCache.ff_i);
	T(JawaFuncOpcode.FCMPL, SigCache.ff_i);
	T(JawaFuncOpcode.FREM, SigCache.ff_f);
	T(JawaFuncOpcode.IALOAD, sig_ji_i(JawaTypes.INT_ARRAY));
	T(JawaFuncOpcode.IASTORE, sig_jii_v(JawaTypes.INT_ARRAY));
	T(JawaFuncOpcode.LALOAD, SigDecl.new([ValueType.Host(JawaTypes.LONG_ARRAY), ValueType.I32], SigCache.arr_l));
	T(JawaFuncOpcode.LASTORE, SigDecl.new([ValueType.Host(JawaTypes.LONG_ARRAY), ValueType.I32, ValueType.I64], SigCache.arr_v));
	T(JawaFuncOpcode.MONITORENTER, JawaSigCache.o_v);
	T(JawaFuncOpcode.MONITOREXIT, JawaSigCache.o_v);
	T(JawaFuncOpcode.ISNULL, JawaSigCache.o_i);
	T(JawaFuncOpcode.SALOAD, sig_ji_i(JawaTypes.SHORT_ARRAY));
	T(JawaFuncOpcode.SASTORE, sig_jii_v(JawaTypes.SHORT_ARRAY));
}

def test_err_noimm(t: JawaTester) {
	for (op in JawaFuncOpcode) {
		if (op.imm == JawaImmKind.NONE) continue;
		var n = JawaTester.new(t.t);
		var it = n.addFuncImport(t.strCode(op.code), SigCache.i_i); // sig doesn't matter
		n.assertProcessFails();
	}
	for (op in JawaTypeOpcode) {
		if (op.imm == JawaImmKind.NONE) continue;
		var n = JawaTester.new(t.t);
		var it = n.addTypeImport(t.strCode(op.code), []); // constraints don't matter
		n.assertProcessFails();
	}
	for (op in JawaGlobalOpcode) {
		if (op.imm == JawaImmKind.NONE) continue;
		var n = JawaTester.new(t.t);
		var it = n.addGlobalImport(t.strCode(op.code), ValueType.I32); // type doesn't matter
		n.assertProcessFails();
	}

}

def test_err_class1(t: JawaTester) {
	var name = "Zonk", jname = JawaStrings.of(name);
	var it1 = t.declareClass(name, t.NO_CLASS_ATTRS, null, []);
	var it2 = t.defineClass(it1,
		[], // instance fields
		[], // instance methods
		[], // static fields
		[]  // static methods
	);
	var it3 = t.defineClass(it1,
		[], // instance fields
		[], // instance methods
		[], // static fields
		[]  // static methods
	);

	t.assertProcessFails(); // error: redefinition

}

def test_err_class2(t: JawaTester) {
	var name = "Nek", jname = JawaStrings.of(name);
	var fieldName = "F", jfieldName = JawaStrings.of(fieldName);
	for (order in [[0, 1], [1, 0]]) {
		var n = JawaTester.new(t.t);
		var it1 = n.declareClass(name, n.NO_CLASS_ATTRS, null, []);

		for (o in order) {
			if (o == 0) {
				var str1 = n.strCodeTypeJawaName(JawaFuncOpcode.GETSTATIC.code, it1, jfieldName);
				var fi = n.addFuncImport(str1, SigDecl.new(SigCache.arr_v, [ValueType.I32]));
			} else {
				var it2 = n.defineClass(it1,
					[], // instance fields
					[], // instance methods
					[(jfieldName, n.NO_FIELD_ATTRS, JawaTypeRef.Prim(JawaTypes.INT))], // static fields
					[]  // static methods
				);
			}
		}
		if (order[0] == 0) n.assertProcessFails();  // getstatic before class is defined
		else n.process();
	}
}

def test_err_intf1(t: JawaTester) {
	var name = "iKol", jname = JawaStrings.of(name);
	var it1 = t.declareInterface(name, []);
	var it2 = t.defineInterface(it1,
		[] // instance methods
	);
	var it3 = t.defineInterface(it1,
		[] // instance methods
	);

	t.assertProcessFails();
}

def test_err_sigR(t: JawaTester) {
	var ts = t.t;
	for (x in RETURN_TYPES) {
		for (y in RETURN_TYPES) {
			var n = JawaTester.new(ts);
			var name = "iYut", jname = JawaStrings.of(name);
			var m1 = "m1", jm1 = JawaStrings.of(m1);
			var it1 = n.declareClass(name, t.NO_CLASS_ATTRS, null, []);

			var rt = if(y != JawaTypeRef.Void, [JawaTypeRef.Prim.!(y).t.valueType()], SigCache.arr_v);
			var m1d = n.newFunction(SigDecl.new(SigCache.arr_v, rt), []);

			var it2 = n.defineClass(it1,
				[], // instance fields
				[], // instance methods
				[], // static fields
				[(jm1, n.NO_METHOD_ATTRS, JawaSigRef.new([], x), m1d)]  // static methods
			);

			var ok = x == y;
			match (x) {
				Prim(xt) => match (y) {
					Prim(yt) => ok = xt.valueType() == yt.valueType();
					_ => ;
				}
				_ => ;
			}
			if (ok) n.process();
			else n.assertProcessFails();
		}
	}
}

def test_err_sigP(t: JawaTester) {
	var ts = t.t;
	for (x in JawaTypes.PRIMITIVES) {
		for (y in JawaTypes.PRIMITIVES) {
			var n = JawaTester.new(ts);
			var name = "eWut", jname = JawaStrings.of(name);
			var m1 = "m1", jm1 = JawaStrings.of(m1);
			var it1 = n.declareClass(name, t.NO_CLASS_ATTRS, null, []);

			var m1d = n.newFunction(SigDecl.new([y.valueType()], SigCache.arr_v), []);

			var it2 = n.defineClass(it1,
				[], // instance fields
				[], // instance methods
				[], // static fields
				[(jm1, n.NO_METHOD_ATTRS, JawaSigRef.new([JawaTypeRef.Prim(x)], JawaTypeRef.Void), m1d)]  // static methods
			);

			var ok = x.valueType() == y.valueType();
			if (ok) n.process();
			else n.assertProcessFails();
		}
	}
}

/*
TODO AALOAD
  - not a ref array
  - improper sig
TODO AASTORE
TODO ANEWARRAY
TODO ARRAYLENGTH
TODO CHECKCAST
TODO GETFIELD
TODO GETSTATIC
TODO INSTANCEOF
TODO INVOKEDYNAMIC
TODO INVOKEINTERFACE
TODO INVOKESPECIAL
TODO INVOKESTATIC
TODO INVOKEVIRTUAL
TODO MONITORENTER
TODO MONITOREXIT
TODO MULTIANEWARRAY
TODO NEW
TODO NEWARRAY
TODO PUTFIELD
TODO PUTSTATIC
*/

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A utility class to build an in-memory {Module} object.
class ModuleBuilder {
	var extensions: Extension.set;
	def module = Module.new(null);
	var func: FuncDecl;
	def locals = Vector<(ValueType, u32)>.new();
	var num_locals: int;
	new() {
		var sig = SigCache.v_i;
		module.deftypes.put(DefType.Function(sig));
		func = FuncDecl.new(false, 0, 0, sig);
		module.functions.put(func);
	}
	def sig(sig: FuncSig) -> this {
		module.deftypes[0] = DefType.Function(sig);
		func = FuncDecl.new(false, 0, 0, sig);
		module.functions[0] = func;
	}
	def addSig(sig: FuncSig) -> int {
		var index = module.deftypes.length;
		module.deftypes.put(DefType.Function(sig));
		return index;
	}
	def code(raw: Array<byte>) -> this {
		var body = makeBody(raw, this.locals);
		func.code = FunctionCode.new(body);
		func.code.num_locals = num_locals;
	}
	def validate() -> bool {
		var v = CodeValidator.new(extensions,
			Limits.new().set(extensions), module,
			WasmErrorGen.new(module.filename));
		return CodeValidatorResult.Ok.?(v.validateFunc(func));
	}
	private def makeBody(raw: Array<byte>, locals: Vector<(ValueType, u32)>) -> Array<byte> {
		var copy = BinBuilder.new();
		copy.put_u32leb(u32.!(locals.length));
		for (i < locals.length) {
			var e = locals[i];
			copy.put_u32leb(u32.!(e.1));
			copy.put_ValueType(e.0);
		}
		copy.puta(raw);
		copy.put(Opcode.END.code);
		return copy.extract();
	}
	def addGlobal(typ: ValueType, init: InitExpr) -> int {
		var index = module.globals.length;
		module.globals.put(GlobalDecl.new(module.globals.length, typ, true, init));
		return index;
	}
	def addLocal(typ: ValueType) -> int {
		return addLocals(1, typ);
	}
	def addLocals(count: int, typ: ValueType) -> int {
		var size = locals.length;
		if (size > 0) {
			var last = locals[size-1];
			if (last.0 == typ) {
				locals[size-1] = (last.0, last.1 + u32.!(count));
				var prev = num_locals;
				num_locals += count;
				return func.sig.params.length + prev;
			}
		}
		locals.put((typ, u32.!(count)));
		var prev = num_locals;
		num_locals += count;
		return func.sig.params.length + prev;
	}
	def addFunction(sig: FuncSig, raw: Array<byte>) -> FuncDecl {
		var sig_index = module.deftypes.length;
		module.deftypes.put(DefType.Function(sig));
		var func = FuncDecl.new(false, module.functions.length, sig_index, sig);
		module.functions.put(func);
		func.code = FunctionCode.new(makeBody(raw, Vector.new()));
		return func;
	}
	def addTable(length: int, offset: int, indices: Array<int>) -> this {
		var table = TableDecl.new(module.tables.length, ValueType.FUNCREF, length, length);
		module.tables.put(table);
		if (indices != null) {
			var mode = SegmentMode.Active(table.index, InitExpr.I32(offset));
			var details = ElemDetails.FuncRefs(indices);
			var elem = ElemDecl.new(ValueType.FUNCREF, mode, details);
			module.elems.put(elem);
		}
	}
	def addTableWithMax(initial: int, length: int) -> this {
		var table = TableDecl.new(module.tables.length, ValueType.FUNCREF, initial, length);
		module.tables.put(table);
	}
	def addMemory(initial: int, maximum: int) -> this {
		var memory = MemoryDecl.new(module.memories.length, initial, maximum, false);
		module.memories.put(memory);
	}
	def addData(offset: int, raw: Array<byte>) -> this {
		var mode = SegmentMode.Active(0, InitExpr.I32(offset));
		var data = DataDecl.new(mode, raw);
		module.data.put(data);
	}
	def addPassiveData(raw: Array<byte>) -> this {
		var data = DataDecl.new(SegmentMode.Passive, raw);
		module.data.put(data);
	}
	def addPassiveElems(indices: Array<int>) -> this {
		var details = ElemDetails.FuncRefs(indices);
		var elem = ElemDecl.new(ValueType.FUNCREF, SegmentMode.Passive, details);
		module.elems.put(elem);
	}
}
// Copyright 2024 Wizard authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("whamm:", _, WhammTester.new, _);
def X_ = [
	T("parse1", test_parse1),
	T("parse2", test_parse2),
	T("call1", test_call1),
	T("call2", test_call2),
	T("call3", test_call3),
	T("imm0", test_imm0),
	T("imm1", test_imm1),
	T("local0", test_local0),
	T("local1", test_local1),
	T("arg0", test_arg0),
	T("arg1", test_arg1),
	T("fail0", test_fail0),
	T("fail1", test_fail1),
	T("fail2", test_fail2),
	T("fail3", test_fail3),
	()
];

class WhammTester(t: Tester) {
	def assert_params(expected: Array<WhammParam>, str: string) {
		var r = TextReader.new("<input>", str);
		var got = Whamm.parseParams(r);
		if (!r.ok) {
			Trace.OUT.puts("failed to parse:").ln();
			r.renderCurrentLineWithCaret(Trace.OUT, r.error_column);
			Trace.OUT.ln();
			t.fail1("failed to parse: %s", r.error_msg);
		}
		if (got.length != expected.length) return t.fail2("expected %d params, got %d", expected.length, got.length);
		for (i < expected.length) {
			if (!equal(expected[i], got[i])) {
				var buf = StringBuilder.new();
				buf.puts("expected [");
				for (i < expected.length) {
					if (i > 0) buf.csp();
					expected[i].render(buf);
				}
				buf.puts("], got [");
				for (i < got.length) {
					if (i > 0) buf.csp();
					got[i].render(buf);
				}
				buf.puts("]");
				return t.fail(buf.toString());
			}
		}
	}
	def assert_fail(expected_msg: string, str: string) {
		var r = TextReader.new("<input>", str);
		var got = Whamm.parseParams(r);
		if (r.ok) return t.fail1("expected parse failure: \"%s\"", str);
		if (!Strings.startsWith(r.error_msg, expected_msg)) t.fail2("expected parse failure {%s}, got {%s}", expected_msg, r.error_msg);

	}
	def equal(a: WhammParam, b: WhammParam) -> bool {
		if (a == b) return true;
		match (a) {
			Imm(orig, i) => match (b) {
				Imm(orig, j) => return i == j;
				_ => ;
			}
			Stack(orig, i) => match (b) {
				Stack(orig, j) => return i == j;
				_ => ;
			}
			Local(orig, i) => match (b) {
				Local(orig, j) => return i == j;
				_ => ;
			}
			Call(target, params) => match (b) {
				Call(t2, p2) => {
					return Strings.equal(target.image, t2.image) && Arrays.allTrue(params, p2, equal);
				}
				_ => ;
			}
			_ => ;
		}
		return false;
	}
}

def PC = WhammParam.Pc;
def FUNC = WhammParam.Func;
def FRAME = WhammParam.FrameAccessor;

def CALL(str: string, params: Array<WhammParam>) -> WhammParam.Call {
	return WhammParam.Call(Token.new("<file>", str, 0, 0), params);
}

def IMM = WhammParam.Imm(null, _);
def LOCAL = WhammParam.Local(null, _);
def ARG = WhammParam.Stack(null, _);

def test_parse1(t: WhammTester) {
	t.assert_params([PC], "(pc)");
	t.assert_params([FUNC], "(func)");
	t.assert_params([FRAME], "(frame)");
}

def test_parse2(t: WhammTester) {
	t.assert_params([PC, PC], "(pc,pc)");
	t.assert_params([FUNC, PC], "(func,pc)");
	t.assert_params([FRAME, PC], "(frame,pc)");

	t.assert_params([PC, FUNC], "(pc, func)");
	t.assert_params([FUNC, FUNC], "(func, func)");
	t.assert_params([FRAME, FUNC], "(frame, func)");

	t.assert_params([PC, FRAME], "(pc,  frame)");
	t.assert_params([FUNC, FRAME], "(func,    frame)");
	t.assert_params([FRAME, FRAME], "(frame,     frame)");
}

def test_call1(t: WhammTester) {
	t.assert_params([CALL("foobar", [PC])], "(foobar(pc))");
	t.assert_params([CALL("bar", [FUNC])], "(bar(func))");
	t.assert_params([CALL("$BAZ", [FRAME])], "($BAZ(frame))");
	t.assert_params([CALL("$BAZ", [FRAME])], "($BAZ(frame))");
	t.assert_params([CALL("11_29", [])], "(11_29())");
}

def test_call2(t: WhammTester) {
	t.assert_params([CALL("foo", [FUNC]), CALL("bar", [])], "(foo(func), bar())");
}

def test_call3(t: WhammTester) {
	t.assert_params([CALL("foo", [ARG(0)]), LOCAL(0), IMM(0)], "(foo(arg0), local0, imm0))");
	t.assert_params([CALL("$BAZ", [LOCAL(1), LOCAL(2), ARG(0), ARG(1)])], "($BAZ(local1, local2, arg0, arg1))");
}

def test_imm0(t: WhammTester) {
	t.assert_params([IMM(0)], "(imm0)");
}

def test_imm1(t: WhammTester) {
	t.assert_params([IMM(1)], "(imm1)");
	t.assert_params([IMM(7)], "(imm7)");
	t.assert_params([IMM(22)], "(imm22)");
}

def test_local0(t: WhammTester) {
	t.assert_params([LOCAL(0)], "(local0)");
}

def test_local1(t: WhammTester) {
	t.assert_params([LOCAL(1)], "(local1)");
	t.assert_params([LOCAL(6)], "(local6)");
	t.assert_params([LOCAL(99)], "(local99)");
	t.assert_params([LOCAL(1273)], "(local1273)");
}

def test_arg0(t: WhammTester) {
	t.assert_params([ARG(0)], "(arg0)");
}

def test_arg1(t: WhammTester) {
	t.assert_params([ARG(1)], "(arg1)");
	t.assert_params([ARG(3)], "(arg3)");
	t.assert_params([ARG(888)], "(arg888)");
	t.assert_params([ARG(999)], "(arg999)");
}

def test_fail0(t: WhammTester) {
	t.assert_fail("expected identifier", "(");
	t.assert_fail("\"(\" expected", "arg");
}

def test_fail1(t: WhammTester) {
	t.assert_fail("unresolved identifier", "(unknown)");
	t.assert_fail("unresolved identifier", "(foo)");
	t.assert_fail("unresolved identifier", "(pc, bar)");
	t.assert_fail("unresolved identifier", "(pc, $NEN)");
}

def test_fail2(t: WhammTester) {
	t.assert_fail("expected positive integer", "(arg)");
	t.assert_fail("expected positive integer", "(imm)");
	t.assert_fail("expected positive integer", "(local)");

	t.assert_fail("unresolved", "(pc0)");
	t.assert_fail("unresolved", "(func1)");
	t.assert_fail("unresolved", "(frame2)");
}

def test_fail3(t: WhammTester) {
	t.assert_fail("", "((");
	t.assert_fail("", ")(");
	t.assert_fail("", "(()");
	t.assert_fail("", "(())");
	t.assert_fail("", "[]");

	t.assert_fail("", "(pc");
	t.assert_fail("", "(pc, func");
	t.assert_fail("", "(pc, func]");
	t.assert_fail("", "(pc + func)");
	t.assert_fail("", "(pc - func]");
	t.assert_fail("", "(pc func]");
	t.assert_fail("", "(pc(func)]");
}

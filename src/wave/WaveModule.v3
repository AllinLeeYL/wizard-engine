// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Enumeration of the exported functions
def iiii_v = ValueType.Function([ValueType.I32, ValueType.I32, ValueType.I32, ValueType.I32], []);
enum WaveExports(sig: ValueType.Function, invoke: (WaveInstance, Executor, Array<Value>) -> Result) {
	arg_len(SigCache.i_i, WaveInstance.arg_len),
	arg_copy(SigCache.iii_i, WaveInstance.arg_copy),
	fs_size(SigCache.ii_i, WaveInstance.fs_size),
	fs_chmod(SigCache.iii_i, WaveInstance.fs_chmod),
	fs_open(SigCache.iii_i, WaveInstance.fs_open),
	fs_read(SigCache.iii_i, WaveInstance.fs_read),
	fs_write(SigCache.iii_i, WaveInstance.fs_write),
	fs_avail(SigCache.i_i, WaveInstance.fs_avail),
	fs_close(SigCache.i_v, WaveInstance.fs_close),
	throw_ex(iiii_v, WaveInstance.throw_ex)
}

// State for an instance that has imported the wave module.
class WaveInstance(var cmdline_args: Array<string>) {
	private def fds = Array<int>.new(MAX_FDS);
	private var lastfd: int;
	private def oob = Result.Trap(TrapReason.MEM_OUT_OF_BOUNDS);
	var memory: Memory;
	var main: Function;
	new() {
		for (i < fds.length) fds[i] = -1;
		fds[0] = 0;
		fds[1] = 1;
		fds[2] = 2;
		lastfd = 3;
	}
	def provideImports(module: Module, result: Array<Exportable>) {
		var imports = module.imports;
		for (j < imports.length) {
			var i = imports[j];
			if (!Strings.equals("wave", i.modname)) continue;
			if (!ImportDetails.Function.?(i.details)) continue;
			var impf = ImportDetails.Function.!(i.details).decl;
			for (ex in WaveExports) {
				if (Strings.equals(ex.name, i.name)) {
					result[j] = HostFunction.new(ex.sig, ex.invoke(this, _, _));
					break;
				}
			}
		}
	}
	def extractMemoryExport(instance: Instance) -> bool {
		// Find memory and save internally
		var module = instance.module;
		var exports = module.exports;
		for (j < exports.length) {
			var e = module.exports[j];
			if (Strings.equals("memory", e.name) && ExportDetails.Memory.?(e.details)) {
				memory = Memory.!(instance.exports[j]);
				return true;
			}
		}
		return false;
	}
	def extractMainExport(instance: Instance) -> Function {
		var module = instance.module;
		var exports = module.exports;
		var found: Function;
		var count = 0;
		for (j < exports.length) {
			var e = module.exports[j];
			if (!ExportDetails.Function.?(e.details)) continue;
			found = Function.!(instance.exports[j]);
			if (Strings.equals("main", e.name)) return found; // explicit name match
			count++;
		}
		return if(count == 1, found); // if only one exported function, assume it is main
	}

	// ==={Provided functions}============================================
	def arg_len(e: Executor, args: Array<Value>) -> Result {
		var arg = Values.v_u(args[0]);
		if (arg >= args.length) return MINUS_1;
		return i(cmdline_args[arg].length);
	}
	def arg_copy(e: Executor, args: Array<Value>) -> Result {
		if (memory == null) return oob;
		var arg = Values.v_u(args[0]);
		var ptr = Values.v_u(args[1]);
		var len = Values.v_u(args[2]);
		if (arg >= args.length) return MINUS_1;
		var data = cmdline_args[arg];
		if (len > data.length) len = u32.!(data.length);
		var i = memory.boundsCheck(0, ptr, len);
		if (i < 0) return oob;
		Arrays.copyInto(memory.data, int.!(ptr), data, 0, int.!(len));
		return this.i(int.!(len));
	}

	def fs_size(e: Executor, args: Array<Value>) -> Result {
		if (memory == null) return oob;
		var ptr = Values.v_u(args[0]);
		var len = Values.v_u(args[1]);
		var path = memory.copy(ptr, len);
		var fd = System.fileOpen(path, true);
		if (fd < 0) return i(0);
		var size = System.fileLeft(fd);
		System.fileClose(fd);
		return i(size);
	}
	def fs_chmod(e: Executor, args: Array<Value>) -> Result {
		if (memory == null) return oob;
		var ptr = Values.v_u(args[0]);
		var len = Values.v_u(args[1]);
		var perm = Values.v_u(args[2]);
		var path = memory.copy(ptr, len);
		if (path == null) return MINUS_1;
		System.chmod(path, int.view(perm));
		return i(0);
	}
	def fs_open(e: Executor, args: Array<Value>) -> Result {
		if (memory == null) return oob;
		var ptr = Values.v_u(args[0]);
		var len = Values.v_u(args[1]);
		var mode = Values.v_u(args[2]);
		var path = memory.copy(ptr, len);
		if (path == null) return MINUS_1;
		var fd = allocfd();
		if (fd < 0) return MINUS_1; // out of file descriptors
		var s = System.fileOpen(path, mode == 0);
		if (s < 0) return i(s);
		fds[fd] = s;
		return i(fd);
	}
	def fs_read(e: Executor, args: Array<Value>) -> Result {
		if (memory == null) return oob;
		var fd = Values.v_i(args[0]);
		var buf = Values.v_u(args[1]);
		var len = Values.v_u(args[2]);
		var s = sysfd(fd);
		if (s < 0) return MINUS_1;
		var t = memory.alias(buf, len);
		if (t.0 == null) return MINUS_1;
		var r = System.fileReadK(s, t.0, t.1, t.2);
		return i(r);
	}
	def fs_write(e: Executor, args: Array<Value>) -> Result {
		if (memory == null) return oob;
		var fd = Values.v_i(args[0]);
		var buf = Values.v_u(args[1]);
		var len = Values.v_u(args[2]);
		var s = sysfd(fd);
		if (s < 0) return MINUS_1;
		var t = memory.alias(buf, len);
		if (t.0 == null) return MINUS_1;
		System.fileWriteK(s, t.0, t.1, t.2);
		return i(0);
	}
	def fs_avail(e: Executor, args: Array<Value>) -> Result {
		var fd = Values.v_i(args[0]);
		var s = sysfd(fd);
		if (s < 0) return MINUS_1;
		var r = System.fileLeft(s);
		return i(r);
	}
	def fs_close(e: Executor, args: Array<Value>) -> Result {
		var fd = Values.v_i(args[0]);
		var s = sysfd(fd);
		if (s < 0) return MINUS_1;
		System.fileClose(s);
		fds[fd] = -1;
		return NONE;
	}
	def throw_ex(e: Executor, args: Array<Value>) -> Result {
		if (memory == null) return oob;
		var ex = Values.v_u(args[0]);
		var ex_len = Values.v_u(args[1]);
		var msg = Values.v_u(args[2]);
		var msg_len = Values.v_u(args[3]);
		var errstr = memory.copy(ex, ex_len);
		var msgstr = memory.copy(msg, msg_len);
		System.error(errstr, msgstr);  // TODO: print wasm-level stack trace.
		return NONE;
	}
	// ===================================================================

	private def i(v: int) -> Result {
		return Result.Value([Value.I32(u32.view(v))]);
	}
	private def sysfd(fd: int) -> int {
		return if(fd < 0 || fd >= fds.length, -1, fds[fd]);
	}
	private def allocfd() -> int {
		for (i = lastfd; i < fds.length; i++) {
			if (fds[i] < 0) {
				lastfd = (i + 1) % fds.length;
				return i;
			}
		}
		for (i < lastfd) {
			lastfd = (i + 1) % fds.length;
			return i;
		}
		return -1;
	}
}
def MINUS_1 = Result.Value([Value.I32(0xFFFFFFFFu)]);
def NONE = Result.Value([]);
def MAX_FDS = 256;
// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A simple iterator for bytecodes in a function.
class BytecodeIterator(func: FunctionDecl) {
	private def decoder = Decoder.new(func.code.orig, null);
	private var pc: int;
	new() {
		var codeptr = decoder;
		// skip local declarations
		var count = codeptr.read_u32leb();
		for (i < count) {
			var d = codeptr.read_u32leb();
			var t = codeptr.read_u32leb();
		}
		pc = codeptr.pos;
	}
	def immptr() -> Decoder {
		return decoder.at(pc + 1);
	}
	def more() -> bool {
		return pc < decoder.limit;
	}
	def current() -> Opcode {
		if (more()) {
			var p = decoder.at(pc);
			var b = p.read_u8();
			return Opcodes.opcodes[b];
		}
		return Opcode.NOP;
	}
	def next() {
		if (more()) {
			var p = decoder.at(pc);
			match (current().imm) {
				NONE => ;
				BLOCK_TYPE,
				FUNC_INDEX,
				LOCAL_INDEX,
				GLOBAL_INDEX,
				MEMORY_INDEX,
				LABEL => p.read_u32leb();
				LABELS => {
					var count = p.read_u32leb();
					for (i < count + 1) {
						p.read_u32leb();
					}
				}
				MEMARG,
				SIG_TABLE_INDEX => {
					p.read_u32leb();
					p.read_u32leb();
				}
				I32 => p.read_i32leb();
				I64 => p.read_i64leb();
				F32 => p.skip_bytes(4);
				F64 => p.skip_bytes(8);
			}
			pc = p.pos;
		}
	}
}

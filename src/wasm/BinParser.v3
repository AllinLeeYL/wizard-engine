// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Parses the binary format of WebAssembly and produces an in-memory module
// representation. The parser uses a "push" model which allows the creator
// to input segments of data into the parser incrementally, e.g. if streaming
// it over a network.
class BinParser(filename: string) {
	private def module = Module.new();
        private var state = BpState.HEADER;
        private var cur_function: int;
        private var decoder = Decoder.new([]);
        private var size_estimate: int;
        private var declared_code_size: int;
        private var seen_sections = Array<bool>.new(BpSection.Data.tag + 3);
        private var total_module_size: int;

	// Checks whether any error has occured yet and returns {true} if not.
	def ok() -> bool { return decoder.ok() || decoder.eof(); }
	// Checks whether any error has occurred yet and returns {true} if so.
        def error() -> bool { return decoder.error() && !decoder.eof(); }

	// Push new data into the parser from the specified range. The given array is
        // not modified or retained by this call; internal copies of data are made
        // if necessary. However, do not pass an array that could be concurrently modified.
	def push(x: Array<byte>, xpos: int, xlength: int) -> this {
        	if (decoder.error() && !decoder.eof()) return;  // Already hit a non-EOF error.

		total_module_size += xlength;
		if (total_module_size > Limits.max_module_size) {
                	// Enforce maximum module size.
                        decoder.fail("maximum module size exceeded"); // TODO error position
                	return;
                }
        	if (decoder.available() > 0) {
                	// If there is a remainder, append the new data into it.
                        decoder = decoder.append(size_estimate, x, xpos, xlength);
                } else {
                	// No remainder from previous decoding, decode in-place from caller's buffer.
                        var skipped = decoder.skipped;
                        decoder = Decoder.new(x);
                        decoder.pos = xpos;
                        decoder.limit = xpos + xlength;
                        decoder.skipped = skipped - xpos;
                }

		// Run the decode loop.
        	var prev = decoder.pos;
        	while (decoder.more()) {
	        	match (state) {
        	        	HEADER => readHeader();
                	        SECTIONS => readSection();
                        	FUNCTIONS => readFunctionBody();
	                }
                        if (decoder.eof()) break;
                }

		if (decoder.data == x) {
			// If this was an in-place decoding, copy out the remainder into a buffer.
                        decoder = decoder.extract(size_estimate);
                }
        }

	// Finish the decoding of the pushed bytes, returning a valid module
	def finish() -> Decoded<Module> {
        	match (state) {
                	HEADER => decoder.fail("incomplete header");
                        FUNCTIONS => decoder.fail("incomplete code section");
                        SECTIONS => {
		        	if (decoder.more()) {
                                	decoder.fail("incomplete section");
		                } else {
                                	checkSectionConstraints();
                                }
                        }
                }
		return Decoded<Module>.new(filename, 0, total_module_size, module, "");
        }

	private def readHeader() {
        	var p1 = decoder.pos, magic = decoder.read_u32();
		if (decoder.eof()) return rewind(p1, 4);                
                if (magic != WASM_MAGIC) {
                	decoder.fail_at(p1, "incorrect Wasm magic word"); // TODO: expectation in msg
                        return;
                }
                var p2 = decoder.pos, version = decoder.read_u32();
		if (decoder.eof()) return rewind(p2, 4);                
                if (version != WASM_VERSION) {
                	decoder.fail_at(p2, "incorrect Wasm version");  // TODO: expectation in msg
                        return;
                }
                if (decoder.ok()) state = BpState.SECTIONS;
        }

	private def rewind(pos: int, expect: int) {
        	decoder.at(pos);
               	size_estimate = if (expect > 0, if (expect < MAX_SIZE_ESTIMATE, expect, MAX_SIZE_ESTIMATE));
        }

	private def readSection() {
        	var start = decoder.pos;
        	var code = decoder.read_u8();
                var size = decoder.read_u32leb();
                if (decoder.eof()) return rewind(start, 5);  // size not available yet
		start = decoder.pos;

		// Check for duplicate sections
                if (code != 0 && code < seen_sections.length && seen_sections[code]) {
                	decoder.fail_at(start, "duplicate section");
                }

                // The code section has a special state; function bodies are handled individually.
                if (code == BpSection.Code.code) {
                	// Transition into reading code section
	        	var num_functions = decoder.read_u32leb();
                        if (decoder.eof()) return rewind(start, 0);
        	        if (num_functions != module.functions.declared.size()) {
                		decoder.fail_at(start, "number of function bodies != function declarations");
                        	return;
	                }
        	        state = BpState.FUNCTIONS;
                        seen_sections[code] = true;
                        declared_code_size = int.!(size);
			return;
                }
                
                // For all other sections, rewind if they are not complete.
                if (!decoder.check_bytes(int.!(size))) return rewind(start, int.!(size));

		// For valid sections, record that the section has now been seen.
                if (code >= 0 && code < seen_sections.length) {
	                seen_sections[code] = true;
                }
                
                match (code) {
                        0 => readCustomSection(size);
			BpSection.Type.code => readMultiple("types", Limits.max_num_types, module.types, readTypeDecl);
			BpSection.Import.code => readMultiple("imports", Limits.max_num_imports, module.imports, readImportDecl);
			BpSection.Function.code => readMultiple("functions", Limits.max_num_functions, module.functions.declared, readFunctionDecl);
			BpSection.Table.code => readMultiple("tables", Limits.max_num_tables, module.tables.declared, readTableDecl);
			BpSection.Memory.code => readMultiple("memories", Limits.max_num_memories, module.memories.declared, readMemoryDecl);
			BpSection.Global.code => readMultiple("globals", Limits.max_num_globals, module.globals.declared, readGlobalDecl);
			BpSection.Export.code => readMultiple("exports", Limits.max_num_exports, module.exports, readExportDecl);
			BpSection.Start.code => readStartSection();
			BpSection.Element.code => readMultiple("elements", Limits.max_num_table_entries, module.elems, readElemDecl);
			BpSection.Data.code => readMultiple("data", Limits.max_num_data_segments, module.data, readDataDecl);
                        _ => decoder.fail_at(start, "unknown section code");  // TODO: value in msg
               }

		// Check that the size of bytes read equals the section's declared size
                var read = decoder.pos - start;
                if (read < size) {
                	decoder.fail("section is shorter than declared size");
                } else if (read > size) {
                	decoder.fail("section is longer than declared size");
                }
        }

	private def readCustomSection(size: u32) {
        	var start = decoder.pos;
        	var name_len = decoder.read_u32leb();
                var name = decoder.read_bytes(int.!(name_len));
                var payload_len = int.!(size) - (decoder.pos - start);
                var payload = decoder.read_bytes(payload_len);
                module.custom_sections.add(CustomSection.new(name, payload));
        }
	private def readMultiple<T>(thing_name: string, max: u32, vec: Vector<T>, read: int -> T) {
		var count = readU32(thing_name, 0, max);
		if (!decoder.ok()) return;
		if (count < MAX_GROW_SIZE) vec.grow(int.!(count));
		for (index < int.!(count)) {
			var thing = read(index);
			vec.set(index, thing);
		}
	}
	private def readTypeDecl(index: int) -> TypeDecl {
		var pt = decoder.pos, invalid: TypeDecl;
		var form = decoder.read_u8();
		if (form != BpTypecon.Function.code) {
			decoder.fail_at(pt, "invalid type, expected function");
			return invalid;
		}
		pt = decoder.pos;
		var param_count = readU32("param count", 0, Limits.max_num_func_params);
		if (!decoder.ok()) return invalid;
		var ptypes = Array<ValueType>.new(int.!(param_count));
		for (j < param_count) {
			ptypes[int.!(j)] = readValueType();
		}
		var ret_count = readU32("result count", 0, Limits.max_num_func_results);
		if (!decoder.ok()) return invalid;
		var rtypes = Array<ValueType>.new(int.!(ret_count));
		for (j < ret_count) {
			rtypes[int.!(j)] = readValueType();
		}
		return TypeDecl.Function(ptypes, rtypes);
	}
	private def readValueType() -> ValueType {
		var pt = decoder.pos, b = decoder.read_u8();
		match (b) {
			BpTypecon.I32.code => return ValueType.I32;
			BpTypecon.I64.code => return ValueType.I64;
			BpTypecon.F32.code => return ValueType.F32;
			BpTypecon.F64.code => return ValueType.F64;
			BpTypecon.VEC128.code => return ValueType.VEC128;
			BpTypecon.AnyRef.code => return ValueType.ANYREF;
		}
		decoder.fail_at(pt, "invalid value type");
		return ValueType.I32;
	}
	private def readImportDecl(index: int) -> ImportDecl {
		var module_name = readString("import module name");
		var field_name = readString("import field name");
		var pt = decoder.pos;
		var kind = decoder.read_u8();
		var result: ImportDecl;
		var details: ImportDetails;
		match (kind) {
			BpImportExportKind.Function.code => {
				var sig = readSigIndex();
				var decl = FunctionDecl.new(true, sig.0, sig.1);
				module.functions.imported.add(decl);
				details = ImportDetails.Function(decl);
			}
			BpImportExportKind.Table.code => {
				var et = readElemType();
				var l = readLimits("table", Limits.max_table_size);
				var decl = TableDecl.new(true, et, l.0, l.1);
				module.tables.imported.add(decl);
				details = ImportDetails.Table(decl);
			}
			BpImportExportKind.Memory.code => {
				var l = readLimits("memory", Limits.max_memory_pages); // TODO: shared flag
				var decl = MemoryDecl.new(true, l.0, l.1, false);
				module.memories.imported.add(decl);
				details = ImportDetails.Memory(decl);
			}
			BpImportExportKind.Global.code => {
				var t = readValueType();
				var mut = decoder.read_u8() != 0;
				var decl = GlobalDecl.new(true, t, mut, InitExpr.I32(0));
				module.globals.imported.add(decl);
				details = ImportDetails.Global(decl);
			}
			_ => decoder.fail_at(pt, "invalid import kind");
		}
		return ImportDecl.new(module_name, field_name, details);
	}
	private def readFunctionDecl(index: int) -> FunctionDecl {
		var pt = decoder.pos;
		var sig = readSigIndex();
		return FunctionDecl.new(false, sig.0, sig.1);
	}
	private def readTableDecl(index: int) -> TableDecl {
		var et = readElemType();
		var l = readLimits("table", Limits.max_table_size);
		return TableDecl.new(false, et, l.0, l.1);
	}
	private def readMemoryDecl(index: int) -> MemoryDecl {
		var l = readLimits("memory", Limits.max_memory_pages); // TODO: shared flag
		return MemoryDecl.new(false, l.0, l.1, false);
	}
	private def readGlobalDecl(index: int) -> GlobalDecl {
		var vt = readValueType();
		var mut = decoder.read_u8() != 0;
		var init = readInitExpr("global initializer");
		return GlobalDecl.new(false, vt, mut, init);
	}
	private def readExportDecl(index: int) -> ExportDecl {
		var name = readString("export name");
		var pt = decoder.pos;
		var k = decoder.read_u8();
		var details: ExportDetails;
		match (k) {
			BpImportExportKind.Function.code => {
				var index = readFuncIndex();
				details = ExportDetails.Function(index);
			}
			BpImportExportKind.Table.code => {
				var index = readTableIndex();
				details = ExportDetails.Table(index);
			}
			BpImportExportKind.Memory.code => {
				var index = readMemoryIndex();
				details = ExportDetails.Memory(index);
			}
			BpImportExportKind.Global.code => {
				var index = readGlobalIndex();
				details = ExportDetails.Global(index);
			}
			_ => decoder.fail_at(pt, "invalid export kind");
		}
		return ExportDecl.new(name, details);
	}
	private def readElemDecl(index: int) -> ElemDecl {
		var table_index = readTableIndex();
		var offset = readI32Expr("elements offset");
		var count = readU32("element count", 0, Limits.max_num_table_entries);
		var array = Array<int>.new(int.!(count));
		for (i < int.!(count)) {
			array[i] = readFuncIndex(); // TODO: support init expressions
		}
		var details = ElemDetails.FuncRefs(array);
		var active = true; // TODO(bulk-memory)
		return ElemDecl.new(table_index, offset, details, active);
	}
	private def readDataDecl(index: int) -> DataDecl {
		var mem_index = readMemoryIndex();
		var offset = readI32Expr("data element offset");
		var len = readU32("data segment size", 0, Limits.max_data_segment_size);
		var data = decoder.read_bytes(int.!(len));
		var active = true; // TODO(bulk-memory)
		return DataDecl.new(mem_index, offset, data, active);
	}
	private def readStartSection() {
		module.start_function = readFuncIndex();
	}

	def readU32(quantity: string, min: u32, max: u32) -> u32 {
		var pt = decoder.pos;
		var val = decoder.read_u32leb();
		if (decoder.eof()) return 0;
		if (val < min || val > max) decoder.fail_at(pt, "exceeded maximum"); // TODO msg
		return val;
	}
	def readString(name: string) -> string {
		var len = decoder.read_u32leb();
		var str = decoder.read_bytes(int.!(len));
		return str;
	}
	def readLimits(name: string, limit: u32) -> (int, int) { // TODO: return (u32, bool, u32)
		var flags = decoder.read_u8();
		var min = decoder.read_u32leb();
		var has_max = (flags & 1) != 0;
		var max = -1;
		if (has_max) {
			var pt = decoder.pos;
			var m = decoder.read_u32leb();
			if (m > limit) decoder.fail_at(pt, "maximum too large"); // TODO: msg
			max = int.!(max);
		}
		return (int.!(min), max);
	}
	def readTableIndex() -> int {
		var pt = decoder.pos;
		var index = decoder.read_u32leb();
		if (index >= module.tables.size()) decoder.fail_at(pt, "invalid table index");
		return int.!(index);
	}
	def readSigIndex() -> (int, TypeDecl.Function) {
		var pt = decoder.pos;
		var index = decoder.read_u32leb(), ft: TypeDecl.Function;
		if (index >= module.types.size()) {
			decoder.fail_at(pt, "invalid signature index");
		} else {
			var t = module.types[int.!(index)];
			if (!TypeDecl.Function.?(t)) decoder.fail_at(pt, "expected function type signature");
			else ft = TypeDecl.Function.!(t);
			
		}
		return (int.!(index), ft);
	}
	def readFuncIndex() -> int {
		var pt = decoder.pos;
		var index = decoder.read_u32leb();
		if (index >= module.functions.size()) decoder.fail_at(pt, "invalid function index");
		return int.!(index);
	}
	def readMemoryIndex() -> int {
		var pt = decoder.pos;
		var index = decoder.read_u32leb();
		if (index >= module.memories.size()) decoder.fail_at(pt, "invalid memory index");
		return int.!(index);
	}
	def readGlobalIndex() -> int {
		var pt = decoder.pos;
		var index = decoder.read_u32leb();
		if (index >= module.globals.size()) decoder.fail_at(pt, "invalid global index");
		return int.!(index);
	}
	def readElemType() -> ElemType {
		var pt = decoder.pos;
		var b = decoder.read_u8();
		var et: ElemType;
		match (b) {
			BpTypecon.AnyFunc.code => et = ElemType.FuncRef;
			BpTypecon.AnyRef.code => et = ElemType.AnyRef;
			_ => decoder.fail_at(pt, "invalid table element type");
		}
		return et;
	}
	def readI32Expr(quantity: string) -> InitExpr {
		var pt = decoder.pos;
		var init = readInitExpr(quantity);
		match (init) {
			I32(val) => ;
			Global(global_index) => {
				var g = module.globals[global_index];
				if (g == null || g.valtype != ValueType.I32) {
					decoder.fail_at(pt, "expected i32 init expr");
				}
			}
			_ => decoder.fail_at(pt, "expected i32 init expr");
		}
		return init;
	}
	def readInitExpr(quantity: string) -> InitExpr; // TODO

	private def readFunctionBody() {
        	var start = decoder.pos;
        	var size = decoder.read_u32leb();
                if (decoder.eof()) return rewind(start, 5);
                if (size > Limits.max_func_size) {
                	decoder.fail("function too large");  // TODO: size in msg
                        return;
                }
		var body = decoder.read_bytes(int.!(size));
		if (decoder.eof()) return rewind(start, int.!(size));
                var f = module.functions.declared[cur_function++];
                f.body = body;
                if (cur_function == module.functions.declared.size()) {
                	state = BpState.SECTIONS;
                        // TODO: check size of code section against declared size
                }
        }

	private def checkSectionConstraints() {
        }
}
// Internal constants.
def MAX_SIZE_ESTIMATE = 16 * 1024 * 1024;
def MAX_GROW_SIZE = 1000000;
// Header constants.
def WASM_MAGIC = 0x6d736100u;
def WASM_VERSION = 0x01u;
// Selects the amount of tracing output printed by the decoder.
enum Verbosity {
	SILENT,     // no output
	DIAGNOSTIC, // summarizes sections prior to error, verbose near error
	VERBOSE	    // details for everything printed
}
// Used internally in the binary parser.
enum BpState {
	HEADER,
        SECTIONS,
        FUNCTIONS
}
// Section codes.
enum BpSection(code: byte) {
	Unknown(0),
	Type(1),
	Import(2),
	Function(3),
	Table(4),
	Memory(5),
	Global(6),
	Export(7),
	Start(8),
	Element(9),
	Code(10),
	Data(11),
}
// Import/export kind codes.
enum BpImportExportKind(code: byte) {
	Function(0),
	Table(1),
	Memory(2),
	Global(3)
}
// Type constructor codes.
enum BpTypecon(code: byte) {
	I32(0x7F),
        I64(0x7E),
        F32(0x7D),
        F64(0x7C),
        VEC128(0x7B), // ext:simd
	AnyFunc(0x70),
        AnyRef(0x6F), // ext:reference-types
	Function(0x60),
	EmptyBlock(0x40)
}

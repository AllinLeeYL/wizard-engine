// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Parses the binary format of WebAssembly and produces an in-memory module
// representation. The parser uses a "push" model which allows the creator
// to input segments of data into the parser incrementally, e.g. if streaming
// it over a network.
class ModuleParser(vb: Verbosity, filename: string) extends WasmParser {
	new() super(Module.new(filename)) {
		verbose = vb.tag > Verbosity.SILENT.tag;
	}

	private var state = BpState.HEADER;
	private var cur_function: int;
	private var size_estimate: int;
	private var expected_code_size: u32;
	private var code_start: int;
	private var seen_sections = Array<bool>.new(BpSection.Data.tag + 3);
	private var total_module_size: int;
	private var current_section: byte;
	private var finished: bool;

	// Checks whether any error has occured yet and returns {true} if not.
	def ok() -> bool { return err.ok() || decoder.eof; }
	// Checks whether any error has occurred yet and returns {true} if so.
	def error() -> bool { return err.error() && !decoder.eof; }

	// Push new data into the parser from the specified range. The given array is
	// not modified or retained by this call; internal copies of data are made
	// if necessary. However, do not pass an array that could be concurrently modified,
	// as it may be decoded in place.
	def push(x: Array<byte>, xpos: int, xlength: int) -> this {
		if (xlength == 0) return; // nothing to do
		if (err.error()) return;  // already hit an error

		total_module_size += xlength;
		if (total_module_size > Limits.max_module_size) {
			// Enforce maximum module size.
			err.fail1(decoder.pos, WasmError.EXCEEDED_LIMIT,
				"maximum module size of %d exceeded",
				Limits.max_module_size);
			return;
		}
		// Append data to end of current buffer.
		decoder.append(0, x, xpos, xlength);

		// Run the decode loop.
		decodeLoop();

		// Don't allow the decoder to hold onto the caller's buffer.
		decoder.divest(0, x);
	}
	private def decodeLoop() {
		// Run the decode loop.
		while (true) {
			traceBuffer();
			match (state) {
				HEADER => readHeader();
				SECTIONS => if (decoder.more()) readSection();
				FUNCTIONS => readFunctionBody();
			}
			if (!decoder.more()) break;
			if (!err.ok()) break;
			if (decoder.eof) break;
		}
	}

	// Finish the decoding of the pushed bytes, returning a valid module upon
	// success, or an error.
	def finish() -> BinParserResult {
		finished = true;
		decoder.reset_eof();
		// Run the decode loop to flush out EOF errors.
		decodeLoop();
		decoder.finish();

		if (err.ok()) return BinParserResult.Ok(module);

		return BinParserResult.Error(err.error_code, filename,
				err.error_pos, err.error_msg);
	}

	private def readHeader() {
		var p1 = decoder.pos, magic = decoder.read_u32();
		if (decoder.eof) {
			return retry(p1, 8, p1, WasmError.INVALID_HEADER,
					"EOF: expecting magic word", (), ());
		}
		if (magic != WASM_MAGIC) {
			return err.fail2(p1, WasmError.INVALID_HEADER,
					"incorrect Wasm magic word %x, expected %x",
					magic, WASM_MAGIC);
		}
		var p2 = decoder.pos, version = decoder.read_u32();
		if (decoder.eof) {
			return retry(p1, 4, p2, WasmError.INVALID_HEADER,
					"EOF: expecting version", (), ());
		}
		if (version != WASM_VERSION) {
			return err.fail2(p2, WasmError.INVALID_HEADER,
					"incorrect Wasm version %d, expected %d",
					version, magic);
		}
		if (err.ok()) state = BpState.SECTIONS;
	}

	private def retry0(pos: int, expect: int) -> bool {
		if (verbose) {
			trace.put2("[rewind to +%d, expecting %d]\n", pos, expect);
			flush();
		}
		if (finished) return false;
		decoder.at(pos);
		size_estimate = if (expect > 0,
			if (expect < MAX_SIZE_ESTIMATE, expect, MAX_SIZE_ESTIMATE));
		return true;
	}
	private def retry<A, B>(pos: int, expect: int, error_pos: int,
			error: WasmError, msg: string, a: A, b: B) {
		if (!retry0(pos, expect)) {
			err.fail2(error_pos, error, msg, a, b);
		}
	}

	private def readSection() {
		var start = decoder.pos;
		var code = readByte("section code", renderSectionName);
		var size_pt = decoder.pos;
		var size = readU32("section size", 0, Limits.max_module_size);
		if (!err.ok()) return;
		if (verbose) {
			trace.put3("=>section code=%d (%q), size=%d\n",
				code, renderSectionName(_, code), size);
			flush();
		}
		if (decoder.eof) {
			return retry(start, 5, size_pt, WasmError.INCOMPLETE_SECTION,
					"EOF: expecting size for %q section",
					renderSectionName(_, code), ());
		}

		current_section = code;
		var body_pt = decoder.pos;
		// Check for duplicate sections
		if (code != 0 && code < seen_sections.length && seen_sections[code]) {
			return err.fail1(start, WasmError.DUPLICATE_SECTION,
				"duplicate %q section", renderSectionName(_, code));
		}

		// The code section has a special state: function bodies are
		// handled individually.
		if (code == BpSection.Code.code) {
			// Transition into reading code section
			var num_functions = readU32("function body count", 0, Limits.max_num_functions);
			if (decoder.eof) {
				return retry(start, 5, size_pt, WasmError.INCOMPLETE_SECTION,
					"EOF: expecting count in code section",
					(), ());
			}
			if (num_functions != module.functions.declared.size()) {
				return err.fail2(body_pt, WasmError.FUNC_COUNT_MISMATCH,
					"expecting %d function bodies, got %d",
					module.functions.declared.size(), num_functions);
			}
			seen_sections[code] = true;
			state = BpState.FUNCTIONS;
			expected_code_size = size;
			code_start = decoder.abs(body_pt);
			return;
		}

		// For all other sections, rewind if they are not complete.
		if (!decoder.check_bytes(int.!(size))) {
			return retry(start, int.!(size), decoder.pos, WasmError.INCOMPLETE_SECTION,
					"EOF: incomplete %q section", renderSectionName(_, code), ());
		}

		// For valid sections, record that the section has now been seen.
		if (code >= 0 && code < seen_sections.length) {
			seen_sections[code] = true;
		}

		match (code) {
			0 => readCustomSection(size);
			BpSection.Type.code => readMultiple("types", size,
				Limits.max_num_types, module.types.declared, readTypeDecl);
			BpSection.Import.code => readMultiple("imports", size,
				Limits.max_num_imports, module.imports, readImportDecl);
			BpSection.Function.code => readMultiple("functions", size,
				Limits.max_num_functions, module.functions.declared, readFunctionDecl);
			// TODO: enforce maximum number of tables
			BpSection.Table.code => readMultiple("tables", size,
				Limits.max_num_tables, module.tables.declared, readTableDecl);
			// TODO: enforce maximum number of memories
			BpSection.Memory.code => readMultiple("memories", size,
				Limits.max_num_memories, module.memories.declared, readMemoryDecl);
			BpSection.Global.code => readMultiple("globals", size,
				Limits.max_num_globals, module.globals.declared, readGlobalDecl);
			BpSection.Export.code => readMultiple("exports", size,
				Limits.max_num_exports, module.exports, readExportDecl);
			BpSection.Start.code =>
				readStartSection();
			BpSection.Element.code => readMultiple("elements", size,
				Limits.max_num_table_entries, module.elems, readElemDecl);
			BpSection.Data.code => readMultiple("data", size,
				Limits.max_num_data_segments, module.data, readDataDecl);
			_ => return err.fail1(start, WasmError.INVALID_SECTION,
				"unknown section code %x", code);
	       }

		// Check that the size of bytes read equals the section's declared size
		var read = decoder.pos - body_pt;
		traceBuffer();
		checkReadSize(code, body_pt, size);
	}
	private def checkReadSize(code: byte, body_pt: int, size: u32) {
		var read = decoder.pos - body_pt;
		if (read < size) {
			var pt = decoder.abs_pos();
			err.fail2(pt, WasmError.INCOMPLETE_SECTION,
				"expected section size of %d, read %d bytes", size, read);
		} else if (read > size) {
			var pt = decoder.abs(decoder.pos - (read - int.!(size)));
			err.fail2(pt, WasmError.OVERFLOW_SECTION,
				"expected section size of %d, read %d bytes", size, read);
		}
	}

	private def readCustomSection(size: u32) {
		var start = decoder.pos;
		var name_len = readU32("name length", 0, Limits.max_module_size);
		var name = decoder.read_bytes(int.!(name_len));
		var payload_len = int.!(size) - (decoder.pos - start);
		if (payload_len < 0) {
			return err.fail2(start, WasmError.OVERFLOW_SECTION,
				"custom section name length %d exceeds section size %d", name_len, size);
		}
		var payload = decoder.read_bytes(payload_len);
		module.custom_sections.add(CustomSection.new(name, payload));
	}
	private def readMultiple<T>(thing_name: string, size: u32,
		max: u32, vec: Vector<T>, read: int -> T) {
		var max_pt = decoder.pos + int.!(size);
		var count = readU32(thing_name, 0, max);
		if (!err.ok()) return;
		if (count < MAX_GROW_SIZE) vec.grow(int.!(count));
		for (index < int.!(count)) {
			if (verbose) {
				trace.put2("==>%s #%d\n", thing_name, index);
				flush();
			}
			if (decoder.pos >= max_pt) {
				err.fail1(decoder.abs(max_pt),
					WasmError.OVERFLOW_SECTION,
				"expected section size of %d bytes", size);
			}
			var thing = read(index);
			vec.set(index, thing);
		}
	}
	private def readTypeDecl(index: int) -> TypeDecl {
		var pt = decoder.pos, invalid: TypeDecl;
		var form = readByte("type constructor", renderTypecon);
		if (form != BpTypecon.Function.code) {
			err.fail2(pt, WasmError.INVALID_TYPE,
				"invalid type %x, expected function (%x)",
				form, BpTypecon.Function.code);
			return invalid;
		}
		pt = decoder.pos;
		var param_count = readU32("param count", 0, Limits.max_num_func_params);
		if (!err.ok()) return invalid;
		var ptypes = Array<ValueType>.new(int.!(param_count));
		for (j < param_count) {
			ptypes[int.!(j)] = readValueType();
		}
		var ret_count = readU32("result count", 0, Limits.max_num_func_results);
		if (!err.ok()) return invalid;
		var rtypes = Array<ValueType>.new(int.!(ret_count));
		for (j < ret_count) {
			rtypes[int.!(j)] = readValueType();
		}
		return TypeDecl.Function(ptypes, rtypes);
	}
	private def readImportDecl(index: int) -> ImportDecl {
		var module_name = readString("import module name");
		var field_name = readString("import field name");
		var pt = decoder.pos;
		var kind = readByte("import kind", renderImportKind);
		var result: ImportDecl;
		var details: ImportDetails;
		match (kind) {
			BpImportExportKind.Function.code => {
				var sig = readSig();
				var decl = FunctionDecl.new(module.functions.size(), sig.0, sig.1);
				module.functions.imported.add(decl);
				details = ImportDetails.Function(decl);
			}
			BpImportExportKind.Table.code => {
				var et = readElemType();
				var l = readLimits("table", Limits.max_table_size);
				var decl = TableDecl.new(module.tables.size(), et, l.0, l.1);
				module.tables.imported.add(decl);
				details = ImportDetails.Table(decl);
			}
			BpImportExportKind.Memory.code => {
				var l = readMemoryLimits("memory", Limits.max_memory_pages);
				var decl = MemoryDecl.new(module.memories.size(), l.0, l.1, l.2);
				module.memories.imported.add(decl);
				details = ImportDetails.Memory(decl);
			}
			BpImportExportKind.Global.code => {
				var t = readValueType();
				var mut = readByte("flags", renderGlobalFlags) != 0;
				var decl = GlobalDecl.new(module.globals.size(), t, mut, InitExpr.I32(0));
				module.globals.imported.add(decl);
				details = ImportDetails.Global(decl);
			}
			_ => err.fail1(pt, WasmError.INVALID_IMPORT_KIND,
				"invalid import kind %x", kind);
		}
		return ImportDecl.new(module_name, field_name, details);
	}
	private def readFunctionDecl(index: int) -> FunctionDecl {
		var pt = decoder.pos;
		var sig = readSig();
		return FunctionDecl.new(module.functions.size(), sig.0, sig.1);
	}
	private def readTableDecl(index: int) -> TableDecl {
		var et = readElemType();
		var l = readLimits("table", Limits.max_table_size);
		return TableDecl.new(module.tables.size(), et, l.0, l.1);
	}
	private def readMemoryDecl(index: int) -> MemoryDecl {
		var l = readMemoryLimits("memory", Limits.max_memory_pages);
		return MemoryDecl.new(module.memories.size(), l.0, l.1, l.2);
	}
	private def readGlobalDecl(index: int) -> GlobalDecl {
		var vt = readValueType();
		var mut = readByte("flags", renderGlobalFlags) != 0;
		var pos = decoder.pos;
		var init = readInitExpr("global initializer"), vti = init.1;
		if (!ValueTypes.isAssignable(vti, vt)) {
			err.fail2(decoder.abs(pos), WasmError.TYPE_MISMATCH,
				"expected type %q in global initializer, got %q",
				ValueTypes.render(_, vt), ValueTypes.render(_, vti));
		}
		return GlobalDecl.new(module.globals.size(), vt, mut, init.0);
	}
	private def readExportDecl(index: int) -> ExportDecl {
		var name = readString("export name");
		var pt = decoder.pos;
		var kind = readByte("export kind", renderImportKind);
		var details: ExportDetails;
		match (kind) {
			BpImportExportKind.Function.code => {
				var index = readFunc().0;
				details = ExportDetails.Function(index);
			}
			BpImportExportKind.Table.code => {
				var index = readTableIndex();
				details = ExportDetails.Table(index);
			}
			BpImportExportKind.Memory.code => {
				var index = readMemoryIndex();
				details = ExportDetails.Memory(index);
			}
			BpImportExportKind.Global.code => {
				var index = readGlobal().0;
				details = ExportDetails.Global(index);
			}
			_ => err.fail1(pt, WasmError.INVALID_IMPORT_KIND,
				"invalid export kind %x", kind);
		}
		return ExportDecl.new(name, details);
	}
	private def readElemDecl(index: int) -> ElemDecl {
		var pt = decoder.pos;
		var flags = readByte("data flags", renderNone);
		var active = true, table_index = 0, init_exprs = false;
		if (Extensions.bulk_memory) {
			if ((flags & 1) == 1) active = false;
			if ((flags & 2) == 2) table_index = readTableIndex();
			if ((flags & 4) == 4) init_exprs = true;
		} else if (flags != 0) {
			err.fail1(pt, WasmError.EXPECTED_ZERO_BYTE,
				"expected zero byte for elements, got %x", flags);
		} else {
			table_index = checkIndex(pt, "table index", 0, module.tables).0;
		}
		var offset = readI32Expr("elements offset");
		var count = readU32("element count", 0, Limits.max_num_table_entries);
		var details: ElemDetails;
		if (init_exprs) { // init expressions
			var array = Array<InitExpr>.new(int.!(count));
			for (i < int.!(count)) {
				// TODO: typecheck init exprs for elements
				array[i] = readInitExpr("element").0;
			}
			details = ElemDetails.Exprs(array);
		} else {  // function indices
			var array = Array<int>.new(int.!(count));
			for (i < int.!(count)) {
				array[i] = readFunc().0;
			}
			details = ElemDetails.FuncRefs(array);
		}
		return ElemDecl.new(table_index, offset, details, active);
	}
	private def readDataDecl(index: int) -> DataDecl {
		var pt = decoder.pos;
		var flags = readByte("data flags", renderNone);
		var active = true, mem_index = 0;
		if (Extensions.bulk_memory) {
			if ((flags & 1) == 1) {
				active = false;
				mem_index = readMemoryIndex();
			}
		} else if (flags != 0) {
			err.fail1(pt, WasmError.EXPECTED_ZERO_BYTE,
				"expected zero byte for data segment, got %x", flags);
		}
		checkIndex(pt, "memory index", u32.!(mem_index), module.memories);
		var offset = readI32Expr("data element offset");
		var len = readU32("data segment size", 0, Limits.max_data_segment_size);
		var data = decoder.read_bytes(int.!(len));
		return DataDecl.new(mem_index, offset, data, active);
	}
	private def readStartSection() {
		module.start_function = readFunc().0;
	}

	def readLimits(quantity: string, limit: u32) -> (int, int) {
		var flags = readByte("flags", renderLimitFlags);
		var min = readU32("initial", 0, limit);
		var has_max = (flags & 1) == 1;
		var max = -1;
		if (has_max) {
			var pt = decoder.pos;
			var m = readU32("maximum", min, limit);
			max = int.!(max);
		}
		return (int.!(min), max);
	}
	def readMemoryLimits(quantity: string, limit: u32) -> (int, int, bool) {
		var pt = decoder.pos;
		var flags = readByte("flags", renderLimitFlags);
		var min = readU32("initial", 0, limit);
		var has_max = (flags & 1) == 1;
		var max = -1, shared = false;
		if (has_max) {
			var pt = decoder.pos;
			var m = readU32("maximum", min, limit);
			max = int.!(max);
		}
		if (Extensions.threads) {
			shared = (flags & 2) == 2;
			if (shared && !has_max) {
				err.fail(pt, WasmError.EXPECTED_MAXIMUM,
					"shared memory must have maximum");
			}
		}
		return (int.!(min), max, shared);
	}
	def readElemType() -> ElemType {
		var pt = decoder.pos;
		var b = readByte("element type", renderTypecon);
		var et: ElemType;
		match (b) {
			BpTypecon.AnyFunc.code => et = ElemType.FuncRef;
			BpTypecon.AnyRef.code => et = ElemType.AnyRef;
			_ => err.fail1(pt, WasmError.ILLEGAL_TYPE,
				"invalid table element type %x", b);
		}
		return et;
	}
	def readI32Expr(quantity: string) -> InitExpr {
		var pt = decoder.pos;
		var init = readInitExpr(quantity), vt = init.1;
		if (!ValueTypes.isAssignable(vt, ValueType.I32)) {
			err.fail1(pt, WasmError.TYPE_MISMATCH,
				"expected i32 init expr, got %q",
				ValueTypes.render(_, vt));
		}
		return init.0;
	}
	def readInitExpr(quantity: string) -> (InitExpr, ValueType) {
		var pt = decoder.pos, expr: InitExpr;
		def opcode = readByte("opcode", Opcodes.render);
		var vt: ValueType;
		match (opcode) {
			Opcode.I32_CONST.code => {
				var val = readU32("i32 constant", 0, u32.max);
				expr = InitExpr.I32(int.!(val));
				vt = ValueType.I32;
			}
			Opcode.I64_CONST.code => {
				var val = readU64("i64 constant");
				expr = InitExpr.I64(long.!(val));
				vt = ValueType.I64;
			}
			Opcode.F32_CONST.code => {
				var val = decoder.read_u32();
				expr = InitExpr.F32(val);
				vt = ValueType.F32;
			}
			Opcode.F64_CONST.code => {
				var val = decoder.read_u64();
				expr = InitExpr.F64(val);
				vt = ValueType.F64;
			}
			Opcode.GLOBAL_GET.code => {
				var g = readGlobal();
				expr = InitExpr.Global(g);
				if (g.1 != null) vt = g.1.valtype;
			}
			_ => {
				err.fail2(pt, WasmError.INVALID_INIT_EXPR,
					"unexpected opcode %x (%q) in init expression", opcode,
					Opcodes.render(_, opcode));
			}
		}
		pt = decoder.pos;
		var end = readByte("end opcode", Opcodes.render);
		if (end != Opcode.END.code) {
			err.fail2(pt, WasmError.INVALID_INIT_EXPR,
				"expected %x (END) opcode, got %x", Opcode.END.code, end);
		}
		return (expr, vt);
	}
	private def readFunctionBody() {
		if (cur_function == module.functions.declared.size()) {
			state = BpState.SECTIONS;
			var read = decoder.abs_pos() - code_start;
			var logical_body_pt = decoder.pos - read;
			checkReadSize(BpSection.Code.code, logical_body_pt,
					expected_code_size);
			return;
		}
		var start = decoder.pos;
		var size = readU32("function size", 0, Limits.max_func_size);
		if (decoder.eof) {
			return retry(start, 5, start, WasmError.INCOMPLETE_FUNCTION_BODY,
					"EOF: expecting function body size", (), ());
		}
		var body = decoder.read_bytes(int.!(size));
		if (decoder.eof) {
			return retry(start, int.!(size), start, WasmError.INCOMPLETE_FUNCTION_BODY,
					"EOF: incomplete function body", (), ());
		}
		var f = module.functions.declared[cur_function++];
		f.code = FunctionCode.new(body);
	}

	private def checkSectionConstraints() {
		// TODO
	}
}
type BinParserResult {
	case Ok(module: Module) { }
	case Error(code: WasmError, filename: string, error_pos: int, error_msg: string) { }
}
// Internal constants.
def MAX_SIZE_ESTIMATE = 16 * 1024 * 1024;
def MAX_GROW_SIZE = 1000000;
// Header constants.
def WASM_MAGIC = 0x6d736100u;
def WASM_VERSION = 0x01u;
// Selects the amount of tracing output printed by the decoder.
enum Verbosity {
	SILENT,	    // no output
	DIAGNOSTIC, // summarizes sections prior to error, verbose near error
	VERBOSE	    // details for everything printed
}
// Used internally in the binary parser.
enum BpState {
	HEADER,
	SECTIONS,
	FUNCTIONS
}
def renderSectionName(buf: StringBuffer, b: byte) -> StringBuffer {
	var s = "unknown";
	match (b) {
		BpSection.Type.code => s = "type";
		BpSection.Import.code => s = "import";
		BpSection.Function.code => s = "function";
		BpSection.Table.code => s = "table";
		BpSection.Memory.code => s = "memory";
		BpSection.Global.code => s = "global";
		BpSection.Export.code => s = "export";
		BpSection.Start.code => s = "start";
		BpSection.Element.code => s = "element";
		BpSection.Code.code => s = "code";
		BpSection.Data.code => s = "data";
	}
	return buf.puts(s);
}
def renderImportKind(buf: StringBuffer, b: byte) -> StringBuffer {
	var s = "unknown";
	match (b) {
		BpImportExportKind.Function.code => s = "function";
		BpImportExportKind.Table.code => s = "table";
		BpImportExportKind.Memory.code => s = "memory";
		BpImportExportKind.Global.code => s = "global";
	}
	return buf.puts(s);
}
def renderTypecon(buf: StringBuffer, b: byte) -> StringBuffer {
	var s = "unknown";
	match (b) {
		BpTypecon.I32.code => s = "i32";
		BpTypecon.I64.code => s = "i64";
		BpTypecon.F32.code => s = "f32";
		BpTypecon.F64.code => s = "f64";
		BpTypecon.VEC128.code => s = "vec128";
		BpTypecon.AnyFunc.code => s = "anyfunc";
		BpTypecon.AnyRef.code => s = "anyref";
		BpTypecon.Function.code => s = "func";
		BpTypecon.EmptyBlock.code => s = "empty";
	}
	return buf.puts(s);
}
def renderNone(buf: StringBuffer, b: byte) -> StringBuffer {
	return buf;
}
def renderMemFlags(buf: StringBuffer, v: u32) -> StringBuffer {
	return buf.put1("align=%d", v);
}
def renderGlobalFlags(buf: StringBuffer, b: byte) -> StringBuffer {
	if ((b & 1) == 1) buf.puts("mutable");
	return buf;
}
def renderLimitFlags(buf: StringBuffer, b: byte) -> StringBuffer {
	if ((b & 1) == 1) buf.puts("has_max");
	if ((b & 2) == 2) buf.puts(" shared");
	return buf;
}
def EMPTY: Array<ValueType> = [];
def FUNC_VEC128 = TypeDecl.Function(EMPTY, [ValueType.VEC128]);
def FUNC_ANYREF = TypeDecl.Function(EMPTY, [ValueType.ANYREF]);
// A binary parser customized to immediates.
class BinImmParser extends WasmParser {
	new(module: Module, decoder: Decoder) super(module) {
		this.decoder = decoder;
	}
	// skip an immediate of the given kind and return its size
	def skipImm(kind: ImmKind) -> int {
		var pt = decoder.pos;
		match (kind) {
			NONE => ;
			BLOCK_TYPE => readBlockType();
			LABEL => readLabel();
			LABELS => readLabels();
			FUNC_INDEX => readFunc();
			SIG_TABLE_INDEX => { readSig(); readTableIndex(); }
			LOCAL_INDEX => readLocalIndex();
			GLOBAL_INDEX => readGlobal();
			MEMORY_INDEX => readMemoryIndex();
			MEMARG => readMemoryArg();
			I32 => readI32();
			I64 => readI64();
			F32 => readF32();
			F64 => readF64();
		}
		return decoder.pos - pt;
	}
	def readBlockType() -> TypeDecl.Function {
		var pt = decoder.pos, b = readByte("block type", renderTypecon);
		match (b) {
			BpTypecon.EmptyBlock.code => return SigCache.v_v;
			BpTypecon.I32.code => return SigCache.v_i;
			BpTypecon.I64.code => return SigCache.v_l;
			BpTypecon.F32.code => return SigCache.v_f;
			BpTypecon.F64.code => return SigCache.v_d;
			BpTypecon.VEC128.code => return FUNC_VEC128;
			BpTypecon.AnyRef.code => return FUNC_ANYREF;
		}
		decoder.at(pt); // backup and try again as full signed LEB
		var index = decoder.read_i32leb(), r: TypeDecl.Function;
		if (index < 0 || index > module.types.size()) {
			err.fail1(pt, WasmError.INVALID_BLOCK_TYPE,
				"invalid block type %d", index);
			return r;
		}
		var t = module.types[index];
		if (TypeDecl.Function.?(t)) {
			return TypeDecl.Function.!(t);
		} else {
			var d: TypeDecl.Function;
			err.fail1(pt, WasmError.ILLEGAL_BLOCK_TYPE,
				"expected type index %d to be a function", index);
			return r;
		}
	}
	def readLabel() -> u32 {
		var depth = decoder.read_u32leb();
		return depth;
	}
	def readLabels() -> Array<u32> {
		var pt = decoder.pos;
		var count = decoder.read_u32leb(), max = Limits.max_func_size;
		if (count > max) {
			err.fail2(pt, WasmError.EXCEEDED_LIMIT,
				"target count %d exceeds maximum %d", count, max);
			return null;
		}
		var length = int.!(count + 1);
		var result = Array<u32>.new(length);
		for (i < length) result[i] = decoder.read_u32leb();
		return result;
	}
	def readLocalIndex() -> u32 {
		var index = decoder.read_u32leb();
		return index;
	}
	def readMemoryArg() -> (u32, int, u32) {
		var pt = decoder.pos;
		var flags = readU32("memarg flags", 0, u32.max); // TODO render
		var mem_index = 0;
		if (Extensions.multi_memory && (flags & 0x40) != 0) {
			mem_index = readMemoryIndex();
			flags ^= 0x40;  // flip flag back
		} else {
			checkIndex(pt, "memory index", 0, module.memories);
		}
		var offset = readU32("memarg offset", 0, u32.max);
		return (flags, mem_index, offset);
	}
	def readI32() -> u32 {
		var val = decoder.read_u32leb();
		return val;
	}
	def readI64() -> u64 {
		var val = decoder.read_u64leb();
		return val;
	}
	def readF32() -> u32 {
		var val = decoder.read_u32();
		return val;
	}
	def readF64() -> u64 {
		var val = decoder.read_u64();
		return val;
	}
}
// Contains common routines for the module parser and function body parser.
class WasmParser(module: Module) {
	def err = WasmErrorGen.new(module.filename);
	var decoder = Decoder.new([], err);
	var verbose = false;
	def trace = StringBuffer.new();

	def readTableIndex() -> int {
		return readIndex("table index", module.tables).0;
	}
	def readSig() -> (int, TypeDecl.Function) {
		var pt = decoder.pos;
		var r = readIndex("signature index", module.types);
		if (TypeDecl.Function.?(r.1)) {
			return (r.0, TypeDecl.Function.!(r.1));
		} else {
			var d: TypeDecl.Function;
			err.fail1(pt, WasmError.ILLEGAL_TYPE,
				"expected type index %d to be a function", r.0);
			return (r.0, d);
		}
	}
	def readFunc() -> (int, FunctionDecl) {
		return readIndex("function index", module.functions);
	}
	def readMemoryIndex() -> int {
		return readIndex("memory index", module.memories).0;
	}
	def readGlobal() -> (int, GlobalDecl) {
		return readIndex("global index", module.globals);
	}
	def readIndex<T>(quantity: string, space: IndexSpace<T>) -> (int, T) {
		var pt = decoder.pos;
		var index = decoder.read_u32leb();
		if (verbose) {
			traceBytes(pt, quantity);
			trace.putd(index).ln();
			flush();
		}
		return checkIndex(pt, quantity, index, space);
	}
	def checkIndex<T>(pt: int, quantity: string, index: u32, space: IndexSpace<T>) -> (int, T) {
		var t: T, max = space.size();
		if (index < max) {
			t = space[int.!(index)];
		} else {
			err.fail3(pt, WasmError.OOB_INDEX,
				"%s %d exceeds maximum %d", quantity, index, max);
		}
		return (int.!(index), t);
	}
	def readValueType() -> ValueType {
		var pt = decoder.pos, b = readByte("type constructor", renderTypecon);
		match (b) {
			BpTypecon.I32.code => return ValueType.I32;
			BpTypecon.I64.code => return ValueType.I64;
			BpTypecon.F32.code => return ValueType.F32;
			BpTypecon.F64.code => return ValueType.F64;
			BpTypecon.VEC128.code => return ValueType.VEC128;
			BpTypecon.AnyRef.code => return ValueType.ANYREF;
		}
		err.fail1(pt, WasmError.INVALID_TYPE,
			"invalid value type %x", b);
		return ValueType.I32;
	}
	def readU32(quantity: string, min: u32, max: u32) -> u32 {
		var pt = decoder.pos;
		var val = decoder.read_u32leb();
		if (decoder.eof) return 0;
		if (val < min) err.fail3(pt, WasmError.EXCEEDED_LIMIT,
			"%s %d exceeds minimum %d", quantity, val, min);
		if (val > max) err.fail3(pt, WasmError.EXCEEDED_LIMIT,
			"%s %d exceeds maximum %d", quantity, val, max);
		if (verbose) {
			traceBytes(pt, quantity);
			trace.putd(val).ln();
			flush();
		}
		return val;
	}
	def readU64(quantity: string) -> u64 {
		var pt = decoder.pos;
		var val = decoder.read_u64leb();
		if (decoder.eof) return 0;
		if (verbose) {
			traceBytes(pt, quantity);
			trace.putd(val).ln();
			flush();
		}
		return val;
	}
	def readString(quantity: string) -> string {
		var len = readU32("string length", 0, Limits.max_module_size);
		var pt = decoder.pos;
		var str = decoder.read_bytes(int.!(len));
		if (verbose) {
			traceBytes(pt, quantity);
			trace.puts("\"");
			var max = 24;
			var count = decoder.pos - pt;
			for (i = 0; i < count && i < max; i++) {
				trace.put1("%c", toPrintableChar(decoder.data[pt + i]));
			}
			trace.puts("\"\n");
			flush();
		}
		return str;
	}
	def readByte(quantity: string, render: (StringBuffer, byte) -> StringBuffer) -> byte {
		var pt = decoder.pos;
		var r = decoder.read_u8();
		if (verbose) {
			traceBytes(pt, quantity);
			trace.put2("%d (%q)\n", r, render(_, r));
			flush();
		}
		return r;
	}

	def traceBytes(pt: int, quantity: string) -> StringBuffer {
		if (quantity == null) return trace;
		var count = decoder.pos - pt;
		trace.put1("%x: ", decoder.abs(pt));
		for (i < count) {
			if (i > 0 && (i % 8) == 0) trace.puts("\n         ");
			trace.put1("%x ", decoder.data[pt + i]);
		}
		var rounded = ((count + 7) / 8) * 8;
		for (i < rounded - count) trace.puts("   ");
		trace.put1(" %s = ", quantity);
		return trace;
	}

	def traceBuffer() {
		if (!verbose) return;
		trace.put2("[buf@+%d limit=%d ", decoder.pos, decoder.limit);
		if (decoder.eof) trace.puts("eof ");
		if (err.error_pos < int.max) {
			trace.put1("err@+%d ", err.error_pos);
		}
		if (err.error_msg != null) {
			trace.put1("msg=\"%s\"", err.error_msg);
		}
		trace.putc(']').ln();
		flush();
	}

	def toPrintableChar(b: byte) -> byte {
		if (b < ' ' || b > 127) b = '.';
		return b;
	}
	def flush() {
		trace.out(STDOUT);
		trace.reset();
	}
}
def STDOUT = System.fileWriteK(1, _, _, _);

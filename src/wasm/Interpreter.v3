// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Interpreter for Wasm bytecode.
def EMPTY: Array<byte> = [];
class Interpreter extends Executor {
	def val_stack = Stack<Value>.new();
	def call_stack = Stack<Frame>.new();
	def codeptr = Decoder.new(EMPTY);
	var frame: Frame;	// cache of top-of-stack
	var state: ExecState;
	var trap_reason: TrapReason;
	var error_msg: string;
	var step_count: int;
	var traceSteps: bool;
	var trace = StringBuffer.new(); // TODO: allocate lazily

	def run(count: int, f: Function, args: Array<Value>) -> Result {
		val_stack.resize(0);
		if (args != null) for (a in args) val_stack.push(a);
		doCallFunction(f);
		loop(count);
		match (state) {
			FINISHED => {
				var r = Array<Value>.new(f.sig.results.length);
				for (i < r.length) r[i] = val_stack.elems[i];
				return Result.Value(r);
			}
			TRAPPED => return Result.Trap(trap_reason);
			PAUSED, BREAKPOINT => return Result.Break;
			_ => System.error("InterpreterError", "unexpected state");
		}
		return Result.Break;
	}

	def pushFrame(f: WasmFunction) {
		var nf = call_stack.next();
		if (nf != null) {  // reuse cached Frame object if possible
			call_stack.top++;
		} else {
			nf = Frame.new();
			call_stack.push(nf);
		}
		var sp = val_stack.top;
		nf.fp = sp - f.decl.sig.params.length;
		val_stack.resize(sp + f.decl.code.num_locals);
		nf.func = f;
		// Initialize locals
		nf.pc = 0;
		var code = f.decl.code.code;
		codeptr.reset(code, 0, code.length);
		var count = codeptr.read_u32leb();
		for (i < count) {
			var d = codeptr.read_u32leb();
			var t = codeptr.read_u8();
			var val: Value;
			match (t) {
				BpTypecon.I32.code => val = Values.I32_0;
				BpTypecon.I64.code => val = Values.I64_0;
				BpTypecon.F32.code => val = Values.F32_0;
				BpTypecon.F64.code => val = Values.F64_0;
				_ => error("invalid local value type");
			}
			for (i < d) val_stack.elems[sp++] = val;
		}
		nf.pc = codeptr.pos;
		frame = nf;
	}

	private def loop(count: int) -> ExecState {
		match (state) {
			PAUSED,
			RUNNING,
			RESUME,
			STOPPED => state = ExecState.RUNNING;
			BREAKPOINT => state = ExecState.RESUME;
			FINISHED,
			TRAPPED => return state;
		}
		if (count <= 0) {
			// Run until exhaustion.
			while (true) {
				var completed = step();
				if (completed) step_count++;
				if (state != ExecState.RUNNING) break;
			}
		} else {
			// Run for a limited number of steps.
			while (count-- > 0) {
				var completed = step();
				if (completed) step_count++;
				if (state != ExecState.RUNNING) break;
			}
		}
		return state;
	}
	// Execute a single instruction. Return {true} if the instruction was completed.
	def step() -> bool {
		var pc = codeptr.pos;
		var opcode = codeptr.read_u8();
		if (traceSteps) traceStep(pc, opcode);
		while (true) {
			match (opcode) {
				WasmOpcode.UNREACHABLE.code => {
					trap(TrapReason.UNREACHABLE);
				}
				WasmOpcode.NOP.code => {
					// do nothing
				}
				WasmOpcode.BLOCK.code,
				WasmOpcode.LOOP.code => {
					codeptr.read_u32leb(); // skip blocktype
				}
				WasmOpcode.IF.code => {
					codeptr.read_u32leb(); // skip blocktype
					var cond = popi32();
					if (cond == 0) codeptr.pos = doBranch(pc);
				}
				WasmOpcode.ELSE.code => {
					codeptr.pos = doBranch(pc);
				}
				WasmOpcode.END.code => {
					if (codeptr.available() == 0) doReturn();
				}
				WasmOpcode.BR.code => {
					codeptr.pos = doBranch(pc);
				}
				WasmOpcode.BR_IF.code => {
					var cond = popi32();
					if (cond == 0) codeptr.read_u32leb();  // read and skip label
					else codeptr.pos = doBranch(pc);
				}
				WasmOpcode.BR_TABLE.code => {
					var key = popu32();
					codeptr.pos = doSwitch(pc, key);
				}
				WasmOpcode.RETURN.code => {
					doReturn();
				}
				WasmOpcode.CALL.code => {
					var func_index = codeptr.read_u32leb();
					doCall(func_index);
				}
				WasmOpcode.CALL_INDIRECT.code => {
					var sig_index = codeptr.read_u32leb();
					var table_index = codeptr.read_u32leb();
					var func_index = popu32();
					doCallIndirect(sig_index, table_index, func_index);
				}
				WasmOpcode.DROP.code => {
					pop();
				}
				WasmOpcode.SELECT.code => {
					var cond = popu32();
					var a = pop();
					var b = pop();
					push(if(cond != 0, a, b));
				}
				WasmOpcode.LOCAL_GET.code => {
					var index = codeptr.read_u32leb();
					push(val_stack.elems[frame.fp + int.!(index)]);
				}
				WasmOpcode.LOCAL_SET.code => {
					var index = codeptr.read_u32leb();
					val_stack.elems[frame.fp + int.!(index)] = pop();
				}
				WasmOpcode.LOCAL_TEE.code => {
					var index = codeptr.read_u32leb();
					val_stack.elems[frame.fp + int.!(index)] = val_stack.peek();
				}
				WasmOpcode.GLOBAL_GET.code => {
					var index = codeptr.read_u32leb();
					push(frame.func.instance.globals[int.!(index)].value);
				}
				WasmOpcode.GLOBAL_SET.code => {
					var index = codeptr.read_u32leb();
					frame.func.instance.globals[int.!(index)].value = pop();
				}

				// TODO: Loads and stores

				WasmOpcode.MEMORY_SIZE.code => {
					var index = codeptr.read_u32leb();
					var pages = frame.func.instance.memories[int.!(index)].size();
					pushu32(pages);
				}
				WasmOpcode.MEMORY_GROW.code => {
					var index = codeptr.read_u32leb();
					var result = frame.func.instance.memories[int.!(index)].grow(popu32());
					pushu32(u32.!(result));
				}
				WasmOpcode.I32_CONST.code => {
					var val = codeptr.read_u32leb();
					pushu32(val);
				}
				WasmOpcode.I64_CONST.code => {
					var val = codeptr.read_u64leb();
					pushu64(val);
				}
				WasmOpcode.F32_CONST.code => {
					var val = codeptr.read_u32();
					push(Value.F32(val));
				}
				WasmOpcode.F64_CONST.code => {
					var val = codeptr.read_u64();
					push(Value.F64(val));
				}

				WasmOpcode.I32_EQZ.code => pushbool(popu32() == 0);
				WasmOpcode.I32_EQ.code => pushbool(popu32() == popu32());
				WasmOpcode.I32_NE.code => pushbool(popu32() != popu32());
				WasmOpcode.I32_LT_S.code => pushbool(popi32() < popi32());
				WasmOpcode.I32_LT_U.code => pushbool(popu32() < popu32());
				WasmOpcode.I32_GT_S.code => pushbool(popi32() > popi32());
				WasmOpcode.I32_GT_U.code => pushbool(popu32() > popu32());
				WasmOpcode.I32_LE_S.code => pushbool(popi32() <= popi32());
				WasmOpcode.I32_LE_U.code => pushbool(popu32() <= popu32());
				WasmOpcode.I32_GE_S.code => pushbool(popi32() >= popi32());
				WasmOpcode.I32_GE_U.code => pushbool(popu32() >= popu32());

				WasmOpcode.I64_EQZ.code => pushbool(popu64() == 0);
				WasmOpcode.I64_EQ.code => pushbool(popu64() == popu64());
				WasmOpcode.I64_NE.code => pushbool(popu64() != popu64());
				WasmOpcode.I64_LT_S.code => pushbool(popi64() < popi64());
				WasmOpcode.I64_LT_U.code => pushbool(popu64() < popu64());
				WasmOpcode.I64_GT_S.code => pushbool(popi64() > popi64());
				WasmOpcode.I64_GT_U.code => pushbool(popu64() > popu64());
				WasmOpcode.I64_LE_S.code => pushbool(popi64() <= popi64());
				WasmOpcode.I64_LE_U.code => pushbool(popu64() <= popu64());
				WasmOpcode.I64_GE_S.code => pushbool(popi64() >= popi64());
				WasmOpcode.I64_GE_U.code => pushbool(popu64() >= popu64());

				// TODO: floating point comparisons

				WasmOpcode.I32_CLZ.code => {
					var x = popu32();
					var count = 0;
					if (x == 0) pushi32(32);
					else {
						while ((x & 0x80000000u) == 0) { count++; x <<= 1; }
						pushi32(count);
					}
				}
				WasmOpcode.I32_CTZ.code => {
					var x = popu32();
					var count = 0;
					if (x == 0) pushi32(32);
					else {
						while ((x & 1u) == 0) { count++; x >>= 1; }
						pushi32(count);
					}
				}
				WasmOpcode.I32_POPCNT.code => {
					var x = popu32();
					var count = 0;
					for (i < 32) {
						if ((x & 1) == 1) count++;
						x >>= 1;
					}
					pushi32(count);
				}
				WasmOpcode.I32_ADD.code => pushu32(popu32() + popu32());
				WasmOpcode.I32_SUB.code => pushu32(popu32() - popu32());
				WasmOpcode.I32_MUL.code => pushu32(popu32() * popu32());
				WasmOpcode.I32_DIV_S.code => {
					var y = popi32(), x = popi32();
					if (y == 0) trap(TrapReason.DIV_BY_ZERO);
					else if (y == -1 && x == int.min) trap(TrapReason.DIV_UNREPRESENTABLE);
					else pushi32(x / y);
				}
				WasmOpcode.I32_DIV_U.code => {
					var y = popu32(), x = popu32();
					if (y == 0) trap(TrapReason.DIV_BY_ZERO);
					else pushu32(x / y);
				}
				WasmOpcode.I32_REM_S.code => {
					var y = popi32(), x = popi32();
					if (y == 0) trap(TrapReason.REM_BY_ZERO);
					else if (y == -1) pushi32(0);
					else pushi32(x % y);
				}
				WasmOpcode.I32_REM_U.code => {
					var y = popu32(), x = popu32();
					if (y == 0) trap(TrapReason.REM_BY_ZERO);
					else if (y == 1) pushi32(0);
					else pushu32(x % y);
				}
				WasmOpcode.I32_AND.code => pushu32(popu32() & popu32());
				WasmOpcode.I32_OR.code => pushu32(popu32() | popu32());
				WasmOpcode.I32_XOR.code => pushu32(popu32() ^ popu32());
				WasmOpcode.I32_SHL.code => pushu32(popu32() << u5.!(popu32()));
				WasmOpcode.I32_SHR_S.code => pushi32(popi32() >> u5.!(popu32()));
				WasmOpcode.I32_SHR_U.code => pushu32(popu32() >> u5.!(popu32()));
				WasmOpcode.I32_ROTL.code => {
					var y = u5.!(popu32()), x = popu32();
					if (y != 0) {
						var upper = x << y;
						var lower = x >> byte.!(32) - y;
						x = upper | lower;
					}
					pushu32(x);
				}
				WasmOpcode.I32_ROTR.code => {
					var y = u5.!(popu32()), x = popu32();
					if (y != 0) {
						var upper = x << byte.!(32) - y;
						var lower = x >> y;
						x = upper | lower;
					}
					pushu32(x);
				}

				WasmOpcode.I64_CLZ.code => {
					var x = popu64();
					var count = 0;
					if (x == 0) pushi64(64);
					else {
						while ((x & 0x8000000000000000ul) == 0) { count++; x <<= 1; }
						pushi64(count);
					}
				}
				WasmOpcode.I64_CTZ.code => {
					var x = popu64();
					var count = 0;
					if (x == 0) pushi64(64);
					else {
						while ((x & 1u) == 0) { count++; x >>= 1; }
						pushi64(count);
					}
				}
				WasmOpcode.I64_POPCNT.code => {
					var x = popu64();
					var count = 0;
					for (i < 64) {
						if ((x & 1) == 1) count++;
						x >>= 1;
					}
					pushi64(count);
				}
				WasmOpcode.I64_ADD.code => pushu64(popu64() + popu64());
				WasmOpcode.I64_SUB.code => pushu64(popu64() - popu64());
				WasmOpcode.I64_MUL.code => pushu64(popu64() * popu64());
				WasmOpcode.I64_DIV_S.code => {
					var y = popi64(), x = popi64();
					if (y == 0) trap(TrapReason.DIV_BY_ZERO);
					else if (y == -1 && x == long.min) trap(TrapReason.DIV_UNREPRESENTABLE);
					else pushi64(x / y);
				}
				WasmOpcode.I64_DIV_U.code => {
					var y = popu64(), x = popu64();
					if (y == 0) trap(TrapReason.DIV_BY_ZERO);
					else pushu64(x / y);
				}
				WasmOpcode.I64_REM_S.code => {
					var y = popi64(), x = popi64();
					if (y == 0) trap(TrapReason.REM_BY_ZERO);
					else if (y == -1) pushi64(0);
					else pushi64(x % y);
				}
				WasmOpcode.I64_REM_U.code => {
					var y = popu64(), x = popu64();
					if (y == 0) trap(TrapReason.REM_BY_ZERO);
					else if (y == 1) pushi64(0);
					else pushu64(x % y);
				}
				WasmOpcode.I64_AND.code => pushu64(popu64() & popu64());
				WasmOpcode.I64_OR.code => pushu64(popu64() | popu64());
				WasmOpcode.I64_XOR.code => pushu64(popu64() ^ popu64());
				WasmOpcode.I64_SHL.code => pushu64(popu64() << u6.!(popu64()));
				WasmOpcode.I64_SHR_S.code => pushi64(popi64() >> u6.!(popu64()));
				WasmOpcode.I64_SHR_U.code => pushu64(popu64() >> u6.!(popu64()));
				WasmOpcode.I64_ROTL.code => {
					var y = u6.!(popu64()), x = popu64();
					if (y != 0) {
						var upper = x << y;
						var lower = x >> byte.!(64) - y;
						x = upper | lower;
					}
					pushu64(x);
				}
				WasmOpcode.I64_ROTR.code => {
					var y = u6.!(popu64()), x = popu64();
					if (y != 0) {
						var upper = x << byte.!(64) - y;
						var lower = x >> y;
						x = upper | lower;
					}
					pushu64(x);
				}
				// TODO: floating point arithmetic

				WasmOpcode.I32_WRAP_I64.code => pushu32(u32.!(popu64()));

				// TODO: floating point conversions

				WasmOpcode.I64_EXTEND_I32_S.code => pushu64(u64.!(i64.!(popi32())));
				WasmOpcode.I64_EXTEND_I32_U.code => pushu64(popu32());

				WasmOpcode.I32_REINTERPRET_F32.code => {
					var x = Value.F32.!(pop());
					pushu32(x.bits);
				}
				WasmOpcode.F32_REINTERPRET_I32.code => {
					push(Value.F32(popu32()));
				}
				WasmOpcode.I64_REINTERPRET_F64.code => {
					var x = Value.F64.!(pop());
					pushu64(x.bits);
				}
				WasmOpcode.F64_REINTERPRET_I64.code => {
					push(Value.F64(popu64()));
				}

				InternalOpcode.BREAK.code => {
					if (state == ExecState.RUNNING) {
						state = ExecState.BREAKPOINT;
						return false; // did not execute instruction
					} else {
						var orig_opcode = frame.func.decl.code.orig[pc];
						opcode = orig_opcode;
						continue;  // re-execute switch with original opcode
					}
				}
				InternalOpcode.PROBE.code => {
					// TODO
				}
				_ => error("unknown opcode");
			}
			if (frame != null) frame.pc = codeptr.pos;
			break;
		}
		return true;
	}
	def doBranch(pc: int) -> int {
		var t = findCtlSummary(pc), e = t.0[t.1];
		var pc_delta = e.1, valcount = e.2, popcount = e.3;
		if (popcount > 0) {
			copyVals(valcount, val_stack.top - int.!(popcount + valcount));
		}
		return pc + pc_delta;
	}
	def doSwitch(pc: int, key: u32) -> int {
		var t = findCtlSummary(pc), e = t.0[t.1];
		var max = e.1;
		e = t.0[if(key > max, (max + 1), int.!(key + 1))];
		var pc_delta = e.1, valcount = e.2, popcount = e.3;
		if (popcount > 0) {
			copyVals(valcount, val_stack.top - int.!(popcount + valcount));
		}
		return pc + pc_delta;
	}
	def findCtlSummary(pc: int) -> (Array<(u23, i23, u10, u23)>, int) {
		var c = frame.func.decl.code.ctl_summary;
		for (i = 0; i < c.length; i += 3) {
			if (c[i].0 == pc) return (c, i);
		}
		return (null, -1);
	}
	def doReturn() {
		var count = frame.func.decl.sig.results.length;
		copyVals(count, frame.fp);
		val_stack.resize(frame.fp + count);
		call_stack.pop();
		frame = call_stack.peek();
		if (frame == null) {
			state = ExecState.FINISHED;
			codeptr.reset(null, 0, 0);
		} else {
			// Advance past caller's call instruction.
			var code = frame.func.decl.code.code;
			codeptr.reset(code, 0, code.length);
			var opcode = codeptr.read_u8();
			match (opcode) {
				WasmOpcode.CALL.code => {
					codeptr.read_u32leb();
				}
				WasmOpcode.CALL_INDIRECT.code => {
					codeptr.read_u32leb();
					codeptr.read_u32leb();
				}
			}
			frame.pc = codeptr.pos;
		}
	}
	def doCall(func_index: u32) {
		var f = frame.func.instance.getFunction(int.!(func_index));
		doCallFunction(f);
	}
	def doCallIndirect(sig_index: u32, table_index: u32, func_index: u32) {
		if (func_index >= frame.func.instance.module.functions.size()) {
			return trap(TrapReason.FUNC_INVALID);
		}
		var table = FunctionTable.!(frame.func.instance.tables[int.!(table_index)]);
		var f = table.elems[int.!(func_index)];
		var sig = TypeDecl.Function.!(frame.func.instance.module.types[int.!(sig_index)]);
		if (!ValueTypes.isAssignableSig(f.sig, sig)) {
			return trap(TrapReason.FUNC_SIG_MISMATCH);
		}
		doCallFunction(f);
	}
	def doCallFunction(f: Function) {
		match (f) {
			hf: HostFunction => {
				var count = f.sig.params.length;
				var args = Array<Value>.new(count);
				var sp = val_stack.top - count;
				for (i < count) args[i] = val_stack.elems[sp + i];
				var results = hf.invoke(this, args);
				count = f.sig.results.length;
				val_stack.resize(sp + count);
				for (i < count) val_stack.elems[sp + i] = results[i];
			}
			wf: WasmFunction => {
				pushFrame(wf);
			}
		}
	}
	def trap(reason: TrapReason) {
		state = ExecState.TRAPPED;
		trap_reason = reason;
	}
	def pause();
	def error(msg: string) {
		state = ExecState.TRAPPED;
		trap_reason = TrapReason.ERROR;
		error_msg = msg;
	}
	def copyVals(count: int, dest: int) {
		var sp = val_stack.top - count;
		if (sp != dest) {
			var e = val_stack.elems;
			for (i < count) e[dest + i] = e[sp + i];
		}
	}
	def pop() -> Value {
		return val_stack.pop();
	}
	def popi32() -> i32 {
		var val = val_stack.pop();
		return i32.!(Value.I32.!(val).val);
	}
	def popu32() -> u32 {
		var val = val_stack.pop();
		return Value.I32.!(val).val;
	}
	def popi64() -> i64 {
		var val = val_stack.pop();
		return i64.!(Value.I64.!(val).val);
	}
	def popu64() -> u64 {
		var val = val_stack.pop();
		return Value.I64.!(val).val;
	}
	def push(val: Value) {
		val_stack.push(val);
	}
	def pushbool(val: bool) {
		val_stack.push(if(val, TRUE, FALSE));
	}
	def pushu32(val: u32) {
		val_stack.push(Value.I32(val));
	}
	def pushi32(val: i32) {
		val_stack.push(Value.I32(u32.!(val)));
	}
	def pushu64(val: u64) {
		val_stack.push(Value.I64(val));
	}
	def pushi64(val: i64) {
		val_stack.push(Value.I64(u64.!(val)));
	}
	def traceStep(pos: int, opcode: byte) {
		for (i < call_stack.top) trace.sp();
		trace.put3("%x: %x %q", pos, opcode, WasmOpcodes.render(_, opcode));
		trace.ln();
		trace.out(STDOUT);
		trace.reset();
	}
}
def STDOUT = System.fileWriteK(1, _, _, _);
enum ExecState {
	STOPPED,	// execution has not yet begun
	RUNNING,	// currently running
	BREAKPOINT,	// stopped at (code) breakpoint
	RESUME,		// continuing over current breakpoint
	PAUSED,		// paused by probe
	FINISHED,	// execution completed bottom-most function
	TRAPPED		// execution encountered a trap
}
class Frame {
	var func: WasmFunction;
	var fp: int;
	var pc: int;
}
enum InternalOpcode(code: u8) {
	BREAK(0x12),
	PROBE(0x13)
}
def TRUE = Value.I32(1), FALSE = Value.I32(0);
type Result {
	case Break {}
	case Value(vals: Array<Value>) {}
	case Trap(reason: TrapReason) {}
}

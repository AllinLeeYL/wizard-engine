// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A Wasm-specific error generator that tracks additional context for more
// usefule error messages, as well as an error code for programmatic matching.
class WasmErrorGen(filename: string) extends ErrorGen {
	var section: BpSection;		// current section
	var index: int = -1;		// current index into section
	var error_section: BpSection;	// section where error ocurred
	var error_index: int;		// index where error ocurred
	var error_code: WasmError;	// wasm error code

	def setc(code: WasmError, msg: string) {
		if (set(msg)) {
			error_section = section;
			error_index = index;
			error_code = code;
			error_msg = msg;
		}
	}
	// --{Binary parser errors}-------------------------------------------
	def MissingCodeSection(func_count: int) {
		setc(WasmError.FUNC_COUNT_MISMATCH,
			Strings.format1("expected %d function bodies, missing code section", func_count));
	}
	def DuplicateSection(sect: BpSection) {
		setc(WasmError.DUPLICATE_SECTION,
			Strings.format1("duplicate %q section", BpConstants.renderSectionName(_, sect.code)));
	}
	def InvalidSectionCode(code: byte) {
		setc(WasmError.INVALID_SECTION,
			Strings.format1("invalid section code 0x%x", code));
	}
	def IncompleteSection(kind: byte, read: int, size: u32) {
		setc(WasmError.INCOMPLETE_SECTION,
			Strings.format3("incomplete %q section, expected %d bytes, read %d",
				BpConstants.renderSectionName(_, kind), size, read));
	}
	def OverflowSection(kind: byte, read: int, size: u32) {
		setc(WasmError.OVERFLOW_SECTION,
			Strings.format3("overflow %q section, expected %d bytes, read %d",
				BpConstants.renderSectionName(_, kind), size, read));
	}
	def QuantityExceededMaximum(quantity: string, val: u32, max: u32) {
		setc(WasmError.EXCEEDED_LIMIT,
			Strings.format3("expected maximum of %d %s, got %d", max, quantity, val));
	}
	def QuantityExceededMaximumI(quantity: string, val: int, max: u32) {
		setc(WasmError.EXCEEDED_LIMIT,
			Strings.format3("expected maximum of %d %s, got %d", max, quantity, val));
	}
	def QuantityBelowMinimum(quantity: string, val: int, min: u32) {
		setc(WasmError.EXCEEDED_LIMIT,
			Strings.format3("expected minimum of %d %s, got %d", min, quantity, val));
	}
	def InvalidValueTypecon(code: byte) {
		setc(WasmError.INVALID_TYPE,
			Strings.format1("invalid value type 0x%x", code));
	}
	def InvalidBlockType(type_index: int) {
		setc(WasmError.INVALID_BLOCK_TYPE,
			Strings.format1("invalid block type %d", type_index));
	}
	def InvalidGlobalFlags(flags: byte) {
		setc(WasmError.INVALID_GLOBAL_FLAGS,
			Strings.format1("invalid global flags 0x%x", flags));
	}
	def InvalidImportKind(code: byte) {
		setc(WasmError.INVALID_IMPORT_KIND,
			Strings.format1("invalid import kind 0x%x", code));
	}
	def InvalidExportKind(code: byte) {
		setc(WasmError.INVALID_IMPORT_KIND,
			Strings.format1("invalid export kind 0x%x", code));
	}
	def DuplicateExport(export_index: int) {
		setc(WasmError.DUPLICATE_EXPORT,
			Strings.format1("duplicate export %d", export_index));
	}
	def ExpectedMemoryIndexZeroByte(memory_index: byte) {
		setc(WasmError.EXPECTED_ZERO_BYTE,
			Strings.format1("expected zero byte for memory index, got 0x%x", memory_index));
	}
	def ExpectedTableIndexZeroByte(table_index: byte) {
		setc(WasmError.EXPECTED_ZERO_BYTE,
			Strings.format1("expected zero byte for table index, got 0x%x", table_index));
	}
	def ExpectedElementsZeroByte(flags: byte) {
		setc(WasmError.EXPECTED_ZERO_BYTE,
			Strings.format1("expected zero byte for elements, got 0x%x", flags));
	}
	def ExpectedDataFlagsZeroByte(flags: byte) {
		setc(WasmError.EXPECTED_ZERO_BYTE,
			Strings.format1("expected zero byte for data, got 0x%x", flags));
	}
	def ExpectedFunctionType(type_index: int) {
		setc(WasmError.ILLEGAL_TYPE,
			Strings.format1("expected function type, got %d", type_index));
	}
	def InvalidUtf8String() {
		setc(WasmError.INVALID_UTF8_STRING, "invalid UTF-8 string");
	}
	def ExpectedSharedMemoryMaximum() {
		setc(WasmError.INVALID_MEMORY_FLAGS, "expected maximum for shared memory");
	}
	def ExpectedFunctionTypecon(code: byte) {
		setc(WasmError.INVALID_TYPE,
			Strings.format2("expected function type 0x%x, got 0x%x", BpTypecon.Function.code, code));
	}
	def ExpectedI32InitExpr(vt: ValueType) {
		setc(WasmError.TYPE_MISMATCH,
			Strings.format1("expected init expression of type i32, got %q", ValueTypes.render(_, vt)));
	}
	def EOFMagicWord() {
		setc(WasmError.INVALID_HEADER, "expected magic word, got EOF");
	}
	def InvalidMagicWord(word: u32) {
		setc(WasmError.INVALID_HEADER,
			Strings.format2("expected magic word 0x%x, got 0x%x", BpConstants.WASM_MAGIC, word));
	}
	def EOFWasmVersion() {
		setc(WasmError.INVALID_HEADER, "expected wasm version, got EOF");
	}
	def InvalidWasmVersion(version: u32) {
		setc(WasmError.INVALID_HEADER,
			Strings.format2("expected wasm version 0x%x, got 0x%x", BpConstants.WASM_VERSION, version));
	}
	def OverflowFunctionBody(read: int, size: u32) {
		setc(WasmError.OVERFLOW_FUNCTION,
			Strings.format2("expected function body of size %d, read %d", size, read));
	}
	def IncompleteFunctionBody(read: int, size: u32) {
		setc(WasmError.INCOMPLETE_FUNCTION_BODY,
			Strings.format2("expected function body of size %d, read %d", size, read));
	}
	def CustomSectionNameLengthTooLong(len: int, size: u32) {
		setc(WasmError.OVERFLOW_SECTION,
			Strings.format2("name length %d exceeds section size of %d", len, size));
	}
	def IllegalTableElementType(code: byte) {
		setc(WasmError.ILLEGAL_TYPE,
			Strings.format1("illegal table elem type 0x%x", code));
	}
	def ExpectedEndInInit(end: int) {
		setc(WasmError.INVALID_INIT_EXPR,
			Strings.format1("", ()));
	}
	def UnexpectedOpcodeInInit(code: byte) {
		setc(WasmError.INVALID_INIT_EXPR,
			Strings.format2("expected end opcode 0x%x in init expression, got 0x%x",
				Opcode.END.code, code));
	}
	def IllegalStartFunctionType(sig: TypeDecl.Function) {
		setc(WasmError.ILLEGAL_TYPE, "expected start function type [] -> []");
	}
	def FuncCountMismatch(expected: int, count: u32) {
		setc(WasmError.FUNC_COUNT_MISMATCH,
			Strings.format2("expected %d function bodies, got %d", expected, count));
	}
	def TypeMismatchInGlobalInit(expected: ValueType, got: ValueType) {
		setc(WasmError.TYPE_MISMATCH,
			Strings.format2("expected type %q in global init expression, got %q",
				ValueTypes.render(_, expected), ValueTypes.render(_, got)));
	}
	def TypeMismatchInElemInit(expected: ValueType, got: ValueType) {
		setc(WasmError.TYPE_MISMATCH,
			Strings.format2("expected type %q in element expression, got %q",
				ValueTypes.render(_, expected), ValueTypes.render(_, got)));
	}
	def OobIndex(quantity: string, index: u32, max: u32) {
		setc(WasmError.OOB_INDEX,
			Strings.format3("exceeded %s index maximum %d, got %d", quantity, max, index));
	}
	// --{Code validation errors}-----------------------------------------
	def UnterminatedFunctionBody() {
		setc(WasmError.UNTERMINATED_BODY, "unterminated function body");
	}
	def MismatchedElse() {
		setc(WasmError.MISMATCHED_ELSE, "mismatched else");
	}
	def EmptyControlStack() {
		setc(WasmError.OOB_LABEL, "empty control stack");
	}
	def EmptyValueStack() {
		setc(WasmError.TYPE_MISMATCH, "empty value stack");
	}
	def EmptyValueStackExpecting(e: ValueType) {
		setc(WasmError.TYPE_MISMATCH,
			Strings.format1("empty value stack, expected %q", ValueTypes.render(_, e)));
	}
	def InvalidOpcode(code: byte) {
		setc(WasmError.INVALID_OPCODE,
			Strings.format1("invalid opcode 0x%x", code));
	}
	def OobLabel(depth: u32, max: int) {
		setc(WasmError.OOB_LABEL,
			Strings.format2("exceeded label depth maximum %d, got %d", max, depth));
	}
	def OobLocalIndex(local_index: u32, max: int) {
		setc(WasmError.OOB_INDEX,
			Strings.format2("exceeded local variable maximum %d, got %d", max, local_index));
	}
	def OpcodeRequiresExtension(code: byte, ext: Extension) {
		setc(WasmError.INVALID_OPCODE,
			Strings.format3("opcode 0x%x (%s) requires \"%s\" extension",
				code, Opcodes.opcodes[code].name, ext.short_name));
	}
	def ReturnSigMismatch(i: int, e: ValueType, g: ValueType) {
		setc(WasmError.TYPE_MISMATCH,
			Strings.format3("expected return type [%d] = %q, got %q",
				i, ValueTypes.render(_, e), ValueTypes.render(_, g)));
	}
	def ReturnArityMismatch(e: int, g: int) {
		setc(WasmError.TYPE_MISMATCH,
			Strings.format2("expected %d return values, got %d", e, g));
	}
	def ExpectedType(e: ValueType, g: ValueType) {
		setc(WasmError.TYPE_MISMATCH,
			Strings.format2("expected type %q, got %q",
				ValueTypes.render(_, e), ValueTypes.render(_, g)));
	}
	def IllegalAssignmentToImmutableGlobal(global_index: int) {
		setc(WasmError.ILLEGAL_ASSIGNMENT,
			Strings.format1("illegal assignment to immutable global #%d", global_index));
	}
	def IllegalAlignment(max: u32, g: u32) {
		setc(WasmError.INVALID_ALIGNMENT,
			Strings.format2("expected max alignment %d, got %d", max, g));
	}
	def ArityMismatchAtFallthru(e: int, g: int) {
		setc(WasmError.TYPE_MISMATCH,
			Strings.format2("expected %d values for fallthru, got %d", e, g));
	}
	def BrTableArityMismatch(i: int, e: int, g: int) {
		setc(WasmError.TYPE_MISMATCH,
			Strings.format3("br_table[0] label expects %d values, br_table[%d] expects %d",
				i, e, g));
	}
	def BrTableTypeMismatch(i: int, j: int, e: ValueType, g: ValueType) {
		var buf = StringBuilder.new();
		buf.put2("br_table[%d][%d] ", i, j);
		buf.put2("type %q cannot be merged with type %q",
			ValueTypes.render(_, e), ValueTypes.render(_, g));
		setc(WasmError.TYPE_MISMATCH, buf.toString());
	}
	def ExpectedElseForIf(e: int) {
		setc(WasmError.TYPE_MISMATCH,
			Strings.format1("expected else for if with %d result values", e));
	}
	// --{Instantiation errors}-------------------------------------------
	def ExpectedExport(name: string, kind: string) {
		setc(WasmError.EXPECTED_EXPORT,
			Strings.format2("expected export \"%s\" of kind \"%s\"", name, kind));
	}
}
// Errors are organized into classes, which allows programmatic matching in
// unit tests.
enum WasmError {
	NONE,
	// Decoder errors.
	EOF,
	LEB_ERROR,
	// Wasm binary decoding errors.
	INVALID_HEADER,
	INCOMPLETE_SECTION,
	INCOMPLETE_FUNCTION_BODY,
	OVERFLOW_SECTION,
	OVERFLOW_FUNCTION,
	DUPLICATE_SECTION,
	DUPLICATE_EXPORT,
	EXCEEDED_LIMIT,
	OOB_INDEX,
	FUNC_COUNT_MISMATCH,
	INVALID_UTF8_STRING,
	INVALID_SECTION,
	INVALID_TYPE,
	INVALID_IMPORT_KIND,
	INVALID_MEMORY_FLAGS,
	INVALID_GLOBAL_FLAGS,
	EXPECTED_ZERO_BYTE,
	EXPECTED_MAXIMUM,
	INVALID_INIT_EXPR,
	ILLEGAL_TYPE,
	// Code validation errors.
	INVALID_BLOCK_TYPE,
	ILLEGAL_BLOCK_TYPE,
	ILLEGAL_ASSIGNMENT,
	TYPE_MISMATCH,
	MISMATCHED_ELSE,
	UNTERMINATED_BODY,
	OOB_LABEL,
	INVALID_ALIGNMENT,
	INVALID_OPCODE,
	// Module instantiation errors.
	IMPORT_COUNT_MISMATCH,
	OOM_TABLE,
	OOM_MEMORY,
	IMPORT_KIND_MISMATCH,
	IMPORT_TYPE_MISMATCH,
	OOB_TABLE_ELEMS,
	OOB_DATA_INIT,
	EXPECTED_EXPORT
}

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Superclass of all import/exportable objects.
class Exportable {
}
// Interpreter callback interface for functions provided by the host.
class Executor {
	def trap(reason: TrapReason);
	def pause();
}
// Host objects must extend this class to be extern refs.
class HostObject { }
// Abstract base class of host and wasm functions.
class Function(sig: TypeDecl.Function) extends Exportable {
}
class HostFunction extends Function {
	def invoke: (Executor, Array<Value>) -> Result;
	new(sig: TypeDecl.Function, invoke) super(sig) { }
}
// A function from a wasm instance.
class WasmFunction(instance: Instance, decl: FunctionDecl) extends Function {
	new() super(decl.sig) { }
}
class Table(decl: TableDecl) extends Exportable {
	var oom = false;
	def grow(elems: int) -> int;
	def size() -> int;
}
class FunctionTable extends Table {
	var elems: Array<Function>;
	new(decl: TableDecl) super(decl) {
		elems = Array.new(decl.initial);
	}
	def size() -> int { return elems.length; }
}
class ValueTable extends Table {
	var elems: Array<Value>;
	new(decl: TableDecl) super(decl) {
		elems = Array.new(decl.initial);
	}
	def size() -> int { return elems.length; }
}
class Global(decl: GlobalDecl) extends Exportable {
	var value: Value;
}

// An instantiated module, including memories, tables, functions, etc.
class Instance(module: Module, imports: Array<Exportable>) {
	def memories = Array<Memory>.new(module.memories.size());
	private def functions = Array<Function>.new(module.functions.size());  // lazily allocated
	def globals = Array<Global>.new(module.globals.size());
	def tables = Array<Table>.new(module.tables.size());
	def exports = Array<Exportable>.new(module.exports.length);
	def dropped_elems = Array<bool>.new(module.elems.length);
	def dropped_data = Array<bool>.new(module.data.length);

	// Lazily allocates and caches functions for this instance.
	def getFunction(index: int) -> Function {
		var f = functions[index];
		if (f == null) {
			f = functions[index] = WasmFunction.new(this, module.functions[index]);
		}
		return f;
	}
	def getFunctions() -> Array<Function> {
		return functions;
	}
}

// Creates {Instance} objects, given a module and a list of imports.
class Instantiator(module: Module, imports: Array<Exportable>) {
	private def instance = Instance.new(module, imports);
	def err = WasmErrorGen.new(module.filename);
	def run() -> Instance {
		if (imports.length != module.imports.length) return fail("import count mismatch");

		// Check and organize imports.
		var func_index = 0;
		var table_index = 0;
		var memory_index = 0;
		var global_index = 0;

		var functions = instance.getFunctions();
		var tables = instance.tables;
		var memories = instance.memories;
		var globals = instance.globals;
		for (i < imports.length) {
			var imp = imports[i];
			var decl = module.imports[i];
			match (decl.details) {
				Function(decl) =>
					functions[func_index++] = checkFunction(decl, imp);
				Table(decl) =>
					tables[table_index++] = checkTable(decl, imp);
				Memory(decl) =>
					memories[memory_index++] = checkMemory(decl, imp);
				Global(decl) =>
					globals[global_index++] = checkGlobal(decl, imp);
			}
			if (err.error()) return null;
		}

		// Instantiate memories, tables, globals, etc.
		for (i < module.tables.declared.length) {
			var decl = module.tables.declared[i];
			var t = if(decl.elemtype == ValueType.FUNCREF,
					FunctionTable.new(decl),
					ValueTable.new(decl));
			tables[table_index++] = t;
			if (t.oom) return fail("out of memory allocating table");
		}
		for (i < module.memories.declared.length) {
			var m = Memory.new(module.memories.declared[i]);
			memories[memory_index++] = m;
			if (m.oom) return fail("out of memory allocating memory");
		}
		for (i < module.globals.declared.length) {
			var d = module.globals.declared[i];
			var g = Global.new(d);
			globals[global_index++] = g;
			g.value = evalInitExpr(d.init);
		}

		// Bounds-check element and data segments.
		for (i < module.elems.length) {
			var e = module.elems[i];
			if (!e.active) continue;
			if (!checkElemBounds(e)) return null;
		}
		for (i < module.data.length) {
			var d = module.data[i];
			if (!d.active) continue;
			var offset = Value.I32.!(evalInitExpr(d.offset)).val;
			if (!checkDataBounds(d)) return null;
		}

		// Load element segments.
		for (i < module.elems.length) {
			var e = module.elems[i];
			if (!e.active) continue;
			loadElems(e);
			instance.dropped_elems[i] = true;
		}

		// Load data segments.
		for (i < module.data.length) {
			var d = module.data[i];
			if (!d.active) continue;
			loadData(d);
			instance.dropped_data[i] = true;
		}

		// Organize exports
		var exports = instance.exports;
		for (i < module.exports.length) {
			var exp = module.exports[i];
			var v: Exportable;
			match (exp.details) {
				Function(index) => v = instance.getFunction(index);
				Table(index) => v = tables[index];
				Memory(index) => v = memories[index];
				Global(index) => v = globals[index];
			}
			exports[i] = v;
		}
		return instance;
	}
	private def fail(msg: string) -> Instance {
		err.error_msg = msg;
		err.error_pos = 0;
		clear();
		return null;
	}
	private def checkFunction(decl: FunctionDecl, imp: Exportable) -> Function {
		if (!Function.?(imp)) {
			fail("expected function import");
			return null;
		}
		var func = Function.!(imp);
		if (!ValueTypes.isAssignableSig(decl.sig, func.sig)) fail("function sig mismatch");
		return func;
	}
	private def checkTable(decl: TableDecl, imp: Exportable) -> Table {
		if (!Table.?(imp)) {
			fail("expected table import");
			return null;
		}
		var table = Table.!(imp);
		if (!checkLimits(table.decl.initial, table.decl.maximum, decl.initial, decl.maximum)) {
			fail("table limits mismatch");
		}
		return table;
	}
	private def checkMemory(decl: MemoryDecl, imp: Exportable) -> Memory {
		if (!Memory.?(imp)) {
			fail("expected import");
			return null;
		}
		var memory = Memory.!(imp);
		if (!checkLimits(memory.decl.initial, memory.decl.maximum, decl.initial, decl.maximum)) {
			fail("memory limits mismatch");
		}
		if (memory.decl.shared != decl.shared) {
			fail("memory sharing mismatch");
		}
		return memory;
	}
	private def checkGlobal(decl: GlobalDecl, imp: Exportable) -> Global {
		if (!Global.?(imp)) {
			fail("expected global import");
			return null;
		}
		var global = Global.!(imp);
		if (decl.mutable != global.decl.mutable) {
			fail("global immutability mismatch");
		}
		if (!ValueTypes.isAssignable(global.decl.valtype, decl.valtype)) {
			fail("global type mismatch");
		}
		if (!decl.mutable &&!ValueTypes.isAssignable(global.decl.valtype, decl.valtype)) {
			fail("global type mismatch");
		}
		return global;
	}
	private def evalInitExpr(init: InitExpr) -> Value {
		match (init) {
			I32(val) => return Value.I32(u32.!(val));
			I64(val) => return Value.I64(u64.!(val));
			F32(val) => return Value.F32(val);
			F64(val) => return Value.F64(val);
			Null(vtype) => return Value.Null;
			Global(global_index, g) => {
				return instance.globals[global_index].value;
			}
		}
	}
	// Upon error, clear internal fields to prevent retaining garbage.
	private def clear() {
		for (i = module.memories.imported.length; i < instance.memories.length; i++) {
			var m = instance.memories[i];
			if (m != null) m.deallocate();	// explicitly deallocate memory
		}
		Arrays.clear(instance.memories);
		Arrays.clear(instance.getFunctions());
		Arrays.clear(instance.globals);
		Arrays.clear(instance.tables);
	}
	private def checkLimits(fmin: int, fmax: int, tmin: int, tmax: int) -> bool {
		if (fmin < tmin) return false;
		if (tmax >= 0) {
			if (fmax < 0) return false;
			if (fmax > tmax) return false;
			if (fmin > tmax) return false;
		}
		return true;
	}
	private def checkBounds(offset: u32, count: int, length: int) -> bool {
		var end = u64.!(offset) + u64.!(count);
		if (end < offset || end > length) {
			fail("out of bounds in initialization");
			return false;
		}
		return true;
	}
	private def checkElemBounds(e: ElemDecl) -> bool {
		var offset = Value.I32.!(evalInitExpr(e.offset)).val;
		var table = instance.tables[e.table_index];
		match (e.details) {
			FuncRefs(vals) => checkBounds(offset, vals.length, table.size());
			Exprs(vals) => checkBounds(offset, vals.length, table.size());
		}
		return err.ok();
	}
	private def checkDataBounds(d: DataDecl) -> bool {
		var offset = Value.I32.!(evalInitExpr(d.offset)).val;
		var memory = instance.memories[d.mem_index];
		var mlength = if(memory != null, memory.data.length);
		checkBounds(offset, d.data.length, mlength);
		return err.ok();
	}
	private def loadElems(e: ElemDecl) {
		var offset = Value.I32.!(evalInitExpr(e.offset)).val;
		var table = instance.tables[e.table_index];
		match (e.details) {
			FuncRefs(vals) => {
				var ft = FunctionTable.!(table);
				for (i < vals.length) {
					ft.elems[i + int.!(offset)] = instance.getFunction(vals[i]);
				}
			}
			Exprs(vals) => {
				var vt = ValueTable.!(table);
				for (i < vals.length) {
					vt.elems[i + int.!(offset)] = evalInitExpr(vals[i]);
				}
			}
		}
	}
	private def loadData(d: DataDecl) {
		var offset = Value.I32.!(evalInitExpr(d.offset)).val;
		var memory = instance.memories[d.mem_index];
		var mlength = if(memory != null, memory.data.length);
		Arrays.copyInto(memory.data, int.!(offset), d.data, 0, d.data.length);
	}
}
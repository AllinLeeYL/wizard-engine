// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// An enumeration of the WebAssembly opcodes, including their mnenomic names,
// the kind of immediate expected, and the (monomorphic) operator signature.
def sig_t: TypeDecl.Function;
def sig: SigCache;
enum Opcode(code: u8, mnemonic: string, imm: ImmKind, sig: TypeDecl.Function) {
	// Control and calls.
	UNREACHABLE(0x00, "unreachable", ImmKind.NONE, sig.none),
	NOP(0x01, "nop", ImmKind.NONE, SigCache.v_v),
	BLOCK(0x02, "block", ImmKind.BLOCK_TYPE, sig_t),
	LOOP(0x03, "loop", ImmKind.BLOCK_TYPE, sig_t),
	IF(0x04, "if", ImmKind.BLOCK_TYPE, sig_t),
	ELSE(0x05, "else", ImmKind.NONE, sig.none),
	END(0x0B, "end", ImmKind.NONE, sig.none),
	BR(0x0C, "br", ImmKind.LABEL, sig.none),
	BR_IF(0x0D, "br_if", ImmKind.LABEL, sig.none),
	BR_TABLE(0x0E, "br_table", ImmKind.LABELS, sig.none),
	RETURN(0x0F, "return", ImmKind.NONE, sig.none),
	CALL(0x10, "call", ImmKind.FUNC_INDEX, sig.none),
	CALL_INDIRECT(0x11, "call_indirect", ImmKind.SIG_TABLE_INDEX, sig.none),
	RETURN_CALL(0x12, "return_call", ImmKind.FUNC_INDEX, sig.none),
	RETURN_CALL_INDIRECT(0x13, "return_call_indirect", ImmKind.SIG_TABLE_INDEX, sig.none),
	DROP(0x1A, "drop", ImmKind.NONE, sig.none),
	SELECT(0x1B, "select", ImmKind.NONE, sig.none),
	// Locals.
	LOCAL_GET(0x20, "local.get", ImmKind.LOCAL_INDEX, sig.none),
	LOCAL_SET(0x21, "local.set", ImmKind.LOCAL_INDEX, sig.none),
	LOCAL_TEE(0x22, "local.tee", ImmKind.LOCAL_INDEX, sig.none),
	// Globals.
	GLOBAL_GET(0x23, "global.get", ImmKind.GLOBAL_INDEX, sig.none),
	GLOBAL_SET(0x24, "global.set", ImmKind.GLOBAL_INDEX, sig.none),
	// Loads and stores.
	I32_LOAD(0x28, "i32.load", ImmKind.MEMARG, sig.i_i),
	I64_LOAD(0x29, "i64.load", ImmKind.MEMARG, sig.i_l),
	F32_LOAD(0x2A, "f32.load", ImmKind.MEMARG, sig.i_f),
	F64_LOAD(0x2B, "f64.load", ImmKind.MEMARG, sig.i_d),
	I32_LOAD8_S(0x2C, "i32.load8_s", ImmKind.MEMARG, sig.i_i),
	I32_LOAD8_U(0x2D, "i32.load8_u", ImmKind.MEMARG, sig.i_i),
	I32_LOAD16_S(0x2E, "i32.load16_s", ImmKind.MEMARG, sig.i_i),
	I32_LOAD16_U(0x2F, "i32.load16_u", ImmKind.MEMARG, sig.i_i),
	I64_LOAD8_S(0x30, "i64.load8_s", ImmKind.MEMARG, sig.i_l),
	I64_LOAD8_U(0x31, "i64.load8_u", ImmKind.MEMARG, sig.i_l),
	I64_LOAD16_S(0x32, "i64.load16_s", ImmKind.MEMARG, sig.i_l),
	I64_LOAD16_U(0x33, "i64.load16_u", ImmKind.MEMARG, sig.i_l),
	I64_LOAD32_S(0x34, "i64.load32_s", ImmKind.MEMARG, sig.i_l),
	I64_LOAD32_U(0x35, "i64.load32_u", ImmKind.MEMARG, sig.i_l),
	I32_STORE(0x36, "i32.store", ImmKind.MEMARG, sig.ii_v),
	I64_STORE(0x37, "i64.store", ImmKind.MEMARG, sig.il_v),
	F32_STORE(0x38, "f32.store", ImmKind.MEMARG, sig.if_v),
	F64_STORE(0x39, "f64.store", ImmKind.MEMARG, sig.id_v),
	I32_STORE8(0x3A, "i32.store8", ImmKind.MEMARG, sig.ii_v),
	I32_STORE16(0x3B, "i32.store16", ImmKind.MEMARG, sig.ii_v),
	I64_STORE8(0x3C, "i64.store8", ImmKind.MEMARG, sig.il_v),
	I64_STORE16(0x3D, "i64.store16", ImmKind.MEMARG, sig.il_v),
	I64_STORE32(0x3E, "i64.store32", ImmKind.MEMARG, sig.il_v),
	// Misc memory.
	MEMORY_SIZE(0x3F, "memory.size", ImmKind.MEMORY_INDEX, sig.v_i),
	MEMORY_GROW(0x40, "memory.grow", ImmKind.MEMORY_INDEX, sig.i_i),
	// Constants.
	I32_CONST(0x41, "i32.const", ImmKind.I32, sig.none),
	I64_CONST(0x42, "i64.const", ImmKind.I64, sig.none),
	F32_CONST(0x43, "f32.const", ImmKind.F32, sig.none),
	F64_CONST(0x44, "f64.const", ImmKind.F64, sig.none),
	// Comparisons.
	I32_EQZ(0x45, "i32.eqz", ImmKind.NONE, sig.i_i),
	I32_EQ(0x46, "i32.eq", ImmKind.NONE, sig.ii_i),
	I32_NE(0x47, "i32.ne", ImmKind.NONE, sig.ii_i),
	I32_LT_S(0x48, "i32.lt_s", ImmKind.NONE, sig.ii_i),
	I32_LT_U(0x49, "i32.lt_u", ImmKind.NONE, sig.ii_i),
	I32_GT_S(0x4A, "i32.gt_s", ImmKind.NONE, sig.ii_i),
	I32_GT_U(0x4B, "i32.gt_u", ImmKind.NONE, sig.ii_i),
	I32_LE_S(0x4C, "i32.le_s", ImmKind.NONE, sig.ii_i),
	I32_LE_U(0x4D, "i32.le_u", ImmKind.NONE, sig.ii_i),
	I32_GE_S(0x4E, "i32.ge_s", ImmKind.NONE, sig.ii_i),
	I32_GE_U(0x4F, "i32.ge_u", ImmKind.NONE, sig.ii_i),
	I64_EQZ(0x50, "i64.eqz", ImmKind.NONE, sig.l_i),
	I64_EQ(0x51, "i64.eq", ImmKind.NONE, sig.ll_i),
	I64_NE(0x52, "i64.ne", ImmKind.NONE, sig.ll_i),
	I64_LT_S(0x53, "i64.lt_s", ImmKind.NONE, sig.ll_i),
	I64_LT_U(0x54, "i64.lt_u", ImmKind.NONE, sig.ll_i),
	I64_GT_S(0x55, "i64.gt_s", ImmKind.NONE, sig.ll_i),
	I64_GT_U(0x56, "i64.gt_u", ImmKind.NONE, sig.ll_i),
	I64_LE_S(0x57, "i64.le_s", ImmKind.NONE, sig.ll_i),
	I64_LE_U(0x58, "i64.le_u", ImmKind.NONE, sig.ll_i),
	I64_GE_S(0x59, "i64.ge_s", ImmKind.NONE, sig.ll_i),
	I64_GE_U(0x5A, "i64.ge_u", ImmKind.NONE, sig.ll_i),
	F32_EQ(0x5B, "f32.eq", ImmKind.NONE, sig.ff_i),
	F32_NE(0x5C, "f32.ne", ImmKind.NONE, sig.ff_i),
	F32_LT(0x5D, "f32.lt", ImmKind.NONE, sig.ff_i),
	F32_GT(0x5E, "f32.gt", ImmKind.NONE, sig.ff_i),
	F32_LE(0x5F, "f32.le", ImmKind.NONE, sig.ff_i),
	F32_GE(0x60, "f32.ge", ImmKind.NONE, sig.ff_i),
	F64_EQ(0x61, "f64.eq", ImmKind.NONE, sig.dd_i),
	F64_NE(0x62, "f64.ne", ImmKind.NONE, sig.dd_i),
	F64_LT(0x63, "f64.lt", ImmKind.NONE, sig.dd_i),
	F64_GT(0x64, "f64.gt", ImmKind.NONE, sig.dd_i),
	F64_LE(0x65, "f64.le", ImmKind.NONE, sig.dd_i),
	F64_GE(0x66, "f64.ge", ImmKind.NONE, sig.dd_i),
	// I32 arithmetic.
	I32_CLZ(0x67, "i32.clz", ImmKind.NONE, sig.i_i),
	I32_CTZ(0x68, "i32.ctz", ImmKind.NONE, sig.i_i),
	I32_POPCNT(0x69, "i32.popcnt", ImmKind.NONE, sig.i_i),
	I32_ADD(0x6A, "i32.add", ImmKind.NONE, sig.ii_i),
	I32_SUB(0x6B, "i32.sub", ImmKind.NONE, sig.ii_i),
	I32_MUL(0x6C, "i32.mul", ImmKind.NONE, sig.ii_i),
	I32_DIV_S(0x6D, "i32.div_s", ImmKind.NONE, sig.ii_i),
	I32_DIV_U(0x6E, "i32.div_u", ImmKind.NONE, sig.ii_i),
	I32_REM_S(0x6F, "i32.rem_s", ImmKind.NONE, sig.ii_i),
	I32_REM_U(0x70, "i32.rem_u", ImmKind.NONE, sig.ii_i),
	I32_AND(0x71, "i32.and", ImmKind.NONE, sig.ii_i),
	I32_OR(0x72, "i32.or", ImmKind.NONE, sig.ii_i),
	I32_XOR(0x73, "i32.xor", ImmKind.NONE, sig.ii_i),
	I32_SHL(0x74, "i32.shl", ImmKind.NONE, sig.ii_i),
	I32_SHR_S(0x75, "i32.shr_s", ImmKind.NONE, sig.ii_i),
	I32_SHR_U(0x76, "i32.shr_u", ImmKind.NONE, sig.ii_i),
	I32_ROTL(0x77, "i32.rotl", ImmKind.NONE, sig.ii_i),
	I32_ROTR(0x78, "i32.rotr", ImmKind.NONE, sig.ii_i),
	// I64 arithmetic.
	I64_CLZ(0x79, "i64.clz", ImmKind.NONE, sig.l_l),
	I64_CTZ(0x7A, "i64.ctz", ImmKind.NONE, sig.l_l),
	I64_POPCNT(0x7B, "i64.popcnt", ImmKind.NONE, sig.l_l),
	I64_ADD(0x7C, "i64.add", ImmKind.NONE, sig.ll_l),
	I64_SUB(0x7D, "i64.sub", ImmKind.NONE, sig.ll_l),
	I64_MUL(0x7E, "i64.mul", ImmKind.NONE, sig.ll_l),
	I64_DIV_S(0x7F, "i64.div_s", ImmKind.NONE, sig.ll_l),
	I64_DIV_U(0x80, "i64.div_u", ImmKind.NONE, sig.ll_l),
	I64_REM_S(0x81, "i64.rem_s", ImmKind.NONE, sig.ll_l),
	I64_REM_U(0x82, "i64.rem_u", ImmKind.NONE, sig.ll_l),
	I64_AND(0x83, "i64.and", ImmKind.NONE, sig.ll_l),
	I64_OR(0x84, "i64.or", ImmKind.NONE, sig.ll_l),
	I64_XOR(0x85, "i64.xor", ImmKind.NONE, sig.ll_l),
	I64_SHL(0x86, "i64.shl", ImmKind.NONE, sig.ll_l),
	I64_SHR_S(0x87, "i64.shr_s", ImmKind.NONE, sig.ll_l),
	I64_SHR_U(0x88, "i64.shr_u", ImmKind.NONE, sig.ll_l),
	I64_ROTL(0x89, "i64.rotl", ImmKind.NONE, sig.ll_l),
	I64_ROTR(0x8A, "i64.rotr", ImmKind.NONE, sig.ll_l),
	// F32 arithmetic.
	F32_ABS(0x8B, "f32.abs", ImmKind.NONE, sig.f_f),
	F32_NEG(0x8C, "f32.neg", ImmKind.NONE, sig.f_f),
	F32_CEIL(0x8D, "f32.ceil", ImmKind.NONE, sig.f_f),
	F32_FLOOR(0x8E, "f32.floor", ImmKind.NONE, sig.f_f),
	F32_TRUNC(0x8F, "f32.trunc", ImmKind.NONE, sig.f_f),
	F32_NEAREST(0x90, "f32.nearest", ImmKind.NONE, sig.f_f),
	F32_SQRT(0x91, "f32.sqrt", ImmKind.NONE, sig.f_f),
	F32_ADD(0x92, "f32.add", ImmKind.NONE, sig.ff_f),
	F32_SUB(0x93, "f32.sub", ImmKind.NONE, sig.ff_f),
	F32_MUL(0x94, "f32.mul", ImmKind.NONE, sig.ff_f),
	F32_DIV(0x95, "f32.div", ImmKind.NONE, sig.ff_f),
	F32_MIN(0x96, "f32.min", ImmKind.NONE, sig.ff_f),
	F32_MAX(0x97, "f32.max", ImmKind.NONE, sig.ff_f),
	F32_COPYSIGN(0x98, "f32.copysign", ImmKind.NONE, sig.ff_f),
	// F64 arithmetic.
	F64_ABS(0x99, "f64.abs", ImmKind.NONE, sig.d_d),
	F64_NEG(0x9A, "f64.neg", ImmKind.NONE, sig.d_d),
	F64_CEIL(0x9B, "f64.ceil", ImmKind.NONE, sig.d_d),
	F64_FLOOR(0x9C, "f64.floor", ImmKind.NONE, sig.d_d),
	F64_TRUNC(0x9D, "f64.trunc", ImmKind.NONE, sig.d_d),
	F64_NEAREST(0x9E, "f64.nearest", ImmKind.NONE, sig.d_d),
	F64_SQRT(0x9F, "f64.sqrt", ImmKind.NONE, sig.d_d),
	F64_ADD(0xA0, "f64.add", ImmKind.NONE, sig.dd_d),
	F64_SUB(0xA1, "f64.sub", ImmKind.NONE, sig.dd_d),
	F64_MUL(0xA2, "f64.mul", ImmKind.NONE, sig.dd_d),
	F64_DIV(0xA3, "f64.div", ImmKind.NONE, sig.dd_d),
	F64_MIN(0xA4, "f64.min", ImmKind.NONE, sig.dd_d),
	F64_MAX(0xA5, "f64.max", ImmKind.NONE, sig.dd_d),
	F64_COPYSIGN(0xA6, "f64.copysign", ImmKind.NONE, sig.dd_d),
	// Conversions and casts.
	I32_WRAP_I64(0xA7, "i32.wrap_i64", ImmKind.NONE, sig.l_i),
	I32_TRUNC_F32_S(0xA8, "i32.trunc_f32_s", ImmKind.NONE, sig.f_i),
	I32_TRUNC_F32_U(0xA9, "i32.trunc_f32_u", ImmKind.NONE, sig.f_i),
	I32_TRUNC_F64_S(0xAA, "i32.trunc_f64_s", ImmKind.NONE, sig.d_i),
	I32_TRUNC_F64_U(0xAB, "i32.trunc_f64_u", ImmKind.NONE, sig.d_i),
	I64_EXTEND_I32_S(0xAC, "i64.extend_i32_s", ImmKind.NONE, sig.i_l),
	I64_EXTEND_I32_U(0xAD, "i64.extend_i32_u", ImmKind.NONE, sig.i_l),
	I64_TRUNC_F32_S(0xAE, "i64.trunc_f32_s", ImmKind.NONE, sig.f_l),
	I64_TRUNC_F32_U(0xAF, "i64.trunc_f32_u", ImmKind.NONE, sig.f_l),
	I64_TRUNC_F64_S(0xB0, "i64.trunc_f64_s", ImmKind.NONE, sig.d_l),
	I64_TRUNC_F64_U(0xB1, "i64.trunc_f64_u", ImmKind.NONE, sig.d_l),
	F32_CONVERT_I32_S(0xB2, "f32.convert_i32_s", ImmKind.NONE, sig.i_f),
	F32_CONVERT_I32_U(0xB3, "f32.convert_i32_u", ImmKind.NONE, sig.i_f),
	F32_CONVERT_I64_S(0xB4, "f32.convert_i64_s", ImmKind.NONE, sig.l_f),
	F32_CONVERT_I64_U(0xB5, "f32.convert_i64_u", ImmKind.NONE, sig.l_f),
	F32_DEMOTE_F64(0xB6, "f32.demote_f64", ImmKind.NONE, sig.d_f),
	F64_CONVERT_I32_S(0xB7, "f64.convert_i32_s", ImmKind.NONE, sig.i_d),
	F64_CONVERT_I32_U(0xB8, "f64.convert_i32_u", ImmKind.NONE, sig.i_d),
	F64_CONVERT_I64_S(0xB9, "f64.convert_i64_s", ImmKind.NONE, sig.l_d),
	F64_CONVERT_I64_U(0xBA, "f64.convert_i64_u", ImmKind.NONE, sig.l_d),
	F64_PROMOTE_F32(0xBB, "f64.promote_f32", ImmKind.NONE, sig.f_d),
	I32_REINTERPRET_F32(0xBC, "i32.reinterpret_f32", ImmKind.NONE, sig.f_i),
	I64_REINTERPRET_F64(0xBD, "i64.reinterpret_f64", ImmKind.NONE, sig.d_l),
	F32_REINTERPRET_I32(0xBE, "f32.reinterpret_i32", ImmKind.NONE, sig.i_f),
	F64_REINTERPRET_I64(0xBF, "f64.reinterpret_i64", ImmKind.NONE, sig.l_d),

	I32_EXTEND8_S(0xC0, "i32.extend8_s", ImmKind.NONE, sig.i_i),
	I32_EXTEND16_S(0xC1, "i32.extend16_s", ImmKind.NONE, sig.i_i),
	I64_EXTEND8_S(0xC2, "i64.extend8_s", ImmKind.NONE, sig.i_l),
	I64_EXTEND16_S(0xC3, "i64.extend16_s", ImmKind.NONE, sig.i_l),
	I64_EXTEND32_S(0xC4, "i64.extend32_s", ImmKind.NONE, sig.i_l)
}
// An enumeration of the different kinds of immediates to WebAssembly
// opcodes.
enum ImmKind {
	NONE,
	BLOCK_TYPE,
	LABEL,
	LABELS,
	FUNC_INDEX,
	SIG_TABLE_INDEX,
	LOCAL_INDEX,
	GLOBAL_INDEX,
	MEMORY_INDEX,
	MEMARG,
	I32,
	I64,
	F32,
	F64
}

// Utilities for WebAssembly opcodes.
component Opcodes {
	def signatures = Array<TypeDecl.Function>.new(256);
	def opcodes = Array<Opcode>.new(256);
	def valid = Array<bool>.new(256);
	def isShortOperator = Array<bool>.new(256);
	new() {
		for (op in Opcode) init(op);
	}
	def init(opcode: Opcode) {
		signatures[opcode.code] = opcode.sig;
		opcodes[opcode.code] = opcode;
		valid[opcode.code] = true;
		isShortOperator[opcode.code] =
			opcode.sig.params != null && opcode.imm == ImmKind.NONE;
	}
	def render(buf: StringBuilder, b: byte) -> StringBuilder {
		if (valid[b]) {
			return buf.puts(opcodes[b].mnemonic);
		} else {
			return buf.put1("%x <invalid>", b);
		}
	}
	def renderInstr(buf: StringBuilder, m: Module, d: Decoder) -> StringBuilder {
		var prev = d.pos;
		var all = Extension.set.all;
		var limits = Limits.new().set(all);
		// TODO(fast): improve speed of rendering instructions by caching
		// the Error generator and parser.
		var err = WasmErrorGen.new("");
		var p = WasmParser.new(all, limits, m, err, d);
		var b = d.read_u8();
		render(buf, b);
		if (!valid[b]) {
			d.at(prev);
			return buf;
		}
		match (opcodes[b].imm) {
			NONE => ;
			BLOCK_TYPE => {
				var t = p.readBlockType();
				var pl = t.params.length, rl = t.results.length;
				if (pl == 0 && rl == 0) {
					// do nothing
				} else if (pl == 0 && rl == 1) {
					buf.puts("[");
					ValueTypes.render(buf, t.results[0]);
					buf.puts("]");
				} else {
					buf.puts("[");
					ValueTypes.renderSig(buf, t);
					buf.puts("]");
				}
			}
			LABEL => buf.put1("[depth=%d]", p.readLabel());
			FUNC_INDEX => buf.put1("[func=%d]", p.readFunc().0);
			SIG_TABLE_INDEX => {
				var sig_index = p.readSig().0;
				var table_index = p.readTableIndex();
				if (table_index == 0) {
					buf.put1("[sig=%d]", sig_index);
				} else {
					buf.put2("[sig=%d,table=%d]", sig_index, table_index);
				}
			}
			LOCAL_INDEX => buf.put1("[%d]", p.readLocalIndex());
			GLOBAL_INDEX => buf.put1("[%d]", p.readGlobal().0);
			MEMORY_INDEX => buf.put1("[%d]", p.readMemoryIndex());
			I32 => buf.put1("[%d]", p.decoder.read_i32leb());
			I64 => buf.put1("[%d]", p.decoder.read_i64leb());
			F32 => buf.put1("[0x%x]", p.readF32());
			F64 => buf.put1("[0x%x]", p.readF64());
			MEMARG => {
				var mem = p.readMemoryArg();
				var align = 1 << byte.!(mem.0 >> 1);
				var offset = mem.1;
				buf.put2("[align=%d,offset=%d]", align, offset);
			}
			LABELS => {
				var labels = p.readLabels();
				buf.put1("[%d...]", labels.length);
			}
		}
		d.at(prev);
		return buf;
	}
}

// TODO: support for prefix opcodes
// TODO: support for extension configuration in opcodes
// TODO: bulk_memory, non_trapping_fic, threads, sign_extension

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implements that validation logic for the code of a function.
class CodeValidator(extensions: Extension.set, limits: Limits,
		module: Module, err: WasmErrorGen) {
	def parser = WasmParser.new(extensions, limits, module, err, null);
	def locals = Vector<ValueType>.new();
	def val_stack = Stack<ValueType>.new();
	def ctl_stack = Stack<ControlEntry>.new();
	def trace = if(Trace.verify, StringBuilder.new());
	def ctlxfer = CtlXferBuilder.new(trace);
	var ctl_top: ControlEntry;  // FAST: cache of top of control stack
	var func: FunctionDecl;
	var opcode_pos: int;

	def validateFunc(f: FunctionDecl) -> CodeValidatorResult {
		return validate(f, Decoder.new(f.code.orig, err));
	}
	def validate(f: FunctionDecl, d: Decoder) -> CodeValidatorResult {
		if (trace != null) {
			trace.put2("verify(func #%d: %q)\n",
				f.index, ValueTypes.renderSig(_, f.sig));
			trace.out(Trace.STDOUT);
			trace.reset();
		}
		func = f;
		parser.decoder = d;
		ctl_stack.clear();
		val_stack.clear();
		ctlxfer.reset(parser.decoder.pos);
		setupLocals();
		opcode_pos = parser.decoder.pos;
		pushControl(Opcode.UNREACHABLE.code, f.sig, 0);
		validateCode();
		if (ctl_stack.top != 0) {
			err.fail(f.code.orig.length, WasmError.UNTERMINATED_BODY,
				"unterminated function body");
		}
		func.code.ctl_xfer = ctlxfer.extract();
		if (err.ok()) return CodeValidatorResult.Ok;
		else return CodeValidatorResult.Error(err.error_code, err.error_pos, err.error_msg);
	}

	def setupLocals() {
		// setup params
		locals.resize(0);
		locals.puta(func.sig.params);
		// read and initialize locals
		var start = locals.length, max = limits.max_num_locals;
		var d = parser.readU32("local decl count", 0, max);
		for (i < d) {
			var pt = parser.decoder.pos;
			var count = parser.readU32("local count", 0, max);
			if (!err.ok()) break;
			var ltype = parser.readValueType();
			if (trace != null) traceLocals(count, ltype);
			locals.putn(ltype, int.!(count));
			if ((locals.length - start) > max) {
				err.fail1(parser.decoder.abs(pt),
					WasmError.EXCEEDED_LIMIT,
					"maximum %d total locals exceeded", max);
				break;
			}
		}
		func.code.num_locals = locals.length;
	}
	def traceLocals(count: u32, ltype: ValueType) {
		trace.put2("  locals %d: %q\n", count, ValueTypes.render(_, ltype));
		trace.out(Trace.STDOUT);
		trace.reset();
	}
	def validateCode() {
		var d = parser.decoder;
		while (d.pos < d.limit) {
			opcode_pos = parser.decoder.pos;
			var opcode = parser.readByte("opcode", Opcodes.render);
			if (trace != null) { traceOpcode(); traceStack(true); }
			// FAST: Handle short operators (predictable direct branch)
			if (Opcodes.isShortOperator[opcode]) {
				// TODO(fast): combine signature read with isOperator() check
				var sig = Opcodes.signatures[opcode];
				var p = sig.params, r = sig.results;
				if (p.length > 0) checkAndPopArgs(p);
				if (r.length > 0) pushTypes(r);
				if (trace != null) traceStack(false);
				continue;
			}
			// Handle all other operators in the switch (indirect branch)
			match (opcode) {
				Opcode.UNREACHABLE.code => {
					ctl_top.reachable = false;
					val_stack.top = ctl_top.val_stack_top;
				}
				Opcode.BLOCK.code => {
					var sig = parser.readBlockType();
					checkArgsAndPushControl(opcode, sig);
				}
				Opcode.LOOP.code => {
					var sig = parser.readBlockType();
					checkArgsAndPushControl(opcode, sig);
				}
				Opcode.IF.code => {
					var sig = parser.readBlockType();
					popE(ValueType.I32);
					var ctl = checkArgsAndPushControl(opcode, sig);
					ctlxfer.refV(ctl, opcode_pos, 0, 0);
					ctl_top.reachable = true;
				}
				Opcode.ELSE.code => {
					if (ctl_top.start_opcode != Opcode.IF.code) {
						return err.fail(opcode_pos,
							WasmError.MISMATCHED_ELSE,
							"mismatched else");
					}
					checkArgsAndTransfer();
					var if_branch = ctl_top.ctl_refs[0];
					// branches within if-true block go to "else"...
					ctlxfer.bind(ctl_top, opcode_pos);
					// ... except false target of "if"
					ctl_top.ctl_refs.put(if_branch);
					ctlxfer.bind(ctl_top, opcode_pos + 1);
					// "else" implicitly goes to end
					ctlxfer.refS(ctl_top, opcode_pos, val_stack);

					ctl_top.start_opcode = opcode;
					ctl_top.reachable = true;
					val_stack.top = ctl_top.val_stack_top;
					pushTypes(ctl_top.sig.params);
				}
				Opcode.END.code => {
					if (ctl_stack.top == 0) {
						return err.fail(opcode_pos,
							WasmError.OOB_LABEL,
							"empty control stack");
					}
					checkArgsAndTransfer();
					var ctl = popControl();
					if (ctl.start_opcode == Opcode.LOOP.code) {
						ctlxfer.bind(ctl, ctl.start_pos);
					} else {
						ctlxfer.bind(ctl, opcode_pos);
					}
				}
				Opcode.BR.code => {
					var depth = parser.readLabel();
					var target = getControl(depth);
					if (target == null) return;
					ctlxfer.refS(target, opcode_pos, val_stack);
					checkAndPopArgs(labelArgs(target));
					ctl_top.reachable = false;
					val_stack.top = ctl_top.val_stack_top;
				}
				Opcode.BR_IF.code => {
					var depth = parser.readLabel();
					var target = getControl(depth);
					if (target == null) return;
					popE(ValueType.I32);
					ctlxfer.refS(target, opcode_pos, val_stack);
					checkArgs(labelArgs(target));
				}
				Opcode.BR_TABLE.code => {
					var labels = parser.readLabels();
					popE(ValueType.I32);
					ctlxfer.entries.put(ctlxfer.rel(opcode_pos),
						i23.!(labels.length), 0, 0);
					// merge argument types and check
					var args = mergeArgTypes(labels);
					checkArgs(args);
					if (err.error()) return;
					// add refs for all labels
					for (i < labels.length) {
						var target = getControl(labels[i]);
						ctlxfer.refS(target, opcode_pos + i + 1, val_stack);
					}
					ctl_top.reachable = false;
					val_stack.top = ctl_top.val_stack_top;
				}
				Opcode.RETURN.code => {
					checkAndPopArgs(func.sig.results);
					ctl_top.reachable = false;
					val_stack.top = ctl_top.val_stack_top;
				}
				Opcode.CALL.code => {
					var t = parser.readFunc(), target = t.1;
					if (target == null) return;
					checkAndPopArgs(target.sig.params);
					pushTypes(target.sig.results);
				}
				Opcode.CALL_INDIRECT.code => {
					var sig = parser.readSig().1;
					var t = parser.readTableImm();
					popE(ValueType.I32);
					if (sig.params == null) return;
					checkAndPopArgs(sig.params);
					pushTypes(sig.results);
				}
				Opcode.DROP.code => {
					popAny();
				}
				Opcode.SELECT.code => {
					popE(ValueType.I32);
					var t = popAny();
					popE(t);
					val_stack.push(t);
				}
				Opcode.LOCAL_GET.code => {
					var index = parser.readLocalIndex();
					var t = getLocalType(index);
					val_stack.push(t);
				}
				Opcode.LOCAL_SET.code => {
					var index = parser.readLocalIndex();
					var t = getLocalType(index);
					popE(t);
				}
				Opcode.LOCAL_TEE.code => {
					var index = parser.readLocalIndex();
					var t = getLocalType(index);
					popE(t);
					val_stack.push(t);  // TODO: unreachable concern?
				}
				Opcode.GLOBAL_GET.code => {
					var g = parser.readGlobal().1;
					if (g == null) return;
					val_stack.push(g.valtype);
				}
				Opcode.GLOBAL_SET.code => {
					var g = parser.readGlobal().1;
					if (g == null) return;
					if (!g.mutable) {
						err.fail1(opcode_pos, WasmError.ILLEGAL_ASSIGNMENT,
							"illegal assignment to immutable global #%d", g.index);
					}
					popE(g.valtype);
				}

				Opcode.I32_LOAD8_S.code,
				Opcode.I32_LOAD8_U.code,
				Opcode.I64_LOAD8_S.code,
				Opcode.I64_LOAD8_U.code,
				Opcode.I32_STORE8.code,
				Opcode.I64_STORE8.code => checkAlignment(opcode, 0);

				Opcode.I32_LOAD16_S.code,
				Opcode.I32_LOAD16_U.code,
				Opcode.I64_LOAD16_S.code,
				Opcode.I64_LOAD16_U.code,
				Opcode.I32_STORE16.code,
				Opcode.I64_STORE16.code => checkAlignment(opcode, 1);

				Opcode.I32_LOAD.code,
				Opcode.F32_LOAD.code,
				Opcode.I64_LOAD32_S.code,
				Opcode.I64_LOAD32_U.code,
				Opcode.I32_STORE.code,
				Opcode.F32_STORE.code,
				Opcode.I64_STORE32.code => checkAlignment(opcode, 2);

				Opcode.I64_LOAD.code,
				Opcode.F64_LOAD.code,
				Opcode.I64_STORE.code,
				Opcode.F64_STORE.code => checkAlignment(opcode, 3);

				Opcode.MEMORY_SIZE.code,
				Opcode.MEMORY_GROW.code => {
					var index = parser.readMemoryImm();
					var sig = Opcodes.signatures[opcode];
					checkAndPopArgs(sig.params);
					pushTypes(sig.results);
				}
				Opcode.I32_CONST.code => {
					parser.decoder.read_i32leb();
					val_stack.push(ValueType.I32);
				}
				Opcode.I64_CONST.code => {
					parser.decoder.read_i64leb();
					val_stack.push(ValueType.I64);
				}
				Opcode.F32_CONST.code => {
					parser.decoder.skip_bytes(4);
					val_stack.push(ValueType.F32);
				}
				Opcode.F64_CONST.code => {
					parser.decoder.skip_bytes(8);
					val_stack.push(ValueType.F64);
				}
				_ => ;
			}
			if (trace != null) traceStack(false);
		}
	}
	def mergeArgTypes(labels: Array<u32>) -> Array<ValueType> {
		var args = SigCache.arr_v;
		var first = getControl(labels[0]);
		if (first == null) return args;
		args = labelArgs(first);
		args = Arrays.range(args, 0, args.length);
		for (i = 1; i < labels.length; i++) {
			var target = getControl(labels[i]);
			if (target == null) break;
			mergeArgTypesAt(i, args, labelArgs(target));
			if (err.error()) break;
		}
		return args;
	}
	def mergeArgTypesAt(i: int, args: Array<ValueType>, nargs: Array<ValueType>) {
		if (args.length != nargs.length) {
			err.fail3(opcode_pos, WasmError.TYPE_MISMATCH,
				"br_table[0] label expects %d values, br_table[%d] label expects %d",
				i, args.length, nargs.length);
			return;
		}
		for (j < args.length) {
			var e = args[j], g = nargs[j];
			var t = ValueTypes.leastUpperBound(e, g);
			if (!t.0) {
				var buf = StringBuilder.new();
				buf.put2("br_table[%d][%d] ", i, j);
				buf.put2("type %q cannot be merged with type %q",
					 ValueTypes.render(_, e), ValueTypes.render(_, g));
				err.fail(opcode_pos, WasmError.TYPE_MISMATCH,
					buf.extract());
				return;
			}
			args[j] = t.1;
		}
	}
	def checkAlignment(opcode: byte, max: u32) {
		var memarg = parser.readMemoryArg();
		var align = memarg.0;
		if (align > max) {
			err.fail2(opcode_pos, WasmError.INVALID_ALIGNMENT,
				"expect max alignment %d, got %d", max, align);
		}
		var sig = Opcodes.signatures[opcode];
		checkAndPopArgs(sig.params);
		pushTypes(sig.results);
	}
	def traceOpcode() {
		trace.put2("  %x(+%d): ", opcode_pos, opcode_pos - ctlxfer.start_pos);
		var codeptr = parser.decoder;
		var prev = codeptr.pos;
		codeptr.pos = opcode_pos;
		Opcodes.renderInstr(trace, module, codeptr);
		codeptr.pos = prev;
		trace.ln();
		trace.out(Trace.STDOUT);
		trace.reset();
	}
	def checkArgs(p: Array<ValueType>) {
		if (p == null) return;
		for (i = p.length - 1; i >= 0; i--) popE(p[i]);
		val_stack.pushA(p);  // TODO: unreachable concern?
	}
	def checkAndPopArgs(p: Array<ValueType>) {
		for (i = p.length - 1; i >= 0; i--) popE(p[i]);
	}
	def checkArgsAndTransfer() {
		var p = ctl_top.sig.results;
		var count = val_stack.top - ctl_top.val_stack_top;
		if (count > p.length || (ctl_top.reachable && count < p.length)) {
			err.fail2(opcode_pos, WasmError.TYPE_MISMATCH,
				"expected %d values for fallthru, found %d",
				p.length, count);
		}
		for (i = p.length - 1; i >= 0; i--) popE(p[i]);
		val_stack.top = ctl_top.val_stack_top;
		val_stack.pushA(p);
	}

	def push(v: ValueType) {
		val_stack.push(v);
	}
	def pop() -> ValueType {
		if (val_stack.top <= ctl_top.val_stack_top) {
			if (ctl_top.reachable) err.fail(opcode_pos,
				WasmError.TYPE_MISMATCH,
				"empty value stack");
			return ValueType.I32;
		}
		return val_stack.pop();
	}
	def popE(expected: ValueType) {
		if (val_stack.top <= ctl_top.val_stack_top) {
			if (ctl_top.reachable) {
				err.fail1(opcode_pos, WasmError.TYPE_MISMATCH,
						"empty value stack, expected %q",
						ValueTypes.render(_, expected));
			}
			return; // unreachable or already signalled an error
		}
		var t = val_stack.pop();
		if (!ValueTypes.isAssignable(t, expected)) {
			err.fail2(opcode_pos, WasmError.TYPE_MISMATCH,
				"expected type %q, got %q",
				ValueTypes.render(_, expected),
				ValueTypes.render(_, t));
		}
	}
	def popAny() -> ValueType {
		if (val_stack.top <= ctl_top.val_stack_top) {
			if (ctl_top.reachable) err.fail(opcode_pos, WasmError.TYPE_MISMATCH, "empty value stack");
		}
		return val_stack.pop();
	}
	def pushTypes(r: Array<ValueType>) {
		val_stack.pushA(r);
	}
	def checkArgsAndPushControl(opcode: byte, sig: TypeDecl.Function) -> ControlEntry {
		checkArgs(sig.params);
		return pushControl(opcode, sig, val_stack.top - sig.params.length);
	}
	def pushControl(opcode: byte, sig: TypeDecl.Function,
			val_stack_top: int) -> ControlEntry {
		var ctl = ctl_stack.next();
		if (ctl != null) { // FAST: reuse previous ControlEntry object
			ctl_stack.top++;
		} else { // allocate and cache new ControlEntry object
			ctl = ControlEntry.new();
			ctl_stack.push(ctl);
		}
		ctl_top = ctl;
		ctl.start_pos = opcode_pos;
		ctl.start_opcode = opcode;
		ctl.sig = sig;
		ctl.val_stack_top = val_stack_top;
		ctl.reachable = true;
		ctl.ctl_refs.resize(0);
		return ctl;
	}
	def popControl() -> ControlEntry {
		var entry = ctl_stack.pop();
		ctl_top = ctl_stack.peek();
		return entry;
	}
	def getControl(depth: u32) -> ControlEntry {
		if (depth >= ctl_stack.top) {
			err.fail2(opcode_pos, WasmError.OOB_LABEL,
				"label %d exceeds control depth %d",
				depth, ctl_stack.top);
			return null;
		}
		var result = ctl_stack.elems[ctl_stack.top - int.!(depth) - 1];
		if (Trace.verify) {
			trace.put2("    label: depth=%d @+%d\n", depth, result.start_pos - ctlxfer.start_pos);
			trace.out(Trace.STDOUT);
			trace.reset();
		}
		return result;
	}
	def getLocalType(index: u32) -> ValueType {
		if (index >= locals.length) {
			err.fail2(opcode_pos, WasmError.OOB_INDEX,
				"local index %d exceeds local count %d",
				index, locals.length);
			return ValueType.I32;
		}
		return locals[int.!(index)];
	}
	def traceStack(before: bool) {
		if (before) trace.put1("    stack: %d| ", val_stack.top);
		else        trace.put1("       ==> %d| ", val_stack.top);

		var start = val_stack.top - 5;
		if (start > 0) trace.puts("... ");
		else start = 0;
		for (i = start; start < val_stack.top; start++) {
			var e = val_stack.elems[i];
			ValueTypes.render(trace, e);
			trace.putc(' ');
		}
		trace.ln();
		trace.out(Trace.STDOUT);
		trace.reset();
	}
}
def labelArgs(target: ControlEntry) -> Array<ValueType> {
	if (target.start_opcode == Opcode.LOOP.code) return target.sig.params;
	else return target.sig.results;
}
type CodeValidatorResult {
	case Ok {}
	case Error(error: WasmError, pc: int, msg: string) { }
}
// An entry in the control stack, exposed guts.
class ControlEntry {
	var start_pos: int;
	var start_opcode: byte;
	var sig: TypeDecl.Function;
	var reachable = true;
	var val_stack_top: int;
	def ctl_refs = Vector<int>.new();
}
// Responsible for building the mapping from pc -> ctlxfer
class CtlXferBuilder(trace: StringBuilder) {
	def entries = Vector<(u23, i23, u10, u23)>.new();
	var start_pos: int;
	def reset(start_pos: int) {
		this.start_pos = start_pos;
		entries.resize(0);
	}
	def refS(target: ControlEntry, pos: int, val_stack: Stack<ValueType>) {
		var valcount = u10.!(labelArgs(target).length);
		var popcount = val_stack.top - valcount - target.val_stack_top;
		refV(target, pos, valcount, u23.!(popcount));
	}
	def refV(target: ControlEntry, pos: int, valcount: u10, popcount: u23) {
		var pc = rel(pos);
		if (trace != null) {
			trace.put2("    refV(@+%d to +%d.label, ",
				int.!(pc), int.!(rel(target.start_pos)));
			trace.put2("valcount=%d, popcount=%d)\n",
				u32.!(valcount), u32.!(popcount));
			trace.out(Trace.STDOUT);
			trace.reset();
		}
		var index = entries.length;
		entries.put(pc, 0, valcount, popcount);
		target.ctl_refs.put(index);
	}
	def bind(target: ControlEntry, pos: int) {
		var refs = target.ctl_refs, pc = rel(pos);
		for (i = refs.length - 1; i >= 0; i--) {
			var index = refs[i];
			var t = entries[index];
			var delta = i23.!(pc - int.!(t.0));
			entries[index] = (t.0, delta, t.2, t.3);
			if (trace != null) {
				trace.put2("    resolve(@+%d to +%d)\n",
					int.!(t.0), int.!(pc));
				trace.out(Trace.STDOUT);
				trace.reset();
			}
		}
		refs.resize(0);
	}
	def rel(pos: int) -> u23 {
		return u23.!(pos - start_pos);
	}
	def extract() -> Array<(u23, i23, u10, u23)> {
		return if(entries.length > 0, entries.extract());
	}
}
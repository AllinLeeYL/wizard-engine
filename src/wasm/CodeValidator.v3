// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implements that validation logic for the code of a function.
class CodeValidator(module: Module) {
	def decoder = Decoder.new([]);
	def parser = BinImmParser.new(module, decoder);
	def locals = Vector<ValueType>.new();
	def val_stack = Stack<ValueType>.new();
	def ctl_stack = Stack<ControlEntry>.new();
	def ctl_xfers = Vector<(u23, i23, u10, u23)>.new();
	var ctl_top: ControlEntry;  // FAST: cache of top of control stack
	var func: FunctionDecl;
	var opcode_pt: int;

	def validate(f: FunctionDecl) -> CodeValidatorResult {
		func = f;
		decoder.reset(f.code.orig, 0, f.code.orig.length);
		ctl_stack.clear();
		val_stack.clear();
		ctl_xfers.resize(0);
		setupParams();
		readLocalDecls();
		opcode_pt = parser.decoder.pos;
		pushControl(WasmOpcode.UNREACHABLE.code, f.sig);
		validateCode();
		if (ctl_xfers.size() > 0) func.code.ctl_xfer = ctl_xfers.extract();
		if (decoder.ok()) return CodeValidatorResult.Ok;
		else return CodeValidatorResult.Error(decoder.error_pos + decoder.skipped,
				decoder.error_msg);
	}

	def setupParams() {
		var p = func.sig.params;
		locals.resize(p.length);
		for (i < p.length) locals[i] = p[i];
	}
	def readLocalDecls() {
		var d = parser.readU32("local decl count", 0, Limits.max_num_locals);
		for (i < d) {
			var count = parser.readU32("local count", 0, Limits.max_num_locals);
			var ltype = parser.readValueType();
			for (i < count) locals.add(ltype); // TODO(fast): bulk append value type
		}
		func.code.num_locals = locals.size();
	}
	def validateCode() {
		var d = parser.decoder;
		while (d.pos < d.limit) {
			opcode_pt = parser.decoder.pos;
			var opcode = parser.readByte("opcode", WasmOpcodes.render);
			// FAST: Handle short operators (predictable direct branch)
			if (WasmOpcodes.isShortOperator[opcode]) {
				// TODO(fast): combine signature read with isOperator() check
				var sig = WasmOpcodes.signatures[opcode];
				var p = sig.params, r = sig.results;
				if (p.length > 0) checkAndPopArgs(p);
				if (r.length > 0) pushTypes(r);
				continue;
			}
			// Handle all other operators in the switch (indirect branch)
			match (opcode) {
				WasmOpcode.UNREACHABLE.code => {
					ctl_top.reachable = false;
					val_stack.top = ctl_top.val_stack_top;
				}
				WasmOpcode.BLOCK.code => {
					var sig = parser.readBlockType();
					checkArgs(sig.params);
					pushControl(opcode, sig);
				}
				WasmOpcode.LOOP.code => {
					var sig = parser.readBlockType();
					checkArgs(sig.params);
					pushControl(opcode, sig);
				}
				WasmOpcode.IF.code => {
					var sig = parser.readBlockType();
					popE(ValueType.I32);
					checkArgs(sig.params);
					var ctl = pushControl(opcode, sig);
					var ctl_index = ctl_xfers.size();
					ctl_xfers.add(u23.!(opcode_pt), 0, 0, 0);
					ctl.ctl_refs.add(ctl_index);
				}
				WasmOpcode.ELSE.code => {
					if (ctl_top.start_opcode != WasmOpcode.IF.code) {
						return parser.FAIL1(opcode_pt, "mismatched else", ());
					}
					checkArgsAndTransfer();
					var if_branch = ctl_top.ctl_refs[0];
					// branches within if-true block go to "else"...
					resolveBranches(ctl_top, opcode_pt);
					// ... except false target of "if"
					ctl_top.ctl_refs.add(if_branch);
					resolveBranches(ctl_top, opcode_pt + 1);
					// "else" implicitly goes to end
					addCtlRef(ctl_top, opcode_pt);
					
					ctl_top.start_opcode = opcode;
					val_stack.top = ctl_top.val_stack_top;
					pushTypes(ctl_top.sig.params);
				}
				WasmOpcode.END.code => {
					checkArgsAndTransfer();
					var ctl = popControl();
					if (ctl == null) {
						return parser.FAIL1(opcode_pt, "empty control stack", ());
					}
					if (ctl.start_opcode == WasmOpcode.LOOP.code) {
						resolveBranches(ctl, ctl.start_pt);
					} else {
						resolveBranches(ctl, opcode_pt);
					}
				}
				WasmOpcode.BR.code => {
					var depth = parser.readLabel();
					var target = getControl(depth);
					if (target == null) return;
					addCtlRef(target, opcode_pt);
					checkAndPopArgs(target.sig.results);
					ctl_top.reachable = false;
					val_stack.top = ctl_top.val_stack_top;
				}
				WasmOpcode.BR_IF.code => {
					var depth = parser.readLabel();
					var target = getControl(depth);
					if (target == null) return;
					popE(ValueType.I32);
					addCtlRef(target, opcode_pt);
					checkArgs(target.sig.results);
				}
				WasmOpcode.BR_TABLE.code => {
					var labels = parser.readLabels();
					popE(ValueType.I32);
					var i = 0;
					ctl_xfers.add(u23.!(opcode_pt), i23.!(labels.length), 0, 0);
					for (depth in labels) {
						var target = getControl(depth);
						if (target == null) return;
						checkArgs(target.sig.results);
						addCtlRef(target, opcode_pt + ++i);
					}
					ctl_top.reachable = false;
					val_stack.top = ctl_top.val_stack_top;
				}
				WasmOpcode.RETURN.code => {
					checkAndPopArgs(func.sig.results);
					ctl_top.reachable = false;
					val_stack.top = ctl_top.val_stack_top;
				}
				WasmOpcode.CALL.code => {
					var t = parser.readFunc(), target = t.1;
					checkAndPopArgs(target.sig.params);
					pushTypes(target.sig.results);
				}
				WasmOpcode.CALL_INDIRECT.code => {
					var sig = parser.readSig().1;
					var t = parser.readTableIndex();
					popE(ValueType.I32);
					checkAndPopArgs(sig.params);
					pushTypes(sig.results);
				}
				WasmOpcode.DROP.code => {
					popAny();
				}
				WasmOpcode.SELECT.code => {
					popE(ValueType.I32);
					var t = popAny();
					popE(t);
					val_stack.push(t);
				}
				WasmOpcode.LOCAL_GET.code => {
					var index = parser.readLocalIndex();
					var t = getLocalType(index);
					val_stack.push(t);
				}
				WasmOpcode.LOCAL_SET.code => {
					var index = parser.readLocalIndex();
					var t = getLocalType(index);
					popE(t);
				}
				WasmOpcode.LOCAL_TEE.code => {
					var index = parser.readLocalIndex();
					var t = getLocalType(index);
					popE(t);
					val_stack.push(t);  // TODO: unreachable concern?
				}
				WasmOpcode.GLOBAL_GET.code => {
					var g = parser.readGlobal().1;
					if (g == null) return;
					val_stack.push(g.valtype);
				}
				WasmOpcode.GLOBAL_SET.code => {
					var g = parser.readGlobal().1;
					if (g == null) return;
					popE(g.valtype);
				}
				WasmOpcode.I32_LOAD.code,
				WasmOpcode.I64_LOAD.code,
				WasmOpcode.F32_LOAD.code,
				WasmOpcode.F64_LOAD.code,
				WasmOpcode.I32_LOAD8_S.code,
				WasmOpcode.I32_LOAD8_U.code,
				WasmOpcode.I32_LOAD16_S.code,
				WasmOpcode.I32_LOAD16_U.code,
				WasmOpcode.I64_LOAD8_S.code,
				WasmOpcode.I64_LOAD8_U.code,
				WasmOpcode.I64_LOAD16_S.code,
				WasmOpcode.I64_LOAD16_U.code,
				WasmOpcode.I64_LOAD32_S.code,
				WasmOpcode.I64_LOAD32_U.code,
				WasmOpcode.I32_STORE.code,
				WasmOpcode.I64_STORE.code,
				WasmOpcode.F32_STORE.code,
				WasmOpcode.F64_STORE.code,
				WasmOpcode.I32_STORE8.code,
				WasmOpcode.I32_STORE16.code,
				WasmOpcode.I64_STORE8.code,
				WasmOpcode.I64_STORE16.code,
				WasmOpcode.I64_STORE32.code => {
					var memarg = parser.readMemoryArg();
					// TODO: check alignment
					var sig = WasmOpcodes.signatures[opcode];
					checkAndPopArgs(sig.params);
					pushTypes(sig.results);
				}

				WasmOpcode.MEMORY_SIZE.code,
				WasmOpcode.MEMORY_GROW.code => {
					var index = parser.readMemoryIndex();
					var sig = WasmOpcodes.signatures[opcode];
					checkAndPopArgs(sig.params);
					pushTypes(sig.results);
				}
				WasmOpcode.I32_CONST.code => {
					parser.readI32();
					val_stack.push(ValueType.I32);
				}
				WasmOpcode.I64_CONST.code => {
					parser.readI64();
					val_stack.push(ValueType.I64);
				}
				WasmOpcode.F32_CONST.code => {
					parser.readF32();
					val_stack.push(ValueType.F32);
				}
				WasmOpcode.F64_CONST.code => {
					parser.readF64();
					val_stack.push(ValueType.F64);
				}
				_ => ;
			}
		}
	}

	def resolveBranches(target: ControlEntry, pc: int) {
		var refs = target.ctl_refs;
		for (i = refs.size() - 1; i >= 0; i--) {
			var index = refs[i];
			var t = ctl_xfers[index];
			var delta = i23.!(pc - int.!(t.0));
			ctl_xfers[index] = (t.0, delta, t.2, t.3);
		}
		refs.resize(0);
	}
	def addCtlRef(target: ControlEntry, pc: int) {
		var index = ctl_xfers.size();
		var valcount = target.sig.results.length;
		var popcount = val_stack.top - valcount - target.val_stack_top;
		ctl_xfers.add(u23.!(pc), 0, u10.!(valcount), u23.!(popcount));
		target.ctl_refs.add(index);
		if (false) {
			var buf = StringBuffer.new();
			buf.put3("++val_stack.top=%d, valcount=%d, target.val_stack_top=%d\n",
				val_stack.top, valcount, target.val_stack_top);
			System.puts(buf.extract());
		}
	}
	def checkArgs(p: Array<ValueType>) {
		for (i = p.length - 1; i >= 0; i--) popE(p[i]);
		val_stack.pushA(p);  // TODO: unreachable concern?
	}
	def checkAndPopArgs(p: Array<ValueType>) {
		for (i = p.length - 1; i >= 0; i--) popE(p[i]);
	}
	def checkArgsAndTransfer() {
		var p = ctl_top.sig.results;
		var count = val_stack.top - ctl_top.val_stack_top;
		if (ctl_top.reachable && count != p.length) {
			parser.FAIL2(opcode_pt, "expected %d values for fallthru, found %d", p.length, count);
		}
		for (i = p.length - 1; i >= 0; i--) popE(p[i]);
		val_stack.top = ctl_top.val_stack_top;
		val_stack.pushA(p);
	}

	def push(v: ValueType) {
		val_stack.push(v);
	}
	def pop() -> ValueType {
		if (val_stack.top <= ctl_top.val_stack_top) {
			if (ctl_top.reachable) parser.FAIL1(opcode_pt, "empty value stack", ());
			return ValueType.I32;
		}
		return val_stack.pop();
	}
	def popE(expected: ValueType) {
		if (val_stack.top <= ctl_top.val_stack_top) {
			if (ctl_top.reachable) {
				parser.FAIL1(opcode_pt, "empty value stack, expected %q",
						ValueTypes.render(_, expected));
			}
			return; // unreachable or already signalled an error
		}
		var t = val_stack.pop();
		if (!ValueTypes.isAssignable(t, expected)) {
			parser.FAIL2(opcode_pt, "expected type %q, got %q",
				ValueTypes.render(_, expected), ValueTypes.render(_, t));
		}
	}
	def popAny() -> ValueType {
		if (val_stack.top <= ctl_top.val_stack_top) {
			if (ctl_top.reachable) parser.FAIL1(opcode_pt, "empty value stack", ());
		}
		return val_stack.pop();
	}
	def pushTypes(r: Array<ValueType>) {
		val_stack.pushA(r);
	}
	def pushControl(opcode: byte, sig: TypeDecl.Function) -> ControlEntry {
		var ctl = ctl_stack.next();
		if (ctl != null) { // FAST: reuse previous ControlEntry object
			ctl_stack.top++;
		} else { // allocate and cache new ControlEntry object
			ctl = ControlEntry.new();
			ctl_stack.push(ctl);
		}
		ctl_top = ctl;
		ctl.start_pt = opcode_pt;
		ctl.start_opcode = opcode;
		ctl.sig = sig;
		ctl.val_stack_top = val_stack.top;
		ctl.reachable = true;
		ctl.ctl_refs.resize(0);
		return ctl;
	}
	def popControl() -> ControlEntry {
		var entry = ctl_stack.pop();
		ctl_top = ctl_stack.peek();
		return entry;
	}
	def getControl(depth: u32) -> ControlEntry {
		if (depth >= ctl_stack.top) {
			parser.FAIL2(opcode_pt, "label %d exceeds control depth %d",
					depth, ctl_stack.top);
			return null;
		}
		return ctl_stack.elems[ctl_stack.top - int.!(depth) - 1];
	}
	def getLocalType(index: u32) -> ValueType {
		if (index >= locals.size()) {
			parser.FAIL2(opcode_pt, "local index %d exceeds local count %d",
					index, locals.size());
			return ValueType.I32;
		}
		return locals[int.!(index)];
	}
}
type CodeValidatorResult {
	case Ok {}
	case Error(pc: int, msg: string) { }
}
// An entry in the control stack, exposed guts.
class ControlEntry {
	var start_pt: int;
	var start_opcode: byte;
	var sig: TypeDecl.Function;
	var reachable = true;
	var val_stack_top: int;
	def ctl_refs = Vector<int>.new();
}

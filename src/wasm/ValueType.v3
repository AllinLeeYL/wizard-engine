// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// The allowable types of any value in WebAssembly.
enum ValueType {
	I32,
	I64,
	F32,
	F64,
	VEC128, /* ext:simd */
	ANYREF /* ext:reference-types */
	/* ext:exception-handling case Exception() */
	/* ext:typed-functions case Function() */
	/* ext:gc case Ref() */
}

// Utility functions associated with value types.
component ValueTypes {
	def render(buf: StringBuilder, t: ValueType) -> StringBuilder {
		var s: string;
		match (t) {
			I32 => s = "i32";
			I64 => s = "i64";
			F32 => s = "f32";
			F64 => s = "f64";
			VEC128 => s = "v128";
			ANYREF => s = "ref";
		}
		return buf.puts(s);
	}
	def isAssignable(from: ValueType, to: ValueType) -> bool {
		return from == to;
	}
	def isAssignableSig(from: TypeDecl.Function, to: TypeDecl.Function) -> bool {
		if (from.params.length != to.params.length) return false;
		if (from.results.length != to.results.length) return false;
		for (i < from.params.length) {
			var f = from.params[i], t = to.params[i];
			if (!isAssignable(t, f)) return false; // contra-variant
		}
		for (i < from.results.length) {
			var f = from.results[i], t = to.results[i];
			if (!isAssignable(f, t)) return false; // co-variant
		}
		return true;
	}
	def renderSig(buf: StringBuilder, t: TypeDecl.Function) -> StringBuilder {
		buf.puts("(");
		for (i < t.params.length) {
			if (i > 0) buf.puts(", ");
			render(buf, t.params[i]);
		}
		buf.puts(") -> (");
		for (i < t.results.length) {
			if (i > 0) buf.puts(", ");
			render(buf, t.results[i]);
		}
		buf.puts(")");
		return buf;
	}
	def leastUpperBound(t: ValueType, f: ValueType) -> (bool, ValueType) {
		if (t == f) return (true, t);
		return (false, t);
	}
}
// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Mutable in-memory representation of a WebAssembly module.
class Module {
	def types = IndexSpace<TypeDecl>.new();
	def imports = Vector<ImportDecl>.new();
	def functions = IndexSpace<FunctionDecl>.new();
	def tables = IndexSpace<TableDecl>.new();
	def memories = IndexSpace<MemoryDecl>.new();
	def globals = IndexSpace<GlobalDecl>.new();
	def events = Vector<EventDecl>.new(); /* ext:exception-handling */
	def exports = Vector<ExportDecl>.new();
	var start_function = -1;
	def elems = Vector<ElemDecl>.new();
	def data = Vector<DataDecl>.new();
	def custom_sections = Vector<CustomSection>.new();
}

// An index space may have a number of imported entities, which get indices
// before declared entities.
class IndexSpace<T> {
	def imported = Vector<T>.new();
	def declared = Vector<T>.new();
	def [i: int] -> T {
		if (i < imported.size()) return imported[i];
		else return declared[i - imported.size()];
	}
	def size() -> int {
		return imported.size() + declared.size();
	}
}

// Value types as defined by the spec.
enum ValueType {
	I32,
	I64,
	F32,
	F64,
	VEC128, /* ext:simd */
	ANYREF, /* ext:reference-types */
	EXNREF /* ext:exception-handling */
	/* ext:typed-functions case Function() */
	/* ext:gc case Ref() */
}

// A type declaration that can occur in the types section.
type TypeDecl {
	case Function(params: Array<ValueType>, /* ext:multi-value */ results: Array<ValueType>);
	/* ext:gc case Struct() */
}

// Import declaration, including module name, element name, and details, including kind.
class ImportDecl(modname: string, name: string, details: ImportDetails) {
}

// The details for each of the different kinds of imports.
type ImportDetails {
	case Function(decl: FunctionDecl);
	case Table(decl: TableDecl);
	case Memory(decl: MemoryDecl);
	case Global(decl: GlobalDecl);
	/* ext:type-imports case Type() */
	/* ext:exception-handling Event() */
}

// A function declaration than can occur in the function section.
class FunctionDecl(imported: bool, sig_index: int, var sig: TypeDecl.Function) {
	var body: Array<byte>;
}

// A table declaration that can occur in the tables section.
class TableDecl(imported: bool, elemtype: ElemType, minimum: int, maximum: int) {
}
type ElemType {
	case FuncRef;
	case AnyRef;
}

// A memory declaration that can occur in the memories section.
class MemoryDecl(imported: bool, minimum: int, maximum: int, /* ext: threads */ shared: bool) {
}

// A global declaration that can occur in the globals section.
class GlobalDecl(imported: bool, valtype: ValueType, mutable: bool, init: InitExpr) {
}

// ext:exception-handling
class EventDecl(attribute: int, evntype_index: int, evntype: TypeDecl.Function) {
}

// An export declaration for a module.
class ExportDecl(name: string, details: ExportDetails) {
}

// The details for each of the different kinds of exports.
type ExportDetails {
	case Function(index: int);
	case Table(index: int);
	case Memory(index: int);
	case Global(index: int);
	/* ext:type-imports case Type() */
	/* ext:exception-handling Event() */
}

// An element declaration that can occur in the elements section.
class ElemDecl(table_index: int, offset: InitExpr, details: ElemDetails,
		/* ext:bulk-memory */ active: bool) {
}
type ElemDetails {
	case FuncRefs(vals: Array<int>);
	case Exprs(vals: Array<InitExpr>); /* ext:bulk-memory */
}


// A data segment declaration that can occur in the data section.
class DataDecl(mem_index: int, offset: InitExpr, data: Array<byte>,
		/* ext: bulk-memory */ active: bool) {
}

// An uninterpreted custom section.
class CustomSection(name: string, payload: Array<byte>) {
}

// The names section is a special custom section that is interpreted by
// engines to aid in debugging.
class NamesSection extends CustomSection {
	new(data: Array<byte>) super("names", data) { }
}

// A special kind of expression that can be used in initialization.
type InitExpr {
	case I32(val: i32);
	case I64(val: i64);
	case F32(val: u32);
	case F64(val: u64);
	case Global(global_index: int);
}
// Utility functions associated with value types.
component ValueTypes {
	def render(buf: StringBuffer, t: ValueType) -> StringBuffer {
		var s: string;
		match (t) {
			I32 => s = "i32";
			I64 => s = "i64";
			F32 => s = "f32";
			F64 => s = "f64";
			VEC128 => s = "v128";
			ANYREF => s = "ref";
			EXNREF => s = "exn";
		}
		return buf.puts(s);
	}
	def isAssignable(from: ValueType, to: ValueType) -> bool {
		return from == to;
	}
	def isAssignableSig(from: TypeDecl.Function, to: TypeDecl.Function) -> bool {
		if (from.params.length != from.params.length) return false;
		if (from.results.length != to.results.length) return false;
		for (i < from.params.length) {
			var f = from.params[i], t = to.params[i];
			if (!isAssignable(t, f)) return false; // contra-variant
		}
		for (i < from.results.length) {
			var f = from.results[i], t = to.results[i];
			if (!isAssignable(f, t)) return false; // co-variant
		}
		return false;
	}
}
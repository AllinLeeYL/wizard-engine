// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Mutable in-memory representation of a WebAssembly module.
class Module(filename: string) {
	def types = IndexSpace<TypeDecl>.new();
	def imports = Vector<ImportDecl>.new();
	def functions = IndexSpace<FunctionDecl>.new();
	def tables = IndexSpace<TableDecl>.new();
	def memories = IndexSpace<MemoryDecl>.new();
	def globals = IndexSpace<GlobalDecl>.new();
	def events = Vector<EventDecl>.new(); /* ext:exception-handling */
	def exports = Vector<ExportDecl>.new();
	var start_function = -1;
	var explicit_data_count = -1;
	def elems = Vector<ElemDecl>.new();
	def data = Vector<DataDecl>.new();
	def custom_sections = Vector<CustomSection>.new();
}

// An index space may have a number of imported entities, which get indices
// before declared entities.
class IndexSpace<T> {
	def imported = Vector<T>.new();
	def declared = Vector<T>.new();
	def [i: int] -> T {
		if (i < imported.length) return imported[i];
		else return declared[i - imported.length];
	}
	def size() -> int {
		return imported.length + declared.length;
	}
	def usize() -> u32 {
		return u32.!(imported.length + declared.length);
	}
}

// A type declaration that can occur in the types section.
type TypeDecl {
	case Function(f: ValueType.Function);
	case Imported(index: u32, details: ImportDetails.Type);
	/* ext:gc case Struct() */
}

// Import declaration, including module name, element name, and details,
// including kind.
class ImportDecl(modname: string, name: string, details: ImportDetails) {
}

// The details for each of the different kinds of imports.
type ImportDetails {
	case Function(decl: FunctionDecl);
	case Table(decl: TableDecl);
	case Memory(decl: MemoryDecl);
	case Global(decl: GlobalDecl);
	case Type(constraints: Array<TypeConstraint>);
	/* ext:exception-handling Event() */
}
// A constraint on an imported type.
type TypeConstraint {
	case HasDefaultValue;
	case AssignTo(t: TypeExpr);
	case Equal(t: TypeExpr);
}
// A function declaration than can occur in the function section.
class FunctionDecl(index: int, sig_index: int, var sig: ValueType.Function) {
	var code: FunctionCode;
	var reffed: bool;
}
// A table declaration that can occur in the tables section.
class TableDecl(index: int, elemtype: ValueType, initial: int, maximum: int) {
}

// A memory declaration that can occur in the memories section.
class MemoryDecl(index: int, initial: int, maximum: int, /* ext: threads */ shared: bool) {
}

// A global declaration that can occur in the globals section.
class GlobalDecl(index: int, valtype: ValueType, mutable: bool, init: InitExpr) {
}

// ext:exception-handling
class EventDecl(attribute: int, evntype_index: int, evntype: ValueType.Function) {
}

// An export declaration for a module.
class ExportDecl(name: string, details: ExportDetails) {
}

// The details for each of the different kinds of exports.
type ExportDetails {
	case Function(index: int);
	case Table(index: int);
	case Memory(index: int);
	case Global(index: int);
	/* ext:type-imports case Type() */
	/* ext:exception-handling Event() */
}

// An element declaration that can occur in the elements section.
class ElemDecl(elemtype: ValueType, mode: SegmentMode, details: ElemDetails) {
}
type ElemDetails {
	case FuncRefs(vals: Array<int>);
	case Exprs(vals: Array<InitExpr>); /* ext:reference-types */
	def length() -> int {
		match (this) {
			FuncRefs(vals) => return vals.length;
			Exprs(vals) => return vals.length;
		}
	}
}
type SegmentMode {
	case Passive;
	case Active(index: int, offset: InitExpr);
	case Declarative;
}

// A data segment declaration that can occur in the data section.
class DataDecl(mode: SegmentMode, data: Array<byte>) {
}

// An uninterpreted custom section.
class CustomSection(name: string, payload: Array<byte>) {
}

// The names section is a special custom section that is interpreted by
// engines to aid in debugging.
class NamesSection extends CustomSection {
	new(data: Array<byte>) super("names", data) { }
}

// A special kind of expression that can be used in initialization.
type InitExpr {
	case I32(val: i32);
	case I64(val: i64);
	case F32(val: u32);
	case F64(val: u64);
	case FuncRefNull;
	case ExternRefNull;
	case Global(global_index: int, decl: GlobalDecl);
	case FuncRef(func_index: int, decl: FunctionDecl);
}

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A wasm memory, currently backed by an array of bytes.
class Memory(decl: MemoryDecl) extends Exportable {
	var data: Array<byte>;
	var oom = false;
	new() {
		var bytes = u64.!(decl.initial) * PAGE_SIZE;
		if (bytes > int.max || decl.initial > EngineLimits.limit_memory_pages) {
			oom = true;
		} else {
			data = Array<byte>.new(int.!(bytes));
		}
	}
	def size() -> u32 {
		return if(data != null, u32.!(data.length) / PAGE_SIZE);
	}
	def length() -> int {
		return if(data != null, data.length);
	}
	def deallocate() {
		data = null;
	}
	def grow(pages: u32) -> int {
		var current = u64.!(size());
		if (pages == 0) return int.!(current);
		var nsize = current + pages;
		if (decl.maximum > 0 && nsize > decl.maximum) return -1;
		if (nsize > EngineLimits.limit_memory_pages) return -1;
		var ndata = Array<byte>.new(int.!(nsize * PAGE_SIZE));
		for (i < data.length) ndata[i] = data[i];
		data = ndata;
		return int.!(current);
	}
	def read_u8(offset: u32, index: u32) -> (TrapReason, u8) {
		var i = boundsCheck(offset, index, 1);
		if (i < 0) return (TrapReason.MEM_OUT_OF_BOUNDS, 0);
		var val = data[i];
		return (TrapReason.NONE, val);
	}
	def read_u16(offset: u32, index: u32) -> (TrapReason, u16) {
		var i = boundsCheck(offset, index, 2);
		if (i < 0) return (TrapReason.MEM_OUT_OF_BOUNDS, 0);
		var b0 = data[i], b1 = data[i+1];
		var val = u16.!(b1) << 8 | b0;
		return (TrapReason.NONE, val);
	}
	def read_u32(offset: u32, index: u32) -> (TrapReason, u32) {
		var i = boundsCheck(offset, index, 4);
		if (i < 0) return (TrapReason.MEM_OUT_OF_BOUNDS, 0);
		var b0 = data[i], b1 = data[i+1], b2 = data[i+2], b3 = data[i+3];
		var val = (u32.!(b3) << 24) | (u32.!(b2) << 16) | (u32.!(b1) << 8) | b0;
		return (TrapReason.NONE, val);
	}
	def read_u64(offset: u32, index: u32) -> (TrapReason, u64) {
		var i = boundsCheck(offset, index, 8);
		if (i < 0) return (TrapReason.MEM_OUT_OF_BOUNDS, 0);
		var b0 = data[i], b1 = data[i+1], b2 = data[i+2], b3 = data[i+3];
		var w0 = (u32.!(b3) << 24) | (u32.!(b2) << 16) | (u32.!(b1) << 8) | b0;
		var b4 = data[i+4], b5 = data[i+5], b6 = data[i+6], b7 = data[i+7];
		var w1 = (u32.!(b7) << 24) | (u32.!(b6) << 16) | (u32.!(b5) << 8) | u32.!(b4);
		var val = (u64.!(w1) << 32) | w0;
		return (TrapReason.NONE, val);
	}
	def write_u8(offset: u32, index: u32, val: u8) -> TrapReason {
		var i = boundsCheck(offset, index, 8);
		if (i < 0) return TrapReason.MEM_OUT_OF_BOUNDS;
		data[i] = val;
		return TrapReason.NONE;
	}
	def write_u16(offset: u32, index: u32, val: u16) -> TrapReason {
		var i = boundsCheck(offset, index, 2);
		if (i < 0) return TrapReason.MEM_OUT_OF_BOUNDS;
		data[i] = u8.!(val);
		data[i+1] = u8.!(val >> 8);
		return TrapReason.NONE;
	}
	def write_u32(offset: u32, index: u32, val: u32) -> TrapReason {
		var i = boundsCheck(offset, index, 4);
		if (i < 0) return TrapReason.MEM_OUT_OF_BOUNDS;
		data[i] = u8.!(val);
		data[i+1] = u8.!(val >> 8);
		data[i+2] = u8.!(val >> 16);
		data[i+3] = u8.!(val >> 24);
		return TrapReason.NONE;
	}
	def write_u64(offset: u32, index: u32, val: u64) -> TrapReason {
		var i = boundsCheck(offset, index, 8);
		if (i < 0) return TrapReason.MEM_OUT_OF_BOUNDS;
		data[i] = u8.!(val);
		data[i+1] = u8.!(val >> 8);
		data[i+2] = u8.!(val >> 16);
		data[i+3] = u8.!(val >> 24);
		data[i+4] = u8.!(val >> 32);
		data[i+5] = u8.!(val >> 40);
		data[i+6] = u8.!(val >> 48);
		data[i+7] = u8.!(val >> 56);
		return TrapReason.NONE;
	}
	def boundsCheck(offset: u32, index: u32, size: byte) -> int {
		if (data == null) return int.min;
		var x = u64.!(offset) + u64.!(index);
		var length = u64.!(data.length);
		return if(x + size > length, int.min, int.!(x));
	}
}
def PAGE_SIZE = 65536u;

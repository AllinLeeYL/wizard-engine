// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Main entrypoint to the Jawa execution environment.
def main(args: Array<string>) -> int {
	var engine = Engine.new();
	var programArgs: Array<string>;
	var path: string;

	engine.extensions |= Extension.REPEAT_SECTIONS;
	engine.extensions |= Extension.TYPE_IMPORTS;

	// Parse options and extract module and module arguments
	for (i < args.length) {
		var a = args[i];
		if (a.length > 0 && a[0] == '-') {
			if (!engine.parseOption(a)) return ErrorBuilder.new()
				.puts("jawa: unrecognized option ")
				.putsq(a)
				.ln()
				.exit(1);
		} else {
			path = a;
			programArgs = Arrays.range(args, i+1, args.length);
			break;
		}
	}

	if (path == null) return ErrorBuilder.new()
		.puts("jawa: no input files\n")
		.exit(3);

	if (!Strings.endsWith(path, ".wasm")) return ErrorBuilder.new()
		.puts(path)
		.puts(": unknown file format, expected .wasm\n")
		.exit(4);

	// Parse the binary module
	var result = engine.loadWasmFile(path);
	var module: Module;
	match (result) {
		Ok(m) => module = m;
		FileNotFound => return ErrorBuilder.new()
			.puts("jawa: could not load file ")
			.puts(path)
			.puts("\n")
			.exit(2);
		ParseError(code, path, error_pos, error_msg) => return ErrorBuilder.new()
			.render(code, path, error_pos, error_msg)
			.exit(3);
	}

	// Provide imports to the module and instantiate
	var err = WasmErrorGen.new(path);
	var binder = ImportBinder.new(module, err);
	var jip = JawaImportProcessor.new(JawaEnvironment.new(null), binder);
	binder.process();
	if (!err.ok()) return ErrorBuilder.new()
		.render(err.error_code, path, err.error_pos, err.error_msg)
		.exit(6);
	var i = Instantiator.new(engine.extensions, module, binder.bindings);
	var instance = i.run();

	if (!i.err.ok()) return ErrorBuilder.new()
		.render(i.err.error_code, path, i.err.error_pos, i.err.error_msg)
		.exit(6);

	// Find the main exported function
	var main = jip.extractMainExport(instance);

	if (main == null) return ErrorBuilder.new()
		.puts(path)
		.puts(": no main export from module\n")
		.exit(7);

	if (!checkMainSig(jip, main.sig)) return ErrorBuilder.new()
		.puts(path)
		.put1(": expected main export of type [jawa.lang.String] -> [], got %q\n", main.sig.render)
		.exit(8);

	// Provide the main arguments as an array of JawaStrings
	var exe = Interpreter.new();
	var exeArgs = Array<Value>.new(programArgs.length);
	for (i < exeArgs.length) {
		var a = programArgs[i];
		var t = Utf8.decodeUtf16(a, 0, a.length);
		if (t.0 == null) return ErrorBuilder.new()
			.puts("invalid UTF-8 argument: ")
			.putsq(a)
			.exit(8);
		var val = Value.ExternRef(JawaString.new(t.0));
		exeArgs[i] = val;
	}

	// Run the program
	var r = exe.run(-1, main, exeArgs);
	match (r) {
		Break => ;
		Value(vals) => return if(vals.length == 1, Values.v_i(vals[0]));
		Trap(reason) => {
			var e = ErrorBuilder.new()
				.puts("trap: ")
				.puts(reason.name)
				.ln();
			// TODO: provide a source-level stacktrace
			for (i = exe.call_stack.top - 1; i >= 0; i--) {
				var f = exe.call_stack.elems[i];
				e.puts("\t@ f");
				e.putd(f.func.decl.index);
				e.puts(" +");
				e.putd(f.pc);
				e.ln();
			}
			e.exit(10);
		}
	}
	return 0;
}
def checkMainSig(jip: JawaImportProcessor, sig: FuncSig) -> bool {
	if (sig.params.length != 1) return false;
	if (sig.results.length != 0) return false;
	match (sig.params[0]) {
		Host(host) => {
			if (!JawaType.?(host)) return false;
			return jip.env.isStringType(JawaType.!(host));
		}
		_ => return false;
	}
}

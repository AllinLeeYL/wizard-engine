// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class JawaField(name: JawaString, index: int, typ: JawaType) {
	def defaultValue() -> Value {
		return JawaTypes.defaultValue(typ);
	}
	def render(buf: StringBuilder) -> StringBuilder {
		buf.puts("field \"");
		name.render(buf);
		buf.puts("\" :");
		typ.renderJ(buf);
		return buf;
	}
}
class JawaMethod(name: JawaString, params: Array<JawaType>, ret: JawaType, var impl: Function) {
	var vtable_index = -1;
	var itable_index = -1;
	def sig(receiver: JawaType) -> FuncSig {
		var rt = if(ret.kind != JawaKind.VOID, [ret.valueType()], SigCache.arr_v);
		if (receiver == null) {
			return FuncSig.new(Arrays.map(params, JawaType.valueType), rt);
		} else {
			var v = Vector<ValueType>.new().grow(1 + params.length);
			v.put(receiver.valueType());
			for (p in params) v.put(p.valueType());
			return FuncSig.new(v.extract(), rt);
		}
	}
	def render(buf: StringBuilder) -> StringBuilder {
		buf.puts("method \"");
		name.render(buf);
		buf.puts("\" (");
		for (p in params) p.renderJ(buf);
		buf.puts(")");
		ret.renderJ(buf);
		return buf;
	}
}

// All built-in classes in Jawa.
component JawaClasses {
	def NO_INTERFACES: Array<JawaInterfaceType> = [];

	def OBJECT = JawaClassType.new(JawaStrings.of("jawa/lang/Object"), null, NO_INTERFACES);
	def STRING = JawaClassType.new(JawaStrings.of("jawa/lang/String"), OBJECT, NO_INTERFACES);

	new() {
		OBJECT.boilerplate = Values.NONE;
		STRING.boilerplate = Values.NONE;
		def NO_METHODS = Array<JawaMethod>.new(0);
		def NO_FIELDS = Array<JawaField>.new(0);
		OBJECT.instanceFields = OBJECT.staticFields = NO_FIELDS;
		STRING.instanceFields = STRING.staticFields = NO_FIELDS;
		OBJECT.instanceMethods = OBJECT.staticMethods = NO_METHODS;
		STRING.instanceMethods = STRING.staticMethods = NO_METHODS;
		OBJECT.vtable = [];
		STRING.vtable = [];
	}

	def add(env: JawaEnvironment) {
		env.add(OBJECT);
		env.add(STRING);
	}
	// Build vtable and itable for a class.
	def buildIVTables(ct: JawaClassType, err: ErrorGen) {
		var trace = if(Trace.jawa, TraceBuilder.new());
		if (ct.parent == null) {
			if (trace != null) trace.put2("jawa vtable \"%q\", parent=null, %d entries",
					ct.name.render, ct.instanceMethods.length)
				.outln();
			ct.vtable = Arrays.dup(ct.instanceMethods);
			for (i < ct.vtable.length) ct.vtable[i].vtable_index = i;
			buildITable(ct, err);
			return;
		}
		if (trace != null) trace.put3("jawa vtable \"%q\", parent=\"%q\", %d entries",
				ct.name.render, ct.parent.name.render, ct.parent.vtable.length)
			.outln();
		var vtable = Vector<JawaMethod>.new();
		vtable.puta(ct.parent.vtable);
		for (m in ct.instanceMethods) {
			if (trace != null) trace.put1("  process \"%q\" ", m.name.render);
			var found = false;
			for (pm in ct.parent.vtable) {
				if (!err.ok()) return;
				if (override(m, pm, err)) {
					m.vtable_index = pm.vtable_index;
					vtable.set(m.vtable_index, m);
					found = true;
					if (trace != null) trace.put1("-> override @%d", m.vtable_index).outln();
					break;
				}
			}
			if (!found) {
				m.vtable_index = vtable.length;
				vtable.put(m);
				if (trace != null) trace.put1("-> add @%d", m.vtable_index).outln();
			}
		}
		ct.vtable = vtable.extract();
		buildITable(ct, err);
	}
	private def buildITable(ct: JawaClassType, err: ErrorGen) {
		ct.itable = if(ct.parent != null, ct.parent.itable);  // share itable list with parent
		for (i in ct.interfaces) { // add new interfaces for this class
			buildITableR(ct, i, err);
		}
	}
	private def buildITableR(ct: JawaClassType, i: JawaInterfaceType, err: ErrorGen) {
		var indexes = Array<int>.new(i.instanceMethods.length);
		var found = false;
		for (j < i.instanceMethods.length) {
			var pm = i.instanceMethods[j];
			for (m in ct.vtable) {
				if (override(m, pm, err)) {
					indexes[j] = m.vtable_index;
					pm.itable_index = j;
					found = true;
					break;
				}
			}
			if (!found) {
				err.abs(0).set(Strings.format2("no implementation for interface method %q.%q",
					i.name.render, pm.render));
				return;
			}
		}
		ct.itable = List.new((i, indexes), ct.itable);

		for (j in i.interfaces) buildITableR(ct, j, err);
	}
	def override(m: JawaMethod, pm: JawaMethod, err: ErrorGen) -> bool {
		if (!m.name.equals(pm.name)) return false;
		var mp = m.params, pmp = pm.params;
		if (mp.length != pmp.length) return false;  // overloading
		for (i < mp.length) {
			if (mp[i] != pmp[i]) return false; // overloading
		}
		if (!m.ret.isAssignableToH(pm.ret)) {
			err.abs(0).set(Strings.format1("cannot override return value in method %q", m.name.render));
			return false;
		}
		return true;
	}
}

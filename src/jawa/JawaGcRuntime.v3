// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implementation of the Jawa runtime using the GC extension to Wasm.
def CLASS_HEADER_FIELDS = 1;
class JawaGcRuntime extends JawaRuntime {
	def arrayReps = HashMap<JawaArrayType, JawaGcRuntimeArrayRep>.new(JawaRefType.hash, JawaArrayType.==);
	def classReps = HashMap<JawaClassType, JawaGcRuntimeClassRep>.new(JawaRefType.hash, JawaClassType.==);
	def interfaceReps = HashMap<JawaInterfaceType, JawaGcRuntimeInterfaceRep>.new(JawaRefType.hash, JawaInterfaceType.==);
	def comodule = Module.new(null);
	def reftypes = Vector<JawaRefType>.new(); // parallel mapping of deftype <-> jawa type
	def coinstance = Instance.new(comodule, []);

	var asm = WasmGcAsm.new();

	new() super(JawaGcStringLens.new(), JawaGcRefTypeClassObjectLens.new()) { }


	def toWasmType(t: JawaType) -> ValueType {
		match (t) {
			x: JawaPrimType => return x.prim.valueType;
			x: JawaArrayType => return toWasmArrayType(x);
			x: JawaClassType => return toWasmClassType(x);
			x: JawaInterfaceType => return toWasmInterfaceType(x);
			_ => return ValueType.Host(t); // XXX: that's an error
		}
	}
	def toWasmArrayType(at: JawaArrayType) -> ValueType.RefArray {
		var gcrep = arrayReps[at];
		if (gcrep == null) {
			var array = ArrayDecl.new(Array.new(1));
			comodule.addDecl(array);
			reftypes.set(array.array_index, at);
			var rtt = Value.Rtt(array, null);
			arrayReps[at] = gcrep = JawaGcRuntimeArrayRep.new(array, rtt);
			array.elem_types[0] = toStorageType(at.elem, true);
		}
		return gcrep.valueType;
	}
	def toWasmClassType(ct: JawaClassType) -> ValueType.RefStruct {
		var gcrep = classReps[ct];
		if (gcrep == null) {
			var metaStruct = StructDecl.new([]); // TODO: meta fields
			comodule.addDecl(metaStruct);
			var field_types = Array<StorageType>.new(1 + if(ct.instanceFields != null, ct.instanceFields.length));
			var struct = StructDecl.new(field_types);
			comodule.addDecl(struct);
			reftypes.set(struct.struct_index, ct);
			var rtt = Value.Rtt(struct, null);
			classReps[ct] = gcrep = JawaGcRuntimeClassRep.new(metaStruct, struct, rtt);
			gcrep.rtt_global = addGlobal(ValueType.Rtt(0, struct), false, rtt);
			var staticFields = ct.staticFields;
			if (staticFields != null && staticFields.length > 0) {
				gcrep.staticFields = Array.new(staticFields.length);
				for (i < staticFields.length) {
					var f = staticFields[i], v = f.defaultValue();
					gcrep.staticFields[i] = addGlobal(toWasmType(f.typ), true, v);
				}
			}
			var meta_field = StorageType.new(ValueType.RefStruct(true, metaStruct), Packedness.UNPACKED, false);
			var j = 0;
			field_types[j++] = meta_field;
			if (ct.instanceFields != null) {
				for (f in ct.instanceFields) {
					field_types[j++] = toStorageType(f.typ, true);
				}
			}
		}
		return gcrep.valueType;
	}
	def toWasmInterfaceType(it: JawaInterfaceType) -> ValueType.RefStruct {
		var gcrep = interfaceReps[it];
		if (gcrep == null) {
			var metaStruct = StructDecl.new([]); // TODO: meta fields
			comodule.addDecl(metaStruct);
			var metaField = StorageType.new(ValueType.RefStruct(true, metaStruct), Packedness.UNPACKED, false);
			var struct = StructDecl.new([metaField]);
			comodule.addDecl(struct);
			reftypes.set(struct.struct_index, it);
			interfaceReps[it] = gcrep = JawaGcRuntimeInterfaceRep.new(metaStruct, struct);
		}
		return gcrep.valueType;
	}
	def toExportedType(t: JawaRefType) -> ExportedType {
		return ExportedValueType.new(t, toWasmType(t));
	}
	def nullRef() -> Value {
		return Values.HEAPREF_NULL;
	}
	def newObject(ct: JawaClassType) -> Value {
		var vt = toWasmClassType(ct), gcrep = classReps[ct];
		var obj = HeapStruct.new(gcrep.struct, gcrep.rtt, Array<Value>.new(gcrep.struct.field_types.length));
		obj.vals[0] = gcrep.metaObject;
		Arrays.copyInto(obj.vals, CLASS_HEADER_FIELDS, ct.boilerplate, 0, ct.boilerplate.length);
		return Value.HeapRef(obj);
	}
	def getStatic(ct: JawaClassType, f: JawaField) -> Value {
		var gcrep = classReps[ct];
		return coinstance.globals[gcrep.staticFields[f.index].global_index].value;
	}
	def setStatic(ct: JawaClassType, f: JawaField, v: Value) {
		var gcrep = classReps[ct];
		coinstance.globals[gcrep.staticFields[f.index].global_index].value = v;
	}
	def getField(obj: Value, i: int) -> Value {
		var ref = HeapStruct.!(Value.HeapRef.!(obj).val);
		return ref.vals[i + CLASS_HEADER_FIELDS];
	}
	def setField(obj: Value, i: int, v: Value) {
		var ref = HeapStruct.!(Value.HeapRef.!(obj).val);
		ref.vals[i + CLASS_HEADER_FIELDS] = v;
	}
	def newArray(at: JawaArrayType, length: int) -> Value {
		var vt = toWasmArrayType(at);
		var array = HeapArray.new(vt.array, Value.Rtt(vt.array, null), Array<Value>.new(length));
		return Value.HeapRef(array);
	}
	def initArray<T>(at: JawaArrayType, vals: Array<T>, map: JawaPrimMappingOf<T>) -> Value {
		var vt = toWasmArrayType(at);
		var vals = Arrays.map(vals, map.box);
		var array = HeapArray.new(vt.array, Value.Rtt(vt.array, null), vals);
		return Value.HeapRef(array);
	}
	def getElem(arr: Value, i: int) -> Value {
		var ref = HeapArray.!(Value.HeapRef.!(arr).val);
		return ref.vals[i];
	}
	def setElem(arr: Value, i: int, v: Value) {
		var ref = HeapArray.!(Value.HeapRef.!(arr).val);
		ref.vals[i] = v;
	}
	def toStorageType(jt: JawaType, mutable: bool) -> StorageType {
		var packing = Packedness.UNPACKED;
		var vt: ValueType;
		match (jt) {
			x: JawaPrimType => {
				match (x.kind) {
					CHAR, SHORT => packing = Packedness.PACKED_I16;
					BYTE, BOOL => packing = Packedness.PACKED_I8;
					_ => ;
				}
				vt = x.prim.valueType;
			}
			x: JawaArrayType => vt = toWasmArrayType(x);
			x: JawaClassType => vt = toWasmClassType(x);
			x: JawaInterfaceType => vt = toWasmInterfaceType(x);
		}
		return StorageType.new(vt, packing, mutable);
	}
	def addGlobal(vt: ValueType, mutable: bool, v: Value) -> GlobalDecl {
		var decl = GlobalDecl.new(vt, mutable, InitExpr.Const(v));
		comodule.addDecl(decl);
		// XXX: better management of coinstance globals
		var g = Global.new(vt, decl);
		coinstance.globals = Arrays.append(g, coinstance.globals);
		g.value = v;
		return decl;
	}

//-------------------------------------------------------------------------------------------------
	def AALOAD(at: JawaArrayType) -> WasmFunction {
		var vt = toWasmArrayType(at);
		start0()
			.local_get(0)
			.local_get(1)
			.array_get(vt.array);
		return makeFuncP([toWasmArrayType(at), ValueType.I32], [toWasmType(at.elem)]);
	}
//-------------------------------------------------------------------------------------------------
	def AASTORE(at: JawaArrayType) -> WasmFunction {
		var vt = toWasmArrayType(at);
		start0()
			.local_get(0)
			.local_get(1)
			.local_get(2)
			.array_set(vt.array);
		return makeFuncP([toWasmArrayType(at), ValueType.I32, toWasmType(at.elem)], SigCache.arr_v);
	}
//-------------------------------------------------------------------------------------------------
	def TODO: Function;
	def ACMPEQ() -> Function {
		var vt = toWasmClassType(JawaLang.OBJECT);
		start0()
			.local_get(0)
			.local_get(1)
			.ref_eq(vt.struct);
		return makeFuncP([vt, vt], SigCache.arr_i);
	}
	def ANEWARRAY(at: JawaArrayType) -> Function {
		return NEWARRAY(at);
	}
	def ARRAYLENGTH(at: JawaArrayType) -> Function {
		var vt = toWasmArrayType(at);
		start0()
			.local_get(0)
			.array_len(vt.array);
		return makeFuncP([vt], SigCache.arr_i);
	}
	def NEWARRAY(at: JawaArrayType) -> Function {
		var vt = toWasmArrayType(at);
		start0()
			.local_get(0)
			.array_new(vt.array);
		return makeFuncP(SigCache.arr_i, [vt]); // TODO: rtt
	}
	def ALOAD<T>(at: JawaArrayType, map: JawaPrimMappingOf<T>) -> Function {
		var vt = toWasmArrayType(at);
		start0()
			.local_get(0)
			.local_get(1);
		match (at.elem.kind) {
			BYTE, SHORT => asm.array_get_s(vt.array);
			CHAR => asm.array_get_u(vt.array);
			_ => asm.array_get(vt.array);
		}
		return makeFuncP([vt, ValueType.I32], [toWasmType(at.elem)]);
	}
	def ASTORE<T>(at: JawaArrayType, map: JawaPrimMappingOf<T>) -> Function {
		var vt = toWasmArrayType(at);
		start0()
			.local_get(0)
			.local_get(1)
			.local_get(2)
			.array_set(vt.array);
		return makeFuncP([vt, ValueType.I32, toWasmType(at.elem)], SigCache.arr_v);
	}
	def CHECKCAST(t: JawaRefType) -> Function { return TODO; }
	def DCMPG() -> Function { return TODO; }
	def DCMPL() -> Function { return TODO; }
	def DREM() -> Function { return TODO; }
	def FCMPG() -> Function { return TODO; }
	def FCMPL() -> Function { return TODO; }
	def FREM() -> Function { return TODO; }
	def GETFIELD(ct: JawaClassType, f: JawaField) -> Function {
		var vt = toWasmClassType(ct);
		start0()
			.local_get(0)
			.struct_get(vt.struct, f.index + CLASS_HEADER_FIELDS);
		return makeFuncP([vt], [toWasmType(f.typ)]);
	}
	def GETSTATIC(ct: JawaClassType, f: JawaField) -> Function {
		var gcrep = classReps[ct];
		start0()
			.global_get(gcrep.staticFields[f.index].global_index);
		return makeFuncP(SigCache.arr_v, [toWasmType(f.typ)]);
	}
	def INSTANCEOF(t: JawaRefType) -> Function { return TODO; }
	def INVOKEINTERFACE(it: JawaInterfaceType, m: JawaMethod) -> Function { return TODO; }
	def INVOKESPECIAL(ct: JawaClassType, m: JawaMethod) -> Function {
		var vt = toWasmClassType(JawaLang.OBJECT);
		start0()
			.local_get(0)
			.struct_get(vt.struct, 0)  // trap on null
			.local_get(0);
		for (i < m.sig.params.length) {
			asm.local_get(i + 1);
		}
		var sig = m.sig.sig(ct, toWasmType);
		var g = addGlobal(ValueType.RefFunc(false, sig), false, Value.FuncRef(m.impl)); // XXX: cache impl ref?
		asm.global_get(g.global_index);
		asm.call_ref();
		return makeFunc(sig);
	}
	def INVOKESTATIC(ct: JawaClassType, m: JawaMethod) -> Function {
		return m.impl;
	}
	def INVOKEVIRTUAL(ct: JawaClassType, m: JawaMethod) -> Function { return TODO; }
	def ISNULL() -> Function {
		var vt = toWasmClassType(JawaLang.OBJECT);
		start0()
			.local_get(0)
			.ref_is_null();
		return makeFuncP([vt], SigCache.arr_i);
	}
	def MONITORENTER() -> Function {
		var vt = toWasmClassType(JawaLang.OBJECT);
		start0()
			.local_get(0)
			.struct_get(vt.struct, 0);  // trap on null
		return makeFuncP([vt], SigCache.arr_v);
	}
	def MONITOREXIT() -> Function {
		var vt = toWasmClassType(JawaLang.OBJECT);
		start0()
			.local_get(0)
			.struct_get(vt.struct, 0);  // trap on null
		return makeFuncP([vt], SigCache.arr_v); // nop
	}
	def MULTIANEWARRAY(dims: int, at: JawaArrayType) -> Function { return TODO; }
	def NEW(ct: JawaClassType) -> Function {
		var gcrep = classReps[ct];
		var vt = toWasmClassType(ct);
		start0()
			.global_get(gcrep.rtt_global.global_index)
			.struct_new_default_with_rtt(vt.struct);
		return makeFuncP(SigCache.arr_v, [vt]);
	}
	def PUTFIELD(ct: JawaClassType, f: JawaField) -> Function {
		var vt = toWasmClassType(ct);
		start0()
			.local_get(0)
			.local_get(1)
			.struct_set(vt.struct, f.index + CLASS_HEADER_FIELDS);
		return makeFuncP([vt, toWasmType(f.typ)], SigCache.arr_v);
	}
	def PUTSTATIC(ct: JawaClassType, f: JawaField) -> Function {
		var gcrep = classReps[ct];
		start0()
			.local_get(0)
			.global_set(gcrep.staticFields[f.index].global_index);
		return makeFuncP([toWasmType(f.typ)], SigCache.arr_v);
	}

//-------------------------------------------------------------------------------------------------

	def start0() -> WasmGcAsm {
		asm.resize(0);
		return asm.put(0 /*locals*/);
	}
	def makeFuncP(params: Array<ValueType>, results: Array<ValueType>) -> WasmFunction {
		return makeFunc(SigDecl.new(params, results));
	}
	def makeFunc(sig: SigDecl) -> WasmFunction {
		comodule.addDecl(sig);
		var func = FuncDecl.new(sig);
		func.code = Code.new(asm.put(Opcode.END.code).extract()); // TODO: run CodeValidator
		comodule.addDecl(func);
		return WasmFunction.new(coinstance, func);
	}
}

class WasmGcAsm extends Vector<byte> {
	def put_u32leb(v: int) -> this {
		var data = u32.view(v);
		while (data >= 0x80) {
			put(byte.view(0x80u | (data & 0x7F)));
			data = data >> 7;
		}
		put(byte.view(data));
	}
	def local_get(index: int) -> this {
		put(Opcode.LOCAL_GET.code).put_u32leb(index);
	}
	def global_get(index: int) -> this {
		put(Opcode.GLOBAL_GET.code).put_u32leb(index);
	}
	def global_set(index: int) -> this {
		put(Opcode.GLOBAL_SET.code).put_u32leb(index);
	}
	def local_set(index: int) -> this {
		put(Opcode.LOCAL_SET.code).put_u32leb(index);
	}
	def struct_get(decl: StructDecl, field: int) -> this {
		put(Opcode.STRUCT_GET.prefix).put(Opcode.STRUCT_GET.code).put_u32leb(decl.struct_index).put_u32leb(field);
	}
	def struct_set(decl: StructDecl, field: int) -> this {
		put(Opcode.STRUCT_SET.prefix).put(Opcode.STRUCT_SET.code).put_u32leb(decl.struct_index).put_u32leb(field);
	}
	def struct_new_default_with_rtt(decl: StructDecl) -> this {
		put(Opcode.STRUCT_NEW_DEFAULT_WITH_RTT.prefix)
			.put(Opcode.STRUCT_NEW_DEFAULT_WITH_RTT.code).put_u32leb(decl.struct_index);
	}
	def array_get(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_GET.prefix).put(Opcode.ARRAY_GET.code).put_u32leb(decl.array_index);
	}
	def array_get_s(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_GET_S.prefix).put(Opcode.ARRAY_GET_S.code).put_u32leb(decl.array_index);
	}
	def array_get_u(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_GET_U.prefix).put(Opcode.ARRAY_GET_U.code).put_u32leb(decl.array_index);
	}
	def array_set(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_SET.prefix).put(Opcode.ARRAY_SET.code).put_u32leb(decl.array_index);
	}
	def array_new(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_NEW.prefix).put(Opcode.ARRAY_NEW.code).put_u32leb(decl.array_index);
	}
	def array_len(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_LEN.prefix).put(Opcode.ARRAY_LEN.code).put_u32leb(decl.array_index);
	}
	def ref_eq(decl: StructDecl) -> this {
		put(Opcode.REF_EQ.code).put_u32leb(decl.struct_index);
	}
	def ref_is_null() -> this {
		put(Opcode.REF_IS_NULL.code);
	}
	def call_ref() -> this {
		put(Opcode.CALL_REF.code);
	}
}

class JawaGcStringLens extends JawaWasmLens<JawaString, Value> {
	def toWasm(s: JawaString) -> Value {
		return Values.HEAPREF_NULL; // TODO
	}
	def fromWasm(v: Value) -> JawaString {
		return null; // TODO
	}
}
class JawaGcRefTypeClassObjectLens extends JawaWasmLens<JawaRefType, Value> {
	def toWasm(ct: JawaRefType) -> Value {
		return Values.HEAPREF_NULL; // TODO
	}
	def fromWasm(v: Value) -> JawaRefType {
		return null; // TODO
	}
}

class JawaGcRuntimeArrayRep(array: ArrayDecl, rtt: Value.Rtt) {
	def valueType = ValueType.RefArray(true, array);
}

class JawaGcRuntimeClassRep(metaStruct: StructDecl, struct: StructDecl, rtt: Value.Rtt) {
	def valueType = ValueType.RefStruct(true, struct);
	def metaObject = Value.HeapRef(null); // TODO
	var rtt_global: GlobalDecl;
	var staticFields: Array<GlobalDecl>;
}

class JawaGcRuntimeInterfaceRep(metaStruct: StructDecl, struct: StructDecl) {
	def valueType = ValueType.RefStruct(true, struct);
}

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implementation of the Jawa runtime using the GC extension to Wasm.
class JawaGcRuntime extends JawaRuntime {
	def comodule = Module.new(null);
	def reftypes = Vector<JawaRefType>.new(); // parallel mapping of deftype <-> jawa type
	def coinstance = Instance.new(comodule, []);

	var jawa_class_field: byte;
	var ref_array_obj: StructDecl; // TODO
	var ref_array_obj_array_field: byte; // TODO
	var ref_array: ArrayDecl; // TODO
	var asm = WasmGcAsm.new();

	new() super(JawaGcStringLens.new(), JawaGcRefTypeClassObjectLens.new()) { }


	def toWasmType(t: JawaType) -> ValueType {
		match (t) {
			x: JawaPrimType => return x.prim.valueType;
			x: JawaArrayType => return toWasmArrayType(x);
			x: JawaClassType => return toWasmClassType(x);
			x: JawaInterfaceType => return toWasmInterfaceType(x);
			_ => return ValueType.Host(t); // XXX: that's an error
		}
	}
	def toWasmArrayType(at: JawaArrayType) -> ValueType.RefArray {
		var st = at.array;
		if (st == null) {
			st = at.array = ArrayDecl.new(Array.new(1));
			comodule.addDecl(st);
			st.elem_types[0] = toStorageType(at.elem, true);
			reftypes.set(st.array_index, at);
		}
		return ValueType.RefArray(true, st);
	}
	def toWasmClassType(ct: JawaClassType) -> ValueType.RefStruct {
		var st = ct.struct;
		if (st == null) {
			ct.metaStruct = StructDecl.new([]); // TODO: meta fields
			comodule.addDecl(ct.metaStruct);
			var field_types = Array<StorageType>.new(1 + if(ct.instanceFields != null, ct.instanceFields.length));
			st = ct.struct = StructDecl.new(field_types);
			comodule.addDecl(st);
			reftypes.set(st.struct_index, ct);
			var meta_field = StorageType.new(ValueType.RefStruct(true, ct.metaStruct), Packedness.UNPACKED, false);
			var j = 0;
			field_types[j++] = meta_field;
			if (ct.instanceFields != null) {
				for (f in ct.instanceFields) {
					field_types[j++] = toStorageType(f.typ, true);
				}
			}
		}
		return ValueType.RefStruct(true, st);
	}
	def toWasmInterfaceType(it: JawaInterfaceType) -> ValueType.RefStruct {
		var st = it.struct;
		if (st == null) {
			it.metaStruct = StructDecl.new([]); // TODO: meta fields
			comodule.addDecl(it.metaStruct);
			var metaField = StorageType.new(ValueType.RefStruct(true, it.metaStruct), Packedness.UNPACKED, false);
			st = it.struct = StructDecl.new([metaField]);
			comodule.addDecl(st);
			reftypes.set(st.struct_index, it);
		}
		return ValueType.RefStruct(true, st);
	}
	def toExportedType(t: JawaRefType) -> ExportedType {
		return ExportedValueType.new(t, toWasmType(t));
	}
	def nullRef() -> Value {
		return Values.HEAPREF_NULL;
	}
	def newObject(ct: JawaClassType) -> Value {
		var vt = toWasmClassType(ct), struct = ct.struct;
		// TODO: metafield and rtt
		var obj = HeapStruct.new(struct, Value.Rtt(struct, null), Array<Value>.new(struct.field_types.length));
		return Value.HeapRef(obj);
	}
	def newArray(at: JawaArrayType, length: int) -> Value {
		var vt = toWasmArrayType(at);
		var array = HeapArray.new(vt.array, Value.Rtt(vt.array, null), Array<Value>.new(length));
		return Value.HeapRef(array);
	}
	def getElem(arr: Value, i: int) -> Value {
		var ref = HeapArray.!(Value.HeapRef.!(arr).val);
		return ref.vals[i];
	}
	def setElem(arr: Value, i: int, v: Value) {
		var ref = HeapArray.!(Value.HeapRef.!(arr).val);
		ref.vals[i] = v;
	}
	def toStorageType(jt: JawaType, mutable: bool) -> StorageType {
		var packing = Packedness.UNPACKED;
		var vt: ValueType;
		match (jt) {
			x: JawaPrimType => {
				match (x.kind) {
					CHAR, SHORT => packing = Packedness.PACKED_I16;
					BYTE, BOOL => packing = Packedness.PACKED_I8;
					_ => ;
				}
				vt = x.prim.valueType;
			}
			x: JawaArrayType => vt = toWasmArrayType(x);
			x: JawaClassType => vt = toWasmClassType(x);
			x: JawaInterfaceType => vt = toWasmInterfaceType(x);
		}
		return StorageType.new(vt, packing, mutable);
	}

//-------------------------------------------------------------------------------------------------
	def AALOAD(at: JawaArrayType) -> WasmFunction {
		var vt = toWasmArrayType(at);
		start0()
			.local_get(0)
			.local_get(1)
			.array_get(vt.array);
		return makeFunc(SigDecl.new([toWasmArrayType(at), ValueType.I32], [toWasmType(at.elem)]));
	}
//-------------------------------------------------------------------------------------------------
	def AASTORE(at: JawaArrayType) -> WasmFunction {
		var vt = toWasmArrayType(at);
		start0()
			.local_get(0)
			.local_get(1)
			.local_get(2)
			.array_set(vt.array);
		return makeFunc(SigDecl.new([toWasmArrayType(at), ValueType.I32, toWasmType(at.elem)], SigCache.arr_v));
	}
//-------------------------------------------------------------------------------------------------
	def TODO: Function;
	def ACMPEQ() -> Function { return TODO; }
	def ANEWARRAY(at: JawaArrayType) -> Function { return TODO; }
	def ARRAYLENGTH(at: JawaArrayType) -> Function { return TODO; }
	def NEWARRAY(at: JawaArrayType) -> Function { return TODO; }
	def ALOAD<T>(at: JawaArrayType, map: JawaPrimMappingOf<T>) -> Function { return TODO; }
	def ASTORE<T>(at: JawaArrayType, map: JawaPrimMappingOf<T>) -> Function { return TODO; }
	def CHECKCAST(t: JawaRefType) -> Function { return TODO; }
	def DCMPG() -> Function { return TODO; }
	def DCMPL() -> Function { return TODO; }
	def DREM() -> Function { return TODO; }
	def FCMPG() -> Function { return TODO; }
	def FCMPL() -> Function { return TODO; }
	def FREM() -> Function { return TODO; }
	def GETFIELD(ct: JawaClassType, f: JawaField) -> Function { return TODO; }
	def GETSTATIC(ct: JawaClassType, f: JawaField) -> Function { return TODO; }
	def INSTANCEOF(t: JawaRefType) -> Function { return TODO; }
	def INVOKEINTERFACE(it: JawaInterfaceType, m: JawaMethod) -> Function { return TODO; }
	def INVOKESPECIAL(ct: JawaClassType, m: JawaMethod) -> Function { return TODO; }
	def INVOKESTATIC(ct: JawaClassType, m: JawaMethod) -> Function { return TODO; }
	def INVOKEVIRTUAL(ct: JawaClassType, m: JawaMethod) -> Function { return TODO; }
	def ISNULL() -> Function { return TODO; }
	def MONITORENTER() -> Function { return TODO; }
	def MONITOREXIT() -> Function { return TODO; }
	def MULTIANEWARRAY(dims: int, at: JawaArrayType) -> Function { return TODO; }
	def NEW(ct: JawaClassType) -> Function { return TODO; }
	def PUTFIELD(ct: JawaClassType, f: JawaField) -> Function { return TODO; }
	def PUTSTATIC(ct: JawaClassType, f: JawaField) -> Function { return TODO; }
//-------------------------------------------------------------------------------------------------

	def start0() -> WasmGcAsm {
		asm.resize(0);
		return asm.put(0 /*locals*/);
	}
	def makeFunc(sig: SigDecl) -> WasmFunction {
		comodule.addDecl(sig);
		var func = FuncDecl.new(sig);
		func.code = Code.new(asm.put(Opcode.END.code).extract()); // TODO: run verifier?
		return WasmFunction.new(coinstance, func);
	}
}

class WasmGcAsm extends Vector<byte> {
	def put_u32leb(v: int) -> this {
		var data = u32.view(v);
		while (data >= 0x80) {
			put(byte.view(0x80u | (data & 0x7F)));
			data = data >> 7;
		}
		put(byte.view(data));
	}
	def local_get(index: byte) -> this {
		put(Opcode.LOCAL_GET.code).put(index);
	}
	def local_set(index: byte) -> this {
		put(Opcode.LOCAL_SET.code).put(index);
	}
	def struct_get(decl: StructDecl, field: byte) -> this {
		put(Opcode.STRUCT_GET.prefix).put(Opcode.STRUCT_GET.code).put_u32leb(decl.struct_index).put(field);
	}
	def array_get(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_GET.prefix).put(Opcode.ARRAY_GET.code).put_u32leb(decl.array_index);
	}
	def array_set(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_SET.prefix).put(Opcode.ARRAY_SET.code).put_u32leb(decl.array_index);
	}
}

class JawaGcTypeLens extends JawaWasmLens<JawaType, ValueType> {
}
class JawaGcStringLens extends JawaWasmLens<JawaString, Value> {
	def toWasm(s: JawaString) -> Value {
		return Values.HEAPREF_NULL; // TODO
	}
	def fromWasm(v: Value) -> JawaString {
		return null; // TODO
	}
}
class JawaGcRefTypeClassObjectLens extends JawaWasmLens<JawaRefType, Value> {
	def toWasm(ct: JawaRefType) -> Value {
		return Values.HEAPREF_NULL; // TODO
	}
	def fromWasm(v: Value) -> JawaRefType {
		return null; // TODO
	}
}

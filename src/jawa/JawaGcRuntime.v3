// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implementation of the Jawa runtime using the GC extension to Wasm.
def CLASS_HEADER_FIELDS = 1;
def META_STRUCT_HEADER_FIELDS = 2;
class JawaGcRuntime extends JawaRuntime {
	def arrayReps = HashMap<JawaArrayType, JawaGcRuntimeArrayRep>.new(JawaRefType.hash, JawaArrayType.==);
	def classReps = HashMap<JawaClassType, JawaGcRuntimeClassRep>.new(JawaRefType.hash, JawaClassType.==);
	def interfaceReps = HashMap<JawaInterfaceType, JawaGcRuntimeInterfaceRep>.new(JawaRefType.hash, JawaInterfaceType.==);
	def comodule = Module.new(null);
	def reftypes = Vector<JawaRefType>.new(); // parallel mapping of deftype <-> jawa type
	def coinstance = Instance.new(comodule, []);
	def validator = CodeValidator.new(Jawa.ENGINE_EXTENSIONS, Jawa.ENGINE_LIMITS, comodule, WasmErrorGen.new(null));
	var iTableStruct: StructDecl;
	def trace = if(Trace.jawa, TraceBuilder.new());

	var asm = WasmGcAsm.new();

	new() super(JawaGcStringLens.new(), JawaGcRefTypeClassObjectLens.new()) { }


	def toWasmType(t: JawaType) -> ValueType {
		match (t) {
			x: JawaPrimType => return x.prim.valueType;
			x: JawaArrayType => return toWasmArrayType(x);
			x: JawaClassType => return toWasmClassType(x);
			x: JawaInterfaceType => return toWasmInterfaceType(x);
			_ => return ValueType.Host(t); // XXX: that's an error
		}
	}
	def toWasmArrayType(at: JawaArrayType) -> ValueType.RefArray {
		var gcrep = arrayReps[at];
		if (gcrep == null) {
			var array = ArrayDecl.new(Array.new(1));
			comodule.addDecl(array);
			reftypes.set(array.array_index, at);
			var rtt = Value.Rtt(array, null);
			arrayReps[at] = gcrep = JawaGcRuntimeArrayRep.new(array, rtt);
			array.elem_types[0] = toStorageType(at.elem, true);
		}
		return gcrep.valueType;
	}
	def toWasmClassType(ct: JawaClassType) -> ValueType.RefStruct {
		var gcrep = classReps[ct];
		if (gcrep != null) return gcrep.valueType;
		if (trace != null) trace.put1("JawaGcRuntime.toWasmClassType(%q)", ct.render).outln();

		// Build struct before recursing on field/method types
		var field_types = Array<StorageType>.new(
			CLASS_HEADER_FIELDS + if(ct.instanceFields != null, ct.instanceFields.length));
		var struct = newStruct(ct, field_types);

		// Build meta struct
		var meta_field_types = Array<StorageType>.new(
			META_STRUCT_HEADER_FIELDS + if(ct.vtable != null, ct.vtable.length));
		var metaStruct = newStruct(null, meta_field_types);

		classReps[ct] = gcrep = JawaGcRuntimeClassRep.new(metaStruct, struct);

		// Build rtt
		if (ct.parent == null) {
			gcrep.rtt = Value.Rtt(struct, Array<Value.Rtt>.new(1));
			gcrep.rtt.supers[0] = gcrep.rtt;
		} else {
			var prep = makeClassRep(ct.parent);
			gcrep.rtt = Values.subRtt(prep.rtt, struct);
		}
		gcrep.rtt_global = addGlobal(ValueType.Rtt(ct.depth, struct), false, gcrep.rtt);

		// Finish meta struct
		var jlcrep = makeClassRep(JawaLang.CLASS);
		meta_field_types[0] = StorageType.new(jlcrep.valueType, Packedness.UNPACKED, false);
		meta_field_types[1] = StorageType.new(ValueType.RefStruct(true, getITableStruct()), Packedness.UNPACKED, false);
		if (ct.vtable != null) {
			for (i < ct.vtable.length) {
				var m = ct.vtable[i];
				var receiver = ct;
				if (trace != null) trace.put2("  vtable[%d] = %q", i, m.render).outln();
				while (true) {  // find the highest parent that defined this method
					var pt = receiver.parent;
					if (pt == null || pt.vtable.length < i) break;
					receiver = pt;
				}
				var sig = m.sig.sig(receiver, toWasmType);
				meta_field_types[2 + i] = StorageType.new(
					ValueType.RefFunc(false, sig), Packedness.UNPACKED, false);
			}
		}

		// Build static fields
		var staticFields = ct.staticFields;
		if (staticFields != null && staticFields.length > 0) {
			gcrep.staticFields = Array.new(staticFields.length);
			for (i < staticFields.length) {
				var f = staticFields[i], v = f.defaultValue();
				gcrep.staticFields[i] = addGlobal(toWasmType(f.typ), true, v);
			}
		}

		// Finish field types of struct (recursively)
		var meta_field = StorageType.new(ValueType.RefStruct(true, metaStruct), Packedness.UNPACKED, false);
		var j = 0;
		field_types[j++] = meta_field;
		if (ct.instanceFields != null) {
			for (f in ct.instanceFields) {
				field_types[j++] = toStorageType(f.typ, true);
			}
		}
		return gcrep.valueType;
	}
	def makeClassRep(ct: JawaClassType) -> JawaGcRuntimeClassRep {
		toWasmClassType(ct);
		return classReps[ct];
	}
	def makeMetaObject(ct: JawaClassType) -> Value {
		var gcrep = makeClassRep(ct);
		if (gcrep.metaObject.val == null) {
			var jlcrep = makeClassRep(JawaLang.CLASS);
			var vals = Array<Value>.new(gcrep.metaStruct.field_types.length);
			gcrep.metaObject = Value.HeapRef(HeapStruct.new(gcrep.metaStruct, jlcrep.rtt, vals));
			var jlcobj = makeMetaObject(JawaLang.CLASS);
			vals[0] = jlcobj;
			if (ct.vtable != null) for (i < ct.vtable.length) {
				var m = ct.vtable[i];
				vals[META_STRUCT_HEADER_FIELDS + i] = Value.FuncRef(m.impl);
			}
			gcrep.metaObjectGlobal = addGlobal(ValueType.RefStruct(false, gcrep.metaStruct), false, gcrep.metaObject);
		}
		return gcrep.metaObject;
	}
	def toWasmInterfaceType(it: JawaInterfaceType) -> ValueType.RefStruct {
		var gcrep = interfaceReps[it];
		if (gcrep != null) return gcrep.valueType;

		// Build struct before recursing on field/method types
		var struct = newStruct(it, Array<StorageType>.new(1));

		// Build meta struct
		var metaStruct = newStruct(null, []);
		struct.field_types[0] = StorageType.new(ValueType.RefStruct(true, metaStruct), Packedness.UNPACKED, false);
		interfaceReps[it] = gcrep = JawaGcRuntimeInterfaceRep.new(metaStruct, struct);
		return gcrep.valueType;
	}
	def newStruct(t: JawaRefType, field_types: Array<StorageType>) -> StructDecl {
		var struct = StructDecl.new(field_types);
		comodule.addDecl(struct);
		if (t != null) reftypes.set(struct.struct_index, t);
		return struct;
	}
	def getITableStruct() -> StructDecl {
		if (iTableStruct != null) return iTableStruct;
		iTableStruct = newStruct(null, Array<StorageType>.new(1));
		iTableStruct.field_types[0] = StorageType.new(
			ValueType.RefStruct(true, iTableStruct), Packedness.UNPACKED, true);
		return iTableStruct;
	}
	def toExportedType(t: JawaRefType) -> ExportedType {
		return ExportedValueType.new(t, toWasmType(t));
	}
	def nullRef() -> Value {
		return Values.HEAPREF_NULL;
	}
	def newObject(ct: JawaClassType) -> Value {
		var gcrep = makeClassRep(ct);
		var obj = HeapStruct.new(gcrep.struct, gcrep.rtt, Array<Value>.new(gcrep.struct.field_types.length));
		obj.vals[0] = makeMetaObject(ct);
		Arrays.copyInto(obj.vals, CLASS_HEADER_FIELDS, ct.boilerplate, 0, ct.boilerplate.length);
		return Value.HeapRef(obj);
	}
	def getStatic(ct: JawaClassType, f: JawaField) -> Value {
		var gcrep = makeClassRep(ct);
		return coinstance.globals[gcrep.staticFields[f.index].global_index].value;
	}
	def setStatic(ct: JawaClassType, f: JawaField, v: Value) {
		var gcrep = makeClassRep(ct);
		coinstance.globals[gcrep.staticFields[f.index].global_index].value = v;
	}
	def getField(obj: Value, i: int) -> Value {
		var ref = HeapStruct.!(Value.HeapRef.!(obj).val);
		return ref.vals[i + CLASS_HEADER_FIELDS];
	}
	def setField(obj: Value, i: int, v: Value) {
		var ref = HeapStruct.!(Value.HeapRef.!(obj).val);
		ref.vals[i + CLASS_HEADER_FIELDS] = v;
	}
	def newArray(at: JawaArrayType, length: int) -> Value {
		var vt = toWasmArrayType(at);
		var array = HeapArray.new(vt.array, Value.Rtt(vt.array, null), Array<Value>.new(length));
		return Value.HeapRef(array);
	}
	def initArray<T>(at: JawaArrayType, vals: Array<T>, map: JawaPrimMappingOf<T>) -> Value {
		var vt = toWasmArrayType(at);
		var vals = Arrays.map(vals, map.box);
		var array = HeapArray.new(vt.array, Value.Rtt(vt.array, null), vals);
		return Value.HeapRef(array);
	}
	def getElem(arr: Value, i: int) -> Value {
		var ref = HeapArray.!(Value.HeapRef.!(arr).val);
		return ref.vals[i];
	}
	def setElem(arr: Value, i: int, v: Value) {
		var ref = HeapArray.!(Value.HeapRef.!(arr).val);
		ref.vals[i] = v;
	}
	def getLength(arr: Value) -> int {
		return HeapArray.!(Value.HeapRef.!(arr).val).vals.length;
	}
	def getJawaType(v: Value) -> JawaType {
		match (v) {
			I32 => return JawaTypes.INT;
			I64 => return JawaTypes.LONG;
			F32 => return JawaTypes.FLOAT;
			F64 => return JawaTypes.DOUBLE;
			HeapRef(ref) => match (ref) {
				x: HeapStruct => {
					var i = x.decl.struct_index;
					if (i <= comodule.heaptypes.length && comodule.heaptypes[i] == x.decl) return reftypes[i];
				}
				x: HeapArray => {
					var i = x.decl.array_index;
					if (i <= comodule.heaptypes.length && comodule.heaptypes[i] == x.decl) return reftypes[i];
				}
			}
			_ => ;
		}
		return null;
	}

	def toStorageType(jt: JawaType, mutable: bool) -> StorageType {
		var packing = Packedness.UNPACKED;
		var vt: ValueType;
		match (jt) {
			x: JawaPrimType => {
				match (x.kind) {
					CHAR, SHORT => packing = Packedness.PACKED_I16;
					BYTE, BOOL => packing = Packedness.PACKED_I8;
					_ => ;
				}
				vt = x.prim.valueType;
			}
			x: JawaArrayType => vt = toWasmArrayType(x);
			x: JawaClassType => vt = toWasmClassType(x);
			x: JawaInterfaceType => vt = toWasmInterfaceType(x);
		}
		return StorageType.new(vt, packing, mutable);
	}
	def addGlobal(vt: ValueType, mutable: bool, v: Value) -> GlobalDecl {
		var decl = GlobalDecl.new(vt, mutable, InitExpr.Const(v));
		comodule.addDecl(decl);
		// XXX: better management of coinstance globals
		var g = Global.new(vt, decl);
		coinstance.globals = Arrays.append(g, coinstance.globals);
		g.value = v;
		return decl;
	}

//-------------------------------------------------------------------------------------------------
	def AALOAD(at: JawaArrayType) -> WasmFunction {
		var vt = toWasmArrayType(at);
		start0()
			.local_get(0)
			.local_get(1)
			.array_get(vt.array);
		return makeFuncP([toWasmArrayType(at), ValueType.I32], [toWasmType(at.elem)]);
	}
//-------------------------------------------------------------------------------------------------
	def AASTORE(at: JawaArrayType) -> WasmFunction {
		var vt = toWasmArrayType(at);
		start0()
			.local_get(0)
			.local_get(1)
			.local_get(2)
			.array_set(vt.array);
		return makeFuncP([toWasmArrayType(at), ValueType.I32, toWasmType(at.elem)], SigCache.arr_v);
	}
//-------------------------------------------------------------------------------------------------
	def TODO: Function;
	def ACMPEQ() -> Function {
		var vt = toWasmClassType(JawaLang.OBJECT);
		start0()
			.local_get(0)
			.local_get(1)
			.ref_eq();
		return makeFuncP([vt, vt], SigCache.arr_i);
	}
	def ANEWARRAY(at: JawaArrayType) -> Function {
		return NEWARRAY(at);
	}
	def ARRAYLENGTH(at: JawaArrayType) -> Function {
		var vt = toWasmArrayType(at);
		start0()
			.local_get(0)
			.array_len(vt.array);
		return makeFuncP([vt], SigCache.arr_i);
	}
	def NEWARRAY(at: JawaArrayType) -> Function {
		var vt = toWasmArrayType(at);
		start0()
			.local_get(0)
			.array_new(vt.array);
		return makeFuncP(SigCache.arr_i, [vt]); // TODO: rtt
	}
	def ALOAD<T>(at: JawaArrayType, map: JawaPrimMappingOf<T>) -> Function {
		var vt = toWasmArrayType(at);
		start0()
			.local_get(0)
			.local_get(1);
		match (at.elem.kind) {
			BYTE, SHORT => asm.array_get_s(vt.array);
			CHAR => asm.array_get_u(vt.array);
			_ => asm.array_get(vt.array);
		}
		return makeFuncP([vt, ValueType.I32], [toWasmType(at.elem)]);
	}
	def ASTORE<T>(at: JawaArrayType, map: JawaPrimMappingOf<T>) -> Function {
		var vt = toWasmArrayType(at);
		start0()
			.local_get(0)
			.local_get(1)
			.local_get(2)
			.array_set(vt.array);
		return makeFuncP([vt, ValueType.I32, toWasmType(at.elem)], SigCache.arr_v);
	}
	def CHECKCAST(t: JawaRefType) -> Function {
		match (t) {
			at: JawaArrayType => {
				return TODO;
			}
			ct: JawaClassType => {
				var ot = toWasmClassType(JawaLang.OBJECT);
				var vt = toWasmClassType(ct);
				var gcrep = makeClassRep(ct);
				start0()
					.local_get(0)
					.ref_is_null()
					.if_(vt)
					.ref_null(vt.struct.struct_index)
					.else_()
					.local_get(0)
					.global_get(gcrep.rtt_global.global_index)
					.ref_cast(ot.struct.struct_index, vt.struct.struct_index)
					.end();
				return makeFuncPV([ot], [vt]);
			}
			it: JawaInterfaceType => {
				return TODO;
			}
		}
		return null;
	}
	def DCMPG() -> Function { return TODO; }
	def DCMPL() -> Function { return TODO; }
	def DREM() -> Function { return TODO; }
	def FCMPG() -> Function { return TODO; }
	def FCMPL() -> Function { return TODO; }
	def FREM() -> Function { return TODO; }
	def GETFIELD(ct: JawaClassType, f: JawaField) -> Function {
		var vt = toWasmClassType(ct);
		start0()
			.local_get(0)
			.struct_get(vt.struct, f.index + CLASS_HEADER_FIELDS);
		return makeFuncP([vt], [toWasmType(f.typ)]);
	}
	def GETSTATIC(ct: JawaClassType, f: JawaField) -> Function {
		var gcrep = classReps[ct];
		start0()
			.global_get(gcrep.staticFields[f.index].global_index);
		return makeFuncP(SigCache.arr_v, [toWasmType(f.typ)]);
	}
	def INSTANCEOF(t: JawaRefType) -> Function {
		match (t) {
			at: JawaArrayType => {
				return TODO;
			}
			ct: JawaClassType => {
				var ot = toWasmClassType(JawaLang.OBJECT);
				var vt = toWasmClassType(ct);
				var gcrep = classReps[ct];
				start0()
					.local_get(0)
					.global_get(gcrep.rtt_global.global_index)
					.ref_test(ot.struct.struct_index, vt.struct.struct_index);
				return makeFuncP([ot], SigCache.arr_i);
			}
			it: JawaInterfaceType => {
				return TODO;
			}
		}
		return null;
	}
	def INVOKEINTERFACE(it: JawaInterfaceType, m: JawaMethod) -> Function {
		return TODO;
	}
	def INVOKESPECIAL(ct: JawaClassType, m: JawaMethod) -> Function {
		var vt = toWasmClassType(JawaLang.OBJECT);
		start0()
			.local_get(0)
			.struct_get(vt.struct, 0)  // trap on null
			.local_get(0);
		for (i < m.sig.params.length) {
			asm.local_get(i + 1);
		}
		var sig = m.sig.sig(ct, toWasmType);
		var g = addGlobal(ValueType.RefFunc(false, sig), false, Value.FuncRef(m.impl)); // XXX: cache impl ref?
		asm.global_get(g.global_index);
		asm.call_ref();
		return makeFunc(sig);
	}
	def INVOKESTATIC(ct: JawaClassType, m: JawaMethod) -> Function {
		return m.impl;
	}
	def INVOKEVIRTUAL(ct: JawaClassType, m: JawaMethod) -> Function {
		var vt = toWasmClassType(ct);
		var gcrep = classReps[ct];
		start0();
		for (i < m.sig.params.length) asm.local_get(i);
		asm.local_get(0)
			.struct_get(gcrep.struct, 0)
			.struct_get(gcrep.metaStruct, META_STRUCT_HEADER_FIELDS + m.vtable_index)
			.call_ref();
		return makeFunc(m.sig.sig(ct, toWasmType));
	}
	def ISNULL() -> Function {
		var vt = toWasmClassType(JawaLang.OBJECT);
		start0()
			.local_get(0)
			.ref_is_null();
		return makeFuncP([vt], SigCache.arr_i);
	}
	def MONITORENTER() -> Function {
		var vt = toWasmClassType(JawaLang.OBJECT);
		start0()
			.local_get(0)
			.struct_get(vt.struct, 0);  // trap on null
		return makeFuncP([vt], SigCache.arr_v);
	}
	def MONITOREXIT() -> Function {
		var vt = toWasmClassType(JawaLang.OBJECT);
		start0()
			.local_get(0)
			.struct_get(vt.struct, 0);  // trap on null
		return makeFuncP([vt], SigCache.arr_v);
	}
	def MULTIANEWARRAY(dims: int, at: JawaArrayType) -> Function {
		return TODO;
	}
	def NEW(ct: JawaClassType) -> Function {
		var gcrep = classReps[ct];
		var vt = toWasmClassType(ct);
		makeMetaObject(ct);
		// Declare globals that contain default values for fields
		start().put_u32leb(vt.struct.field_types.length - 1); // # locals
		for (i = 1; i < vt.struct.field_types.length; i++) {
			asm.locals(1, vt.struct.field_types[i].val_type);
		}
		// Load the meta object
		asm.global_get(gcrep.metaObjectGlobal.global_index);
		for (i = 1; i < vt.struct.field_types.length; i++) {
			asm.local_get(i - 1);
		}
		// Load the RTT
		asm.global_get(gcrep.rtt_global.global_index)
			.struct_new_with_rtt(vt.struct);
		return makeFuncPV(SigCache.arr_v, [vt]);
	}
	def PUTFIELD(ct: JawaClassType, f: JawaField) -> Function {
		var vt = toWasmClassType(ct);
		start0()
			.local_get(0)
			.local_get(1)
			.struct_set(vt.struct, f.index + CLASS_HEADER_FIELDS);
		return makeFuncP([vt, toWasmType(f.typ)], SigCache.arr_v);
	}
	def PUTSTATIC(ct: JawaClassType, f: JawaField) -> Function {
		var gcrep = classReps[ct];
		start0()
			.local_get(0)
			.global_set(gcrep.staticFields[f.index].global_index);
		return makeFuncP([toWasmType(f.typ)], SigCache.arr_v);
	}

//-------------------------------------------------------------------------------------------------

	def start0() -> WasmGcAsm {
		return asm.resize(0)
			.put(0 /*locals*/);
	}
	def start() -> WasmGcAsm {
		return asm.resize(0);
	}
	def makeFuncP(params: Array<ValueType>, results: Array<ValueType>) -> WasmFunction {
		return makeFunc(SigDecl.new(params, results));
	}
	def makeFuncPV(params: Array<ValueType>, results: Array<ValueType>) -> WasmFunction {
		var f = makeFuncP(params, results);
		var r = validator.validateFunc(f.decl); // XXX: don't make a decoder every time
		match (r) {
			Error(error, pc, msg) => {
				System.error("JawaGcRuntimeError", Strings.format2("stub validation failed @ +%d: %s", pc, msg));
			}
			_ => ;
		}
		return f;
	}
	def makeFunc(sig: SigDecl) -> WasmFunction {
		comodule.addDecl(sig);
		var func = FuncDecl.new(sig);
		func.code = Code.new(asm.put(Opcode.END.code).extract());
		comodule.addDecl(func);
		return WasmFunction.new(coinstance, func);
	}
}

class WasmGcAsm extends Vector<byte> {
	def put_u32leb(v: int) -> this {
		var data = u32.view(v);
		while (data >= 0x80) {
			put(byte.view(0x80u | (data & 0x7F)));
			data = data >> 7;
		}
		put(byte.view(data));
	}
	def locals(count: int, vt: ValueType) -> this {
		put_u32leb(count);
		put_blockType(vt);
	}
	def local_get(index: int) -> this {
		put(Opcode.LOCAL_GET.code).put_u32leb(index);
	}
	def local_tee(index: int) -> this {
		put(Opcode.LOCAL_TEE.code).put_u32leb(index);
	}
	def global_get(index: int) -> this {
		put(Opcode.GLOBAL_GET.code).put_u32leb(index);
	}
	def global_set(index: int) -> this {
		put(Opcode.GLOBAL_SET.code).put_u32leb(index);
	}
	def local_set(index: int) -> this {
		put(Opcode.LOCAL_SET.code).put_u32leb(index);
	}
	def struct_get(decl: StructDecl, field: int) -> this {
		put(Opcode.STRUCT_GET.prefix).put(Opcode.STRUCT_GET.code).put_u32leb(decl.struct_index).put_u32leb(field);
	}
	def struct_set(decl: StructDecl, field: int) -> this {
		put(Opcode.STRUCT_SET.prefix).put(Opcode.STRUCT_SET.code).put_u32leb(decl.struct_index).put_u32leb(field);
	}
	def struct_new_default_with_rtt(decl: StructDecl) -> this {
		put(Opcode.STRUCT_NEW_DEFAULT_WITH_RTT.prefix)
			.put(Opcode.STRUCT_NEW_DEFAULT_WITH_RTT.code).put_u32leb(decl.struct_index);
	}
	def struct_new_with_rtt(decl: StructDecl) -> this {
		put(Opcode.STRUCT_NEW_WITH_RTT.prefix)
			.put(Opcode.STRUCT_NEW_WITH_RTT.code).put_u32leb(decl.struct_index);
	}
	def array_get(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_GET.prefix).put(Opcode.ARRAY_GET.code).put_u32leb(decl.array_index);
	}
	def array_get_s(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_GET_S.prefix).put(Opcode.ARRAY_GET_S.code).put_u32leb(decl.array_index);
	}
	def array_get_u(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_GET_U.prefix).put(Opcode.ARRAY_GET_U.code).put_u32leb(decl.array_index);
	}
	def array_set(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_SET.prefix).put(Opcode.ARRAY_SET.code).put_u32leb(decl.array_index);
	}
	def array_new(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_NEW.prefix).put(Opcode.ARRAY_NEW.code).put_u32leb(decl.array_index);
	}
	def array_len(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_LEN.prefix).put(Opcode.ARRAY_LEN.code).put_u32leb(decl.array_index);
	}
	def ref_eq() -> this {
		put(Opcode.REF_EQ.code);
	}
	def ref_is_null() -> this {
		put(Opcode.REF_IS_NULL.code);
	}
	def ref_cast(ft: int, tt: int) -> this {
		put(Opcode.REF_CAST.prefix).put(Opcode.REF_CAST.code).put_u32leb(ft).put_u32leb(tt);
	}
	def ref_test(ft: int, tt: int) -> this {
		put(Opcode.REF_TEST.prefix).put(Opcode.REF_TEST.code).put_u32leb(ft).put_u32leb(tt);
	}
	def ref_null(i: int) -> this {
		put(Opcode.REF_NULL.code).put_u32leb(i);
	}
	def call_ref() -> this {
		put(Opcode.CALL_REF.code);
	}
	def loop0() -> this {
		put(Opcode.LOOP.code);
	}
	def if_(t: ValueType) -> this {
		put(Opcode.IF.code);
		put_blockType(t);
	}
	def if0_(t: ValueType) -> this {
		put(Opcode.IF.code);
		put(BpTypecon.EmptyBlock.code);
	}
	def else_() -> this {
		put(Opcode.ELSE.code);
	}
	def end() -> this {
		put(Opcode.END.code);
	}
	def put_blockType(t: ValueType) -> this {
		match (t) {
			I32 => put(BpTypecon.I32.code);
			I64 => put(BpTypecon.I64.code);
			F32 => put(BpTypecon.F32.code);
			F64 => put(BpTypecon.F64.code);
			VEC128 => put(BpTypecon.VEC128.code);
			FUNCREF => put(BpTypecon.FUNCREF.code);
			EXTERNREF => put(BpTypecon.EXTERNREF.code);
			ANYREF => ; // TODO
			I31REF => put(BpTypecon.I31REF.code);
			RefFunc(nullable, sig) => put(if(nullable, BpTypecon.RefNullT.code, BpTypecon.RefT.code))
				.put_u32leb(sig.sig_index);
			RefStruct(nullable, struct) => put(if(nullable, BpTypecon.RefNullT.code, BpTypecon.RefT.code))
				.put_u32leb(struct.struct_index);
			RefArray(nullable, array) => put(if(nullable, BpTypecon.RefNullT.code, BpTypecon.RefT.code))
				.put_u32leb(array.array_index);
			_ => ; // TODO
		}
	}
}

class JawaGcStringLens extends JawaWasmLens<JawaString, Value> {
	def toWasm(s: JawaString) -> Value {
		return Values.HEAPREF_NULL; // TODO
	}
	def fromWasm(v: Value) -> JawaString {
		return null; // TODO
	}
}
class JawaGcRefTypeClassObjectLens extends JawaWasmLens<JawaRefType, Value> {
	def toWasm(ct: JawaRefType) -> Value {
		return Values.HEAPREF_NULL; // TODO
	}
	def fromWasm(v: Value) -> JawaRefType {
		return null; // TODO
	}
}

class JawaGcRuntimeArrayRep(array: ArrayDecl, rtt: Value.Rtt) {
	def valueType = ValueType.RefArray(true, array);
}

class JawaGcRuntimeClassRep(metaStruct: StructDecl, struct: StructDecl) {
	def valueType = ValueType.RefStruct(true, struct);
	var metaObject = Value.HeapRef(null);
	var metaObjectGlobal: GlobalDecl;
	var rtt: Value.Rtt;
	var rtt_global: GlobalDecl;
	var staticFields: Array<GlobalDecl>;
}

class JawaGcRuntimeInterfaceRep(metaStruct: StructDecl, struct: StructDecl) {
	def valueType = ValueType.RefStruct(true, struct);
}

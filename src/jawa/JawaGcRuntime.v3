// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implementation of the Jawa runtime using the GC extension to Wasm.
class JawaGcRuntime(module: Module) extends JawaRuntime {
	def comodule = Module.new(coname(module));
	def reftypes = Vector<JawaRefType>.new(); // parallel mapping of deftype <-> jawa type
	def coinstance: Instance; // TODO

	var jawa_class_field: byte;
	var ref_array_obj: StructDecl; // TODO
	var ref_array_obj_array_field: byte; // TODO
	var ref_array: ArrayDecl; // TODO
	var asm = WasmGcAsm.new();

	new() super(JawaGcStringLens.new(), JawaGcRefTypeClassObjectLens.new()) { }


	def toWasmType(t: JawaType) -> ValueType {
		match (t) {
			x: JawaPrimType => return x.prim.valueType;
			x: JawaArrayType => return toWasmArrayType(x);
			x: JawaClassType => return toWasmClassType(x);
			x: JawaInterfaceType => return toWasmInterfaceType(x);
			_ => return ValueType.Host(t); // XXX: that's an error
		}
	}
	def toWasmArrayType(at: JawaArrayType) -> ValueType {
		var st = at.array;
		if (st == null) {
			st = at.array = ArrayDecl.new(Array.new(1));
			comodule.addDecl(st);
			st.elem_types[0] = toStorageType(at.elem, true);
			reftypes.set(st.decl_index, at);
		}
		return ValueType.RefArray(true, st);
	}
	def toWasmClassType(ct: JawaClassType) -> ValueType {
		var st = ct.struct;
		if (st == null) {
			ct.metaStruct = StructDecl.new([]); // TODO: meta fields
			st = ct.struct = StructDecl.new(Array.new(1 + ct.instanceFields.length));
			var j = 0;
			st.field_types[j++] = StorageType.new(ValueType.RefStruct(true, ct.metaStruct), Packedness.UNPACKED, false);
			for (f in ct.instanceFields) {
				st.field_types[j++] = toStorageType(f.typ, true);
			}
			comodule.addDecl(st);
			reftypes.set(st.decl_index, ct);
		}
		return ValueType.RefStruct(true, st);
	}
	def toWasmInterfaceType(it: JawaInterfaceType) -> ValueType {
		var st = it.struct;
		if (st == null) {
			it.metaStruct = StructDecl.new([]); // TODO: meta fields
			var metaField = StorageType.new(ValueType.RefStruct(true, it.metaStruct), Packedness.UNPACKED, false);
			st = it.struct = StructDecl.new([metaField]);
			reftypes.set(st.decl_index, it);
		}
		return ValueType.RefStruct(true, st);
	}
	def toExportedType(t: JawaRefType) -> ExportedType {
		return ExportedValueType.new(toWasmType(t));
	}
	def toStorageType(jt: JawaType, mutable: bool) -> StorageType {
		var packing = Packedness.UNPACKED;
		var vt: ValueType;
		match (jt) {
			x: JawaPrimType => {
				match (x.kind) {
					CHAR, SHORT => packing = Packedness.PACKED_I16;
					BYTE, BOOL => packing = Packedness.PACKED_I8;
					_ => ;
				}
				vt = x.prim.valueType;
			}
			x: JawaArrayType => vt = toWasmArrayType(x);
			x: JawaClassType => vt = toWasmClassType(x);
			x: JawaInterfaceType => vt = toWasmInterfaceType(x);
		}
		return StorageType.new(vt, packing, mutable);
	}

//-------------------------------------------------------------------------------------------------
	def AALOAD(at: JawaArrayType) -> WasmFunction {
		start0()
			.local_get(0)
			.struct_get(ref_array_obj, ref_array_obj_array_field)
			.local_get(1)
			.array_get(ref_array);
		return makeFunc(SigDecl.new([ValueType.Host(at), ValueType.I32], [ValueType.Host(at.elem)]));
	}
//-------------------------------------------------------------------------------------------------
	def AASTORE(at: JawaArrayType) -> WasmFunction {
		start0()
			.local_get(0)
			.struct_get(ref_array_obj, ref_array_obj_array_field)
			.local_get(1)
			.local_get(2)
			.array_set(ref_array);
		return makeFunc(SigDecl.new([ValueType.Host(at), ValueType.I32, ValueType.Host(at.elem)], SigCache.arr_v));
	}
//-------------------------------------------------------------------------------------------------
	def start0() -> WasmGcAsm {
		asm.resize(0);
		return asm.put(0 /*locals*/);
	}
	def makeFunc(sig: SigDecl) -> WasmFunction {
		comodule.addDecl(sig);
		var func = FuncDecl.new(sig);
		func.code = Code.new(asm.put(Opcode.END.code).extract()); // TODO: run verifier?
		return WasmFunction.new(coinstance, func);
	}
}

class WasmGcAsm extends Vector<byte> {
	def put_u32leb(v: int) -> this {
		var data = u32.view(v);
		while (data >= 0x80) {
			put(byte.view(0x80u | (data & 0x7F)));
			data = data >> 7;
		}
		put(byte.view(data));
	}
	def local_get(index: byte) -> this {
		put(Opcode.LOCAL_GET.code).put(index);
	}
	def local_set(index: byte) -> this {
		put(Opcode.LOCAL_SET.code).put(index);
	}
	def struct_get(decl: StructDecl, field: byte) -> this {
		put(Opcode.STRUCT_GET.prefix).put(Opcode.STRUCT_GET.code).put_u32leb(decl.struct_index).put(field);
	}
	def array_get(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_GET.prefix).put(Opcode.ARRAY_GET.code).put_u32leb(decl.array_index);
	}
	def array_set(decl: ArrayDecl) -> this {
		put(Opcode.ARRAY_SET.prefix).put(Opcode.ARRAY_SET.code).put_u32leb(decl.array_index);
	}
}

class JawaGcTypeLens extends JawaWasmLens<JawaType, ValueType> {
}
class JawaGcStringLens extends JawaWasmLens<JawaString, Value> {
	def toWasm(s: JawaString) -> Value;
	def fromWasm(v: Value) -> JawaString;
}
class JawaGcRefTypeClassObjectLens extends JawaWasmLens<JawaRefType, Value> {
	def toWasm(ct: JawaRefType) -> Value;
	def fromWasm(v: Value) -> JawaRefType;
}
def coname(module: Module) -> string {
	return if (module.filename != null, Strings.format1("%s.jawa-gcrt", module.filename));
}
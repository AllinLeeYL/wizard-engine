// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Code that implements all of the Jawa opcodes/functions as HostFunctions.
component JawaHostStubs {
	def VOID = Result.Value([]);
	def TRUE = Result.Value([Values.I32_1]);
	def FALSE = Result.Value([Values.I32_0]);
	def vt_o = ValueType.Host(JawaTypes.OBJECT);
	def sig_oo_i = FuncSig.new([vt_o, vt_o], SigCache.arr_i);

//-------------------------------------------------------------------------------------------------
	def AALOAD(t: JawaExportedType) -> HostFunction {
		var at = JawaType.Array.!(t.host.t);
		var sig = FuncSig.new([t.rep, ValueType.I32], [ValueType.Host(JawaHostType.new(at.elem))]); // TODO: reference identity of elem JawaHostType
		return HostFunction.new(sig, eval_AALOAD);
	}
	private def eval_AALOAD(e: Executor, args: Array<Value>) -> Result {
		var obj = JawaRefArrayObject.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		var index = Values.v_i(args[1]);
		if (index < 0 || index >= obj.elems.length) return JawaTraps.ArrayIndexOutOfBoundsException;
		return Result.Value([Value.ExternRef(obj.elems[index])]);
	}
//-------------------------------------------------------------------------------------------------
	def AASTORE(t: JawaExportedType) -> HostFunction {
		var at = JawaType.Array.!(t.host.t);
		var sig = FuncSig.new([t.rep, ValueType.I32, ValueType.Host(JawaHostType.new(at.elem))], SigCache.arr_v); // TODO: reference identity of elem JawaHostType
		return HostFunction.new(sig, eval_AASTORE);
	}
	private def eval_AASTORE(e: Executor, args: Array<Value>) -> Result {
		var obj = JawaRefArrayObject.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		var index = Values.v_i(args[1]);
		if (index < 0 || index >= obj.elems.length) return JawaTraps.ArrayIndexOutOfBoundsException;
		obj.elems[index] = JawaObject.!(Value.ExternRef.!(args[2]).val); // TODO: check for array store exception
		return VOID;
	}
//-------------------------------------------------------------------------------------------------
	def ACMPEQ = HostFunction.new(sig_oo_i, eval_ACMPEQ);
	private def eval_ACMPEQ(e: Executor, args: Array<Value>) -> Result {
		var a = Value.ExternRef.!(args[0]);
		var b = Value.ExternRef.!(args[1]);
		return if(a.val == b.val, TRUE, FALSE);
	}
//-------------------------------------------------------------------------------------------------
	def ACMPNE = HostFunction.new(FuncSig.new([ValueType.Host(JawaTypes.OBJECT)], SigCache.arr_i), eval_ACMPNE);
	private def eval_ACMPNE(e: Executor, args: Array<Value>) -> Result {
		var a = Value.ExternRef.!(args[0]);
		var b = Value.ExternRef.!(args[1]);
		return if(a.val != b.val, TRUE, FALSE);
	}
//-------------------------------------------------------------------------------------------------
	def ANEWARRAY(t: JawaExportedType) -> HostFunction {
		var at = t.host;
		var sig = FuncSig.new(SigCache.arr_i, [t.rep]);
		return HostFunction.new(sig, eval_ANEWARRAY(at, _, _));
	}
	private def eval_ANEWARRAY(at: JawaHostType, e: Executor, args: Array<Value>) -> Result {
		var length = Values.v_i(args[0]);
		if (length < 0) return JawaTraps.NegativeArraySizeException;
		var elems = Array<JawaObject>.new(length); // TODO: out-of-memory check
		return Result.Value([Value.ExternRef(JawaRefArrayObject.new(at, elems))]);
	}
//-------------------------------------------------------------------------------------------------
	def ARRAYLENGTH(t: JawaExportedType) -> HostFunction {
		var sig = FuncSig.new([t.rep], SigCache.arr_i);
		return HostFunction.new(sig, eval_ARRAYLENGTH);
	}
	private def eval_ARRAYLENGTH(e: Executor, args: Array<Value>) -> Result {
		var obj = JawaArrayObject.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		return Result.Value([Values.i_v(obj.length())]);  // XXX: avoid virtual dispatch here?
	}
//-------------------------------------------------------------------------------------------------
	def NEWARRAY(t: JawaExportedType) -> HostFunction {
		var sig = FuncSig.new(SigCache.arr_i, [t.rep]);
		var eval: (Executor, Array<Value>) -> Result;
		match (t.host.t) {
			Array(elem) => match (elem) {
				BYTE => eval = eval_NEWARRAY<i8>;
				BOOL => eval = eval_NEWARRAY<bool>;
				CHAR => eval = eval_NEWARRAY<u16>;
				SHORT => eval = eval_NEWARRAY<i16>;
				INT => eval = eval_NEWARRAY<int>;
				LONG => eval = eval_NEWARRAY<long>;
				FLOAT => eval = eval_NEWARRAY<float>;
				DOUBLE => eval = eval_NEWARRAY<double>;
				_ => return null;
			}
			_ => return null;
		}
		return HostFunction.new(sig, eval);
	}
	private def eval_NEWARRAY<T>(e: Executor, args: Array<Value>) -> Result {
		var length = Values.v_i(args[0]);
		if (length < 0) return JawaTraps.NegativeArraySizeException;
		var elems = Array<T>.new(length); // TODO: out-of-memory check
		return Result.Value([Value.ExternRef(JawaArrayObjectOf.new(elems))]);
	}
//-------------------------------------------------------------------------------------------------
	def ALOAD<T>(map: JawaPrimTypeMapOf<T>) -> HostFunction {
		var sig = FuncSig.new([map.jawaArrayValueType, ValueType.I32], [map.valueType]);
		return HostFunction.new(sig, eval_ALOAD<T>(_, _, map.box));
	}
	private def eval_ALOAD<T>(e: Executor, args: Array<Value>, box: T -> Value) -> Result {
		var obj = JawaArrayObjectOf<T>.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		var index = Values.v_i(args[1]);
		if (index < 0 || index >= obj.elems.length) return JawaTraps.ArrayIndexOutOfBoundsException;
		return Result.Value([box(obj.elems[index])]);
	}
//-------------------------------------------------------------------------------------------------
	def ASTORE<T>(map: JawaPrimTypeMapOf<T>) -> HostFunction {
		var sig = FuncSig.new([map.jawaArrayValueType, ValueType.I32, map.valueType], SigCache.arr_v);
		return HostFunction.new(sig, eval_ASTORE<T>(_, _, map.box, map.unbox));
	}
	private def eval_ASTORE<T>(e: Executor, args: Array<Value>, box: T -> Value, unbox: Value -> T) -> Result {
		var obj = JawaArrayObjectOf<T>.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		var index = Values.v_i(args[1]);
		if (index < 0 || index >= obj.elems.length) return JawaTraps.ArrayIndexOutOfBoundsException;
		obj.elems[index] = unbox(args[2]);
		return VOID;
	}
}

component JawaTraps {
	def ArrayIndexOutOfBoundsException = Result.Trap(TrapReason.ERROR); // TODO: better error
	def NullPointerException = Result.Trap(TrapReason.ERROR); // TODO: better error
	def NegativeArraySizeException = Result.Trap(TrapReason.ERROR); // TODO: better error
}

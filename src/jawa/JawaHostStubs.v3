// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Code that implements all of the Jawa opcodes/functions as HostFunctions.
component JawaHostStubs {
	def VOID = HostResult.Value([]);
	def TRUE = HostResult.Value([Values.I32_1]);
	def FALSE = HostResult.Value([Values.I32_0]);
	def vt_o = ValueType.Host(JawaTypes.OBJECT);
	def sig_oo_i = FuncSig.new([vt_o, vt_o], SigCache.arr_i);
	def sig_o_i = FuncSig.new([vt_o], SigCache.arr_i);
	def sig_o_v = FuncSig.new([vt_o], SigCache.arr_v);

//-------------------------------------------------------------------------------------------------
	def AALOAD(at: JawaArrayType) -> HostFunction {
		var sig = FuncSig.new([ValueType.Host(at), ValueType.I32], [ValueType.Host(at.elem)]);
		return HostFunction.new(sig, eval_AALOAD);
	}
	private def eval_AALOAD(args: Array<Value>) -> HostResult {
		var obj = JawaRefArrayObject.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		var index = Values.v_u(args[1]);
		if (index >= obj.elems.length) return JawaTraps.ArrayIndexOutOfBoundsException;
		return HostResult.Value([Value.ExternRef(obj.elems[index])]);
	}
//-------------------------------------------------------------------------------------------------
	def AASTORE(at: JawaArrayType) -> HostFunction {
		var sig = FuncSig.new([ValueType.Host(at), ValueType.I32, ValueType.Host(at.elem)], SigCache.arr_v);
		return HostFunction.new(sig, eval_AASTORE);
	}
	private def eval_AASTORE(args: Array<Value>) -> HostResult {
		var obj = JawaRefArrayObject.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		var index = Values.v_u(args[1]);
		if (index >= obj.elems.length) return JawaTraps.ArrayIndexOutOfBoundsException;
		obj.elems[index] = JawaObject.!(Value.ExternRef.!(args[2]).val); // TODO: check for array store exception
		return VOID;
	}
//-------------------------------------------------------------------------------------------------
	def ACMPEQ = HostFunction.new(sig_oo_i, eval_ACMPEQ);
	private def eval_ACMPEQ(args: Array<Value>) -> HostResult {
		var a = Value.ExternRef.!(args[0]);
		var b = Value.ExternRef.!(args[1]);
		return if(a.val == b.val, TRUE, FALSE);
	}
//-------------------------------------------------------------------------------------------------
	def ANEWARRAY(at: JawaArrayType) -> HostFunction {
		var sig = FuncSig.new(SigCache.arr_i, [ValueType.Host(at)]);
		return HostFunction.new(sig, eval_ANEWARRAY(at, _));
	}
	private def eval_ANEWARRAY(at: JawaArrayType, args: Array<Value>) -> HostResult {
		var length = Values.v_i(args[0]);
		if (length < 0) return JawaTraps.NegativeArraySizeException;
		var elems = Array<JawaObject>.new(length); // TODO: out-of-memory check
		return HostResult.Value([Value.ExternRef(JawaRefArrayObject.new(at, elems))]);
	}
//-------------------------------------------------------------------------------------------------
	def ARRAYLENGTH(at: JawaArrayType) -> HostFunction {
		var sig = FuncSig.new([ValueType.Host(at)], SigCache.arr_i);
		return HostFunction.new(sig, eval_ARRAYLENGTH);
	}
	private def eval_ARRAYLENGTH(args: Array<Value>) -> HostResult {
		var obj = JawaArrayObject.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		return HostResult.Value([Values.i_v(obj.length())]);  // XXX: avoid virtual dispatch here?
	}
//-------------------------------------------------------------------------------------------------
	def NEWARRAY(at: JawaArrayType) -> HostFunction {
		var sig = FuncSig.new(SigCache.arr_i, [ValueType.Host(at)]);
		var eval: Array<Value> -> HostResult;
		match (at.elem.kind) {
			BYTE => eval = eval_NEWARRAY<i8>;
			BOOL => eval = eval_NEWARRAY<bool>;
			CHAR => eval = eval_NEWARRAY<u16>;
			SHORT => eval = eval_NEWARRAY<i16>;
			INT => eval = eval_NEWARRAY<int>;
			LONG => eval = eval_NEWARRAY<long>;
			FLOAT => eval = eval_NEWARRAY<float>;
			DOUBLE => eval = eval_NEWARRAY<double>;
			_ => return null;
		}
		return HostFunction.new(sig, eval);
	}
	private def eval_NEWARRAY<T>(args: Array<Value>) -> HostResult {
		var length = Values.v_i(args[0]);
		if (length < 0) return JawaTraps.NegativeArraySizeException;
		var elems = Array<T>.new(length); // TODO: out-of-memory check
		return HostResult.Value([Value.ExternRef(JawaArrayObjectOf.new(elems))]);
	}
//-------------------------------------------------------------------------------------------------
	def ALOAD<T>(at: JawaArrayType, map: JawaPrimMappingOf<T>) -> HostFunction {
		var et = JawaPrimType.!(at.elem).prim.valueType;
		var sig = FuncSig.new([ValueType.Host(at), ValueType.I32], [et]);
		return HostFunction.new(sig, eval_ALOAD<T>(_, map.box));
	}
	private def eval_ALOAD<T>(args: Array<Value>, box: T -> Value) -> HostResult {
		var obj = JawaArrayObjectOf<T>.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		var index = Values.v_u(args[1]);
		if (index >= obj.elems.length) return JawaTraps.ArrayIndexOutOfBoundsException;
		return HostResult.Value([box(obj.elems[index])]);
	}
//-------------------------------------------------------------------------------------------------
	def ASTORE<T>(at: JawaArrayType, map: JawaPrimMappingOf<T>) -> HostFunction {
		var et = JawaPrimType.!(at.elem).prim.valueType;
		var sig = FuncSig.new([ValueType.Host(at), ValueType.I32, et], SigCache.arr_v);
		return HostFunction.new(sig, eval_ASTORE<T>(_, map.unbox));
	}
	private def eval_ASTORE<T>(args: Array<Value>, unbox: Value -> T) -> HostResult {
		var obj = JawaArrayObjectOf<T>.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		var index = Values.v_u(args[1]);
		if (index >= obj.elems.length) return JawaTraps.ArrayIndexOutOfBoundsException;
		obj.elems[index] = unbox(args[2]);
		return VOID;
	}
//-------------------------------------------------------------------------------------------------
	def CHECKCAST(t: JawaRefType) -> HostFunction {
		var sig = FuncSig.new([ValueType.Host(JawaClasses.OBJECT)], [ValueType.Host(t)]);
		return HostFunction.new(sig, eval_CHECKCAST(t, _));
	}
	private def eval_CHECKCAST(t: JawaRefType, args: Array<Value>) -> HostResult {
		var v = args[0];
		var obj = Value.ExternRef.!(v).val;
		if (obj == null) return HostResult.Value([v]);
		var jt = JawaObject.!(obj).jawaType();
		return if(jt.isAssignableToH(t), HostResult.Value([v]), JawaTraps.ClassCastException);
	}
//-------------------------------------------------------------------------------------------------
	def DCMPG = HostFunction.new(SigCache.dd_i, eval_DCMPG);
	private def eval_DCMPG(args: Array<Value>) -> HostResult {
		var x = double.view(Values.v_d(args[0])), y = double.view(Values.v_d(args[1]));
		var r = if(x < y, -1, if(x == y, 0, 1));
		return HostResult.Value([Values.i_v(r)]);
	}
//-------------------------------------------------------------------------------------------------
	def DCMPL = HostFunction.new(SigCache.dd_i, eval_DCMPL);
	private def eval_DCMPL(args: Array<Value>) -> HostResult {
		var x = double.view(Values.v_d(args[0])), y = double.view(Values.v_d(args[1]));
		var r = if(x > y, 1, if(x == y, 0, -1));
		return HostResult.Value([Values.i_v(r)]);
	}
//-------------------------------------------------------------------------------------------------
	def DREM = HostFunction.new(SigCache.dd_d, eval_DREM);
	private def eval_DREM(args: Array<Value>) -> HostResult {
		var x = double.view(Values.v_d(args[0])), y = double.view(Values.v_d(args[1]));
		if (y == y) {
			var rem = x - y * double.floor(x / y); // TODO: check inf%inf and 0%0
			return HostResult.Value([Value.F64(u64.view(rem))]);
		} else { // y is NaN
			return HostResult.Value([Values.F64_nan]);
		}
	}
//-------------------------------------------------------------------------------------------------
	def FCMPG = HostFunction.new(SigCache.ff_i, eval_FCMPG);
	private def eval_FCMPG(args: Array<Value>) -> HostResult {
		var x = float.view(Values.v_f(args[0])), y = float.view(Values.v_f(args[1]));
		var r = if(x < y, -1, if(x == y, 0, 1));
		return HostResult.Value([Values.i_v(r)]);
	}
//-------------------------------------------------------------------------------------------------
	def FCMPL = HostFunction.new(SigCache.ff_i, eval_FCMPL);
	private def eval_FCMPL(args: Array<Value>) -> HostResult {
		var x = float.view(Values.v_f(args[0])), y = float.view(Values.v_f(args[1]));
		var r = if(x > y, 1, if(x == y, 0, -1));
		return HostResult.Value([Values.i_v(r)]);
	}
//-------------------------------------------------------------------------------------------------
	def FREM = HostFunction.new(SigCache.ff_f, eval_FREM);
	private def eval_FREM(args: Array<Value>) -> HostResult {
		var x = float.view(Values.v_f(args[0])), y = float.view(Values.v_f(args[1]));
		if (y == y) {
			var rem = x - y * float.floor(x / y); // TODO: check inf%inf and 0%0
			return HostResult.Value([Value.F32(u32.view(rem))]);
		} else { // y is NaN
			return HostResult.Value([Values.F32_nan]);
		}
	}
//-------------------------------------------------------------------------------------------------
	def GETFIELD(ct: JawaClassType, f: JawaField) -> HostFunction {
		var sig = FuncSig.new([ValueType.Host(ct)], [f.typ.valueType()]);
		return HostFunction.new(sig, eval_GETFIELD(f, _));
	}
	private def eval_GETFIELD(f: JawaField, args: Array<Value>) -> HostResult {
		var obj = JawaInstanceObject.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		return HostResult.Value([obj.fields[f.index]]);
	}
//-------------------------------------------------------------------------------------------------
	def GETSTATIC(ct: JawaClassType, f: JawaField) -> HostFunction {
		var sig = FuncSig.new(SigCache.arr_v, [f.typ.valueType()]);
		return HostFunction.new(sig, eval_GETSTATIC(ct, f, _));
	}
	private def eval_GETSTATIC(ct: JawaClassType, f: JawaField, args: Array<Value>) -> HostResult {
		return HostResult.Value([ct.fields[f.index]]);
	}
//-------------------------------------------------------------------------------------------------
	def INSTANCEOF(t: JawaRefType) -> HostFunction {
		return HostFunction.new(sig_o_i, eval_INSTANCEOF(t, _));
	}
	private def eval_INSTANCEOF(t: JawaRefType, args: Array<Value>) -> HostResult {
		var obj = Value.ExternRef.!(args[0]).val;
		if (obj == null) return FALSE;
		var jt = JawaObject.!(obj).jawaType();
		return if(jt.isAssignableToH(t), TRUE, FALSE);
	}
//-------------------------------------------------------------------------------------------------
	def INVOKEINTERFACE(ct: JawaInterfaceType, m: JawaMethod) -> Function {
		return HostFunction.new(m.sig(ct), eval_UNIMPLEMENTED);
	}
//-------------------------------------------------------------------------------------------------
	def INVOKESPECIAL(ct: JawaClassType, m: JawaMethod) -> Function {
		return HostFunction.new(m.sig(ct), eval_INVOKESPECIAL(m.impl, _));  // TODO: argument narrowing
	}
	private def eval_INVOKESPECIAL(f: Function, args: Array<Value>) -> HostResult {
		var obj = Value.ExternRef.!(args[0]).val;
		if (obj == null) return JawaTraps.NullPointerException;
		return HostResult.TailCall(f, args);
	}
//-------------------------------------------------------------------------------------------------
	def INVOKESTATIC(ct: JawaClassType, m: JawaMethod) -> Function {
		return HostFunction.new(m.sig(null), eval_fw(m.impl, _));   // TODO: argument narrowing
	}
	private def eval_fw(f: Function, args: Array<Value>) -> HostResult {
		return HostResult.TailCall(f, args);
	}
//-------------------------------------------------------------------------------------------------
	def INVOKEVIRTUAL(ct: JawaClassType, m: JawaMethod) -> Function {
		return HostFunction.new(m.sig(ct), eval_INVOKEVIRTUAL(m, _));
	}
	def eval_INVOKEVIRTUAL(m: JawaMethod, args: Array<Value>) -> HostResult {
		var obj = Value.ExternRef.!(args[0]).val;
		if (obj == null) return JawaTraps.NullPointerException;
		var f: Function;
		match (obj) {
			obj: JawaInstanceObject => f = obj.clazz.vtable[m.vtable_index].impl;
			// TODO: invoke virtual on array objects
		}
		return HostResult.TailCall(f, args);
	}
//-------------------------------------------------------------------------------------------------
	def ISNULL = HostFunction.new(sig_o_i, eval_ISNULL);
	private def eval_ISNULL(args: Array<Value>) -> HostResult {
		var a = Value.ExternRef.!(args[0]);
		return if(a.val == null, TRUE, FALSE);
	}
//-------------------------------------------------------------------------------------------------
	def MONITORENTER = HostFunction.new(sig_o_v, eval_MONITORENTER);
	private def eval_MONITORENTER(args: Array<Value>) -> HostResult { // TODO: nop
		var obj = Value.ExternRef.!(args[0]).val;
		if (obj == null) return JawaTraps.NullPointerException;
		return VOID;
	}
//-------------------------------------------------------------------------------------------------
	def MONITOREXIT = HostFunction.new(sig_o_v, eval_MONITOREXIT);
	private def eval_MONITOREXIT(args: Array<Value>) -> HostResult { // TODO: nop
		var obj = Value.ExternRef.!(args[0]).val;
		if (obj == null) return JawaTraps.NullPointerException;
		return VOID;
	}
//-------------------------------------------------------------------------------------------------
	def MULTIANEWARRAY(dims: int, at: JawaArrayType) -> HostFunction {
		// TODO: negative array size exception
		var p = Vector<ValueType>.new().grow(dims);
		for (i < dims) p.put(ValueType.I32);
		var sig = FuncSig.new(p.extract(), [ValueType.Host(at)]);
		return HostFunction.new(sig, eval_MULTIANEWARRAY(at, _));
	}
	private def eval_MULTIANEWARRAY(at: JawaArrayType, args: Array<Value>) -> HostResult {
		var dims = Arrays.map(args, Values.v_i);
		return HostResult.Value([Value.ExternRef(recMakeArray(at, dims, 0))]);
	}
	private def recMakeArray(at: JawaArrayType, dims: Array<int>, index: int) -> JawaObject {
		var length = dims[index];
		var next = index + 1;
		if (next == dims.length) {
			if (JawaPrimType.?(at.elem)) {
				// Primitive array; dispatch to primitive type to allocate
				return JawaPrimType.!(at.elem).prim.newarray(length);
			} else {
				// Reference array; all null elements
				return JawaRefArrayObject.new(at, Array<JawaObject>.new(length));
			}
		}
		var elems = Array<JawaObject>.new(length);
		var et = JawaArrayType.!(at.elem);
		for (i < length) {
			elems[i] = recMakeArray(et, dims, next);
		}
		return JawaRefArrayObject.new(at, elems);
	}
//-------------------------------------------------------------------------------------------------
	def NEW(ct: JawaClassType) -> HostFunction {
		var sig = FuncSig.new(SigCache.arr_v, [ValueType.Host(ct)]);
		return HostFunction.new(sig, eval_NEW(ct, _));
	}
	private def eval_NEW(ct: JawaClassType, args: Array<Value>) -> HostResult {
		return HostResult.Value([Value.ExternRef(JawaInstanceObject.new(ct))]);
	}
//-------------------------------------------------------------------------------------------------
	def PUTFIELD(ct: JawaClassType, f: JawaField) -> HostFunction {
		var sig = FuncSig.new([ValueType.Host(ct), f.typ.valueType()], SigCache.arr_v);
		return HostFunction.new(sig, eval_PUTFIELD(f, _));
	}
	private def eval_PUTFIELD(f: JawaField, args: Array<Value>) -> HostResult {
		var obj = JawaInstanceObject.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		obj.fields[f.index] = args[1]; // TODO: narrowing stores
		return VOID;
	}
//-------------------------------------------------------------------------------------------------
	def PUTSTATIC(ct: JawaClassType, f: JawaField) -> HostFunction {
		var sig = FuncSig.new([f.typ.valueType()], SigCache.arr_v);
		return HostFunction.new(sig, eval_PUTSTATIC(ct, f, _));
	}
	private def eval_PUTSTATIC(ct: JawaClassType, f: JawaField, args: Array<Value>) -> HostResult {
		ct.fields[f.index] = args[0]; // TODO: narrowing stores
		return VOID;
	}
//-------------------------------------------------------------------------------------------------
	private def eval_UNIMPLEMENTED(args: Array<Value>) -> HostResult {
		return JawaTraps.NullPointerException; // TODO
	}
}

component JawaTraps {
	def ArrayIndexOutOfBoundsException = HostResult.Trap(TrapReason.ERROR); // TODO: better error
	def NullPointerException = HostResult.Trap(TrapReason.ERROR); // TODO: better error
	def NegativeArraySizeException = HostResult.Trap(TrapReason.ERROR); // TODO: better error
	def ClassCastException = HostResult.Trap(TrapReason.ERROR); // TODO: better error
}

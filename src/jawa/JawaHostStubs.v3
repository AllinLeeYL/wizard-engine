// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Code that implements all of the Jawa opcodes/functions as HostFunctions.
component JawaHostStubs {
	def VOID = Result.Value([]);
	def TRUE = Result.Value([Values.I32_1]);
	def FALSE = Result.Value([Values.I32_0]);
	def vt_o = ValueType.Host(JawaTypes.OBJECT);
	def sig_oo_i = FuncSig.new([vt_o, vt_o], SigCache.arr_i);
	def sig_o_i = FuncSig.new([vt_o], SigCache.arr_i);

//-------------------------------------------------------------------------------------------------
	def AALOAD(at: JawaArrayType) -> HostFunction {
		var sig = FuncSig.new([ValueType.Host(at), ValueType.I32], [ValueType.Host(at.elem)]);
		return HostFunction.new(sig, eval_AALOAD);
	}
	private def eval_AALOAD(e: Executor, args: Array<Value>) -> Result {
		var obj = JawaRefArrayObject.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		var index = Values.v_i(args[1]);
		if (index < 0 || index >= obj.elems.length) return JawaTraps.ArrayIndexOutOfBoundsException;
		return Result.Value([Value.ExternRef(obj.elems[index])]);
	}
//-------------------------------------------------------------------------------------------------
	def AASTORE(at: JawaArrayType) -> HostFunction {
		var sig = FuncSig.new([ValueType.Host(at), ValueType.I32, ValueType.Host(at.elem)], SigCache.arr_v);
		return HostFunction.new(sig, eval_AASTORE);
	}
	private def eval_AASTORE(e: Executor, args: Array<Value>) -> Result {
		var obj = JawaRefArrayObject.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		var index = Values.v_i(args[1]);
		if (index < 0 || index >= obj.elems.length) return JawaTraps.ArrayIndexOutOfBoundsException;
		obj.elems[index] = JawaObject.!(Value.ExternRef.!(args[2]).val); // TODO: check for array store exception
		return VOID;
	}
//-------------------------------------------------------------------------------------------------
	def ACMPEQ = HostFunction.new(sig_oo_i, eval_ACMPEQ);
	private def eval_ACMPEQ(e: Executor, args: Array<Value>) -> Result {
		var a = Value.ExternRef.!(args[0]);
		var b = Value.ExternRef.!(args[1]);
		return if(a.val == b.val, TRUE, FALSE);
	}
//-------------------------------------------------------------------------------------------------
	def ANEWARRAY(at: JawaArrayType) -> HostFunction {
		var sig = FuncSig.new(SigCache.arr_i, [ValueType.Host(at)]);
		return HostFunction.new(sig, eval_ANEWARRAY(at, _, _));
	}
	private def eval_ANEWARRAY(at: JawaArrayType, e: Executor, args: Array<Value>) -> Result {
		var length = Values.v_i(args[0]);
		if (length < 0) return JawaTraps.NegativeArraySizeException;
		var elems = Array<JawaObject>.new(length); // TODO: out-of-memory check
		return Result.Value([Value.ExternRef(JawaRefArrayObject.new(at, elems))]);
	}
//-------------------------------------------------------------------------------------------------
	def ARRAYLENGTH(at: JawaArrayType) -> HostFunction {
		var sig = FuncSig.new([ValueType.Host(at)], SigCache.arr_i);
		return HostFunction.new(sig, eval_ARRAYLENGTH);
	}
	private def eval_ARRAYLENGTH(e: Executor, args: Array<Value>) -> Result {
		var obj = JawaArrayObject.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		return Result.Value([Values.i_v(obj.length())]);  // XXX: avoid virtual dispatch here?
	}
//-------------------------------------------------------------------------------------------------
	def NEWARRAY(at: JawaArrayType) -> HostFunction {
		var sig = FuncSig.new(SigCache.arr_i, [ValueType.Host(at)]);
		var eval: (Executor, Array<Value>) -> Result;
		match (at.elem.kind) {
			BYTE => eval = eval_NEWARRAY<i8>;
			BOOL => eval = eval_NEWARRAY<bool>;
			CHAR => eval = eval_NEWARRAY<u16>;
			SHORT => eval = eval_NEWARRAY<i16>;
			INT => eval = eval_NEWARRAY<int>;
			LONG => eval = eval_NEWARRAY<long>;
			FLOAT => eval = eval_NEWARRAY<float>;
			DOUBLE => eval = eval_NEWARRAY<double>;
			_ => return null;
		}
		return HostFunction.new(sig, eval);
	}
	private def eval_NEWARRAY<T>(e: Executor, args: Array<Value>) -> Result {
		var length = Values.v_i(args[0]);
		if (length < 0) return JawaTraps.NegativeArraySizeException;
		var elems = Array<T>.new(length); // TODO: out-of-memory check
		return Result.Value([Value.ExternRef(JawaArrayObjectOf.new(elems))]);
	}
//-------------------------------------------------------------------------------------------------
	def ALOAD<T>(at: JawaArrayType, map: JawaPrimMappingOf<T>) -> HostFunction {
		var et = JawaPrimType.!(at.elem).prim.valueType;
		var sig = FuncSig.new([ValueType.Host(at), ValueType.I32], [et]);
		return HostFunction.new(sig, eval_ALOAD<T>(_, _, map.box));
	}
	private def eval_ALOAD<T>(e: Executor, args: Array<Value>, box: T -> Value) -> Result {
		var obj = JawaArrayObjectOf<T>.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		var index = Values.v_i(args[1]);
		if (index < 0 || index >= obj.elems.length) return JawaTraps.ArrayIndexOutOfBoundsException;
		return Result.Value([box(obj.elems[index])]);
	}
//-------------------------------------------------------------------------------------------------
	def ASTORE<T>(at: JawaArrayType, map: JawaPrimMappingOf<T>) -> HostFunction {
		var et = JawaPrimType.!(at.elem).prim.valueType;
		var sig = FuncSig.new([ValueType.Host(at), ValueType.I32, et], SigCache.arr_v);
		return HostFunction.new(sig, eval_ASTORE<T>(_, _, map.box, map.unbox));
	}
	private def eval_ASTORE<T>(e: Executor, args: Array<Value>, box: T -> Value, unbox: Value -> T) -> Result {
		var obj = JawaArrayObjectOf<T>.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		var index = Values.v_i(args[1]);
		if (index < 0 || index >= obj.elems.length) return JawaTraps.ArrayIndexOutOfBoundsException;
		obj.elems[index] = unbox(args[2]);
		return VOID;
	}
//-------------------------------------------------------------------------------------------------
	def ISNULL = HostFunction.new(sig_o_i, eval_ISNULL);
	private def eval_ISNULL(e: Executor, args: Array<Value>) -> Result {
		var a = Value.ExternRef.!(args[0]);
		return if(a.val == null, TRUE, FALSE);
	}
}

component JawaTraps {
	def ArrayIndexOutOfBoundsException = Result.Trap(TrapReason.ERROR); // TODO: better error
	def NullPointerException = Result.Trap(TrapReason.ERROR); // TODO: better error
	def NegativeArraySizeException = Result.Trap(TrapReason.ERROR); // TODO: better error
}

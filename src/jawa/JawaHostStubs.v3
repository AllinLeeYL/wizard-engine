// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Code that implements all of the Jawa opcodes/functions as HostFunctions.
component JawaHostStubs {
	def Void = Result.Value([]);

	def ArrayLength(t: JawaExportedType) -> HostFunction {
		var sig = ValueType.Function([t.rep], SigCache.arr_i);
		return HostFunction.new(sig, ARRAYLENGTH);
	}
	def ARRAYLENGTH(e: Executor, args: Array<Value>) -> Result {
		var obj = JawaArrayObject.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		return Result.Value([Values.i_v(obj.length())]);  // XXX: avoid virtual dispatch here?
	}
	def NewArray(t: JawaExportedType) -> HostFunction {
		var sig = ValueType.Function(SigCache.arr_i, [t.rep]);
		var eval: (Executor, Array<Value>) -> Result;
		match (t.t) {
			Array(elem) => match (elem) {
				BYTE => eval = NEWARRAY<byte>;
				BOOL => eval = NEWARRAY<bool>;
				CHAR => eval = NEWARRAY<u16>;
				SHORT => eval = NEWARRAY<i16>;
				INT => eval = NEWARRAY<int>;
				LONG => eval = NEWARRAY<long>;
				FLOAT => eval = NEWARRAY<float>;
				DOUBLE => eval = NEWARRAY<double>;
				_ => return null;
			}
			_ => return null;
		}
		return HostFunction.new(sig, eval);
	}
	def NEWARRAY<T>(e: Executor, args: Array<Value>) -> Result {
		var length = Values.v_i(args[0]);
		if (length < 0) return JawaTraps.NegativeArraySizeException;
		var elems = Array<T>.new(length); // TODO: out-of-memory check
		return Result.Value([Value.ExternRef(JawaArrayObjectOf.new(elems))]);
	}
	def ALoad<T>(t: JawaExportedType) -> HostFunction {
		var sig = ValueType.Function([t.rep], SigCache.arr_i);
		var box: T -> Value; // TODO: box function
		return HostFunction.new(sig, ALOAD<T>(_, _, box));
	}
	def ALOAD<T>(e: Executor, args: Array<Value>, box: T -> Value) -> Result {
		var obj = JawaArrayObjectOf<T>.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		var index = Values.v_i(args[1]);
		var length = obj.length();
		if (index < 0 || index >= obj.elems.length) return JawaTraps.ArrayIndexOutOfBoundsException;
		return Result.Value([box(obj.elems[index])]);
	}
	def AStore<T>(t: JawaExportedType) -> HostFunction {
		var sig = ValueType.Function([t.rep], SigCache.arr_i);
		var box: T -> Value; // TODO: box function
		var unbox: Value -> T; // TODO: unbox function
		return HostFunction.new(sig, ASTORE<T>(_, _, box, unbox));
	}
	def ASTORE<T>(e: Executor, args: Array<Value>, box: T -> Value, unbox: Value -> T) -> Result {
		var obj = JawaArrayObjectOf<T>.!(Value.ExternRef.!(args[0]).val);
		if (obj == null) return JawaTraps.NullPointerException;
		var index = Values.v_i(args[1]);
		var length = obj.length();
		if (index < 0 || index >= obj.elems.length) return JawaTraps.ArrayIndexOutOfBoundsException;
		obj.elems[index] = unbox(args[2]);
		return Void;
	}
}

component JawaTraps {
	def ArrayIndexOutOfBoundsException = Result.Trap(TrapReason.ERROR); // TODO: better error
	def NullPointerException = Result.Trap(TrapReason.ERROR); // TODO: better error
	def NegativeArraySizeException = Result.Trap(TrapReason.ERROR); // TODO: better error
}

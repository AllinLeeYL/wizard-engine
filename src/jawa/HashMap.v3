// Copyright 2020 Ben L. Titzer. All rights reserved.
// Copyright 2010 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A general-purpose HashMap implementation.
// For maximum reusability, this implementation accepts the hash and equality functions
// as closures, and thus can map any key type to any value type.
class HashMap<K, V>(hash: K -> u32, equals: (K, K) -> bool) {
	private var table: Array<Bucket<K, V>>;	// lazily allocated hashtable
	private var cache: Bucket<K, V>;	// cache for last entry get/set

	// Get the value for {key}, if one exists; otherwise return the default value for {V}.
	def [key: K] -> V {
		var c = cache;
		if (c == null) { var none: V; return none; }
		// cache is valid, must be at least one entry
		if (c.key == key) return c.val;
		// if table is null, there is only one key/value pair
		if (table == null) {
			if (equals(c.key, key)) return c.val; // a slow hit in the cache
			var none: V;
			return none;
		}
		// cache did not match, hash and do bucket search
		for (bucket = table[toIndex(key)]; bucket != null; bucket = bucket.next) {
			if (bucket.key == key || equals(bucket.key, key)) {
				cache = bucket;
				return bucket.val;
			}
		}
		var none: V;
		return none;
	}
	// Set the value for {key} to {val}, overwriting any previous value.
	def [key: K] = val: V {
		var c = cache;
		if (c == null) {
			// no entries yet, simply add it as the cache
			cache = Bucket<K, V>.new(key, val, null);
			return;
		}
		if (c.key == key) {
			// ==, a fast hit in the cache
			c.val = val;
			return;
		}
		if (table == null) {
			if (equals(c.key, key)) {
				// equals(), a slow hit in the cache
				c.val = val;
				return;
			}
			// missed the cache, table not yet allocated, insert both
			table = Array.new(11); // TUNABLE: initial HashMap table size
			insert(c);
			insert(cache = Bucket.new(key, val, null));
			return;
		}
		// missed the cache, hash and search the table
		var index = toIndex(key);
		var i = 0;
		for (bucket = table[index]; bucket != null; bucket = bucket.next) {
			if (equals(bucket.key, key)) {
				bucket.val = val;
				cache = bucket;
				return;
			}
			i++;
		}
		// insert into table and cache
		table[index] = cache = Bucket.new(key, val, table[index]);
		if (i > 4 && table.length < 1001) balance();  // hash chains getting too long
	}
	private def insert(bucket: Bucket<K, V>) {
		var index = toIndex(bucket.key);
		bucket.next = table[index];
		table[index] = bucket;
	}
	private def toIndex(key: K) -> u32 {
		return hash(key) % u32.view(table.length);
	}
	private def balance() {
		var old = table, olen = old.length;
		table = Array.new(olen * 3 + 1);
		for (i < olen) {
			for (b = old[i]; b != null; b = b.next) {
				var index = toIndex(b.key);
				table[index] = Bucket.new(b.key, b.val, table[index]);
			}
		}
	}
}

// Internal data structure needed by HashMap to represent chained buckets.
class Bucket<K, V> {
	def key: K;
	var val: V;
	var next: Bucket<K, V>;

	new(key, val: V, next: Bucket<K,V>) {
		this.next = next;
		this.val = val;
	}
}

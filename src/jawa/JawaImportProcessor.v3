// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def Stubs: JawaHostStubs; // configurability for stub generation
// Processes a module's imports and supplies Jawa types, functions, and globals.
class JawaImportProcessor(error: ErrorGen, env: JawaEnvironment, module: Module, result: Array<Exportable>) {
	def decoder = Decoder.new([], error);
	def classDefs = Vector<JawaClass>.new();
	def interfaceDefs = Vector<JawaInterface>.new();
	def process() {
		var imports = module.imports;
		for (i < imports.length) {
			var imp = imports[i];
			error.abs(i);
			if (!Strings.equals("jawa", imp.modname)) continue; // not Jawa
			if (result[i] != null) continue; // import already bound
			var exp: Exportable;
			match (imp.details) {
				Function(decl) => exp = processFunction(imp.name, decl);
				Global(decl) =>  exp = processGlobal(imp.name, decl);
				Type(constraints) =>  exp = processType(imp.name, constraints);
				_ => error.set(Strings.format1("invalid import of kind %s", imp.details.name));
			}
			if (exp == null) return;
			if (error.error()) return;
			result[i] = exp;
		}
	}
	def processFunction(name: string, decl: FunctionDecl) -> Exportable {
		if (name.length < 1) error.set("expected opcode for function import");
		decoder.reset(name, 1, name.length);
		var opcode = name[0];
		match (opcode) {
			JawaFunctionOpcode.AALOAD.code => ;
			JawaFunctionOpcode.AASTORE.code => ;
			JawaFunctionOpcode.ACMPEQ.code => ;
			JawaFunctionOpcode.ACMPNE.code => ;
			JawaFunctionOpcode.ANEWARRAY.code => ;
			JawaFunctionOpcode.ARRAYLENGTH.code => {
				var at = read_jawa_array().0;
				if (at == null) return null;
				return Stubs.ARRAYLENGTH(at);
			}
			JawaFunctionOpcode.ATHROW.code => ;
			JawaFunctionOpcode.BALOAD.code => return Stubs.ALOAD<byte>(JawaTypes.BYTE_ARRAY);
			JawaFunctionOpcode.BASTORE.code => return Stubs.ASTORE<byte>(JawaTypes.BYTE_ARRAY);
			JawaFunctionOpcode.CALOAD.code => return Stubs.ALOAD<u16>(JawaTypes.CHAR_ARRAY);
			JawaFunctionOpcode.CASTORE.code => return Stubs.ASTORE<u16>(JawaTypes.CHAR_ARRAY);
			JawaFunctionOpcode.CHECKCAST.code => ;
			JawaFunctionOpcode.D2I.code => ;
			JawaFunctionOpcode.D2L.code => ;
			JawaFunctionOpcode.DALOAD.code => return Stubs.ALOAD<double>(JawaTypes.DOUBLE_ARRAY);
			JawaFunctionOpcode.DASTORE.code => return Stubs.ASTORE<double>(JawaTypes.DOUBLE_ARRAY);
			JawaFunctionOpcode.DCMPG.code => ;
			JawaFunctionOpcode.DCMPL.code => ;
			JawaFunctionOpcode.DREM.code => ;
			JawaFunctionOpcode.F2I.code => ;
			JawaFunctionOpcode.F2L.code => ;
			JawaFunctionOpcode.FALOAD.code => return Stubs.ALOAD<float>(JawaTypes.FLOAT_ARRAY);
			JawaFunctionOpcode.FASTORE.code => return Stubs.ASTORE<float>(JawaTypes.FLOAT_ARRAY);
			JawaFunctionOpcode.FCMPG.code => ;
			JawaFunctionOpcode.FCMPL.code => ;
			JawaFunctionOpcode.FREM.code => ;
			JawaFunctionOpcode.GETFIELD.code => ;
			JawaFunctionOpcode.GETSTATIC.code => ;
			JawaFunctionOpcode.IALOAD.code => return Stubs.ALOAD<int>(JawaTypes.INT_ARRAY);
			JawaFunctionOpcode.IASTORE.code => return Stubs.ASTORE<int>(JawaTypes.INT_ARRAY);
			JawaFunctionOpcode.INSTANCEOF.code => ;
			JawaFunctionOpcode.INVOKEDYNAMIC.code => ;
			JawaFunctionOpcode.INVOKEINTERFACE.code => ;
			JawaFunctionOpcode.INVOKESPECIAL.code => ;
			JawaFunctionOpcode.INVOKESTATIC.code => ;
			JawaFunctionOpcode.INVOKEVIRTUAL.code => ;
			JawaFunctionOpcode.LALOAD.code => return Stubs.ALOAD<long>(JawaTypes.LONG_ARRAY);
			JawaFunctionOpcode.LASTORE.code => return Stubs.ASTORE<long>(JawaTypes.LONG_ARRAY);
			JawaFunctionOpcode.MONITORENTER.code => ;
			JawaFunctionOpcode.MONITOREXIT.code => ;
			JawaFunctionOpcode.MULTIANEWARRAY.code => ;
			JawaFunctionOpcode.NEW.code => ;
			JawaFunctionOpcode.NEWARRAY.code => {
				var at = read_jawa_array().0;
				if (at == null) return null;
				return Stubs.NEWARRAY(at);
			}
			JawaFunctionOpcode.NONNULL.code => ;
			JawaFunctionOpcode.NULL.code => ;
			JawaFunctionOpcode.PUTFIELD.code => ;
			JawaFunctionOpcode.PUTSTATIC.code => ;
			_ => error.set(Strings.format1("invalid function opcode 0x%x", opcode));
		}
		return null;
	}
	def processGlobal(name: string, decl: GlobalDecl) -> Exportable {
		if (name.length < 1) error.set("import of empty global");
		var opcode = name[0];
		match (opcode) {
			JawaGlobalOpcode.STRING_CONST.code => {
				var str = read_jawa_string();
				if (str == null) return null;
				return env.internStringAsGlobal(str);
			}
			_ => error.set(Strings.format1("invalid global opcode 0x%x", opcode));
		}
		return null;
	}
	def processType(name: string, constraints: Array<TypeConstraint>) -> Exportable {
		if (name.length < 1) error.set("import of empty type");
		decoder.reset(name, 1, name.length);
		var opcode = name[0];
		match (opcode) {
			JawaTypeOpcode.BYTE_ARRAY.code => return JawaTypes.BYTE_ARRAY;
			JawaTypeOpcode.BOOL_ARRAY.code => return JawaTypes.BOOL_ARRAY;
			JawaTypeOpcode.CHAR_ARRAY.code => return JawaTypes.CHAR_ARRAY;
			JawaTypeOpcode.SHORT_ARRAY.code => return JawaTypes.SHORT_ARRAY;
			JawaTypeOpcode.INT_ARRAY.code => return JawaTypes.INT_ARRAY;
			JawaTypeOpcode.LONG_ARRAY.code => return JawaTypes.LONG_ARRAY;
			JawaTypeOpcode.FLOAT_ARRAY.code => return JawaTypes.FLOAT_ARRAY;
			JawaTypeOpcode.DOUBLE_ARRAY.code => return JawaTypes.DOUBLE_ARRAY;
			JawaTypeOpcode.EXT_CLASS.code => {
				var str = read_jawa_name();
				if (str == null) return null;
				var c = env.lookupClass(str);
				if (c == null) error.set(Strings.format1("class not found: %q", str.render));
				return env.exportClass(c);
			}
			JawaTypeOpcode.EXT_INTERFACE.code => {
				var str = read_jawa_name();
				if (str == null) return null;
				var i = env.lookupInterface(str);
				if (i == null) error.set(Strings.format1("interface not found: %q", str.render));
				return env.exportInterface(i);
			}
			JawaTypeOpcode.FW_CLASS_DECL.code => {
				var str = read_jawa_name();
				if (str == null) return null;
				var sup = read_jawa_class().1.decl;
				var count = read_jawa_int();
				var intfs = Array<JawaInterface>.new(count);
				for (i < count) {
					intfs[i] = read_jawa_interface().1.decl;
				}
				var cl = env.declareClass(str, sup, intfs);
				classDefs.put(cl);
				return env.exportClass(cl);
			}
			JawaTypeOpcode.FW_INTERFACE_DECL.code => {
				var str = read_jawa_name();
				if (str == null) return null;
				var count = read_jawa_int();
				var intfs = Array<JawaInterface>.new(count);
				for (i < count) {
					intfs[i] = read_jawa_interface().1.decl;
				}
				var cl = env.declareInterface(str, intfs);
				interfaceDefs.put(cl);
				return env.exportInterface(cl);
			}
			JawaTypeOpcode.REF_ARRAY.code => {
				var elem = read_jawa_ref_type();
				if (elem == JawaType.None) return null;
				return env.getArrayType(elem);
			}
			JawaTypeOpcode.DEF_CLASS.code => {
				var t = read_jawa_class(), decl = t.1.decl;
				if (t.0 == null) return null;
				if (decl.complete()) {
					error.set(Strings.format1("class %s already complete", decl.name.render));
					return null;
				}
				var count: int;
				// read instance fields
				count = read_jawa_int();
				var instanceFields = decl.instanceFields = Array.new(count);
				for (i < count) instanceFields[i] = read_jawa_field_decl();
				// read instance methods
				count = read_jawa_int();
				var instanceMethods = decl.instanceMethods = Array.new(count);
				for (i < count) instanceMethods[i] = read_jawa_method_decl();
				// read static fields
				count = read_jawa_int();
				var staticFields = decl.staticFields = Array.new(count);
				for (i < count) staticFields[i] = read_jawa_field_decl();
				// read static methods
				count = read_jawa_int();
				var staticMethods = decl.staticMethods = Array.new(count);
				for (i < count) staticMethods[i] = read_jawa_method_decl();
			}
			JawaTypeOpcode.DEF_INTERFACE.code => {
				var t = read_jawa_interface(), decl = t.1.decl;
				if (t.0 == null) return null;
				if (decl.complete()) {
					error.set(Strings.format1("class %s already complete", decl.name.render));
					return null;
				}
				var count: int;
				// read instance methods
				count = read_jawa_int();
				var instanceMethods = decl.instanceMethods = Array.new(count);
				for (i < count) instanceMethods[i] = read_jawa_method_decl();
			}
			_ => error.set(Strings.format1("invalid type opcode 0x%x", opcode));
		}
		return null;
	}

	def read_jawa_string() -> JawaString {
		// Jawa strings are a length (4-byte Jawa int), followed by {length} UTF-8 bytes
		// that encode a UTF-16 string.
		var length = read_jawa_int();
		if (!decoder.check_bytes(length)) return null;
		var chars = read_utf8_to_utf16(length);
		return if(chars != null, JawaString.new(chars));
	}
	def read_jawa_name() -> JawaString {
		// Jawa names are a length (2-byte Jawa int), followed by {length} UTF-8 bytes
		// that encode a UTF-16 string.
		var length = read_jawa_iN(2);
		if (!decoder.check_bytes(length)) return null;
		var chars = read_utf8_to_utf16(length);
		return if(chars != null, JawaString.new(chars));
	}
	def read_jawa_int() -> u28 {
		// Jawa ints are 4 little-endian 7-bit bytes for 28 bits total.
		// The upper bit of each byte must be 0 so that the int passes through UTF-8.
		return read_jawa_iN(4);
	}
	def read_jawa_iN(max: int) -> u28 {
		var result: u32, shift = 0;
		for (i < max) {
			if (decoder.pos >= decoder.limit) break;
			var b = decoder.data[decoder.pos++];
			if ((b & 0x80) != 0) {
				error.at(decoder).set("Jawa int byte should not have upper bit set");
				return 0;
			}
			result = result | (u32.!(b) << u5.!(shift));
			shift += 7;
		}
		return u28.view(result);
	}
	def read_utf8_to_utf16(length: int) -> Array<u16> {
		var chars = Array<u16>.new(length);
		// TODO: support more than 7-bit ascii
		for (i < chars.length) {
			var b = decoder.data[i + decoder.pos];
			if ((b & 0x80) != 0) {
				error.rel(decoder, decoder.pos + i).set("Jawa strings are currently limited to 7-bit ascii");
				return null;
			}
			chars[i] = b;
		}
		decoder.pos += length;
		return chars;
	}
	def read_jawa_interface() -> (JawaExportedType, JawaType.Interface) {
		return read_jawa_type<JawaType.Interface>("interface ref");
	}
	def read_jawa_class() -> (JawaExportedType, JawaType.Class) {
		return read_jawa_type<JawaType.Class>("class ref");
	}
	def read_jawa_array() -> (JawaExportedType, JawaType.Array) {
		return read_jawa_type<JawaType.Array>("array ref");
	}
	def read_jawa_ref_type() -> JawaType {
		var t = read_jawa_exported_type("ref");
		if (t == null) return JawaType.None;
		match (t.t) {
			Class, Interface, Array => return t.t;
			_ => return JawaType.None;
		}
	}
	def read_jawa_type<T>(kind: string) -> (JawaExportedType, T) {
		var d: T, ext = read_jawa_exported_type(kind);
		if (ext == null) return (null, d);
		var jwt = ext.t;
		if (T.?(jwt)) return (ext, T.!(jwt));
		return (null, d);
	}
	def read_any_jawa_type() -> (JawaExportedType, JawaType); // TODO: devise encoding for primitive types
	def read_non_void_jawa_type() -> (JawaExportedType, JawaType); // TODO: devise encoding for primitive types
	def read_jawa_exported_type(kind: string) -> JawaExportedType {
		var i = read_jawa_int();
		if (i >= module.types.size()) {
			error.set("type index out of bounds");
			return null;
		}
		match (module.types[int.view(i)]) {
			Imported(index, details) => {
				var e = result[index];
				if (e == null) {
					error.set(Strings.format1("expected %s type, got <null>", kind));
					return null;
				}
				if (!JawaExportedType.?(e)) {
					error.set("expected jawa type");
					return null;
				}
				return JawaExportedType.!(e);
			}
			Function(f) => {
				error.set(Strings.format2("expected %s type, got %q", kind, ValueTypes.render(_, f)));
				return null;
			}
		}
	}
	def read_jawa_field_decl() -> JawaField {
		var name = read_jawa_string();
		var typ = read_non_void_jawa_type().1;
		return JawaField.new(name, typ);
	}
	def read_jawa_method_decl() -> JawaMethod {
		var name = read_jawa_string();
		var count: int = read_jawa_int();
		var params = Array<JawaType>.new(count);
		for (i < count) {
			params[i] = read_non_void_jawa_type().1;
		}
		var ret = read_any_jawa_type().1;
		return JawaMethod.new(name, params, ret);
	}
}

// Codes and immediates for functions that can be imported into a Jawa module.
enum JawaFunctionOpcode(code: byte, imm: JawaImmKind) {
	AALOAD		(0x10, JawaImmKind.REF_TYPE),
	AASTORE		(0x11, JawaImmKind.REF_TYPE),
	ACMPEQ		(0x12, JawaImmKind.REF_TYPE),
	ACMPNE		(0x13, JawaImmKind.REF_TYPE),
	ANEWARRAY	(0x14, JawaImmKind.REF_TYPE),
	ARRAYLENGTH	(0x15, JawaImmKind.ARRAY_TYPE),
	ATHROW		(0x16, JawaImmKind.NONE),
	BALOAD		(0x17, JawaImmKind.NONE),
	BASTORE		(0x18, JawaImmKind.NONE),
	CALOAD		(0x19, JawaImmKind.NONE),
	CASTORE		(0x1A, JawaImmKind.NONE),
	CHECKCAST	(0x1B, JawaImmKind.REF_TYPE_REF_TYPE),
	D2I		(0x1C, JawaImmKind.NONE),
	D2L		(0x1D, JawaImmKind.NONE),
	DALOAD		(0x1E, JawaImmKind.NONE),
	DASTORE		(0x1F, JawaImmKind.NONE),
	DCMPG		(0x20, JawaImmKind.NONE),
	DCMPL		(0x21, JawaImmKind.NONE),
	DREM		(0x22, JawaImmKind.NONE),
	F2I		(0x23, JawaImmKind.NONE),
	F2L		(0x24, JawaImmKind.NONE),
	FALOAD		(0x25, JawaImmKind.NONE),
	FASTORE		(0x26, JawaImmKind.NONE),
	FCMPG		(0x27, JawaImmKind.NONE),
	FCMPL		(0x28, JawaImmKind.NONE),
	FREM		(0x29, JawaImmKind.NONE),
	GETFIELD	(0x2A, JawaImmKind.INSTANCE_FIELD_SELECTOR),
	GETSTATIC	(0x2B, JawaImmKind.STATIC_FIELD_SELECTOR),
	IALOAD		(0x2C, JawaImmKind.NONE),
	IASTORE		(0x2D, JawaImmKind.NONE),
	INSTANCEOF	(0x2E, JawaImmKind.REF_TYPE_REF_TYPE),
	INVOKEDYNAMIC	(0x2F, JawaImmKind.INSTANCE_METHOD_SELECTOR),
	INVOKEINTERFACE	(0x30, JawaImmKind.INTERFACE_METHOD_SELECTOR),
	INVOKESPECIAL	(0x31, JawaImmKind.INSTANCE_METHOD_SELECTOR),
	INVOKESTATIC	(0x32, JawaImmKind.STATIC_METHOD_SELECTOR),
	INVOKEVIRTUAL	(0x33, JawaImmKind.INSTANCE_METHOD_SELECTOR),
	LALOAD		(0x34, JawaImmKind.NONE),
	LASTORE		(0x35, JawaImmKind.NONE),
	MONITORENTER	(0x36, JawaImmKind.REF_TYPE),
	MONITOREXIT	(0x37, JawaImmKind.REF_TYPE),
	MULTIANEWARRAY	(0x38, JawaImmKind.INT_REF_TYPE),
	NEW		(0x39, JawaImmKind.CLASS_TYPE),
	NEWARRAY	(0x3A, JawaImmKind.ARRAY_TYPE),
	NONNULL		(0x3B, JawaImmKind.REF_TYPE),
	NULL		(0x3C, JawaImmKind.REF_TYPE),
	PUTFIELD	(0x3D, JawaImmKind.INSTANCE_FIELD_SELECTOR),
	PUTSTATIC	(0x3E, JawaImmKind.STATIC_FIELD_SELECTOR),
}

// Codes and immediates for types that can be imported into a Jawa module.
enum JawaTypeOpcode(code: byte, imm: JawaImmKind) {
	BYTE_ARRAY		(0x00, JawaImmKind.NONE),
	BOOL_ARRAY		(0x01, JawaImmKind.NONE),
	CHAR_ARRAY		(0x02, JawaImmKind.NONE),
	SHORT_ARRAY		(0x03, JawaImmKind.NONE),
	INT_ARRAY		(0x04, JawaImmKind.NONE),
	LONG_ARRAY		(0x05, JawaImmKind.NONE),
	FLOAT_ARRAY		(0x06, JawaImmKind.NONE),
	DOUBLE_ARRAY		(0x07, JawaImmKind.NONE),
	EXT_CLASS		(0x08, JawaImmKind.STRING),
	EXT_INTERFACE		(0x09, JawaImmKind.STRING),
	FW_CLASS_DECL		(0x0A, JawaImmKind.CLASS_DECL),
	FW_INTERFACE_DECL	(0x0B, JawaImmKind.INTERFACE_DECL),
	REF_ARRAY		(0x0C, JawaImmKind.REF_TYPE),
	DEF_CLASS		(0x0D, JawaImmKind.CLASS_DEF),
	DEF_INTERFACE		(0x0E, JawaImmKind.INTERFACE_DEF),
}

// Codes and immediates for globals that can be imported into a Jawa module.
enum JawaGlobalOpcode(code: byte, imm: JawaImmKind) {
	STRING_CONST	(0x00, JawaImmKind.STRING)
}

// The immediate kinds for imports.
enum JawaImmKind {
	NONE,
	STRING,				// UTF-8 encoded UTF-16
	CLASS_TYPE,			// int: type index, must be class
	REF_TYPE,			// int: type index, must be ref
	REF_TYPE_REF_TYPE,		// int: type index, int: type index, must be refs
	ARRAY_TYPE,			// int: type index, must be array
	INSTANCE_FIELD_SELECTOR,	// UTF-8 string pair, must refer to class field
	STATIC_FIELD_SELECTOR,		// UTF-8 string pair, must refer to class field
	INTERFACE_METHOD_SELECTOR,	// UTF-8 string pair, must refer to interface method
	INSTANCE_METHOD_SELECTOR,	// UTF-8 string pair, must refer to class method
	STATIC_METHOD_SELECTOR,		// UTF-8 string pair, must refer to class method
	INT_REF_TYPE,			// int, int: type index, must be ref
	CLASS_DECL,			// string, int: type index, must be class, int*: type index, must be interfaces
	INTERFACE_DECL			// string, int*: type index, must be interfaces
	CLASS_DEF,			// int: type index, must be class, instance fields/methods, static fields/methods
	INTERFACE_DEF			// int: type index, must be interface, interface methods
}

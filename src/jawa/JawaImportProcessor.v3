// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def Stubs: JawaHostStubs; // configurability for stub generation
// Processes a module's imports and supplies Jawa types, functions, and globals.
class JawaImportProcessor(error: ErrorGen, env: JawaEnvironment, module: Module, result: Array<Exportable>) {
	def decoder = Decoder.new([], error);
	def classDefs = Vector<JawaClass>.new();
	def interfaceDefs = Vector<JawaInterface>.new();
	def trace = if(Trace.jawa, StringBuilder.new());
	var current_index = 0;
	def process() {
		var imports = module.imports;
		for (i < imports.length) {
			current_index = i;
			var imp = imports[i];
			if (!Strings.equals("jawa", imp.modname)) continue; // not Jawa
			if (trace != null) {
				trace.put1("jawa import #%d:", i);
				for (b in imp.name) trace.put1(" %x", b);
				trace.ln();
				trace.out(Trace.STDOUT);
				trace.reset();
			}
			if (result[i] != null) continue; // import already bound
			var exp: Exportable;
			match (imp.details) {
				Function(decl) => exp = processFunction(imp.name, decl);
				Global(decl) =>  exp = processGlobal(imp.name, decl);
				Type(decl) =>  exp = processType(imp.name, decl);
				_ => err(Strings.format1("invalid import of kind %s", imp.details.name));
			}
			if (exp == null) return;
			if (error.error()) return;
			result[i] = exp;
		}
	}
	def extractMainExport(instance: Instance) -> Function {
		var module = instance.module;
		var exports = module.exports;
		var found: Function;
		for (j < exports.length) {
			var e = module.exports[j];
			if (!ExportDetails.Function.?(e.details)) continue;
			found = Function.!(instance.exports[j]);
			if (Strings.equals("main", e.name)) return found;
		}
		return null;
	}
	def processFunction(name: string, decl: FunctionDecl) -> Exportable {
		if (name.length < 1) err("expected opcode for function import");
		decoder.reset(name, 1, name.length);
		var opcode = name[0];
		match (opcode) {
			JawaFuncOpcode.AALOAD.code => {
				var at = read_jawa_ref_array();
				if (at == null) return null;
				return Stubs.AALOAD(at);
			}
			JawaFuncOpcode.AASTORE.code => {
				var at = read_jawa_ref_array();
				if (at == null) return null;
				return Stubs.AASTORE(at);
			}
			JawaFuncOpcode.ACMPEQ.code => {
				return Stubs.ACMPEQ;
			}
			JawaFuncOpcode.ANEWARRAY.code => {
				var at = read_jawa_ref_array();
				if (at == null) return null;
				return Stubs.ANEWARRAY(at);
			}
			JawaFuncOpcode.ARRAYLENGTH.code => {
				var at = read_jawa_array();
				if (at == null) return null;
				return Stubs.ARRAYLENGTH(at);
			}
			JawaFuncOpcode.ATHROW.code => ;
			JawaFuncOpcode.BALOAD.code => return Stubs.ALOAD<i8>(JawaTypes.BYTE_ARRAY_PAIR);
			JawaFuncOpcode.BASTORE.code => return Stubs.ASTORE<i8>(JawaTypes.BYTE_ARRAY_PAIR);
			JawaFuncOpcode.CALOAD.code => return Stubs.ALOAD<u16>(JawaTypes.CHAR_ARRAY_PAIR);
			JawaFuncOpcode.CASTORE.code => return Stubs.ASTORE<u16>(JawaTypes.CHAR_ARRAY_PAIR);
			JawaFuncOpcode.CHECKCAST.code => ;
			JawaFuncOpcode.DALOAD.code => return Stubs.ALOAD<double>(JawaTypes.DOUBLE_ARRAY_PAIR);
			JawaFuncOpcode.DASTORE.code => return Stubs.ASTORE<double>(JawaTypes.DOUBLE_ARRAY_PAIR);
			JawaFuncOpcode.DCMPG.code => ;
			JawaFuncOpcode.DCMPL.code => ;
			JawaFuncOpcode.DREM.code => ;
			JawaFuncOpcode.FALOAD.code => return Stubs.ALOAD<float>(JawaTypes.FLOAT_ARRAY_PAIR);
			JawaFuncOpcode.FASTORE.code => return Stubs.ASTORE<float>(JawaTypes.FLOAT_ARRAY_PAIR);
			JawaFuncOpcode.FCMPG.code => ;
			JawaFuncOpcode.FCMPL.code => ;
			JawaFuncOpcode.FREM.code => ;
			JawaFuncOpcode.GETFIELD.code => ;
			JawaFuncOpcode.GETSTATIC.code => ;
			JawaFuncOpcode.IALOAD.code => return Stubs.ALOAD<int>(JawaTypes.INT_ARRAY_PAIR);
			JawaFuncOpcode.IASTORE.code => return Stubs.ASTORE<int>(JawaTypes.INT_ARRAY_PAIR);
			JawaFuncOpcode.INSTANCEOF.code => ;
			JawaFuncOpcode.INVOKEDYNAMIC.code => ;
			JawaFuncOpcode.INVOKEINTERFACE.code => ;
			JawaFuncOpcode.INVOKESPECIAL.code => ;
			JawaFuncOpcode.INVOKESTATIC.code => ;
			JawaFuncOpcode.INVOKEVIRTUAL.code => ;
			JawaFuncOpcode.LALOAD.code => return Stubs.ALOAD<long>(JawaTypes.LONG_ARRAY_PAIR);
			JawaFuncOpcode.LASTORE.code => return Stubs.ASTORE<long>(JawaTypes.LONG_ARRAY_PAIR);
			JawaFuncOpcode.MONITORENTER.code => ;
			JawaFuncOpcode.MONITOREXIT.code => ;
			JawaFuncOpcode.MULTIANEWARRAY.code => {
				var dims = read_jawa_int();
				var rtype = read_jawa_array();
				if (rtype == null) return null;
				var rank = rtype.rank();
				if (rank < dims) {
					err(Strings.format2("expected maximum %d dimensions, got %d", rank, int.!(dims)));
					return null;
				}
				return Stubs.MULTIANEWARRAY(dims, rtype);
			}
			JawaFuncOpcode.NEW.code => ;
			JawaFuncOpcode.NEWARRAY.code => {
				var at = read_jawa_array();
				if (at == null) return null;
				return Stubs.NEWARRAY(at);
			}
			JawaFuncOpcode.ISNULL.code => {
				return Stubs.ISNULL;
			}
			JawaFuncOpcode.PUTFIELD.code => ;
			JawaFuncOpcode.PUTSTATIC.code => ;
			JawaFuncOpcode.SALOAD.code => return Stubs.ALOAD<short>(JawaTypes.SHORT_ARRAY_PAIR);
			JawaFuncOpcode.SASTORE.code => return Stubs.ASTORE<short>(JawaTypes.SHORT_ARRAY_PAIR);
			_ => err(Strings.format1("invalid function opcode 0x%x", opcode));
		}
		return null;
	}
	def processGlobal(name: string, decl: GlobalDecl) -> Exportable {
		if (name.length < 1) err("import of empty global");
		var opcode = name[0];
		match (opcode) {
			JawaGlobalOpcode.STRING_CONST.code => {
				var str = read_jawa_string();
				if (str == null) return null;
				return env.internStringAsGlobal(str);
			}
			_ => err(Strings.format1("invalid global opcode 0x%x", opcode));
		}
		return null;
	}
	def processType(name: string, decl: DefType.Imported) -> Exportable {
		if (name.length < 1) {
			err("import of empty type");
			return null;
		}
		decoder.reset(name, 1, name.length);
		var opcode = name[0];
		match (opcode) {
			JawaTypeOpcode.BYTE_ARRAY.code => return JawaTypes.BYTE_ARRAY;
			JawaTypeOpcode.BOOL_ARRAY.code => return JawaTypes.BOOL_ARRAY;
			JawaTypeOpcode.CHAR_ARRAY.code => return JawaTypes.CHAR_ARRAY;
			JawaTypeOpcode.SHORT_ARRAY.code => return JawaTypes.SHORT_ARRAY;
			JawaTypeOpcode.INT_ARRAY.code => return JawaTypes.INT_ARRAY;
			JawaTypeOpcode.LONG_ARRAY.code => return JawaTypes.LONG_ARRAY;
			JawaTypeOpcode.FLOAT_ARRAY.code => return JawaTypes.FLOAT_ARRAY;
			JawaTypeOpcode.DOUBLE_ARRAY.code => return JawaTypes.DOUBLE_ARRAY;
			JawaTypeOpcode.EXT_CLASS.code => {
				var str = read_jawa_name();
				if (str == null) return null;
				var c = env.lookup(str);
				if (c == null) err(Strings.format1("class not found: %q", str.render));
				if (!JawaClass.?(c)) err(Strings.format1("not a class: %q", str.render));
				else return env.exportClass(JawaClass.!(c));
			}
			JawaTypeOpcode.EXT_INTERFACE.code => {
				var str = read_jawa_name();
				if (str == null) return null;
				var i = env.lookup(str);
				if (i == null) err(Strings.format1("interface not found: %q", str.render));
				if (!JawaInterface.?(i)) err(Strings.format1("not an interface: %q", str.render));
				else return env.exportInterface(JawaInterface.!(i));
			}
			JawaTypeOpcode.FW_CLASS_DECL.code => {
				var str = read_jawa_name();
				if (str == null) return null;
				var sup = read_jawa_class();
				if (sup == null) return null;
				var count = read_jawa_int();
				var intfs = Array<JawaInterface>.new(count);
				for (i < count) {
					var intf = read_jawa_interface();
					if (intf == null) return null;
					intfs[i] = intf.decl;
				}
				var cl = env.declareClass(str, sup.decl, intfs);
				classDefs.put(cl);
				return env.exportClass(cl);
			}
			JawaTypeOpcode.FW_INTERFACE_DECL.code => {
				var str = read_jawa_name();
				if (str == null) return null;
				var count = read_jawa_int();
				var intfs = Array<JawaInterface>.new(count);
				for (i < count) {
					var intf = read_jawa_interface();
					if (intf == null) return null;
					intfs[i] = intf.decl;
				}
				var cl = env.declareInterface(str, intfs);
				interfaceDefs.put(cl);
				return env.exportInterface(cl);
			}
			JawaTypeOpcode.REF_ARRAY.code => {
				var elem = read_jawa_ref_type();
				if (elem == null) return null;
				return env.getArrayType(elem);
			}
			JawaTypeOpcode.DEF_CLASS.code => {
				var t = read_jawa_class();
				if (t == null) return null;
				if (t.decl.complete()) {
					err(Strings.format1("class %s already complete", t.decl.name.render));
					return null;
				}
				var count: int;
				// read instance fields
				count = read_jawa_int();
				var instanceFields = t.decl.instanceFields = Array.new(count);
				for (i < count) instanceFields[i] = read_jawa_field_decl();
				// read instance methods
				count = read_jawa_int();
				var instanceMethods = t.decl.instanceMethods = Array.new(count);
				for (i < count) instanceMethods[i] = read_jawa_method_decl();
				// read static fields
				count = read_jawa_int();
				var staticFields = t.decl.staticFields = Array.new(count);
				for (i < count) staticFields[i] = read_jawa_field_decl();
				// read static methods
				count = read_jawa_int();
				var staticMethods = t.decl.staticMethods = Array.new(count);
				for (i < count) staticMethods[i] = read_jawa_method_decl();
			}
			JawaTypeOpcode.DEF_INTERFACE.code => {
				var t = read_jawa_interface();
				if (t == null) return null;
				if (t.decl.complete()) {
					err(Strings.format1("class %s already complete", t.decl.name.render));
					return null;
				}
				var count: int;
				// read instance methods
				count = read_jawa_int();
				var instanceMethods = t.decl.instanceMethods = Array.new(count);
				for (i < count) instanceMethods[i] = read_jawa_method_decl();
			}
			_ => err(Strings.format1("invalid type opcode 0x%x", opcode));
		}
		return null;
	}
	def err(s: string) {
		error.abs(current_index).set(s);
	}

	def read_jawa_string() -> JawaString {
		// Jawa strings are a length (4-byte Jawa int), followed by {length} UTF-8 bytes
		// that encode a UTF-16 string.
		var length = read_jawa_int();
		if (!decoder.check_bytes(length)) return null;
		var chars = read_utf8_to_utf16(length);
		return if(chars != null, JawaString.new(chars));
	}
	def read_jawa_name() -> JawaString {
		// Jawa names are a length (2-byte Jawa int), followed by {length} UTF-8 bytes
		// that encode a UTF-16 string.
		var length = read_jawa_iN(2);
		if (!decoder.check_bytes(length)) return null;
		var chars = read_utf8_to_utf16(length);
		return if(chars != null, JawaString.new(chars));
	}
	def read_jawa_int() -> u28 {
		// Jawa ints are 4 little-endian 7-bit bytes for 28 bits total.
		// The upper bit of each byte must be 0 so that the int passes through UTF-8.
		return read_jawa_iN(4);
	}
	def read_jawa_iN(max: int) -> u28 {
		var result: u32, shift = 0;
		for (i < max) {
			if (decoder.pos >= decoder.limit) break;
			var b = decoder.data[decoder.pos++];
			if ((b & 0x80) != 0) {
				error.at(decoder).set("Jawa int byte should not have upper bit set");
				return 0;
			}
			result = result | (u32.!(b) << u5.!(shift));
			shift += 7;
		}
		return u28.view(result);
	}
	def read_utf8_to_utf16(length: int) -> Array<u16> {
		var chars = Array<u16>.new(length);
		// TODO: support more than 7-bit ascii
		for (i < chars.length) {
			var b = decoder.data[i + decoder.pos];
			if ((b & 0x80) != 0) {
				error.rel(decoder, decoder.pos + i).set("Jawa strings are currently limited to 7-bit ascii");
				return null;
			}
			chars[i] = b;
		}
		decoder.pos += length;
		return chars;
	}
	def read_jawa_interface() -> JawaInterfaceType {
		return read_jawa_type<JawaInterfaceType>("interface ref");
	}
	def read_jawa_class() -> JawaClassType {
		return read_jawa_type<JawaClassType>("class ref");
	}
	def read_jawa_array() -> JawaArrayType {
		return read_jawa_type<JawaArrayType>("array ref");
	}
	def read_jawa_ref_array() -> JawaArrayType {
		var at = read_jawa_type<JawaArrayType>("refarray ref");
		if (at == null) return null;
		match (at.elem) {
			et: JawaRefType => return at;
			_ => ;
		}
		err("expected reference array");
		return null;
	}
	def read_jawa_ref_type() -> JawaType {
		var t = read_jawa_exported_type("ref");
		match (t) {
			rt: JawaRefType => return t;
			_ => return null;
		}
	}
	def read_jawa_type<T>(kind: string) -> T {
		var ext = read_jawa_exported_type(kind);
		return if(T.?(ext), T.!(ext));
	}
	def read_any_jawa_type() -> JawaType; // TODO: devise encoding for primitive types
	def read_non_void_jawa_type() -> JawaType; // TODO: devise encoding for primitive types
	def read_jawa_exported_type(kind: string) -> JawaType {
		var i = read_jawa_int();
		var msg_render: StringBuilder -> StringBuilder;
		var type_index = int.view(i);
		if (type_index >= module.types.length) {
			msg_render = Strings.puts("out of bounds");
		} else match (module.types[type_index]) {
			Imported(t) => {
				var e = result[t.import_index];
				if (JawaType.?(e)) return JawaType.!(e); // success
				msg_render = if(e == null, Strings.puts("<null>"), e.render);
			}
			Function(f) => {
				msg_render = f.render;
			}
		}
		err(Strings.format3("expected jawa %s, got %q @ module.types[%d]", kind, msg_render, type_index));
		return null;
	}
	def read_jawa_field_decl() -> JawaField {
		var name = read_jawa_string();
		var typ = read_non_void_jawa_type();
		return JawaField.new(name, typ);
	}
	def read_jawa_method_decl() -> JawaMethod {
		var name = read_jawa_string();
		var count: int = read_jawa_int();
		var params = Array<JawaType>.new(count);
		for (i < count) {
			params[i] = read_non_void_jawa_type();
		}
		var ret = read_any_jawa_type();
		return JawaMethod.new(name, params, ret);
	}
}

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def Stubs: JawaHostStubs; // configurability for stub generation
// Processes a module's imports and supplies Jawa types, functions, and globals.
class JawaImportProcessor(error: ErrorGen, env: JawaEnvironment, module: Module, result: Array<Exportable>) {
	def decoder = Decoder.new([], error);
	def classDefs = Vector<JawaClass>.new();
	def interfaceDefs = Vector<JawaInterface>.new();
	var current_index = 0;
	def process() {
		var imports = module.imports;
		for (i < imports.length) {
			current_index = i;
			var imp = imports[i];
			if (!Strings.equals("jawa", imp.modname)) continue; // not Jawa
			if (result[i] != null) continue; // import already bound
			var exp: Exportable;
			match (imp.details) {
				Function(decl) => exp = processFunction(imp.name, decl);
				Global(decl) =>  exp = processGlobal(imp.name, decl);
				Type(decl) =>  exp = processType(imp.name, decl);
				_ => err(Strings.format1("invalid import of kind %s", imp.details.name));
			}
			if (exp == null) return;
			if (error.error()) return;
			result[i] = exp;
		}
	}
	def extractMainExport(instance: Instance) -> Function {
		var module = instance.module;
		var exports = module.exports;
		var found: Function;
		for (j < exports.length) {
			var e = module.exports[j];
			if (!ExportDetails.Function.?(e.details)) continue;
			found = Function.!(instance.exports[j]);
			if (Strings.equals("main", e.name)) return found;
		}
		return null;
	}
	def processFunction(name: string, decl: FunctionDecl) -> Exportable {
		if (name.length < 1) err("expected opcode for function import");
		decoder.reset(name, 1, name.length);
		var opcode = name[0];
		match (opcode) {
			JawaFuncOpcode.AALOAD.code => ;
			JawaFuncOpcode.AASTORE.code => ;
			JawaFuncOpcode.ACMPEQ.code => ;
			JawaFuncOpcode.ACMPNE.code => ;
			JawaFuncOpcode.ANEWARRAY.code => ;
			JawaFuncOpcode.ARRAYLENGTH.code => {
				var at = read_jawa_array().0;
				if (at == null) return null;
				return Stubs.ARRAYLENGTH(at);
			}
			JawaFuncOpcode.ATHROW.code => ;
			JawaFuncOpcode.BALOAD.code => return Stubs.ALOAD<byte>(JawaTypes.BYTE_ARRAY);
			JawaFuncOpcode.BASTORE.code => return Stubs.ASTORE<byte>(JawaTypes.BYTE_ARRAY);
			JawaFuncOpcode.CALOAD.code => return Stubs.ALOAD<u16>(JawaTypes.CHAR_ARRAY);
			JawaFuncOpcode.CASTORE.code => return Stubs.ASTORE<u16>(JawaTypes.CHAR_ARRAY);
			JawaFuncOpcode.CHECKCAST.code => ;
			JawaFuncOpcode.D2I.code => ;
			JawaFuncOpcode.D2L.code => ;
			JawaFuncOpcode.DALOAD.code => return Stubs.ALOAD<double>(JawaTypes.DOUBLE_ARRAY);
			JawaFuncOpcode.DASTORE.code => return Stubs.ASTORE<double>(JawaTypes.DOUBLE_ARRAY);
			JawaFuncOpcode.DCMPG.code => ;
			JawaFuncOpcode.DCMPL.code => ;
			JawaFuncOpcode.DREM.code => ;
			JawaFuncOpcode.F2I.code => ;
			JawaFuncOpcode.F2L.code => ;
			JawaFuncOpcode.FALOAD.code => return Stubs.ALOAD<float>(JawaTypes.FLOAT_ARRAY);
			JawaFuncOpcode.FASTORE.code => return Stubs.ASTORE<float>(JawaTypes.FLOAT_ARRAY);
			JawaFuncOpcode.FCMPG.code => ;
			JawaFuncOpcode.FCMPL.code => ;
			JawaFuncOpcode.FREM.code => ;
			JawaFuncOpcode.GETFIELD.code => ;
			JawaFuncOpcode.GETSTATIC.code => ;
			JawaFuncOpcode.IALOAD.code => return Stubs.ALOAD<int>(JawaTypes.INT_ARRAY);
			JawaFuncOpcode.IASTORE.code => return Stubs.ASTORE<int>(JawaTypes.INT_ARRAY);
			JawaFuncOpcode.INSTANCEOF.code => ;
			JawaFuncOpcode.INVOKEDYNAMIC.code => ;
			JawaFuncOpcode.INVOKEINTERFACE.code => ;
			JawaFuncOpcode.INVOKESPECIAL.code => ;
			JawaFuncOpcode.INVOKESTATIC.code => ;
			JawaFuncOpcode.INVOKEVIRTUAL.code => ;
			JawaFuncOpcode.LALOAD.code => return Stubs.ALOAD<long>(JawaTypes.LONG_ARRAY);
			JawaFuncOpcode.LASTORE.code => return Stubs.ASTORE<long>(JawaTypes.LONG_ARRAY);
			JawaFuncOpcode.MONITORENTER.code => ;
			JawaFuncOpcode.MONITOREXIT.code => ;
			JawaFuncOpcode.MULTIANEWARRAY.code => ;
			JawaFuncOpcode.NEW.code => ;
			JawaFuncOpcode.NEWARRAY.code => {
				var at = read_jawa_array().0;
				if (at == null) return null;
				return Stubs.NEWARRAY(at);
			}
			JawaFuncOpcode.NONNULL.code => ;
			JawaFuncOpcode.NULL.code => ;
			JawaFuncOpcode.PUTFIELD.code => ;
			JawaFuncOpcode.PUTSTATIC.code => ;
			JawaFuncOpcode.SALOAD.code => return Stubs.ALOAD<short>(JawaTypes.SHORT_ARRAY);
			JawaFuncOpcode.SASTORE.code => return Stubs.ASTORE<short>(JawaTypes.SHORT_ARRAY);
			_ => err(Strings.format1("invalid function opcode 0x%x", opcode));
		}
		return null;
	}
	def processGlobal(name: string, decl: GlobalDecl) -> Exportable {
		if (name.length < 1) err("import of empty global");
		var opcode = name[0];
		match (opcode) {
			JawaGlobalOpcode.STRING_CONST.code => {
				var str = read_jawa_string();
				if (str == null) return null;
				return env.internStringAsGlobal(str);
			}
			_ => err(Strings.format1("invalid global opcode 0x%x", opcode));
		}
		return null;
	}
	def processType(name: string, decl: DefType.Imported) -> Exportable {
		if (name.length < 1) {
			err("import of empty type");
			return null;
		}
		decoder.reset(name, 1, name.length);
		var opcode = name[0];
		match (opcode) {
			JawaTypeOpcode.BYTE_ARRAY.code => return JawaTypes.BYTE_ARRAY;
			JawaTypeOpcode.BOOL_ARRAY.code => return JawaTypes.BOOL_ARRAY;
			JawaTypeOpcode.CHAR_ARRAY.code => return JawaTypes.CHAR_ARRAY;
			JawaTypeOpcode.SHORT_ARRAY.code => return JawaTypes.SHORT_ARRAY;
			JawaTypeOpcode.INT_ARRAY.code => return JawaTypes.INT_ARRAY;
			JawaTypeOpcode.LONG_ARRAY.code => return JawaTypes.LONG_ARRAY;
			JawaTypeOpcode.FLOAT_ARRAY.code => return JawaTypes.FLOAT_ARRAY;
			JawaTypeOpcode.DOUBLE_ARRAY.code => return JawaTypes.DOUBLE_ARRAY;
			JawaTypeOpcode.EXT_CLASS.code => {
				var str = read_jawa_name();
				if (str == null) return null;
				var c = env.lookup(str);
				if (c == null) err(Strings.format1("class not found: %q", str.render));
				if (!JawaClass.?(c)) err(Strings.format1("not a class: %q", str.render));
				else return env.exportClass(JawaClass.!(c));
			}
			JawaTypeOpcode.EXT_INTERFACE.code => {
				var str = read_jawa_name();
				if (str == null) return null;
				var i = env.lookup(str);
				if (i == null) err(Strings.format1("interface not found: %q", str.render));
				if (!JawaInterface.?(i)) err(Strings.format1("not an interface: %q", str.render));
				else return env.exportInterface(JawaInterface.!(i));
			}
			JawaTypeOpcode.FW_CLASS_DECL.code => {
				var str = read_jawa_name();
				if (str == null) return null;
				var sup = read_jawa_class().1.decl;
				var count = read_jawa_int();
				var intfs = Array<JawaInterface>.new(count);
				for (i < count) {
					intfs[i] = read_jawa_interface().1.decl;
				}
				var cl = env.declareClass(str, sup, intfs);
				classDefs.put(cl);
				return env.exportClass(cl);
			}
			JawaTypeOpcode.FW_INTERFACE_DECL.code => {
				var str = read_jawa_name();
				if (str == null) return null;
				var count = read_jawa_int();
				var intfs = Array<JawaInterface>.new(count);
				for (i < count) {
					intfs[i] = read_jawa_interface().1.decl;
				}
				var cl = env.declareInterface(str, intfs);
				interfaceDefs.put(cl);
				return env.exportInterface(cl);
			}
			JawaTypeOpcode.REF_ARRAY.code => {
				var elem = read_jawa_ref_type();
				if (elem == JawaType.None) return null;
				return env.getArrayType(elem);
			}
			JawaTypeOpcode.DEF_CLASS.code => {
				var t = read_jawa_class(), decl = t.1.decl;
				if (t.0 == null) return null;
				if (decl.complete()) {
					err(Strings.format1("class %s already complete", decl.name.render));
					return null;
				}
				var count: int;
				// read instance fields
				count = read_jawa_int();
				var instanceFields = decl.instanceFields = Array.new(count);
				for (i < count) instanceFields[i] = read_jawa_field_decl();
				// read instance methods
				count = read_jawa_int();
				var instanceMethods = decl.instanceMethods = Array.new(count);
				for (i < count) instanceMethods[i] = read_jawa_method_decl();
				// read static fields
				count = read_jawa_int();
				var staticFields = decl.staticFields = Array.new(count);
				for (i < count) staticFields[i] = read_jawa_field_decl();
				// read static methods
				count = read_jawa_int();
				var staticMethods = decl.staticMethods = Array.new(count);
				for (i < count) staticMethods[i] = read_jawa_method_decl();
			}
			JawaTypeOpcode.DEF_INTERFACE.code => {
				var t = read_jawa_interface(), decl = t.1.decl;
				if (t.0 == null) return null;
				if (decl.complete()) {
					err(Strings.format1("class %s already complete", decl.name.render));
					return null;
				}
				var count: int;
				// read instance methods
				count = read_jawa_int();
				var instanceMethods = decl.instanceMethods = Array.new(count);
				for (i < count) instanceMethods[i] = read_jawa_method_decl();
			}
			_ => err(Strings.format1("invalid type opcode 0x%x", opcode));
		}
		return null;
	}
	def err(s: string) {
		error.abs(current_index).set(s);
	}

	def read_jawa_string() -> JawaString {
		// Jawa strings are a length (4-byte Jawa int), followed by {length} UTF-8 bytes
		// that encode a UTF-16 string.
		var length = read_jawa_int();
		if (!decoder.check_bytes(length)) return null;
		var chars = read_utf8_to_utf16(length);
		return if(chars != null, JawaString.new(chars));
	}
	def read_jawa_name() -> JawaString {
		// Jawa names are a length (2-byte Jawa int), followed by {length} UTF-8 bytes
		// that encode a UTF-16 string.
		var length = read_jawa_iN(2);
		if (!decoder.check_bytes(length)) return null;
		var chars = read_utf8_to_utf16(length);
		return if(chars != null, JawaString.new(chars));
	}
	def read_jawa_int() -> u28 {
		// Jawa ints are 4 little-endian 7-bit bytes for 28 bits total.
		// The upper bit of each byte must be 0 so that the int passes through UTF-8.
		return read_jawa_iN(4);
	}
	def read_jawa_iN(max: int) -> u28 {
		var result: u32, shift = 0;
		for (i < max) {
			if (decoder.pos >= decoder.limit) break;
			var b = decoder.data[decoder.pos++];
			if ((b & 0x80) != 0) {
				error.at(decoder).set("Jawa int byte should not have upper bit set");
				return 0;
			}
			result = result | (u32.!(b) << u5.!(shift));
			shift += 7;
		}
		return u28.view(result);
	}
	def read_utf8_to_utf16(length: int) -> Array<u16> {
		var chars = Array<u16>.new(length);
		// TODO: support more than 7-bit ascii
		for (i < chars.length) {
			var b = decoder.data[i + decoder.pos];
			if ((b & 0x80) != 0) {
				error.rel(decoder, decoder.pos + i).set("Jawa strings are currently limited to 7-bit ascii");
				return null;
			}
			chars[i] = b;
		}
		decoder.pos += length;
		return chars;
	}
	def read_jawa_interface() -> (JawaExportedType, JawaType.Interface) {
		return read_jawa_type<JawaType.Interface>("interface ref");
	}
	def read_jawa_class() -> (JawaExportedType, JawaType.Class) {
		return read_jawa_type<JawaType.Class>("class ref");
	}
	def read_jawa_array() -> (JawaExportedType, JawaType.Array) {
		return read_jawa_type<JawaType.Array>("array ref");
	}
	def read_jawa_ref_type() -> JawaType {
		var t = read_jawa_exported_type("ref");
		if (t == null) return JawaType.None;
		match (t.host.t) {
			Class, Interface, Array => return t.host.t;
			_ => return JawaType.None;
		}
	}
	def read_jawa_type<T>(kind: string) -> (JawaExportedType, T) {
		var d: T, ext = read_jawa_exported_type(kind);
		if (ext == null) return (null, d);
		var jwt = ext.host;
		if (T.?(jwt.t)) return (ext, T.!(jwt.t));
		return (null, d);
	}
	def read_any_jawa_type() -> (JawaExportedType, JawaType); // TODO: devise encoding for primitive types
	def read_non_void_jawa_type() -> (JawaExportedType, JawaType); // TODO: devise encoding for primitive types
	def read_jawa_exported_type(kind: string) -> JawaExportedType {
		var i = read_jawa_int();
		if (i >= module.types.size()) {
			err("type index out of bounds");
			return null;
		}
		match (module.types[int.view(i)]) {
			Imported(t) => {
				var e = result[t.import_index];
				if (e == null) {
					err(Strings.format1("expected %s type, got <null>", kind));
					return null;
				}
				if (!JawaExportedType.?(e)) {
					err("expected jawa type");
					return null;
				}
				return JawaExportedType.!(e);
			}
			Function(f) => {
				err(Strings.format2("expected %s type, got %q", kind, f.render));
				return null;
			}
		}
	}
	def read_jawa_field_decl() -> JawaField {
		var name = read_jawa_string();
		var typ = read_non_void_jawa_type().1;
		return JawaField.new(name, typ);
	}
	def read_jawa_method_decl() -> JawaMethod {
		var name = read_jawa_string();
		var count: int = read_jawa_int();
		var params = Array<JawaType>.new(count);
		for (i < count) {
			params[i] = read_non_void_jawa_type().1;
		}
		var ret = read_any_jawa_type().1;
		return JawaMethod.new(name, params, ret);
	}
}

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def Stubs: JawaHostStubs; // configurability for stub generation

// Processes a module's imports and supplies Jawa types, functions, and globals.
class JawaImportProcessor(error: ErrorGen, env: JawaEnvironment, module: Module, result: Array<Exportable>) {
	def decoder = Decoder.new([], error);
	def classDefs = Vector<JawaClassType>.new();
	def interfaceDefs = Vector<JawaInterfaceType>.new();
	def trace = if(Trace.jawa, StringBuilder.new());
	var current_index = 0;

	// Main processing loop to decode and resolve imports.
	def process() {
		var imports = module.imports;
		for (i < imports.length) {
			current_index = i;
			var imp = imports[i];
			if (!Strings.equals("jawa", imp.modname)) continue; // not Jawa
			if (trace != null) traceImport(imp);
			if (result[i] != null) continue; // import already bound
			var exp: Exportable;
			match (imp.details) {
				Function(decl) => exp = processFunction(imp.name, decl);
				Global(decl) =>  exp = processGlobal(imp.name, decl);
				Type(decl) =>  exp = processType(imp.name, decl);
				_ => err1("invalid import of kind %s", imp.details.name);
			}
			if (exp == null) return;
			if (error.error()) return;
			result[i] = exp;
		}
	}
	def extractMainExport(instance: Instance) -> Function {
		var module = instance.module;
		var exports = module.exports;
		var found: Function;
		for (j < exports.length) {
			var e = module.exports[j];
			if (!ExportDetails.Function.?(e.details)) continue;
			found = Function.!(instance.exports[j]);
			if (Strings.equals("main", e.name)) return found;
		}
		return null;
	}
	def processFunction(name: string, decl: FunctionDecl) -> Exportable {
		if (name.length < 1) return err("expected opcode for function import");
		decoder.reset(name, 1, name.length - 1);
		var opcode = name[0];
		match (opcode) {
			JawaFuncOpcode.AALOAD.code => {
				var at = read_ref_array();
				if (at == null) return null;
				return Stubs.AALOAD(at);
			}
			JawaFuncOpcode.AASTORE.code => {
				var at = read_ref_array();
				if (at == null) return null;
				return Stubs.AASTORE(at);
			}
			JawaFuncOpcode.ACMPEQ.code => {
				return Stubs.ACMPEQ;
			}
			JawaFuncOpcode.ANEWARRAY.code => {
				var at = read_ref_array();
				if (at == null) return null;
				return Stubs.ANEWARRAY(at);
			}
			JawaFuncOpcode.ARRAYLENGTH.code => {
				var at = read_array();
				if (at == null) return null;
				return Stubs.ARRAYLENGTH(at);
			}
			JawaFuncOpcode.ATHROW.code => return TODO();
			JawaFuncOpcode.BALOAD.code => return Stubs.ALOAD<i8>(JawaTypes.BYTE_ARRAY_PAIR);
			JawaFuncOpcode.BASTORE.code => return Stubs.ASTORE<i8>(JawaTypes.BYTE_ARRAY_PAIR);
			JawaFuncOpcode.CALOAD.code => return Stubs.ALOAD<u16>(JawaTypes.CHAR_ARRAY_PAIR);
			JawaFuncOpcode.CASTORE.code => return Stubs.ASTORE<u16>(JawaTypes.CHAR_ARRAY_PAIR);
			JawaFuncOpcode.CHECKCAST.code => {
				var tt = read_ref_type();
				if (tt == null) return null;
				return TODO();
			}
			JawaFuncOpcode.DALOAD.code => return Stubs.ALOAD<double>(JawaTypes.DOUBLE_ARRAY_PAIR);
			JawaFuncOpcode.DASTORE.code => return Stubs.ASTORE<double>(JawaTypes.DOUBLE_ARRAY_PAIR);
			JawaFuncOpcode.DCMPG.code => return Stubs.DCMPG;
			JawaFuncOpcode.DCMPL.code => return Stubs.DCMPL;
			JawaFuncOpcode.DREM.code => return TODO();
			JawaFuncOpcode.FALOAD.code => return Stubs.ALOAD<float>(JawaTypes.FLOAT_ARRAY_PAIR);
			JawaFuncOpcode.FASTORE.code => return Stubs.ASTORE<float>(JawaTypes.FLOAT_ARRAY_PAIR);
			JawaFuncOpcode.FCMPG.code => return Stubs.FCMPG;
			JawaFuncOpcode.FCMPL.code => return Stubs.FCMPL;
			JawaFuncOpcode.FREM.code => return TODO();
			JawaFuncOpcode.GETFIELD.code => {
				var t = read_class_field_selector(JawaClassType.instanceFields);
				var ct = t.0, f = t.1;
				if (f != null) return Stubs.GETFIELD(ct, f);
			}
			JawaFuncOpcode.GETSTATIC.code => {
				var t = read_class_field_selector(JawaClassType.staticFields);
				var ct = t.0, f = t.1;
				if (f != null) return Stubs.GETSTATIC(ct, f);
			}
			JawaFuncOpcode.IALOAD.code => return Stubs.ALOAD<int>(JawaTypes.INT_ARRAY_PAIR);
			JawaFuncOpcode.IASTORE.code => return Stubs.ASTORE<int>(JawaTypes.INT_ARRAY_PAIR);
			JawaFuncOpcode.INSTANCEOF.code => {
				var tt = read_ref_type();
				if (tt == null) return null;
				return TODO();
			}
			JawaFuncOpcode.INVOKEDYNAMIC.code => {
				return TODO();
			}
			JawaFuncOpcode.INVOKEINTERFACE.code => {
				return TODO();
			}
			JawaFuncOpcode.INVOKESPECIAL.code => {
				var t = read_class_method_selector(JawaClassType.instanceMethods);
				var ct = t.0, m = t.1;
				return TODO();
			}
			JawaFuncOpcode.INVOKESTATIC.code => {
				var t = read_class_method_selector(JawaClassType.staticMethods);
				var ct = t.0, m = t.1;
				return TODO();
			}
			JawaFuncOpcode.INVOKEVIRTUAL.code => {
				var t = read_class_method_selector(JawaClassType.instanceMethods);
				var ct = t.0, m = t.1;
				return TODO();
			}
			JawaFuncOpcode.LALOAD.code => return Stubs.ALOAD<long>(JawaTypes.LONG_ARRAY_PAIR);
			JawaFuncOpcode.LASTORE.code => return Stubs.ASTORE<long>(JawaTypes.LONG_ARRAY_PAIR);
			JawaFuncOpcode.MONITORENTER.code => return TODO();
			JawaFuncOpcode.MONITOREXIT.code => return TODO();
			JawaFuncOpcode.MULTIANEWARRAY.code => {
				var dims = read_ji4();
				var rtype = read_array();
				if (rtype == null) return null;
				var rank = rtype.rank();
				if (rank < dims) return err(Strings.format2("expected maximum %d dimensions, got %d", rank, int.!(dims)));
				return Stubs.MULTIANEWARRAY(dims, rtype);
			}
			JawaFuncOpcode.NEW.code => {
				var t = read_defined_class();
				if (t == null) return null;
				return Stubs.NEW(t);
			}
			JawaFuncOpcode.NEWARRAY.code => {
				var at = read_array();
				if (at == null) return null;
				return Stubs.NEWARRAY(at);
			}
			JawaFuncOpcode.ISNULL.code => {
				return Stubs.ISNULL;
			}
			JawaFuncOpcode.PUTFIELD.code => {
				var t = read_class_field_selector(JawaClassType.instanceFields);
				var ct = t.0, f = t.1;
				if (f != null) return Stubs.PUTFIELD(ct, f);
			}
			JawaFuncOpcode.PUTSTATIC.code => {
				var t = read_class_field_selector(JawaClassType.staticFields);
				var ct = t.0, f = t.1;
				if (f != null) return Stubs.PUTSTATIC(ct, f);
			}
			JawaFuncOpcode.SALOAD.code => return Stubs.ALOAD<short>(JawaTypes.SHORT_ARRAY_PAIR);
			JawaFuncOpcode.SASTORE.code => return Stubs.ASTORE<short>(JawaTypes.SHORT_ARRAY_PAIR);
			_ => err1("invalid function opcode 0x%x", opcode);
		}
		return null;
	}
	def processGlobal(name: string, decl: GlobalDecl) -> Exportable {
		if (name.length < 1) return err("import of empty global");
		decoder.reset(name, 1, name.length - 1);
		var opcode = name[0];
		match (opcode) {
			JawaGlobalOpcode.CLASS_CONST.code => {
				var ct = read_class();
				return TODO();
			}
			JawaGlobalOpcode.INTERFACE_CONST.code => {
				var it = read_interface();
				return TODO();
			}
			JawaGlobalOpcode.STRING_CONST.code => {
				var str = read_string();
				if (str == null) return null;
				return env.internStringAsGlobal(str);
			}
			_ => err1("invalid global opcode 0x%x", opcode);
		}
		return null;
	}
	def processType(name: string, decl: DefType.Imported) -> Exportable {
		if (name.length < 1) return err("import of empty type");
		decoder.reset(name, 1, name.length - 1);
		var opcode = name[0];
		match (opcode) {
			JawaTypeOpcode.BYTE_ARRAY.code => return JawaTypes.BYTE_ARRAY;
			JawaTypeOpcode.BOOL_ARRAY.code => return JawaTypes.BOOL_ARRAY;
			JawaTypeOpcode.CHAR_ARRAY.code => return JawaTypes.CHAR_ARRAY;
			JawaTypeOpcode.SHORT_ARRAY.code => return JawaTypes.SHORT_ARRAY;
			JawaTypeOpcode.INT_ARRAY.code => return JawaTypes.INT_ARRAY;
			JawaTypeOpcode.LONG_ARRAY.code => return JawaTypes.LONG_ARRAY;
			JawaTypeOpcode.FLOAT_ARRAY.code => return JawaTypes.FLOAT_ARRAY;
			JawaTypeOpcode.DOUBLE_ARRAY.code => return JawaTypes.DOUBLE_ARRAY;
			JawaTypeOpcode.EXT_CLASS.code => {
				var str = read_name();
				if (str == null) return null;
				var c = env.lookup(str);
				if (c == null) return err1("class not found: %q", str.render);
				if (!JawaClassType.?(c)) return err1("not a class: %q", str.render);
				return c;
			}
			JawaTypeOpcode.EXT_INTERFACE.code => {
				var str = read_name();
				if (str == null) return null;
				var i = env.lookup(str);
				if (i == null) return err1("interface not found: %q", str.render);
				if (!JawaInterfaceType.?(i)) return err1("not an interface: %q", str.render);
				return i;
			}
			JawaTypeOpcode.DECL_CLASS.code => {
				var str = read_name();
				if (str == null) return null;
				var sup = read_class();
				if (sup == null) return null;
				var count = read_ji4();
				var intfs = Array<JawaInterfaceType>.new(count);
				for (i < count) {
					var intf = read_interface();
					if (intf == null) return null;
					intfs[i] = intf;
				}
				var cl = env.declareClass(str, sup, intfs);
				classDefs.put(cl);
				return cl;
			}
			JawaTypeOpcode.DECL_INTERFACE.code => {
				var str = read_name();
				if (str == null) return null;
				var count = read_ji4();
				var intfs = Array<JawaInterfaceType>.new(count);
				for (i < count) {
					var intf = read_interface();
					if (intf == null) return null;
					intfs[i] = intf;
				}
				var cl = env.declareInterface(str, intfs);
				interfaceDefs.put(cl);
				return cl;
			}
			JawaTypeOpcode.REF_ARRAY.code => {
				var elem = read_ref_type();
				if (elem == null) return null;
				return env.getArrayType(elem);
			}
			JawaTypeOpcode.DEF_CLASS.code => {
				var t = read_class();
				if (t == null) return null;
				if (t.defined()) return err1("class %s already defined", t.name.render);
				var count: int;
				// read instance fields
				count = read_ji4();
				var instanceFields = t.instanceFields = Array.new(count);
				for (i < count) instanceFields[i] = read_field_decl(i);
				t.boilerplate = Arrays.map(instanceFields, JawaField.defaultValue);
				// read instance methods
				count = read_ji4();
				var instanceMethods = t.instanceMethods = Array.new(count);
				for (i < count) instanceMethods[i] = read_method_def();
				// read static fields
				count = read_ji4();
				var staticFields = t.staticFields = Array.new(count);
				for (i < count) staticFields[i] = read_field_decl(i);
				// read static methods
				count = read_ji4();
				var staticMethods = t.staticMethods = Array.new(count);
				for (i < count) staticMethods[i] = read_method_def();
				return t;
			}
			JawaTypeOpcode.DEF_INTERFACE.code => {
				var t = read_interface();
				if (t == null) return null;
				if (t.defined()) return err1("interface %s already defined", t.name.render);
				var count: int;
				// read instance methods
				count = read_ji4();
				var instanceMethods = t.instanceMethods = Array.new(count);
				for (i < count) instanceMethods[i] = read_method_decl();
				return t;
			}
			_ => err1("invalid type opcode 0x%x", opcode);
		}
		return null;
	}
	def read_class_field_selector(fields: JawaClassType -> Array<JawaField>) -> (JawaClassType, JawaField) {
		var t = read_defined_class();
		if (t == null) return (null, null);
		var name = read_name();
		if (name == null) return (null, null);
		for (f in fields(t)) {
			if (name.equals(f.name)) return (t, f);
		}
		err(Strings.format2("class field %q.%q not found", t.render, name.render));
		return (null, null);
	}
	def read_class_method_selector(methods: JawaClassType -> Array<JawaMethod>) -> (JawaClassType, JawaMethod) {
		var t = read_defined_class();
		if (t == null) return (null, null);
		var name = read_name();
		if (name == null) return (null, null);
		for (m in methods(t)) {
			if (name.equals(m.name)) return (t, m);
		}
		err(Strings.format2("class method %q.%q not found", t.render, name.render));
		return (null, null);
	}


	def read_string() -> JawaString {
		// Jawa strings are a length (4-byte Jawa int), followed by {length} UTF-8 bytes
		// that encode a UTF-16 string.
		var length = read_ji4();
		if (!decoder.check_bytes(length)) return null;
		var chars = read_utf8_to_utf16(length);
		return if(chars != null, JawaString.new(chars));
	}
	def read_name() -> JawaString {
		// Jawa names are a length (2-byte Jawa int), followed by {length} UTF-8 bytes
		// that encode a UTF-16 string.
		var length = read_ji2();
		if (!decoder.check_bytes(length)) return null;
		var chars = read_utf8_to_utf16(length);
		return if(chars != null, JawaString.new(chars));
	}
	def read_ji4() -> u28 {
		// Jawa ints are 4 little-endian 7-bit bytes for 28 bits total.
		// The upper bit of each byte must be 0 so that the int passes through UTF-8.
		return read_jiN(4);
	}
	def read_ji2() -> u28 {
		return read_jiN(2);
	}
	def read_jiN(max: int) -> u28 {
		var result: u32, shift = 0;
		for (i < max) {
			var b = decoder.read_u8();
			if ((b & 0x80) != 0) {
				error.at(decoder).set("Jawa int byte should not have upper bit set");
				return 0;
			}
			result = result | (u32.!(b) << u5.!(shift));
			shift += 7;
			if (decoder.pos >= decoder.limit) break; // truncated int of at least 1 byte
		}
		return u28.view(result);
	}
	def read_utf8_to_utf16(length: int) -> Array<u16> {
		var chars = Array<u16>.new(length);
		// TODO: support more than 7-bit ascii
		for (i < chars.length) {
			var b = decoder.data[i + decoder.pos];
			if ((b & 0x80) != 0) {
				error.rel(decoder, decoder.pos + i).set("Jawa strings are currently limited to 7-bit ascii");
				return null;
			}
			chars[i] = b;
		}
		decoder.pos += length;
		return chars;
	}
	def read_interface() -> JawaInterfaceType {
		return read_type<JawaInterfaceType>("interface");
	}
	def read_class() -> JawaClassType {
		return read_type<JawaClassType>("class");
	}
	def read_defined_class() -> JawaClassType {
		var t = read_class();
		if (t == null) return null;
		if (t.defined()) return t;
		err1("class %q not defined", t.render);
		return null;
	}
	def read_array() -> JawaArrayType {
		return read_type<JawaArrayType>("array");
	}
	def read_ref_array() -> JawaArrayType {
		var at = read_type<JawaArrayType>("refarray");
		if (at == null) return null;
		if (JawaRefType.?(at.elem)) return at;
		type_err("refarray", at, -1);
		return null;
	}
	def read_ref_type() -> JawaType {
		return read_type<JawaRefType>("ref");
	}
	def read_type<T>(kind: string) -> T {
		var t = read_jtref(kind);
		if (T.?(t)) return T.!(t);
		type_err(kind, t, -1);
		var d: T;
		return d;
	}
	def read_return_type() -> JawaType {
		return read_jtref("return");
	}
	def read_nonvoid_type() -> JawaType {
		var t = read_jtref("field");
		if (t == null) return null;
		if (t.kind != JawaKind.VOID) return t;
		err1("expected non-void type, got %q", t.render);
		return null;
	}
	def read_jtref(kind: string) -> JawaType {
		if (decoder.peek_u8() == Utf8.TWO_BYTE_MASK) {
			var discarded = decoder.read_u8();
			var b = decoder.read_u8();
			match (b) {
				'V' => return JawaTypes.VOID;
				'B' => return JawaTypes.BYTE;
				'Z' => return JawaTypes.BOOL;
				'C' => return JawaTypes.CHAR;
				'S' => return JawaTypes.SHORT;
				'I' => return JawaTypes.INT;
				'J' => return JawaTypes.LONG;
				'F' => return JawaTypes.FLOAT;
				'D' => return JawaTypes.DOUBLE;
				_ => err("invalid primitive type code");
			}
		}
		var i = read_ji4();
		var msg_render: StringBuilder -> StringBuilder;
		var type_index = int.view(i);
		if (type_index >= module.types.length) {
			msg_render = Strings.puts("out of bounds");
		} else match (module.types[type_index]) {
			Imported(t) => {
				var e = result[t.import_index];
				if (JawaType.?(e)) return JawaType.!(e); // success
				msg_render = if(e == null, Strings.puts("<null>"), e.render);
			}
			Function(f) => {
				msg_render = f.render;
			}
		}
		err(Strings.format3("expected jawa %s type, got %q @ module.types[%d]", kind, msg_render, type_index));
		return null;
	}
	def read_field_decl(i: int) -> JawaField {
		var name = read_name();
		var typ = read_nonvoid_type();
		return JawaField.new(name, i, typ);
	}
	def read_method_def() -> JawaMethod {
		var decl = read_method_decl();
		// TODO: read reference to function defining method's body
		return decl;
	}
	def read_method_decl() -> JawaMethod {
		var name = read_name();
		var count: int = read_ji2();
		if (count > MAX_JAWA_PARAM_COUNT) {
			err("exceeded maximum parameter count");
			return null;
		}
		var params = Array<JawaType>.new(count);
		for (i < count) params[i] = read_nonvoid_type();

		var ret = read_return_type();
		return JawaMethod.new(name, params, ret);
	}

	// Tracing and error handling helpers
	def traceImport(imp: ImportDecl) {
		trace.put2("jawa import %s #%d:", imp.details.name, current_index);
		var n = imp.name;
		if (n.length > 0) {
			var b = n[0], opname = JawaOpcodes.names[b];
			if (opname == null) opname = "invalid";
			trace.put2(" %x (%s)", b, opname);
		}
		for (i = 1; i < n.length; i++) trace.put1(" %x", n[i]);
		trace.ln();
		trace.out(Trace.STDOUT);
		trace.reset();
	}
	def TODO() -> Exportable {
		return err("unimplemented");
	}
	def err(s: string) -> Exportable {
		error.abs(current_index).set(s);
		return null;
	}
	def err1<T>(s: string, p: T) -> Exportable {
		error.abs(current_index).set(Strings.format1(s, p));
		return null;
	}
	def type_err(kind: string, got: JawaType, type_index: int) {
		var msg_render = if(got == null, Strings.puts("<null>"), got.render);
		if (type_index >= 0) {
			err(Strings.format3("expected jawa %s type, got %q @ module.types[%d]", kind, msg_render, type_index));
		} else {
			err(Strings.format2("expected jawa %s type, got %q", kind, msg_render));
		}
	}
}

def MAX_JAWA_PARAM_COUNT = 256;

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def Stubs: JawaHostStubs; // configurability for stub generation
def EMPTY: Array<byte> = [];

// Processes a module's imports and supplies Jawa types, functions, and globals.
class JawaImportProcessor(env: JawaEnvironment, error: ErrorGen) extends ImportProcessor("jawa") {
	def decoder = Decoder.new(EMPTY, error);
	def classDefs = Vector<JawaClassType>.new();
	def interfaceDefs = Vector<JawaInterfaceType>.new();
	def trace = if(Trace.jawa, TraceBuilder.new());
	var import_args: Array<Exportable>;
	var import_arg_index: int;
	var import_pos = -1;

	def extractMainExport(instance: Instance) -> Function {
		var module = instance.module;
		var exports = module.exports;
		var found: Function;
		for (j < exports.length) {
			var mex = module.exports[j];
			var iex = instance.exports[j];
			if (Strings.equals("main", mex.0) && Function.?(iex)) return Function.!(iex);
		}
		return null;
	}
	def processCommand(name: string, args: Array<Exportable>) -> Exportable {
		setImportArgs(name, args);
		if (name.length < 1) return err("empty command");
		decoder.reset(name, 1, name.length - 1);
		var opcode = name[0];
		match (opcode) {
			JawaCommandOpcode.DEF_CLASS.code => {
				var t = read_class();
				if (t == null) return null;
				if (t.defined()) return err1("class %q already defined", t.name.render);

				var count: int;
				// read instance fields
				count = read_ji4();
				var instanceFields = Array<JawaField>.new(count);
				for (i < count) {
					instanceFields[i] = read_field_decl(i);
					if (error.error()) return null;
				}
				// read instance methods
				count = read_ji4();
				var instanceMethods = Array<JawaMethod>.new(count);
				for (i < count) {
					instanceMethods[i] = read_method_def(i, t);
					if (error.error()) return null;
				}
				// read static fields
				count = read_ji4();
				var staticFields = Array<JawaField>.new(count);
				for (i < count) {
					staticFields[i] = read_field_decl(i);
					if (error.error()) return null;
				}
				// read static methods
				count = read_ji4();
				var staticMethods = Array<JawaMethod>.new(count);
				for (i < count) {
					staticMethods[i] = read_method_def(i, null);
					if (error.error()) return null;
				}
				if (error.error()) return null;

				// Only build the class if there are no errors
				t.instanceFields = instanceFields;
				t.boilerplate = Arrays.map(instanceFields, JawaField.defaultValue);
				t.instanceMethods = instanceMethods;
				t.staticFields = staticFields;
				t.staticMethods = staticMethods;
				t.buildTables(error);
			}
			JawaCommandOpcode.DEF_INTERFACE.code => {
				var t = read_interface();
				if (t == null) return null;
				if (t.defined()) return err1("interface %q already defined", t.name.render);
				var count: int;
				// read instance methods
				count = read_ji4();
				var instanceMethods = t.instanceMethods = Array.new(count);
				for (i < count) {
					instanceMethods[i] = read_method_decl(i);
					if (error.error()) return null;
				}
			}
		}
		return null;
	}
	def processFunction(name: string, args: Array<Exportable>, decl: FuncDecl) -> Exportable {
		setImportArgs(name, args);
		if (name.length < 1) return err("expected opcode for function import");
		decoder.reset(name, 1, name.length - 1);
		var opcode = name[0];
		match (opcode) {
			JawaFuncOpcode.AALOAD.code => {
				var at = read_ref_array();
				if (at == null) return null;
				return Stubs.AALOAD(at);
			}
			JawaFuncOpcode.AASTORE.code => {
				var at = read_ref_array();
				if (at == null) return null;
				return Stubs.AASTORE(at);
			}
			JawaFuncOpcode.ACMPEQ.code => {
				return Stubs.ACMPEQ;
			}
			JawaFuncOpcode.ANEWARRAY.code => {
				var at = read_ref_array();
				if (at == null) return null;
				return Stubs.ANEWARRAY(at);
			}
			JawaFuncOpcode.ARRAYLENGTH.code => {
				var at = read_array();
				if (at == null) return null;
				return Stubs.ARRAYLENGTH(at);
			}
			JawaFuncOpcode.ATHROW.code => return TODO();
			JawaFuncOpcode.BALOAD.code => return Stubs.ALOAD<i8>(JawaTypes.BYTE_ARRAY_PAIR);
			JawaFuncOpcode.BASTORE.code => return Stubs.ASTORE<i8>(JawaTypes.BYTE_ARRAY_PAIR);
			JawaFuncOpcode.CALOAD.code => return Stubs.ALOAD<u16>(JawaTypes.CHAR_ARRAY_PAIR);
			JawaFuncOpcode.CASTORE.code => return Stubs.ASTORE<u16>(JawaTypes.CHAR_ARRAY_PAIR);
			JawaFuncOpcode.CHECKCAST.code => {
				var t = read_ref_type();
				if (t == null) return null;
				return Stubs.CHECKCAST(t);
			}
			JawaFuncOpcode.DALOAD.code => return Stubs.ALOAD<double>(JawaTypes.DOUBLE_ARRAY_PAIR);
			JawaFuncOpcode.DASTORE.code => return Stubs.ASTORE<double>(JawaTypes.DOUBLE_ARRAY_PAIR);
			JawaFuncOpcode.DCMPG.code => return Stubs.DCMPG;
			JawaFuncOpcode.DCMPL.code => return Stubs.DCMPL;
			JawaFuncOpcode.DREM.code => return Stubs.DREM;
			JawaFuncOpcode.FALOAD.code => return Stubs.ALOAD<float>(JawaTypes.FLOAT_ARRAY_PAIR);
			JawaFuncOpcode.FASTORE.code => return Stubs.ASTORE<float>(JawaTypes.FLOAT_ARRAY_PAIR);
			JawaFuncOpcode.FCMPG.code => return Stubs.FCMPG;
			JawaFuncOpcode.FCMPL.code => return Stubs.FCMPL;
			JawaFuncOpcode.FREM.code => return Stubs.FREM;
			JawaFuncOpcode.GETFIELD.code => {
				var t = read_class_field_selector(JawaClassType.instanceFields);
				var ct = t.0, f = t.1;
				if (f != null) return Stubs.GETFIELD(ct, f);
			}
			JawaFuncOpcode.GETSTATIC.code => {
				var t = read_class_field_selector(JawaClassType.staticFields);
				var ct = t.0, f = t.1;
				if (f != null) return Stubs.GETSTATIC(ct, f);
			}
			JawaFuncOpcode.IALOAD.code => return Stubs.ALOAD<int>(JawaTypes.INT_ARRAY_PAIR);
			JawaFuncOpcode.IASTORE.code => return Stubs.ASTORE<int>(JawaTypes.INT_ARRAY_PAIR);
			JawaFuncOpcode.INSTANCEOF.code => {
				var t = read_ref_type();
				if (t == null) return null;
				return Stubs.INSTANCEOF(t);
			}
			JawaFuncOpcode.INVOKEDYNAMIC.code => {
				return TODO();
			}
			JawaFuncOpcode.INVOKEINTERFACE.code => {
				var t = read_interface_method_selector();
				var ct = t.0, m = t.1;
				if (t.1 == null) return null;
				return Stubs.INVOKEINTERFACE(t);
			}
			JawaFuncOpcode.INVOKESPECIAL.code => {
				var t = read_class_method_selector(JawaClassType.instanceMethods);
				var ct = t.0, m = t.1;
				if (t.1 == null) return null;
				return Stubs.INVOKESPECIAL(t);
			}
			JawaFuncOpcode.INVOKESTATIC.code => {
				var t = read_class_method_selector(JawaClassType.staticMethods);
				var ct = t.0, m = t.1;
				if (t.1 == null) return null;
				return Stubs.INVOKESTATIC(t);
			}
			JawaFuncOpcode.INVOKEVIRTUAL.code => {
				var t = read_class_method_selector(JawaClassType.instanceMethods);
				var ct = t.0, m = t.1;
				if (t.1 == null) return null;
				return Stubs.INVOKEVIRTUAL(t);
			}
			JawaFuncOpcode.LALOAD.code => return Stubs.ALOAD<long>(JawaTypes.LONG_ARRAY_PAIR);
			JawaFuncOpcode.LASTORE.code => return Stubs.ASTORE<long>(JawaTypes.LONG_ARRAY_PAIR);
			JawaFuncOpcode.MONITORENTER.code => return Stubs.MONITORENTER;
			JawaFuncOpcode.MONITOREXIT.code => return Stubs.MONITOREXIT;
			JawaFuncOpcode.MULTIANEWARRAY.code => {
				var dims = read_ji4();
				var rtype = read_array();
				if (rtype == null) return null;
				var rank = rtype.rank();
				if (rank < dims) return err(Strings.format2("expected maximum %d dimensions, got %d", rank, int.!(dims)));
				return Stubs.MULTIANEWARRAY(dims, rtype);
			}
			JawaFuncOpcode.NEW.code => {
				var t = read_defined_class();
				if (t == null) return null;
				return Stubs.NEW(t);
			}
			JawaFuncOpcode.NEWARRAY.code => {
				var at = read_array();
				if (at == null) return null;
				return Stubs.NEWARRAY(at);
			}
			JawaFuncOpcode.ISNULL.code => {
				return Stubs.ISNULL;
			}
			JawaFuncOpcode.PUTFIELD.code => {
				var t = read_class_field_selector(JawaClassType.instanceFields);
				var ct = t.0, f = t.1;
				if (f != null) return Stubs.PUTFIELD(ct, f);
			}
			JawaFuncOpcode.PUTSTATIC.code => {
				var t = read_class_field_selector(JawaClassType.staticFields);
				var ct = t.0, f = t.1;
				if (f != null) return Stubs.PUTSTATIC(ct, f);
			}
			JawaFuncOpcode.SALOAD.code => return Stubs.ALOAD<short>(JawaTypes.SHORT_ARRAY_PAIR);
			JawaFuncOpcode.SASTORE.code => return Stubs.ASTORE<short>(JawaTypes.SHORT_ARRAY_PAIR);
			JawaFuncOpcode.SYSCALL.code => {
				var str = read_name();
				if (str == null) return null;
				var f = JawaSysFuncs.lookup(str);
				if (f == null) return err1("unknown syscall %q", str.render);
				return f;
			}
			_ => err1("invalid function opcode 0x%x", opcode);
		}
		return null;
	}
	def processGlobal(name: string, args: Array<Exportable>, decl: GlobalDecl) -> Exportable {
		setImportArgs(name, args);
		if (name.length < 1) return err("import of empty global");
		decoder.reset(name, 1, name.length - 1);
		var opcode = name[0];
		match (opcode) {
			JawaGlobalOpcode.CLASS_CONST.code => {
				var ct = read_class();
				return TODO();
			}
			JawaGlobalOpcode.INTERFACE_CONST.code => {
				var it = read_interface();
				return TODO();
			}
			JawaGlobalOpcode.STRING_CONST.code => {
				var str = read_string();
				if (str == null) return null;
				return env.internStringAsGlobal(str);
			}
			_ => err1("invalid global opcode 0x%x", opcode);
		}
		return null;
	}
	def processAbsType(name: string, args: Array<Exportable>, decl: AbsTypeDecl) -> Exportable {
		setImportArgs(name, args);
		if (name.length < 1) return err("import of empty type");
		decoder.reset(name, 1, name.length - 1);
		var opcode = name[0];
		match (opcode) {
			JawaTypeOpcode.BYTE_ARRAY.code => return JawaTypes.BYTE_ARRAY;
			JawaTypeOpcode.BOOL_ARRAY.code => return JawaTypes.BOOL_ARRAY;
			JawaTypeOpcode.CHAR_ARRAY.code => return JawaTypes.CHAR_ARRAY;
			JawaTypeOpcode.SHORT_ARRAY.code => return JawaTypes.SHORT_ARRAY;
			JawaTypeOpcode.INT_ARRAY.code => return JawaTypes.INT_ARRAY;
			JawaTypeOpcode.LONG_ARRAY.code => return JawaTypes.LONG_ARRAY;
			JawaTypeOpcode.FLOAT_ARRAY.code => return JawaTypes.FLOAT_ARRAY;
			JawaTypeOpcode.DOUBLE_ARRAY.code => return JawaTypes.DOUBLE_ARRAY;
			JawaTypeOpcode.EXT_CLASS.code => {
				var str = read_name();
				if (str == null) return null;
				var c = env.lookup(str);
				if (c == null) return err1("class not found: %q", str.render);
				if (!JawaClassType.?(c)) return err1("not a class: %q", str.render);
				return c;
			}
			JawaTypeOpcode.EXT_INTERFACE.code => {
				var str = read_name();
				if (str == null) return null;
				var i = env.lookup(str);
				if (i == null) return err1("interface not found: %q", str.render);
				if (!JawaInterfaceType.?(i)) return err1("not an interface: %q", str.render);
				return i;
			}
			JawaTypeOpcode.DECL_CLASS.code => {
				var str = read_name();
				if (str == null) return null;
				var attrs = read_class_attrs();
				var sup = read_class();
				if (sup == null) return null;
				var count = read_ji4();
				var intfs = Array<JawaInterfaceType>.new(count);
				for (i < count) {
					var intf = read_interface();
					if (intf == null) return null;
					intfs[i] = intf;
				}
				var cl = env.declareClass(str, attrs, sup, intfs);
				classDefs.put(cl);
				return cl;
			}
			JawaTypeOpcode.DECL_INTERFACE.code => {
				var str = read_name();
				if (str == null) return null;
				var count = read_ji4();
				var intfs = Array<JawaInterfaceType>.new(count);
				for (i < count) {
					var intf = read_interface();
					if (intf == null) return null;
					intfs[i] = intf;
				}
				var cl = env.declareInterface(str, intfs);
				interfaceDefs.put(cl);
				return cl;
			}
			JawaTypeOpcode.REF_ARRAY.code => {
				var elem = read_ref_type();
				if (elem == null) return null;
				return elem.arrayOf();
			}
			_ => err1("invalid type opcode 0x%x", opcode);
		}
		return null;
	}

	def read_class_field_selector(fields: JawaClassType -> Array<JawaField>) -> (JawaClassType, JawaField) {
		var t = read_defined_class();
		if (t == null) return (null, null);
		var name = read_name();
		if (name == null) return (null, null);
		for (x = t; x != null; x = x.parent) {
			for (f in fields(x)) {
				if (name.equals(f.name)) return (t, f);
			}
		}
		err(Strings.format2("class field %q.%q not found", t.render, name.render));
		return (null, null);
	}
	def read_class_method_selector(methods: JawaClassType -> Array<JawaMethod>) -> (JawaClassType, JawaMethod) {
		var t = read_defined_class();
		if (t == null) return (null, null);
		var name = read_name();
		if (name == null) return (null, null);
		for (x = t; x != null; x = x.parent) {
			for (m in methods(x)) {
				if (name.equals(m.name)) return (t, m);
			}
		}
		err(Strings.format2("class method %q.%q not found", t.render, name.render));
		return (null, null);
	}
	def read_interface_method_selector() -> (JawaInterfaceType, JawaMethod) {
		var t = read_defined_interface();
		if (t == null) return (null, null);
		var name = read_name();
		if (name == null) return (null, null);
		for (m in t.instanceMethods) {
			if (name.equals(m.name)) return (t, m);
		}
		err(Strings.format2("interface method %q.%q not found", t.render, name.render));
		return (null, null);
	}

	def read_string() -> JawaString {
		// Jawa strings are a length (4-byte Jawa int), followed by {length} UTF-8 bytes
		// that encode a UTF-16 string.
		var length = read_ji4();
		if (!decoder.check_bytes(length)) return null;
		var chars = read_utf8_to_utf16(length);
		return if(chars != null, JawaString.new(chars));
	}
	def read_name() -> JawaString {
		// Jawa names are a length (2-byte Jawa int), followed by {length} UTF-8 bytes
		// that encode a UTF-16 string.
		var length = read_ji2();
		if (!decoder.check_bytes(length)) return null;
		var chars = read_utf8_to_utf16(length);
		return if(chars != null, JawaString.new(chars));
	}
	def read_ji4() -> u28 {
		// Jawa ints are 4 little-endian 7-bit bytes for 28 bits total.
		// The upper bit of each byte must be 0 so that the int passes through UTF-8.
		return read_jiN(4);
	}
	def read_ji2() -> u28 {
		return read_jiN(2);
	}
	def read_jiN(max: int) -> u28 {
		var result: u32, shift = 0;
		for (i < max) {
			var b = decoder.read_u8();
			if ((b & 0x80) != 0) {
				error.at(decoder).set("Jawa int byte should not have upper bit set");
				return 0;
			}
			result = result | (u32.!(b) << u5.!(shift));
			shift += 7;
			if (decoder.pos >= decoder.limit) break; // truncated int of at least 1 byte
		}
		return u28.view(result);
	}
	def read_utf8_to_utf16(length: int) -> Array<u16> {
		if (!decoder.check_bytes(length)) return null;
		var chars = Utf8.decodeUtf16(decoder.data, decoder.pos, decoder.pos + length);
		if (chars.1 >= 0) {
			err("invalid UTF-8 string");
			return null;
		}
		decoder.pos += length;
		return chars.0;
	}
	def read_interface() -> JawaInterfaceType {
		return read_type<JawaInterfaceType>("interface");
	}
	def read_class() -> JawaClassType {
		return read_type<JawaClassType>("class");
	}
	def read_defined_class() -> JawaClassType {
		var t = read_class();
		if (t == null) return null;
		if (t.defined()) return t;
		defined_err("class", classDefs, t, t.render);
		return null;
	}
	def read_defined_interface() -> JawaInterfaceType {
		var t = read_interface();
		if (t == null) return null;
		if (t.defined()) return t;
		defined_err("interface", interfaceDefs, t, t.render);
		return null;
	}
	def read_array() -> JawaArrayType {
		return read_type<JawaArrayType>("array");
	}
	def read_ref_array() -> JawaArrayType {
		var at = read_type<JawaArrayType>("refarray");
		if (at == null) return null;
		if (JawaRefType.?(at.elem)) return at;
		type_err("refarray", at, -1);
		return null;
	}
	def read_ref_type() -> JawaRefType {
		return read_type<JawaRefType>("ref");
	}
	def read_type<T>(kind: string) -> T {
		var d: T;
		if (import_arg_index >= import_args.length) {
			type_err(kind, null, import_arg_index);
			return d;
		}
		var t = import_args[import_arg_index++];
		if (T.?(t)) return T.!(t);
		type_err(kind, t, import_arg_index-1);
		return d;
	}
	def read_return_type() -> JawaType {
		return read_type_ref("return");
	}
	def read_nonvoid_type() -> JawaType {
		var t = read_type_ref("field");
		if (t == null) return null;
		if (t.kind != JawaKind.VOID) return t;
		err1("expected non-void type, got %q", t.render);
		return null;
	}
	def read_type_ref(kind: string) -> JawaType {
		var b = decoder.read_u8();
		match (b) {
			'V' => return JawaTypes.VOID;
			'B' => return JawaTypes.BYTE;
			'Z' => return JawaTypes.BOOL;
			'C' => return JawaTypes.CHAR;
			'S' => return JawaTypes.SHORT;
			'I' => return JawaTypes.INT;
			'J' => return JawaTypes.LONG;
			'F' => return JawaTypes.FLOAT;
			'D' => return JawaTypes.DOUBLE;
			'L' => return read_type<JawaType>(kind);
			_ => err("invalid type character");
		}
		return null;
	}
	def read_field_decl(index: int) -> JawaField {
		if (trace != null) trace.put1("  field %d: ", index).outln();
		var name = read_name();
		if (name == null) return null;
		var attrs = read_field_attrs();
		var typ = read_nonvoid_type();
		if (typ == null) return null;
		var decl = JawaField.new(name, attrs, index, typ);
		if (trace != null) trace.put1("    => %q", decl.render).outln();
		return decl;
	}
	def read_method_def(index: int, recv: JawaRefType) -> JawaMethod {
		var decl = read_method_decl(index);
		var meth = read_method_ref();
		if (decl != null && meth != null) {
			var sig = decl.sig.sig(recv);
			if (!meth.sig.isAssignableSig(sig)) {
				err(Strings.format2("expected function of type %q, got %q", sig.render, meth.sig.render));
			}
			decl.impl = meth;
		}
		if (trace != null && WasmFunction.?(meth)) trace.put1("    => wasm func #%d", WasmFunction.!(meth).decl.func_index).outln();
		return decl;
	}
	def read_method_decl(index: int) -> JawaMethod {
		if (trace != null) trace.put1("  method %d: ", index).outln();
		var name = read_name();
		if (name == null) return null;
		var attrs = read_method_attrs();
		var count: int = read_ji2();
		if (count > MAX_JAWA_PARAM_COUNT) {
			err("exceeded maximum parameter count");
			return null;
		}
		var params = Array<JawaType>.new(count);
		for (i < count) params[i] = read_nonvoid_type();

		var ret = read_return_type();
		if (ret == null) return null;
		var decl = JawaMethod.new(name, attrs, JawaMethodSig.new(params, ret), null);
		if (trace != null) trace.put1("    => %q", decl.render).outln();
		return decl;
	}
	def read_method_ref() -> Function {
		if (import_arg_index >= import_args.length) {
			err("expected function for method definition");
			return null;
		}
		var t = import_args[import_arg_index++];
		if (!Function.?(t)) {
			err("expected function for method definition");
			return null;
		}
		return Function.!(t);
	}
	def read_class_attrs() -> JawaClassAttr.set {
		var attrs: JawaClassAttr.set;
		var ac = read_ji2();
		for (a in JawaClassAttr) {
			if (ac == 0) break;
			if ((a.code & ac) == a.code) {
				attrs |= a;
				ac &= ~(a.code);
			}
		}
		return attrs;
	}
	def read_method_attrs() -> JawaMethodAttr.set {
		var attrs: JawaMethodAttr.set;
		var ac = read_ji2();
		for (a in JawaMethodAttr) {
			if (ac == 0) break;
			if ((a.code & ac) == a.code) {
				attrs |= a;
				ac &= ~(a.code);
			}
		}
		return attrs;
	}
	def read_field_attrs() -> JawaFieldAttr.set {
		var attrs: JawaFieldAttr.set;
		var ac = read_ji2();
		for (a in JawaFieldAttr) {
			if (ac == 0) break;
			if ((a.code & ac) == a.code) {
				attrs |= a;
				ac &= ~(a.code);
			}
		}
		return attrs;
	}

	// Tracing and error handling helpers
	def setImportArgs(name: string, args: Array<Exportable>) {
		this.import_args = args;
		this.import_arg_index = 0;
		this.import_pos++;
		if (trace == null) return;
		trace.put1("jawa import #%d:", import_pos);
		if (name.length > 0) {
			var b = name[0], opname = JawaOpcodes.names[b];
			if (opname == null) opname = "invalid";
			trace.put2(" %x (%s)", b, opname);
		}
		for (i = 1; i < name.length; i++) trace.put1(" %x", name[i]);
		if (import_args.length > 0) {
			trace.puts(" <");
			for (i < import_args.length) {
				if (i > 0) trace.sp();
				import_args[i].render(trace);
			}
			trace.puts(">");
		}
		trace.outln();
	}
	def traceByte(thing: string) {
		if (trace != null) {
			trace.put3("  @+%d %s = %x", decoder.pos, thing, u8.view(decoder.peek_u8()));
			trace.outln();
		}
	}
	def TODO() -> Exportable {
		return err("unimplemented");
	}
	def err(s: string) -> Exportable {
		error.abs(import_pos).set(s);
		return null;
	}
	def err1<T>(s: string, p: T) -> Exportable {
		error.abs(import_pos).set(Strings.format1(s, p));
		return null;
	}
	def err2<T, U>(s: string, p: T, q: U) -> Exportable {
		error.abs(import_pos).set(Strings.format2(s, p, q));
		return null;
	}
	def defined_err<T>(decl: string, vec: Vector<T>, t: T, render: StringBuilder -> StringBuilder) {
		for (i < vec.length) {
			if (t == vec[i]) {
				err2("%s %q declared but not defined", decl, render);
				return;
			}
		}
		err2("%s %q not defined", decl, render);
	}
	def type_err(kind: string, got: Exportable, type_index: int) {
		var msg_render = if(got == null, Strings.puts("<null>"), got.render);
		if (type_index >= 0) {
			err(Strings.format3("expected jawa %s type, got %q @ module.types[%d]", kind, msg_render, type_index));
		} else {
			err(Strings.format2("expected jawa %s type, got %q", kind, msg_render));
		}
	}
}

def MAX_JAWA_PARAM_COUNT = 255;

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def Stubs: JawaHostStubs; // configurability for stub generation
// Processes a module's imports and supplies Jawa types, functions, and globals.
class JawaImportProcessor(error: ErrorGen, env: JawaEnvironment, module: Module, result: Array<Exportable>) {
	def decoder = JawaImmDecoder.new([], error);
	def classDefs = Vector<JawaClass>.new();
	def interfaceDefs = Vector<JawaInterface>.new();
	def process() {
		var imports = module.imports;
		for (i < imports.length) {
			var imp = imports[i];
			error.abs(i);
			if (!Strings.equals("jawa", imp.modname)) continue; // not Jawa
			if (result[i] != null) continue; // import already bound
			var exp: Exportable;
			match (imp.details) {
				Function(decl) => exp = processFunction(imp.name, decl);
				Global(decl) =>  exp = processGlobal(imp.name, decl);
				Type(constraints) =>  exp = processType(imp.name, constraints);
				_ => error.set(Strings.format1("invalid import of kind %s", imp.details.name));
			}
			if (exp == null) return;
			if (error.error()) return;
			result[i] = exp;
		}
	}
	def processFunction(name: string, decl: FunctionDecl) -> Exportable {
		if (name.length < 1) error.set("expected opcode for function import");
		var opcode = name[0];
		match (opcode) {
			JawaFunctionOpcode.AALOAD.code => ;
			JawaFunctionOpcode.AASTORE.code => ;
			JawaFunctionOpcode.ACMPEQ.code => ;
			JawaFunctionOpcode.ACMPNE.code => ;
			JawaFunctionOpcode.ANEWARRAY.code => ;
			JawaFunctionOpcode.ARRAYLENGTH.code => {
				decoder.reset(name, 1, name.length);
				var at = toArrayRef(decoder.read_jawa_int());
				if (at == null) return null;
				return Stubs.ARRAYLENGTH(at);
			}
			JawaFunctionOpcode.ATHROW.code => ;
			JawaFunctionOpcode.BALOAD.code => return Stubs.ALOAD<byte>(JawaTypes.BYTE_ARRAY);
			JawaFunctionOpcode.BASTORE.code => return Stubs.ASTORE<byte>(JawaTypes.BYTE_ARRAY);
			JawaFunctionOpcode.CALOAD.code => return Stubs.ALOAD<u16>(JawaTypes.CHAR_ARRAY);
			JawaFunctionOpcode.CASTORE.code => return Stubs.ASTORE<u16>(JawaTypes.CHAR_ARRAY);
			JawaFunctionOpcode.CHECKCAST.code => ;
			JawaFunctionOpcode.D2I.code => ;
			JawaFunctionOpcode.D2L.code => ;
			JawaFunctionOpcode.DALOAD.code => return Stubs.ALOAD<double>(JawaTypes.DOUBLE_ARRAY);
			JawaFunctionOpcode.DASTORE.code => return Stubs.ASTORE<double>(JawaTypes.DOUBLE_ARRAY);
			JawaFunctionOpcode.DCMPG.code => ;
			JawaFunctionOpcode.DCMPL.code => ;
			JawaFunctionOpcode.DREM.code => ;
			JawaFunctionOpcode.F2I.code => ;
			JawaFunctionOpcode.F2L.code => ;
			JawaFunctionOpcode.FALOAD.code => return Stubs.ALOAD<float>(JawaTypes.FLOAT_ARRAY);
			JawaFunctionOpcode.FASTORE.code => return Stubs.ASTORE<float>(JawaTypes.FLOAT_ARRAY);
			JawaFunctionOpcode.FCMPG.code => ;
			JawaFunctionOpcode.FCMPL.code => ;
			JawaFunctionOpcode.FREM.code => ;
			JawaFunctionOpcode.GETFIELD.code => ;
			JawaFunctionOpcode.GETSTATIC.code => ;
			JawaFunctionOpcode.IALOAD.code => return Stubs.ALOAD<int>(JawaTypes.INT_ARRAY);
			JawaFunctionOpcode.IASTORE.code => return Stubs.ASTORE<int>(JawaTypes.INT_ARRAY);
			JawaFunctionOpcode.INSTANCEOF.code => ;
			JawaFunctionOpcode.INVOKEDYNAMIC.code => ;
			JawaFunctionOpcode.INVOKEINTERFACE.code => ;
			JawaFunctionOpcode.INVOKESPECIAL.code => ;
			JawaFunctionOpcode.INVOKESTATIC.code => ;
			JawaFunctionOpcode.INVOKEVIRTUAL.code => ;
			JawaFunctionOpcode.LALOAD.code => return Stubs.ALOAD<long>(JawaTypes.LONG_ARRAY);
			JawaFunctionOpcode.LASTORE.code => return Stubs.ASTORE<long>(JawaTypes.LONG_ARRAY);
			JawaFunctionOpcode.MONITORENTER.code => ;
			JawaFunctionOpcode.MONITOREXIT.code => ;
			JawaFunctionOpcode.MULTIANEWARRAY.code => ;
			JawaFunctionOpcode.NEW.code => ;
			JawaFunctionOpcode.NEWARRAY.code => {
				decoder.reset(name, 1, name.length);
				var at = toArrayRef(decoder.read_jawa_int());
				if (at == null) return null;
				return Stubs.NEWARRAY(at);
			}
			JawaFunctionOpcode.NONNULL.code => ;
			JawaFunctionOpcode.NULL.code => ;
			JawaFunctionOpcode.PUTFIELD.code => ;
			JawaFunctionOpcode.PUTSTATIC.code => ;
			_ => error.set(Strings.format1("invalid function opcode 0x%x", opcode));
		}
		return null;
	}
	def processGlobal(name: string, decl: GlobalDecl) -> Exportable {
		if (name.length < 1) error.set("import of empty global");
		var opcode = name[0];
		match (opcode) {
			JawaGlobalOpcode.STRING_CONST.code => {
				var str = decoder.read_jawa_string();
				if (str == null) return null;
				return env.internStringAsGlobal(str);
			}
			_ => error.set(Strings.format1("invalid global opcode 0x%x", opcode));
		}
		return null;
	}
	def processType(name: string, constraints: Array<TypeConstraint>) -> Exportable {
		if (name.length < 1) error.set("import of empty type");
		var opcode = name[0];
		match (opcode) {
			JawaTypeOpcode.BYTE_ARRAY.code => return JawaTypes.BYTE_ARRAY;
			JawaTypeOpcode.BOOL_ARRAY.code => return JawaTypes.BOOL_ARRAY;
			JawaTypeOpcode.CHAR_ARRAY.code => return JawaTypes.CHAR_ARRAY;
			JawaTypeOpcode.SHORT_ARRAY.code => return JawaTypes.SHORT_ARRAY;
			JawaTypeOpcode.INT_ARRAY.code => return JawaTypes.INT_ARRAY;
			JawaTypeOpcode.LONG_ARRAY.code => return JawaTypes.LONG_ARRAY;
			JawaTypeOpcode.FLOAT_ARRAY.code => return JawaTypes.FLOAT_ARRAY;
			JawaTypeOpcode.DOUBLE_ARRAY.code => return JawaTypes.DOUBLE_ARRAY;
			JawaTypeOpcode.EXT_CLASS.code => {
				decoder.reset(name, 1, name.length);
				var str = decoder.read_jawa_name();
				if (str == null) return null;
				var c = env.lookupClass(str);
				if (c == null) error.set(Strings.format1("class not found: %q", str.render));
				return env.exportClass(c);
			}
			JawaTypeOpcode.EXT_INTERFACE.code => {
				decoder.reset(name, 1, name.length);
				var str = decoder.read_jawa_name();
				if (str == null) return null;
				var i = env.lookupInterface(str);
				if (i == null) error.set(Strings.format1("interface not found: %q", str.render));
				return env.exportInterface(i);
			}
			JawaTypeOpcode.FW_CLASS_DECL.code => {
				decoder.reset(name, 1, name.length);
				var str = decoder.read_jawa_name();
				if (str == null) return null;
				var sup = toClassRef(decoder.read_jawa_int());
				var count = decoder.read_jawa_int();
				var intfs = Array<JawaInterface>.new(count);
				for (i < count) {
					intfs[i] = toInterfaceRef(decoder.read_jawa_int());
				}
				var cl = env.declareClass(str, sup, intfs);
				classDefs.put(cl);
				return env.exportClass(cl);
			}
			JawaTypeOpcode.FW_INTERFACE_DECL.code => {
				decoder.reset(name, 1, name.length);
				var str = decoder.read_jawa_name();
				if (str == null) return null;
				var count = decoder.read_jawa_int();
				var intfs = Array<JawaInterface>.new(count);
				for (i < count) {
					intfs[i] = toInterfaceRef(decoder.read_jawa_int());
				}
				var cl = env.declareInterface(str, intfs);
				interfaceDefs.put(cl);
				return env.exportInterface(cl);
			}
			JawaTypeOpcode.REF_ARRAY.code => {
				decoder.reset(name, 1, name.length);
				var elem = toRefType(decoder.read_jawa_int());
				if (elem == JawaType.None) return null;
				return env.getArrayType(elem);
			}
			JawaTypeOpcode.DEF_CLASS.code => {
				decoder.reset(name, 1, name.length);
				var cl = toClassRef(decoder.read_jawa_int());
				if (cl == null) return null;
				// TODO: check class building, decode class body
				// TODO: read instance fields
				// TODO: read instance methods
				// TODO: read static fields
				// TODO: read static methods
			}
			JawaTypeOpcode.DEF_INTERFACE.code => {
				decoder.reset(name, 1, name.length);
				var cl = toInterfaceRef(decoder.read_jawa_int());
				if (cl == null) return null;
				// TODO: check class building, decode class body
				// TODO: read instance methods
			}
			_ => error.set(Strings.format1("invalid type opcode 0x%x", opcode));
		}
		return null;
	}
	def toRefType(i: int) -> JawaType; // TODO
	def toClassRef(i: int) -> JawaClass; // TODO
	def toInterfaceRef(i: int) -> JawaInterface; // TODO
	def toArrayRef(i: int) -> JawaExportedType;
}

// Codes and immediates for functions that can be imported into a Jawa module.
enum JawaFunctionOpcode(code: byte, imm: JawaImmKind) {
	AALOAD		(0x10, JawaImmKind.REF_TYPE),
	AASTORE		(0x11, JawaImmKind.REF_TYPE),
	ACMPEQ		(0x12, JawaImmKind.REF_TYPE),
	ACMPNE		(0x13, JawaImmKind.REF_TYPE),
	ANEWARRAY	(0x14, JawaImmKind.REF_TYPE),
	ARRAYLENGTH	(0x15, JawaImmKind.ARRAY_TYPE),
	ATHROW		(0x16, JawaImmKind.NONE),
	BALOAD		(0x17, JawaImmKind.NONE),
	BASTORE		(0x18, JawaImmKind.NONE),
	CALOAD		(0x19, JawaImmKind.NONE),
	CASTORE		(0x1A, JawaImmKind.NONE),
	CHECKCAST	(0x1B, JawaImmKind.REF_TYPE_REF_TYPE),
	D2I		(0x1C, JawaImmKind.NONE),
	D2L		(0x1D, JawaImmKind.NONE),
	DALOAD		(0x1E, JawaImmKind.NONE),
	DASTORE		(0x1F, JawaImmKind.NONE),
	DCMPG		(0x20, JawaImmKind.NONE),
	DCMPL		(0x21, JawaImmKind.NONE),
	DREM		(0x22, JawaImmKind.NONE),
	F2I		(0x23, JawaImmKind.NONE),
	F2L		(0x24, JawaImmKind.NONE),
	FALOAD		(0x25, JawaImmKind.NONE),
	FASTORE		(0x26, JawaImmKind.NONE),
	FCMPG		(0x27, JawaImmKind.NONE),
	FCMPL		(0x28, JawaImmKind.NONE),
	FREM		(0x29, JawaImmKind.NONE),
	GETFIELD	(0x2A, JawaImmKind.INSTANCE_FIELD_SELECTOR),
	GETSTATIC	(0x2B, JawaImmKind.STATIC_FIELD_SELECTOR),
	IALOAD		(0x2C, JawaImmKind.NONE),
	IASTORE		(0x2D, JawaImmKind.NONE),
	INSTANCEOF	(0x2E, JawaImmKind.REF_TYPE_REF_TYPE),
	INVOKEDYNAMIC	(0x2F, JawaImmKind.INSTANCE_METHOD_SELECTOR),
	INVOKEINTERFACE	(0x30, JawaImmKind.INTERFACE_METHOD_SELECTOR),
	INVOKESPECIAL	(0x31, JawaImmKind.INSTANCE_METHOD_SELECTOR),
	INVOKESTATIC	(0x32, JawaImmKind.STATIC_METHOD_SELECTOR),
	INVOKEVIRTUAL	(0x33, JawaImmKind.INSTANCE_METHOD_SELECTOR),
	LALOAD		(0x34, JawaImmKind.NONE),
	LASTORE		(0x35, JawaImmKind.NONE),
	MONITORENTER	(0x36, JawaImmKind.REF_TYPE),
	MONITOREXIT	(0x37, JawaImmKind.REF_TYPE),
	MULTIANEWARRAY	(0x38, JawaImmKind.INT_REF_TYPE),
	NEW		(0x39, JawaImmKind.CLASS_TYPE),
	NEWARRAY	(0x3A, JawaImmKind.ARRAY_TYPE),
	NONNULL		(0x3B, JawaImmKind.REF_TYPE),
	NULL		(0x3C, JawaImmKind.REF_TYPE),
	PUTFIELD	(0x3D, JawaImmKind.INSTANCE_FIELD_SELECTOR),
	PUTSTATIC	(0x3E, JawaImmKind.STATIC_FIELD_SELECTOR),
}

// Codes and immediates for types that can be imported into a Jawa module.
enum JawaTypeOpcode(code: byte, imm: JawaImmKind) {
	BYTE_ARRAY		(0x00, JawaImmKind.NONE),
	BOOL_ARRAY		(0x01, JawaImmKind.NONE),
	CHAR_ARRAY		(0x02, JawaImmKind.NONE),
	SHORT_ARRAY		(0x03, JawaImmKind.NONE),
	INT_ARRAY		(0x04, JawaImmKind.NONE),
	LONG_ARRAY		(0x05, JawaImmKind.NONE),
	FLOAT_ARRAY		(0x06, JawaImmKind.NONE),
	DOUBLE_ARRAY		(0x07, JawaImmKind.NONE),
	EXT_CLASS		(0x08, JawaImmKind.STRING),
	EXT_INTERFACE		(0x09, JawaImmKind.STRING),
	FW_CLASS_DECL		(0x0A, JawaImmKind.CLASS_DECL),
	FW_INTERFACE_DECL	(0x0B, JawaImmKind.INTERFACE_DECL),
	REF_ARRAY		(0x0C, JawaImmKind.REF_TYPE),
	DEF_CLASS		(0x0D, JawaImmKind.CLASS_DEF),
	DEF_INTERFACE		(0x0E, JawaImmKind.INTERFACE_DEF),
}

// Codes and immediates for globals that can be imported into a Jawa module.
enum JawaGlobalOpcode(code: byte, imm: JawaImmKind) {
	STRING_CONST	(0x00, JawaImmKind.STRING)
}

// The immediate kinds for imports.
enum JawaImmKind {
	NONE,
	STRING,				// UTF-8 encoded UTF-16
	CLASS_TYPE,			// int: type index, must be class
	REF_TYPE,			// int: type index, must be ref
	REF_TYPE_REF_TYPE,		// int: type index, int: type index, must be refs
	ARRAY_TYPE,			// int: type index, must be array
	INSTANCE_FIELD_SELECTOR,	// UTF-8 string pair, must refer to class field
	STATIC_FIELD_SELECTOR,		// UTF-8 string pair, must refer to class field
	INTERFACE_METHOD_SELECTOR,	// UTF-8 string pair, must refer to interface method
	INSTANCE_METHOD_SELECTOR,	// UTF-8 string pair, must refer to class method
	STATIC_METHOD_SELECTOR,		// UTF-8 string pair, must refer to class method
	INT_REF_TYPE,			// int, int: type index, must be ref
	CLASS_DECL,			// string, int: type index, must be class, int*: type index, must be interfaces
	INTERFACE_DECL			// string, int*: type index, must be interfaces
	CLASS_DEF,			// int: type index, must be class, instance fields/methods, static fields/methods
	INTERFACE_DEF			// int: type index, must be interface, interface methods
}

// Decoder with Jawa-specific routines.
class JawaImmDecoder extends Decoder {
	new(data: Array<byte>, err: ErrorGen) super(data, err) { }

	def read_jawa_string() -> JawaString {
		// Jawa strings are a length (4-byte Jawa int), followed by {length} UTF-8 bytes
		// that encode a UTF-16 string.
		var length = read_jawa_int();
		if (!check_bytes(length)) return null;
		var chars = read_utf8_to_utf16(length);
		return if(chars != null, JawaString.new(chars));
	}
	def read_jawa_name() -> JawaString {
		// Jawa names are a length (2-byte Jawa int), followed by {length} UTF-8 bytes
		// that encode a UTF-16 string.
		var length = read_jawa_iN(2);
		if (!check_bytes(length)) return null;
		var chars = read_utf8_to_utf16(length);
		return if(chars != null, JawaString.new(chars));
	}
	def read_jawa_int() -> int {
		// Jawa ints are 4 little-endian 7-bit bytes for 28 bits total.
		// The upper bit of each byte must be 0 so that the int passes through UTF-8.
		return read_jawa_iN(4);
	}
	def read_jawa_iN(max: int) -> int {
		var result: int, shift = 0;
		for (i < max) {
			if (pos >= limit) return result;
			var b = data[pos++];
			if ((b & 0x80) != 0) {
				err.at(this).set("Jawa int byte should not have upper bit set");
				return 0;
			}
			result = result | (int.!(b) << u5.!(shift));
			shift += 7;
		}
		return result;
	}
	def read_utf8_to_utf16(length: int) -> Array<u16> {
		var chars = Array<u16>.new(length);
		// TODO: support more than 7-bit ascii
		for (i < chars.length) {
			var b = data[i + pos];
			if ((b & 0x80) != 0) {
				err.rel(this, pos + i).set("Jawa strings are currently limited to 7-bit ascii");
				return null;
			}
			chars[i] = b;
		}
		pos += length;
		return chars;
	}
}

// All built-in classes in Jawa.
component JawaLang {
	def NO_INTERFACES: Array<JawaInterfaceType> = [];
	def NO_CLASS_ATTRS: JawaClassAttr.set;
	def NO_METHODS = Array<JawaMethod>.new(0);
	def NO_FIELDS = Array<JawaField>.new(0);

	def OBJECT = newEmptyClass("jawa/lang/Object", null);
	def STRING = newEmptyClass("jawa/lang/String", OBJECT);
	def CLASS = newEmptyClass("jawa/lang/Class", OBJECT);

	new() {
		def PUBLIC: JawaMethodAttr.set = JawaMethodAttr.PUBLIC;
		var init = JawaStrings.of("<init>");
		var equals = JawaStrings.of("equals");
		var getClass = JawaStrings.of("getClass");
		var sig_v_v = JawaMethodSig.new([], JawaTypes.VOID);
		var sig_v_c = JawaMethodSig.new([], CLASS);
		var sig_o_z = JawaMethodSig.new([OBJECT], JawaTypes.BOOL);
		
		OBJECT.instanceMethods = [
			newInstanceMethod(OBJECT, init, PUBLIC, sig_v_v, nop),
			newInstanceMethod(OBJECT, equals, PUBLIC, sig_o_z, Object_equals),
			newInstanceMethod(OBJECT, getClass, JawaMethodAttr.PUBLIC | JawaMethodAttr.FINAL, sig_v_c, Object_getClass)
		];

		STRING.instanceMethods = [
			newInstanceMethod(STRING, equals, PUBLIC, sig_o_z, String_equals)
		];

		var err = ErrorGen.new();
		OBJECT.finish(err);
		STRING.finish(err);
		CLASS.finish(err);
	}

	def install(env: JawaEnvironment) {
		env.add(OBJECT);
		env.add(STRING);
		env.add(CLASS);
	}
	def newEmptyClass(name: string, sup: JawaClassType) -> JawaClassType {
		var ct = JawaClassType.new(JawaStrings.of(name), JawaClassAttr.PUBLIC, sup, NO_INTERFACES);
		ct.instanceFields = ct.staticFields = NO_FIELDS;
		ct.instanceFields = ct.staticFields = NO_FIELDS;
		ct.instanceMethods = ct.staticMethods = NO_METHODS;
		ct.instanceMethods = ct.staticMethods = NO_METHODS;
		ct.boilerplate = Values.NONE;
		return ct;
	}

	private def newInstanceMethod(t: JawaDeclType, name: JawaString, attrs: JawaMethodAttr.set,
			sig: JawaMethodSig, eval: Array<Value> -> HostResult) -> JawaMethod {
		var buf = StringBuilder.new();
		t.name.render(buf);
		buf.putc('.');
		name.render(buf);
		var hf = JawaHostFunction.new(buf.extract(), sig.sig(t, toHostType), eval);
		return JawaMethod.new(name, attrs, sig, hf);
	}
	private def toHostType(t: JawaType) -> ValueType { // XXX: reduce duplication with HostRuntime
		match (t) {
			x: JawaPrimType => return x.prim.valueType;
			_ => return ValueType.Host(t);
		}
	}

// ---- Implementation of jawa.lang.* methods -----------------------------------
	def TRUE = HostResult.Value([Values.I32_1]);
	def FALSE = HostResult.Value([Values.I32_0]);
	def VOID = HostResult.Value([]);

	private def nop(args: Array<Value>) -> HostResult {
		return VOID;
	}
	private def Object_equals(args: Array<Value>) -> HostResult {
		var x = Value.ExternRef.!(args[0]).val;
		var y = Value.ExternRef.!(args[1]).val;
		return if(x == y, TRUE, FALSE);
	}
	private def Object_getClass(args: Array<Value>) -> HostResult {
		var obj = Value.ExternRef.!(args[0]).val;
		var cl: JawaObject;
		match (obj) {
			x: JawaInstanceObject => {
				cl = x.clazz.obj;
				if (cl == null) cl = x.clazz.obj = JawaClassObject.new(x.clazz);
			}
			_ => ; // TODO: arrays
		}
		return HostResult.Value([Value.ExternRef(cl)]);
	}
	private def String_equals(args: Array<Value>) -> HostResult {
		var x = Value.ExternRef.!(args[0]).val;
		var y = Value.ExternRef.!(args[1]).val;
		if (x == y) return TRUE;
		if (JawaStringObject.?(x) && JawaStringObject.?(y)) {
			var xx = JawaStringObject.!(x), yy = JawaStringObject.!(y);
			return if(xx.rep.equals(yy.rep), TRUE, FALSE);
		}
		return FALSE;
	}
}

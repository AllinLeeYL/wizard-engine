// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// All of the possible Jawa types.
type JawaType {
	case None;
	case BYTE;
	case BOOL;
	case CHAR;
	case SHORT;
	case INT;
	case LONG;
	case FLOAT;
	case DOUBLE;
	case Class(decl: JawaClass);
	case Interface(decl: JawaInterface);
	case Array(elem: JawaType);

	def isRef() -> bool {
		match (this) {
			Class, Interface, Array => return true;
			_ => return false;
		}
	}
	def isSubtype(that: JawaType) -> bool {
		if (this == that) return true; // handle all trivial equalities
		match (this) {
			Class(decl) => {
				match (that) {
					Class(decl2) => {
						var d = decl.parent;
						while (d != null) { // search inheritance chain
							if (d == decl2) return true;
						}
					}
					Interface(decl2) => {
						for (i in decl.interfaces) { // search implemented interfaces
							if (i.isSubtype(that)) return true;
						}
					}
					_ => ;
				}
			}
			Interface(decl) => {
				for (i in decl.interfaces) { // search super-interfaces
					if (i.isSubtype(that)) return true;
				}
			}
			Array(elem) => {
				match (that) {
					Class(decl2) => return decl2.parent == null; // subtype of Object
					Array(elem2) => return elem.isSubtype(elem2); // co-variant arrays
					_ => ;
				}
			}
			_ => ;
		}
		return false;
	}
	def render(buf: StringBuilder) -> StringBuilder {
		var s: string;
		match (this) {
			None => s = "<none>";
			BYTE => s = "B";
			BOOL => s = "Z";
			CHAR => s = "C";
			SHORT => s = "S";
			INT => s = "I";
			LONG => s = "J";
			FLOAT => s = "F";
			DOUBLE => s = "D";
			Class(decl) => {
				buf.puts("L");
				decl.name.render(buf);
				buf.puts(";");
				return buf;
			}
			Interface(decl) => {
				buf.puts("L");
				decl.name.render(buf);
				buf.puts(";");
				return buf;
			}
			Array(elem) => {
				buf.puts("[");
				return elem.render(buf);
			}
		}
		return buf.puts(s);
	}
}
// Wrapper around a Jawa type to integrate with host types.
class JawaHostType(t: JawaType) extends HostType {
	def render(buf: StringBuilder) -> StringBuilder {
		return t.render(buf.puts("jawa:"));
	}
}


// Wrapper around a Jawa exported type that allows it to be imported/exported to wasm.
class JawaExportedType(host: JawaHostType) extends ExportedType(ValueType.Host(host)) { }

// Global top-level Jawa types.
component JawaTypes {
	def BYTE_ARRAY = array(JawaType.BYTE);
	def BOOL_ARRAY = array(JawaType.BOOL);
	def CHAR_ARRAY = array(JawaType.CHAR);
	def SHORT_ARRAY = array(JawaType.SHORT);
	def INT_ARRAY = array(JawaType.INT);
	def LONG_ARRAY = array(JawaType.LONG);
	def FLOAT_ARRAY = array(JawaType.FLOAT);
	def DOUBLE_ARRAY = array(JawaType.DOUBLE);

	def BYTE_MAP = JawaPrimTypeMapOf<i8>.new(JawaType.BYTE, ValueType.I32, b_v, v_b);
	def BOOL_MAP = JawaPrimTypeMapOf<bool>.new(JawaType.BOOL, ValueType.I32, z_v, v_z);
	def CHAR_MAP = JawaPrimTypeMapOf<u16>.new(JawaType.CHAR, ValueType.I32, c_v, v_c);
	def SHORT_MAP = JawaPrimTypeMapOf<i16>.new(JawaType.SHORT, ValueType.I32, s_v, v_s);
	def INT_MAP = JawaPrimTypeMapOf<i32>.new(JawaType.INT, ValueType.I32, Values.i_v, Values.v_i);
	def LONG_MAP = JawaPrimTypeMapOf<i64>.new(JawaType.LONG, ValueType.I32, Values.l_v, Values.v_l);
	def FLOAT_MAP = JawaPrimTypeMapOf<float>.new(JawaType.FLOAT, ValueType.I32, f_v, v_f);
	def DOUBLE_MAP = JawaPrimTypeMapOf<double>.new(JawaType.DOUBLE, ValueType.I32, d_v, v_d);

	def array(elem: JawaType) -> JawaExportedType {
		return JawaExportedType.new(JawaHostType.new(JawaType.Array(elem)));
	}

	def b_v(v: i8) -> Value.I32 { return Value.I32(u32.view(v)); }
	def v_b(v: Value) -> i8 { return i8.view(Value.I32.!(v).val); }
	def z_v(v: bool) -> Value.I32 { return if(v, Values.I32_1, Values.I32_0); }
	def v_z(v: Value) -> bool { return Value.I32.!(v).val != 0; }
	def s_v(v: i16) -> Value.I32 { return Value.I32(u32.view(v)); }
	def v_s(v: Value) -> i16 { return i16.view(Value.I32.!(v).val); }
	def c_v(v: u16) -> Value.I32 { return Value.I32(u32.view(v)); }
	def v_c(v: Value) -> u16 { return u16.view(Value.I32.!(v).val); }
	def f_v(v: float) -> Value.F32 { return Value.F32(u32.view(v)); }
	def v_f(v: Value) -> float { return float.view(Value.F32.!(v).bits); }
	def d_v(v: double) -> Value.F64 { return Value.F64(u64.view(v)); }
	def v_d(v: Value) -> double { return double.view(Value.F64.!(v).bits); }
}

// Three-way mapping between Jawa types, Value types (wasm), and Virgil types.
// For convenience, contains cached array types as well.
class JawaPrimTypeMap(jawaType: JawaType, valueType: ValueType) {
	def jawaArrayType = JawaType.Array(jawaType);
	def jawaArrayHostType = JawaHostType.new(jawaArrayType);
	def jawaArrayValueType = ValueType.Host(jawaArrayHostType);
	def newarray(length: int) -> JawaArrayObject;
}
class JawaPrimTypeMapOf<T> extends JawaPrimTypeMap {
	def box: T -> Value;
	def unbox: Value -> T;
	new(jt: JawaType, vt: ValueType, box, unbox) super(jt, vt) { }
	def newarray(length: int) -> JawaArrayObjectOf<T> {
		return JawaArrayObjectOf<T>.new(Array<T>.new(length));
	}
}

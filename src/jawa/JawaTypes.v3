// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Kinds for Jawa types.
enum JawaKind {
	BYTE,
	BOOL,
	CHAR,
	SHORT,
	INT,
	LONG,
	FLOAT,
	DOUBLE,
	REF
}

// All of the possible Jawa types.
class JawaType(kind: JawaKind) extends HostType {
	def render(buf: StringBuilder) -> StringBuilder {
		return renderJ(buf.puts("jawa:"));
	}
	def renderJ(buf: StringBuilder) -> StringBuilder {
		return buf.puts("<type>");
	}
}

// Jawa primitive types have a {JawaPrimMapping}, which defines its mapping to Wasm types,
// which is actually a {JawaPrimMappingOf<T>}, which defines its mapping to the Virgil
// type {T} as well, including the box and unbox operations. Subtyping hides the type
// parameter.
class JawaPrimMapping(kind: JawaKind, valueType: ValueType) {
	def newarray(length: int) -> JawaArrayObject;
}
class JawaPrimMappingOf<T> extends JawaPrimMapping {
	def box: T -> Value;
	def unbox: Value -> T;
	new(kind: JawaKind, vt: ValueType, box, unbox) super(kind, vt) { }
	def newarray(length: int) -> JawaArrayObjectOf<T> {
		return JawaArrayObjectOf<T>.new(Array<T>.new(length));
	}
}
class JawaPrimType(char: byte, prim: JawaPrimMapping) extends JawaType(prim.kind) {
	def isAssignableTo(t: ValueType) -> bool {
		match (t) {
			Host(host) => return this == host;
			EXTERNREF => return true;
			_ => return prim.valueType == t;
		}
	}
	def render(buf: StringBuilder) -> StringBuilder {
		return buf.puts("jawa:").putc(char);
	}
}

// Jawa reference types extend this class.
class JawaRefType extends JawaType(JawaKind.REF) { }

// Jawa class types.
class JawaClassType(decl: JawaClass) extends JawaRefType {
	def isAssignableTo(t: ValueType) -> bool {
		match (t) {
			Host(host) => {
				if (this == host) return true;
				match (host) {
					that: JawaClassType => {
						return false; // TODO: check interfaces
					}
					that: JawaInterfaceType => {
						return false; // TODO: check interfaces
					}
					_ => return false;
				}
			}
			EXTERNREF => return true;
			_ => return false;
		}
	}
	def renderJ(buf: StringBuilder) -> StringBuilder {
		return decl.name.render(buf.putc('L')).putc(';');
	}
}

// Jawa interface types.
class JawaInterfaceType(decl: JawaInterface) extends JawaRefType {
	def isAssignableTo(t: ValueType) -> bool {
		match (t) {
			Host(host) => {
				if (this == host) return true;
				match (host) {
					that: JawaInterfaceType => {
						return false; // TODO: check interfaces
					}
					_ => return false;
				}
			}
			EXTERNREF => return true;
			_ => return false;
		}
	}
	def renderJ(buf: StringBuilder) -> StringBuilder {
		return decl.name.render(buf.putc('L')).putc(';');
	}
}

// Jawa array types.
class JawaArrayType(elem: JawaType) extends JawaRefType {
	def isAssignableTo(t: ValueType) -> bool {
		match (t) {
			Host(host) => {
				if (this == host) return true;
				match (host) {
					that: JawaClassType => return that.decl.parent == null; // jawa/lang/Object
					that: JawaArrayType => return this.elem.isAssignableTo(ValueType.Host(that.elem)); // co-variant
					_ => return false;
				}
			}
			EXTERNREF => return true;
			_ => return false;
		}
	}
	def renderJ(buf: StringBuilder) -> StringBuilder {
		return elem.renderJ(buf.putc('['));
	}
	def rank() -> int {
		var r = 1, t = elem;
		while (JawaArrayType.?(t)) {
			t = JawaArrayType.!(t).elem;
			r++;
		}
		return r;
	}
}

// Global top-level Jawa types.
component JawaTypes {
	// Kinds define mappings between Virgil, Jawa types, and wasm types.
	def BYTE_MAPPING = JawaPrimMappingOf<i8>.new(JawaKind.BYTE, ValueType.I32, b_v, v_b);
	def BOOL_MAPPING = JawaPrimMappingOf<bool>.new(JawaKind.BOOL, ValueType.I32, z_v, v_z);
	def CHAR_MAPPING = JawaPrimMappingOf<u16>.new(JawaKind.CHAR, ValueType.I32, c_v, v_c);
	def SHORT_MAPPING = JawaPrimMappingOf<i16>.new(JawaKind.SHORT, ValueType.I32, s_v, v_s);
	def INT_MAPPING = JawaPrimMappingOf<i32>.new(JawaKind.INT, ValueType.I32, Values.i_v, Values.v_i);
	def LONG_MAPPING = JawaPrimMappingOf<i64>.new(JawaKind.LONG, ValueType.I32, Values.l_v, Values.v_l);
	def FLOAT_MAPPING = JawaPrimMappingOf<float>.new(JawaKind.FLOAT, ValueType.I32, f_v, v_f);
	def DOUBLE_MAPPING = JawaPrimMappingOf<double>.new(JawaKind.DOUBLE, ValueType.I32, d_v, v_d);

	// Actual primitive types.
	def BYTE = JawaPrimType.new('B', BYTE_MAPPING);
	def BOOL = JawaPrimType.new('Z', BOOL_MAPPING);
	def CHAR = JawaPrimType.new('C', CHAR_MAPPING);
	def SHORT = JawaPrimType.new('S', SHORT_MAPPING);
	def INT = JawaPrimType.new('I', INT_MAPPING);
	def LONG = JawaPrimType.new('J', LONG_MAPPING);
	def FLOAT = JawaPrimType.new('F', FLOAT_MAPPING);
	def DOUBLE = JawaPrimType.new('D', DOUBLE_MAPPING);

	// Cached (exported) array types.
	def BYTE_ARRAY = JawaArrayType.new(BYTE);
	def BOOL_ARRAY = JawaArrayType.new(BOOL);
	def CHAR_ARRAY = JawaArrayType.new(CHAR);
	def SHORT_ARRAY = JawaArrayType.new(SHORT);
	def INT_ARRAY = JawaArrayType.new(INT);
	def LONG_ARRAY = JawaArrayType.new(LONG);
	def FLOAT_ARRAY = JawaArrayType.new(FLOAT);
	def DOUBLE_ARRAY = JawaArrayType.new(DOUBLE);

	// Host types for objects.
	def OBJECT = JawaClassType.new(JawaClasses.OBJECT);
	def STRING = JawaClassType.new(JawaClasses.STRING);

	// Pairs of (primitive array type, primitive mapping).
	def BYTE_ARRAY_PAIR = (BYTE_ARRAY, BYTE_MAPPING);
	def BOOL_ARRAY_PAIR = (BOOL_ARRAY, BOOL_MAPPING);
	def CHAR_ARRAY_PAIR = (CHAR_ARRAY, CHAR_MAPPING);
	def SHORT_ARRAY_PAIR = (SHORT_ARRAY, SHORT_MAPPING);
	def INT_ARRAY_PAIR = (INT_ARRAY, INT_MAPPING);
	def LONG_ARRAY_PAIR = (LONG_ARRAY, LONG_MAPPING);
	def FLOAT_ARRAY_PAIR = (FLOAT_ARRAY, FLOAT_MAPPING);
	def DOUBLE_ARRAY_PAIR = (DOUBLE_ARRAY, DOUBLE_MAPPING);

	// Value conversion utilities.
	def b_v(v: i8) -> Value.I32 { return Value.I32(u32.view(v)); }
	def v_b(v: Value) -> i8 { return i8.view(Value.I32.!(v).val); }
	def z_v(v: bool) -> Value.I32 { return if(v, Values.I32_1, Values.I32_0); }
	def v_z(v: Value) -> bool { return Value.I32.!(v).val != 0; }
	def s_v(v: i16) -> Value.I32 { return Value.I32(u32.view(v)); }
	def v_s(v: Value) -> i16 { return i16.view(Value.I32.!(v).val); }
	def i_v = Values.i_v;
	def v_i = Values.v_i;
	def l_v = Values.l_v;
	def v_l = Values.v_l;
	def c_v(v: u16) -> Value.I32 { return Value.I32(u32.view(v)); }
	def v_c(v: Value) -> u16 { return u16.view(Value.I32.!(v).val); }
	def f_v(v: float) -> Value.F32 { return Value.F32(u32.view(v)); }
	def v_f(v: Value) -> float { return float.view(Value.F32.!(v).bits); }
	def d_v(v: double) -> Value.F64 { return Value.F64(u64.view(v)); }
	def v_d(v: Value) -> double { return double.view(Value.F64.!(v).bits); }
}

// Copyright 2024 Wizard authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def unused_ = HostModuleBuilderOf<WaliInstance>.new("wali", WaliInstance.new)
	.func_M("SYS_read", SigCache.iii_l, WaliInstance.read)
	.func_M("SYS_write", SigCache.iii_l, WaliInstance.write)
	.postprocess(WaliInstance.setMemory)
	.init(init)
	.getMain(getMain)
	.register(false);

class WaliInstance {
	private var memory: Memory;
	private def fdmap = FileDescriptorMap.new(MAX_FDS); // per-instance: fd table
	// TODO: per-instance memory mappings

	def setMemory(instance: Instance) {
		// Find memory and save internally
		memory = instance.findExportOfType<Memory>(null);
	}

	def getSysFd(args: Range<Value>, n: int) -> int {
		return fdmap.get(Values.v_i(args[n]));
	}
	def getRegion(args: Range<Value>, n: int) -> MaybeTrap<Range<byte>> {
		var ptr = Values.v_u(args[n]);
		var len = Values.v_u(args[n+1]);
		return memory.range_ol_32(ptr, len);
	}
	def syscall<T>(num: int, args: T) -> HostResult.Value1 {
		var r = Linux.syscall(num, args);
		return HostResult.Value1(Values.l_v(r.0));
	}

	// Exported functions.
	def read(args: Range<Value>) -> HostResult {
		var sysfd = getSysFd(args, 0);
		var range = getRegion(args, 1);
		if (range.reason != TrapReason.NONE) return range.toHostResultThrow();
		if (sysfd < 0) return EBADFD;
		return syscall(LinuxConst.SYS_read, (sysfd, Pointer.atContents(range.result), range.result.length));
	}
	def write(args: Range<Value>) -> HostResult {
		var sysfd = getSysFd(args, 0);
		var range = getRegion(args, 1);
		if (range.reason != TrapReason.NONE) return range.toHostResultThrow();
		if (sysfd < 0) return EBADFD;
		return syscall(LinuxConst.SYS_write, (sysfd, Pointer.atContents(range.result), range.result.length));
	}
}

def MAX_FDS = 1000;
var cmdline_args: Array<string>; // global: environment
var cmdline_env: Array<string>; // global: environment, TODO
var trace: bool;

def EBADFD = HostResult.Value1(Values.i_v(LinuxConst.EBADFD));

def init(args: Array<string>, t: bool, err: ErrorGen) {
	cmdline_args = args;
	trace = t;
}

def getMain(instance: Instance) -> (Function, Array<Value>) {
	var main = instance.findExportOfType<Function>(GlobMatcher.new("main"));
	if (main == null) {
		for (iex in instance.exports) {
			match (iex) {
				x: Function => {
					// If more than one exported function, don't know
					if (main != null) return (null, null);
					main = x;
				}
			}
		}
	}
	if (main == null) return (null, null);
	if (Arrays.equal(main.sig.params, SigCache.arr_i)) return (main, [Values.i_v(cmdline_args.length)]);
	return (main, Arrays.map(main.sig.params, Values.default));
}

def MINUS_1 = HostResult.Value1(Value.I64(0xFFFFFFFF_FFFFFFFFuL));


layout WaliStruct_stat { // TODO
	=0;
}

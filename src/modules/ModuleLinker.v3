// Copyright 2023 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

/// Links the main module with the pre-loaded modules, and returns the main module instance.
///
/// The linker partially instantiates all the modules, then resolve each import to its original
/// provider, then completes the instantiation. This allows bi-directional imports among multiple modules,
/// as long as the import chain is acyclic.
class ModuleLinker(engine: Engine, program_args: Array<string>, names: Array<string>, modules: Array<Module>, error: ErrorGen) {
    private def instantiators = Strings.newMap<Instantiator>();
	private def processor_map = Strings.newMap<ImportProcessor>();

    def link() -> Instance {
		for (i < names.length) {
			var instantiator = partiallyInstantiate(i);
			if (error.error()) return null;

			instantiators[names[i]] = instantiator;
		}
		return null;

    }

    private def partiallyInstantiate(module_id: int) -> Instantiator {
        var module = modules[module_id];
		var name = names[module_id];
		var imports = Array<Exportable>.new(module.imports.length);
	    var i = Instantiator.new(engine.extensions, module, imports, error);
		var deferred_imports = Vector<int>.new();
		for (j < module.imports.length) {
	    	var imp_mod_name = module.imports[j].imp.module_name;
			if (checkName(imp_mod_name, name)) {
				deferred_imports.put(j);
				continue;
			}
			addProcessor(name, imp_mod_name, i.processors);
			if (error.error()) return null;
	    }
		i.partialRun(deferred_imports.extract());
		return i;
    }

	private def resolveImport(importer_name: string, mod_name: string, field_name: string, max_steps: int) -> Exportable {
		var i = instantiators[mod_name].instance;
		for (id < i.module.exports.length) {
			var exp = i.module.exports[id];
			if (Strings.equal(exp.0, field_name)) {
				if (i.exports[id] != null) return i.exports[id];
				if (max_steps <= 0) {
					error.set(StringBuilder.new()
						.put3("%s.wasm: cyclical import detected for %s.%s\n",
								importer_name, mod_name, field_name)
						.toString());
					return null;
				}
				var new_mod_name = exp.1.imp.module_name;
				var new_field_name = exp.1.imp.field_name;
				return resolveImport(mod_name, new_mod_name, new_field_name, max_steps - 1);
			}
		}
		error.set(StringBuilder.new()
			.put3("%s.wasm: field \"%s\" from module \"%s\" not found\n",
					importer_name, field_name, mod_name)
			.toString());
		return null;
	}

	private def addProcessor(mod_name: string, imp_mod_name: string, processors: Vector<ImportProcessor>) {
		if (processor_map[imp_mod_name] == null) {
	    	var p = ModuleRegistry.get(imp_mod_name);
	    	if (p == null) {
				error.set(StringBuilder.new()
	    			.put2("%s.wasm: import from unknown module \"%s\"\n", mod_name, imp_mod_name).toString());
				return;
			}
			var trace = Trace.moduleFilter != null && Trace.moduleFilter.matchesStr(mod_name, null);
	    	p.init(program_args, trace, error);
	    	processor_map[imp_mod_name] = p;
	    }
		processors.put(processor_map[imp_mod_name]);
	}

	private def checkName(import_module_name: string, self_name: string) -> bool {
		if (Strings.equal(import_module_name, self_name)) return false;
		for (i < names.length) if (Strings.equal(names[i], import_module_name)) return true;
		return false;
	}
}
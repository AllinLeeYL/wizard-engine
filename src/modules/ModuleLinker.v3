// Copyright 2023 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

/// Links the main module with the pre-loaded modules, and returns the main module instance.
///
/// The linker partially instantiates all the modules, then resolve each import to its original
/// provider, then completes the instantiation. This allows bi-directional imports among multiple modules,
/// as long as the import chain is acyclic.
class ModuleLinker(engine: Engine,
				   program_args: Array<string>,
				   names: Array<string>,
				   modules: Array<Module>,
				   binder: (Decl, Exportable) -> Exportable,
				   error: ErrorGen) {
    private def instantiators = Strings.newMap<(Instantiator, int)>();
	private def exportable_cache = Array<Array<(Exportable, Decl)>>.new(names.length);
	private def deferred_imports = Array<Array<int>>.new(modules.length);

    def link() -> Array<Instantiator> {
		for (i < names.length) {
			var instantiator = partiallyInstantiate(i);
			if (error.error()) return null;
			instantiators[names[i]] = (instantiator, i);
			if (modules[i].exports.length > 0) {
				exportable_cache[i] = Array<(Exportable, Decl)>.new(modules[i].exports.length);
			}
		}
		for (i < names.length) {
			if (deferred_imports[i].length == 0) continue;
			var instantiator = instantiators[names[i]].0;
			var module = modules[i];
			var imports = instantiator.imports;
			for (j < module.imports.length) {
				if (instantiator.imports[j] == null) {
					var imp_decl = module.imports[j];
					var requested_mod = imp_decl.imp.module_name;
					var requested_field = imp_decl.imp.field_name;
					instantiator.imports[j] = resolveImport(
							imp_decl,
							i,
							requested_mod,
							requested_field,
							names.length - 1).0;
					if (error.error()) return null;
				}
			}
			instantiator.runPartial(deferred_imports[i]);
			if (error.error()) return null;
		}
		var all_instantiators = Array<Instantiator>.new(names.length);
		for (i < names.length) all_instantiators[i] = instantiators[names[i]].0;
		return all_instantiators;
    }

    private def partiallyInstantiate(module_id: int) -> Instantiator {
        var module = modules[module_id];
		var name = names[module_id];
		var imports = Array<Exportable>.new(module.imports.length);
	    var i = Instantiator.new(engine.extensions, module, imports, error);
		i.binder = binder;
		var deferred_imports = Vector<int>.new();
		var processor_map = Strings.newMap<ImportProcessor>();
		for (j < module.imports.length) {
	    	var imp_mod_name = module.imports[j].imp.module_name;
			// first try to match the import to loaded wasm modules,
			// then instantiate host module processors
			if (isDynamicImport(imp_mod_name, name)) {
				deferred_imports.put(j);
				continue;
			}
			addHostModuleProcessors(j, name, imp_mod_name, i.processors, processor_map);
			if (error.error()) return null;
	    }
		this.deferred_imports[module_id] = deferred_imports.extract();
		i.runPartial(this.deferred_imports[module_id]);
		return i;
    }

	// finds the Exportable instance for each import from a partially instantiated wasm module.
	private def resolveImport(
			imp_decl: Decl,
			importer_id: int,
			requested_module: string,
			field_name: string,
			max_steps: int) -> (Exportable, Decl) {
		var requested_ins = instantiators[requested_module].0.instance;
		var req_mod_id = instantiators[requested_module].1;
		var importer_mod_name = names[importer_id];
		for (exp_id < requested_ins.module.exports.length) {
			var exp = requested_ins.module.exports[exp_id];
			if (Strings.equal(exp.0, field_name)) {
				// check cache first
				var exportable: (Exportable, Decl);
				if (exportable_cache[req_mod_id][exp_id].0 != null) {
					exportable = exportable_cache[req_mod_id][exp_id];
				} else {
					if (requested_ins.exports[exp_id] != null) {
						exportable = (
							wrapExportable(field_name, requested_ins.exports[exp_id]),
							exp.1
						);
					} else if (max_steps <= 0) {
						error.abs(u64.view(exp_id)).setc(WasmError.IMPORT_CYCLE_DETECTED, StringBuilder.new()
							.put3("%s.wasm: import cycle detected for %s.%s\n",
									importer_mod_name, requested_module, field_name)
							.toString());
						return (null, null);
					} else {
						var new_mod_name = exp.1.imp.module_name;
						var new_field_name = exp.1.imp.field_name;
						exportable = resolveImport(exp.1, req_mod_id, new_mod_name, new_field_name, max_steps - 1);
						if (error.error()) return (null, null);
					}
				}
				// cache result along the chain of "exported imports".
				exportable_cache[req_mod_id][exp_id] = exportable;
				var decl_match = validateDecl(imp_decl, exportable.1);
				if (!decl_match.0) {
					error.abs(u64.view(exp_id)).setc(WasmError.IMPORT_KIND_MISMATCH, StringBuilder.new()
						.put3("%s.wasm: kind mismatch for import %s.%s\n",
								importer_mod_name, requested_module, field_name)
						.toString());
					return (null, null);
				}
				if (!decl_match.1) {
					error.abs(u64.view(exp_id)).setc(WasmError.IMPORT_TYPE_MISMATCH, StringBuilder.new()
						.put3("%s.wasm: type mismatch for import %s.%s\n",
								importer_mod_name, requested_module, field_name)
						.toString());
					return (null, null);
				}
				return exportable;
			}
		}
		error.abs(u64.view(importer_id)).setc(WasmError.IMPORT_COUNT_MISMATCH, StringBuilder.new()
			.put3("%s.wasm: field \"%s\" from module \"%s\" not found\n",
					importer_mod_name, field_name, requested_module)
			.toString());
		return (null, null);
	}

	// for imported wasm functions, we wrap it as a HostFunction to simplify cross-module function call.
	private def wrapExportable(name: string, exp: Exportable) -> Exportable {
		if (WasmFunction.?(exp)) {
			var wf = WasmFunction.!(exp);
			return HostFunction.new(name, wf.sig, hostWrapper(wf, _));
		}
		return exp;
	}

	// ensures the import and export declarations match.
	// returns (kind match, type match)
	private def validateDecl(imp_decl: Decl, exp_decl: Decl) -> (bool, bool) {
		if (FuncDecl.?(imp_decl) && FuncDecl.?(exp_decl)) {
			var sig1 = FuncDecl.!(imp_decl).sig, sig2 = FuncDecl.!(exp_decl).sig;
			if (sig1.params.length != sig2.params.length || sig1.results.length != sig2.results.length) {
				return (true, false);
			}
			for (i < sig1.params.length) {
				if (sig1.params[i] != sig2.params[i]) return (true, false);
			}
			for (i < sig1.results.length) {
				if (sig1.results[i] != sig2.results[i]) return (true, false);
			}
			return (true, true);
		}
		if (GlobalDecl.?(imp_decl) && GlobalDecl.?(exp_decl)) {
			var global1 = GlobalDecl.!(imp_decl), global2 = GlobalDecl.!(exp_decl);
			return (true, global1.valtype == global2.valtype && (global1.mutable || !global2.mutable));
		}
		if (MemoryDecl.?(imp_decl) && MemoryDecl.?(exp_decl)) {
			var mem1 = MemoryDecl.!(imp_decl), mem2 = MemoryDecl.!(exp_decl);
			return (true, mem1.maximum == mem2.maximum && mem1.initial == mem2.initial
					&& mem1.log2_pageSize == mem2.log2_pageSize);
		}
		if (TableDecl.?(imp_decl) && TableDecl.?(exp_decl)) {
			var table1 = TableDecl.!(imp_decl), table2 = TableDecl.!(exp_decl);
			return (true, table1.elemtype == table2.elemtype
					&& table1.maximum == table2.maximum
					&& table1.initial == table2.initial);
		}
		if (TagDecl.?(imp_decl) && TagDecl.?(exp_decl)) {
			var tag1 = TagDecl.!(imp_decl), tag2 = TagDecl.!(exp_decl);
			if (tag1.fields.length != tag2.fields.length) return (true, false);
			for (i < tag1.fields.length) {
				if (tag1.fields[i] != tag2.fields[i]) return (true, false);
			}
			return (true, true);
		}
		return (false, false);
	}

	// to be partially applied to build the HostFunction wrapper for imported wasm functions.
	// skip the signature check since validation enforces typechecking.
	private def hostWrapper(wf: WasmFunction, args: Range<Value>) -> HostResult {
		match (Execute.call(wf, args)) {
			Value(vals) => {
				if (vals.length == 0) return HostResult.Value0;
				if (vals.length == 1) return HostResult.Value1(vals[0]);
				return HostResult.ValueN(vals);
			}
			Throw(thrown) => return HostResult.Throw(thrown);
			_ => ;
		}
		return HostResult.Value0;
	}

	private def addHostModuleProcessors(
				imp_id: int,
				mod_name: string,
				imp_mod_name: string,
				processors: Vector<ImportProcessor>,
				processor_map: HashMap<string, ImportProcessor>) {
		if (processor_map[imp_mod_name] == null) {
	    	var p = ModuleRegistry.get(imp_mod_name);
	    	if (p == null) {
				error.abs(u64.view(imp_id)).setc(WasmError.IMPORT_COUNT_MISMATCH, StringBuilder.new()
	    			.put2("%s.wasm: import from unknown module \"%s\"\n", mod_name, imp_mod_name).toString());
				return;
			}
			var trace = BasicTracing.moduleFilter != null && BasicTracing.moduleFilter.matchesStr(imp_mod_name, null);
			p.init(program_args, trace, error);
	    	processor_map[imp_mod_name] = p;
			processors.put(processor_map[imp_mod_name]);
	    }
	}

	private def isDynamicImport(module_name: string, self_name: string) -> bool {
		if (Strings.equal(module_name, self_name)) return false;
		for (i < names.length) if (Strings.equal(names[i], module_name)) return true;
		return false;
	}
}
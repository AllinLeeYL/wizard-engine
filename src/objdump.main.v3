// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Main entrypoint to an wasm file format dumping utility.
def main(args: Array<string>) -> int {
	var engine = Engine.new();

	engine.extensions = Extension.set.all;

	// Parse options and extract module and module arguments
	for (i < args.length) {
		var a = args[i];
		if (a.length > 0 && a[0] == '-') {
			if (!(TraceOptions.parse(a) 
				|| EngineOptions.parse(engine, a)
				|| MetricOptions.parse(a)
				)) return ErrorBuilder.new()
				.puts("objdump: unrecognized option ")
				.putsq(a)
				.ln()
				.exit(1);
			args[i] = null;
		} else if (!Strings.endsWith(a, ".wasm")) {
			return ErrorBuilder.new()
				.puts(a)
				.puts(": unknown file format, expected .wasm\n")
				.exit(4);
		}
	}

	for (a in args) {
		if (a == null) continue;
		var exit = parseAndDump(engine, a);
		if (exit != 0) return exit;
	}
	return 0;
}

def parseAndDump(engine: Engine, path: string) -> int {
	// Parse the binary module
	var result = engine.loadWasmFile(path);
	var module: Module;
	match (result) {
		Ok(m) => module = m;
		FileNotFound => return ErrorBuilder.new()
			.puts("objdump: could not load file ")
			.puts(path)
			.puts("\n")
			.exit(2);
		ParseError(code, path, section, error_index, error_pos, error_msg) => return ErrorBuilder.new()
			.render(code, path, section, error_index, error_pos, error_msg)
			.exit(3);
	}
	var names = if(module.names != null, module.names.lazyDecode());
	// Dump the binary module
	var OUT = Trace.OUT;
	for (i < module.functions.length) {
		var f = module.functions[i];
		OUT.put1("functions[%d] = ", i);
		f.render(names, OUT);
		OUT.put1(": %q", f.sig.render);
		if (f.imp == null) OUT.put1(" { %d bytes }", f.orig_bytecode.length);
		OUT.outln();
	}
	for (i < module.heaptypes.length) {
		var h = module.heaptypes[i];
		OUT.put1("heaptypes[%d] = ", i);
		h.render(OUT);
		var fh = h.getFirstSuperType();
		if (fh != null) fh.render(OUT);
		OUT.outln();
	}
	for (i < module.abstypes.length) {
		var a = module.abstypes[i];
		OUT.put1("abstypes[%d] = ", i);
		OUT.put1(": %z", a.isAssignableTo(ValueType.I32));
		OUT.outln();
	}
	for (i < module.tables.length) {
		var t = module.tables[i];
		OUT.put1("tables[%d] = ", i);
		OUT.put1(": has_default_elem %z", t.has_default_elem);
		OUT.outln();
	}
	for (i < module.tags.length) {
		var t = module.tags[i];
		OUT.put1("tags[%d] = ", i);
		if (t.fields != null) {
			for (value in t.fields) {
				OUT.put1("value: %q", value.render);
				OUT.outln();
			}
		}
		OUT.outln();
	}
	for (i < module.exports.length) {
		var e = module.exports[i];
		OUT.put1("exports[%d] = ", i);
		OUT.puts(e.0);
		OUT.outln();
	}
	OUT.put1("new functions: %d", module.new_funcs);
	OUT.outln();
	return 0;
}
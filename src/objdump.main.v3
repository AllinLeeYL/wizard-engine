// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Main entrypoint to an wasm file format dumping utility.
def main(args: Array<string>) -> int {
	var engine = Engine.new();

	engine.extensions = Extension.set.all;

	// Parse options and extract module and module arguments
	for (i < args.length) {
		var a = args[i];
		if (a.length > 0 && a[0] == '-') {
			if (!(TraceOptions.parse(a) 
				|| EngineOptions.parse(engine, a)
				|| MetricOptions.parse(a)
				)) return ErrorBuilder.new()
				.puts("objdump: unrecognized option ")
				.putsq(a)
				.ln()
				.exit(1);
			args[i] = null;
		} else if (!Strings.endsWith(a, ".wasm")) {
			return ErrorBuilder.new()
				.puts(a)
				.puts(": unknown file format, expected .wasm\n")
				.exit(4);
		}
	}

	for (a in args) {
		if (a == null) continue;
		var exit = parseAndDump(engine, a);
		if (exit != 0) return exit;
	}
	return 0;
}

def parseAndDump(engine: Engine, path: string) -> int {
	// Parse the binary module
	var result = engine.loadWasmFile(path);
	var module: Module;
	match (result) {
		Ok(m) => module = m;
		FileNotFound => return ErrorBuilder.new()
			.puts("objdump: could not load file ")
			.puts(path)
			.puts("\n")
			.exit(2);
		ParseError(code, path, section, error_index, error_pos, error_msg) => return ErrorBuilder.new()
			.render(code, path, section, error_index, error_pos, error_msg)
			.exit(3);
	}
	var names = if(module.names != null, module.names.lazyDecode());
	// Dump the binary module
	var OUT = Trace.OUT;
	for (i < module.functions.length) {
		var f = module.functions[i];
		OUT.put1("functions[%d] = ", i);
		f.render(names, OUT);
		OUT.put1(": %q", f.sig.render);
		if (f.imp == null) OUT.put1(" { %d bytes }", f.orig_bytecode.length);
		OUT.outln();
	}
	for (i < module.heaptypes.length) {
		var h = module.heaptypes[i];
		OUT.put1("heaptypes[%d] = ", i);
		h.render(OUT);
		var fh = h.getFirstSuperType();
		if (fh != null) fh.render(OUT);
		OUT.outln();
	}
	for (i < module.abstypes.length) {
		var a = module.abstypes[i];
		OUT.put1("abstypes[%d] = ", i);
		if (a.isAssignableTo(ValueType.BOTTOM)) {
			OUT.put1("%q ", ValueType.BOTTOM.render);
		}
		if (a.isAssignableTo(ValueType.I32)) {
			OUT.put1("%q ", ValueType.I32.render);
		}
		if (a.isAssignableTo(ValueType.I64)) {
			OUT.put1("%q ", ValueType.I64.render);
		}
		if (a.isAssignableTo(ValueType.F32)) {
			OUT.put1("%q ", ValueType.F32.render);
		}
		if (a.isAssignableTo(ValueType.F64)) {
			OUT.put1("%q ", ValueType.F64.render);
		}
		if (a.isAssignableTo(ValueType.V128)) {
			OUT.put1("%q ", ValueType.V128.render);
		}
		OUT.outln();
	}
	for (i < module.tables.length) {
		var t = module.tables[i];
		OUT.put1("tables[%d] default elem = ", i);
		match (t.default_elem) {
			I32 => OUT.puts("I32");
			I64 => OUT.puts("I64");
			F32 => OUT.puts("F32");
			F64 => OUT.puts("F64");
			V128 => OUT.puts("V128");
			FuncRefNull => OUT.puts("FuncRefNull");
			ExternRefNull => OUT.puts("ExternRefNull");
			Global => OUT.puts("Global");
			FuncRef => OUT.puts("FuncRef");
			Const => OUT.puts("Const");
			I31 => OUT.puts("I31");
			Array => OUT.puts("Array");
			FixedArray => OUT.puts("FixedArray");
			Struct => OUT.puts("Struct");
		}
		OUT.outln();
	}
	for (i < module.tags.length) {
		var t = module.tags[i];
		OUT.put1("tags[%d] = ", i);
		if (t.fields != null) {
			for (value in t.fields) {
				OUT.put1("value: %q", value.render);
				OUT.outln();
			}
		}
		OUT.outln();
	}
	for (i < module.exports.length) {
		var e = module.exports[i];
		OUT.put1("exports[%d] = ", i);
		OUT.puts(e.0);
		match (e.1) {
			x: SigDecl => OUT.puts(": SigDecl");
			x: StructDecl => OUT.puts(": StructDecl");
			x: ArrayDecl => OUT.puts(": ArrayDecl");
			x: AbsTypeDecl => OUT.puts(": AbsTypeDecl");
			x: FuncDecl => OUT.puts(": FuncDecl");
			x: TableDecl => OUT.puts(": TableDecl");
			x: MemoryDecl => OUT.puts(": MemoryDecl");
			x: GlobalDecl => OUT.puts(": GlobalDecl");
			x: TagDecl => OUT.puts(": TagDecl");
			x: ImportCommandDecl => OUT.puts(": ImportCommandDecl");
		}
		OUT.outln();
	}
	OUT.put1("new functions: %d", module.new_funcs);
	OUT.outln();
	return 0;
}
// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def OUT = Trace.OUT;

// Implements a simple monitor that prints each call as it happens and also keeps statistics.
class CallsMonitor extends Monitor {
	def entries = Vector<WasmFunction>.new(); 
	def counts = Vector<u64>.new();
	var depth = 0;
	var filter: DeclFilter;
	var inCodeMode = false;

	def configure(args: string) -> string {
		def argMap = MonitorOptions.parseMonitorArgs(args);
		if (argMap.has("code") || argMap.has("c")) {
			inCodeMode = true;
			var codeArg = if (argMap.has("code"), argMap["code"], argMap["c"]);
			if (codeArg == null) return null;
			filter = DeclFilter.new(codeArg);
			return null;
		}
		def buf = StringBuilder.new();
		buf.put1("invalid argument(s) \"%s\"", args);
		return buf.toString();
	}
	def onParse(module: Module) {
		var mm = ModuleMonitor.new(module);
		if (!inCodeMode) {
			entries.putn(null, module.functions.length);
			counts.putn(0, module.functions.length);
			mm.forEachFunc(isFuncMonitored, mm.beforeFuncExec(_, beforeFuncExec));
		} else {
			mm.forEachFunc(isFuncMonitored, mm.beforeFuncExecAndReturn(_, beforeFuncExec, beforeFuncReturn));
		}
	}
	def onFinish(i: Instance) {
		if (inCodeMode) return;
		// output summary in code mode
		for (i < entries.length) {
			var count = counts[i], e = entries[i];
			if (count > 0) {
				OUT.puts(Palette.FUNC);
				e.render(OUT);
				OUT.puts(Palette.DEFAULT)
					.putc(':')
					.puts(Palette.COUNT)
					.puts("  ")
					.putd(count)
					.puts(Palette.DEFAULT);
				OUT.outln();
			}
		}
	}

	private def isFuncMonitored(module: Module, func: FuncDecl) -> bool {
		if (filter != null && !filter.matches(module, func)) return false;
		if (MonitorUtil.isImport(module, func)) return false;
		return true;
	}
	private def beforeFuncExec(dynamicLoc: DynamicLoc) -> Resumption {
		var func = dynamicLoc.func;
		if (!inCodeMode) {
			var idx = func.decl.func_index;
			entries[idx] = func;
			counts[idx]++;
			return Resumption.Continue;
		}
		match (depth) {
			0 => OUT.puts(Palette.VERY_LOW);
			1 => OUT.puts(Palette.LOW);
			2 => OUT.puts(Palette.MEDIUM);
			3 => OUT.puts(Palette.HIGH);
			_ => OUT.puts(Palette.VERY_HIGH);
		}
		for (i < depth) OUT.puts("  ");
		depth++;
		func.render(OUT);
		OUT.outln();
		return Resumption.Continue;
	}
	private def beforeFuncReturn(dynamicLoc: DynamicLoc) -> Resumption {
		depth--;
		return Resumption.Continue;
	}
}

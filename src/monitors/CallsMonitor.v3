// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def OUT = Trace.OUT;

// Implements a simple monitor that prints each call as it happens and also keeps statistics.
class CallsMonitor extends Monitor {
	def entries = Vector<WasmFunction>.new(); 
	def count = Vector<int>.new(); 
	def counts = Vector<u64>.new();
	var depth = 0;
	var filter: DeclFilter;
	var inCodeMode = false;

	def configure(args: string) -> string {
		if (Strings.startsWith(args, "code") || Strings.startsWith(args, "c")) {
			inCodeMode = true;
			var i = 0;
			while(i < args.length && args[i] != '=') i++;
			if (i == args.length) return null;
			filter = DeclFilter.new(Arrays.range(args, i + 1, args.length));
			return null;
		}
		if (args.length > 0) {
			def buf = StringBuilder.new();
			buf.put1("invalid argument(s) \"%s\"", args);
			return buf.toString();
		}
		return null;
	}
	def onParse(module: Module) {
		var mm = ModuleMonitor.new(module);
		if (!inCodeMode) {
			entries.putn(null, module.functions.length);
			count.putn(0, module.functions.length);
			mm.forEachFunc(isFuncMonitored, mm.beforeFuncExec(_, beforeFuncExec));
		} else {
			mm.forEachFunc(isFuncMonitored, mm.beforeFuncExecAndReturn(_, beforeFuncExec, beforeFuncReturn));
		}
	}
	def onFinish(i: Instance) {
		if (inCodeMode) return;
		// output summary in code mode
		for (i < entries.length) {
			var count = count[i], e = entries[i];
			if (count > 0) {
				e.render(OUT);
				OUT.puts(Palette.COUNT)
				    .putc('\t')
				    .putd(count)
				    .puts(Palette.DEFAULT)
				    .outln();
			}
		}
	}

	private def isFuncMonitored(module: Module, func: FuncDecl) -> bool {
		if (filter != null && !filter.matches(module, func)) return false;
		if (MonitorUtil.isImport(module, func)) return false;
		return true;
	}
	private def beforeFuncExec(dynamicLoc: DynamicLoc) -> Resumption {
		var func = dynamicLoc.func;
		if (!inCodeMode) {
			var idx = func.decl.func_index;
			entries[idx] = func;
			count[idx]++;
			return Resumption.Continue;
		}
		match (depth) {
			0 => OUT.puts(Palette.VERY_LOW);
			1 => OUT.puts(Palette.LOW);
			2 => OUT.puts(Palette.MEDIUM);
			_ => OUT.puts(Palette.HIGH);
		}
		for (i < depth) OUT.puts("  ");
		depth++;
		func.render(OUT);
		OUT.outln();
		return Resumption.Continue;
	}
	private def beforeFuncReturn(dynamicLoc: DynamicLoc) -> Resumption {
		depth--;
		return Resumption.Continue;
	}
}

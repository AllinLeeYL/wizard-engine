private class FuncEnterNoLoopProbe(probe: Probe) extends Probe {
	var frameAccessor: FrameAccessor;
	def fire(func: WasmFunction, pc: int, frame: TargetFrame) -> Resumption {
		var curAccessor = frame.getFrameAccessor();
		if (curAccessor == frameAccessor) return Resumption.Continue;
		frameAccessor = curAccessor;
		return probe.fire(func, pc, frame);
	}
}
private class FuncEnterLoopProbe(probe: Probe) extends Probe {
	var frameAccessors: List<FrameAccessor>;
	def fire(func: WasmFunction, pc: int, frame: TargetFrame) -> Resumption {
		while (frameAccessors != null && frameAccessors.head.isUnwound())
			frameAccessors = frameAccessors.tail;
        var curAccessor = frame.getFrameAccessor();
		if (frameAccessors != null && curAccessor == frameAccessors.head)
			return Resumption.Continue;
		frameAccessors = List.new(curAccessor, frameAccessors);
		return probe.fire(func, pc, frame);
	}
}

component FuncMonitorUtil {
	def probeOnEnterFunc(module: Module, func: FuncDecl, probe: Probe) {
		var it = BytecodeIterator.new();
		var bi = it.reset(func);
		if (bi.current() == Opcode.LOOP) {
			module.insertProbeAt(func.func_index, bi.pc, FuncEnterLoopProbe.new(probe));
		} else {
			module.insertProbeAt(func.func_index, bi.pc, FuncEnterNoLoopProbe.new(probe));
		}
	}
	def probeOnExitFunc(module: Module, func: FuncDecl, probe: Probe) {
		var it = BytecodeIterator.new();
		var bi = it.reset(func);

        for (bi = it.reset(func); bi.more(); bi.next()) {
            var op = bi.current();
            match (op) {
                RETURN => ;
                END => if (bi.pc + 1 < bi.func.cur_bytecode.length) continue;
                _ => continue;
            }

            module.insertProbeAt(func.func_index, bi.pc, probe);
        }
	}
}
// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implements a simple monitor that tracks code coverage.
class CoverageMonitor extends Monitor {
	def entries = Vector<CoverageMonitorProbe>.new();
	def isStartOfBlock = Vector<bool>.new();
	def executed = Vector<bool>.new();
	def var inBasicBlockMode = true;
	def var inCodeMode = false;
	var lowCoverageBar = 75; // in % (used for coloring)

	def configure(args: string) -> string { // TODO: Implement multi-argument parsing
		if (Strings.equal(args, "instr") || Strings.equal(args, "i")) {
			inBasicBlockMode = false;
			return null;
		}
		if (Strings.equal(args, "code") || Strings.equal(args, "c")) {
			inCodeMode = true;
			return null;
		}
		def buf = StringBuilder.new();
		buf.put1("invalid argument(s) \"%s\"", args);
		return buf.toString();
	}

	def onParse(m: Module) {
		for (i < m.functions.length) {
			var f = m.functions[i];
			if (f.imp != null) continue; // skip imported functions
			var offset = executed.length;
			var p = CoverageMonitorProbe.new(m, f, this, offset);
			entries.put(p);
			executed.putn(false, f.cur_bytecode.length);

			if (inBasicBlockMode)
				isStartOfBlock.putn(false, f.cur_bytecode.length);

			var addToNext = true;
			for (bi = BytecodeIterator.new().reset(f); bi.more(); bi.next()) {
				var op = bi.current();
				if (inBasicBlockMode) {
					if (addToNext) {
						addToNext = false;
						isStartOfBlock[offset + bi.pc] = true;
						m.insertProbeAt(f.func_index, bi.pc, p);
					}
					match (op) {
						BLOCK, LOOP, ELSE, TRY, CATCH, CATCH_ALL => {
							isStartOfBlock[offset + bi.pc] = true;
							m.insertProbeAt(f.func_index, bi.pc, p);
						}
						BR, BR_IF, BR_TABLE, IF, THROW, RETHROW, END => addToNext = true;
						_ => ;
					}
				} else {
					m.insertProbeAt(f.func_index, bi.pc, p);
				}
			}
		}
	}
	def onExit(code: int) {
		onFinish(null);
	}
	def onFinish(i: Instance) {
		var prev: FuncDecl;
		var tracer = InstrTracer.new(), d = DataReader.new([]);
		var blockCovered = false;
		var it = BytecodeIterator.new();
		if (inCodeMode || !inBasicBlockMode) {
			for (j < entries.length) {
				var e = entries[j];
				Trace.OUT.puts(TermColors.CYAN);
				Trace.OUT.put1("func %q:", e.func.render(e.module.names, _)).outln();
				Trace.OUT.puts(TermColors.DEFAULT);
				for (bi = it.reset(e.func); bi.more(); bi.next()) {
					bi.current();
					d.reset(e.func.orig_bytecode, bi.pc, e.func.orig_bytecode.length);
					if (inBasicBlockMode) {
						var isStart = isStartOfBlock[e.start + bi.pc];
						if (isStart) {
							blockCovered = executed[e.start + bi.pc];
							if (blockCovered) {
								Trace.OUT.puts(TermColors.BRIGHT_GREEN);
								Trace.OUT.put1("+%d\t", bi.pc);
								Trace.OUT.puts("->");
							} else {
								Trace.OUT.puts(TermColors.GRAY12);
								Trace.OUT.put1("+%d\t", bi.pc);
							}
						} else {
							if (!blockCovered) Trace.OUT.puts(TermColors.GRAY12);
							else Trace.OUT.puts(TermColors.DEFAULT);
							Trace.OUT.puts("-\t");
						}
						if (blockCovered) {
							Trace.OUT.puts(TermColors.BRIGHT_GREEN);
							Trace.OUT.puts(if(isStart, "  ", "    "));
						} else {
							Trace.OUT.puts("    ");
						}
						Trace.OUT.puts(TermColors.DEFAULT);
						if (!blockCovered) Trace.OUT.puts(TermColors.GRAY12);
						else if (isStart) Trace.OUT.puts(TermColors.WHITE);
						tracer.putInstr(Trace.OUT, e.module, d);
						Trace.OUT.puts(TermColors.DEFAULT);
						Trace.OUT.outln();
					} else {
						var byteCovered = executed[e.start + bi.pc];
						if (byteCovered) {
							Trace.OUT.puts(TermColors.BRIGHT_GREEN);
							Trace.OUT.put1("+%d\t", bi.pc);
							Trace.OUT.puts(" * ");
						} else {
							Trace.OUT.puts(TermColors.GRAY12);
							Trace.OUT.put1("+%d\t", bi.pc);
							Trace.OUT.puts("   ");
						}
						Trace.OUT.puts(TermColors.DEFAULT);
						if (!byteCovered) Trace.OUT.puts(TermColors.GRAY12);
						tracer.putInstr(Trace.OUT, e.module, d);
						Trace.OUT.puts(TermColors.DEFAULT);
						Trace.OUT.outln();
					}
				}
			}
		} else { // for summary when no args given
			var bytesCovered = 0;
			var totalBytes = 0;
			var blocksCovered = 0;
			var totalBlocks = 0;
			for (j < entries.length) {
				var e = entries[j];
				var prevPc = 0;
				for (bi = it.reset(e.func); bi.more(); bi.next()) {
					bi.current();
					d.reset(e.func.orig_bytecode, bi.pc, e.func.orig_bytecode.length);
					if (isStartOfBlock[e.start + bi.pc]) {
						totalBlocks++;
						if (executed[e.start + bi.pc]) blocksCovered++;
					}
					totalBytes += bi.pc - prevPc;
					if (executed[e.start + bi.pc]) bytesCovered += bi.pc - prevPc;
					prevPc = bi.pc;
				}
			}
			var byteCovPercentage = 100 * bytesCovered / totalBytes;
			var blockCovPercentage = 100 * blocksCovered / totalBlocks;
			Trace.OUT.puts("Byte coverage:\t");
			Trace.OUT.puts(TermColors.WHITE);
			Trace.OUT.put2("%d out of %d ", bytesCovered, totalBytes);
			Trace.OUT.puts(TermColors.BRIGHT_GREEN);
			if (byteCovPercentage < 100) Trace.OUT.puts(TermColors.YELLOW);
			if (byteCovPercentage < lowCoverageBar) Trace.OUT.puts(TermColors.BRIGHT_RED);
			Trace.OUT.put1("(%d%%)", byteCovPercentage).outln();
			Trace.OUT.puts(TermColors.DEFAULT);
			Trace.OUT.puts("Block coverage:\t");
			Trace.OUT.puts(TermColors.WHITE);
			Trace.OUT.put2("%d out of %d ", blocksCovered, totalBlocks);
			Trace.OUT.puts(TermColors.BRIGHT_GREEN);
			if (blockCovPercentage < 100) Trace.OUT.puts(TermColors.YELLOW);
			if (blockCovPercentage < lowCoverageBar) Trace.OUT.puts(TermColors.RED);
			Trace.OUT.put1("(%d%%)", blockCovPercentage).outln();
			Trace.OUT.puts(TermColors.DEFAULT);
		}
	}
}
class CoverageMonitorProbe(module: Module, func: FuncDecl, monitor: CoverageMonitor, start: int) extends Probe {
	def fire(dynamicLoc: DynamicLoc) -> Resumption {
		monitor.executed[dynamicLoc.pc + start] = true;
		module.removeProbeAt(dynamicLoc.func.decl.func_index, dynamicLoc.pc, this);
		return Resumption.Continue;
	}
}

// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def OUT = Trace.OUT;

// Implements a simple monitor that tracks code coverage.
class CoverageMonitor extends Monitor {
	def entries = Vector<CoverageMonitorProbe>.new();
	def isStartOfBlock = Vector<bool>.new();
	def executed = Vector<bool>.new();
	var inBasicBlockMode = true;
	var inCodeMode = false;
	var lowCoverageThreshold = 75; // in %, for highlighting low coverages

	def configure(args: string) -> string {
		def argMap = MonitorOptions.parseMonitorArgs(args);
		if (argMap.has("code") || argMap.has("c")) {
			inCodeMode = true;
			inBasicBlockMode = true;
			var codeArg = if (argMap.has("code"), argMap["code"], argMap["c"]);
			if (codeArg == null) return null;
			if (Strings.equal(codeArg, "instr") || Strings.equal(codeArg, "i")) {
				inBasicBlockMode = false;
			}
			return null;
		}
		def buf = StringBuilder.new();
		buf.put1("invalid argument(s) \"%s\"", args);
		return buf.toString();
	}

	def onParse(m: Module) {
		for (i < m.functions.length) {
			var f = m.functions[i];
			if (f.imp != null) continue; // skip imported functions
			var offset = executed.length;
			var p = CoverageMonitorProbe.new(m, f, this, offset);
			entries.put(p);
			executed.putn(false, f.cur_bytecode.length);

			if (inBasicBlockMode)
				isStartOfBlock.putn(false, f.cur_bytecode.length);

			var addToNext = true;
			for (bi = BytecodeIterator.new().reset(f); bi.more(); bi.next()) {
				var op = bi.current();
				if (inBasicBlockMode) {
					if (addToNext) {
						addToNext = false;
						isStartOfBlock[offset + bi.pc] = true;
						m.insertProbeAt(f.func_index, bi.pc, p);
					}
					match (op) {
						BLOCK, LOOP, ELSE, TRY, CATCH, CATCH_ALL => {
							isStartOfBlock[offset + bi.pc] = true;
							m.insertProbeAt(f.func_index, bi.pc, p);
						}
						BR, BR_IF, BR_TABLE, IF, THROW, RETHROW, END => addToNext = true;
						_ => ;
					}
				} else {
					m.insertProbeAt(f.func_index, bi.pc, p);
				}
			}
		}
	}
	def onExit(code: int) {
		onFinish(null);
	}
	def onFinish(i: Instance) {
		var prev: FuncDecl;
		var tracer = InstrTracer.new(), d = DataReader.new([]);
		var blockCovered = false;
		var it = BytecodeIterator.new();
		if (inCodeMode) {
			for (j < entries.length) {
				var e = entries[j];
				OUT.puts(Palette.FUNC).put1("func %q:", e.func.render(e.module.names, _)).outln();
				for (bi = it.reset(e.func); bi.more(); bi.next()) {
					bi.current();
					d.reset(e.func.orig_bytecode, bi.pc, e.func.orig_bytecode.length);
					if (inBasicBlockMode) {
						var isStart = isStartOfBlock[e.start + bi.pc];
						if (isStart) {
							blockCovered = executed[e.start + bi.pc];
							if (blockCovered) {
								OUT.puts(Palette.LNO)
								    .rjustify(' ', TraceUtil.renderedLength(OUT, TraceBuilder.put1(_, "+%d", bi.pc)), 5)
								    .puts(Palette.COVERED)
								    .puts(" -->")
								    .puts(Palette.DEFAULT);
							} else {
								OUT.puts(Palette.UNREACHABLE)
								    .rjustify(' ', TraceUtil.renderedLength(OUT, TraceBuilder.put1(_, "+%d", bi.pc)), 5);
							}
						} else {
							if (!blockCovered) OUT.puts(Palette.UNREACHABLE);
							else OUT.puts(Palette.DEFAULT);
							OUT.rjustify(' ', TraceUtil.renderedLength(OUT, TraceBuilder.putc(_, '-')), 5);
						}
						if (blockCovered) {
							OUT.puts(Palette.COVERED).puts(if(isStart, "  ", "    "));
						} else {
							OUT.puts("    ");
						}
						OUT.puts(Palette.DEFAULT);
						if (!blockCovered) OUT.puts(Palette.UNREACHABLE);
						else if (isStart) OUT.puts(Palette.COVERED_FG).puts(Palette.COVERED_BG);
						OUT.putc('\t');
						tracer.putInstr(OUT, e.module, d);
						OUT.puts(Palette.DEFAULT).outln();
					} else {
						var byteCovered = executed[e.start + bi.pc];
						if (byteCovered)  OUT.puts(Palette.LNO);
						else  OUT.puts(Palette.UNREACHABLE); 
						OUT.rjustify(' ', TraceUtil.renderedLength(OUT, TraceBuilder.put1(_, "+%d", bi.pc)), 5);
						OUT.puts("  ");
						if (!byteCovered)  OUT.puts(Palette.UNREACHABLE);
						else OUT.puts(Palette.COVERED_FG).puts(Palette.COVERED_BG);
						tracer.putInstr(OUT, e.module, d);
						OUT.puts(Palette.DEFAULT).outln();
					}
				}
			}
		} else { // for summary when no args given
			var bytesCovered = 0;
			var totalBytes = 0;
			var blocksCovered = 0;
			var totalBlocks = 0;
			for (j < entries.length) {
				var e = entries[j];
				var prevPc = 0;
				for (bi = it.reset(e.func); bi.more(); bi.next()) {
					bi.current();
					d.reset(e.func.orig_bytecode, bi.pc, e.func.orig_bytecode.length);
					if (isStartOfBlock[e.start + bi.pc]) {
						totalBlocks++;
						if (executed[e.start + bi.pc]) blocksCovered++;
					}
					totalBytes += bi.pc - prevPc; // FIXME: Incorrect calculation
					if (executed[e.start + bi.pc]) bytesCovered += bi.pc - prevPc; // FIXME: Incorrect calculation
					prevPc = bi.pc;
				}
			}
			var byteCovPercentage = 100 * bytesCovered / totalBytes;
			var blockCovPercentage = 100 * blocksCovered / totalBlocks;
			OUT.puts("Instr coverage:\t")
			    .puts(Palette.ACTIVE)
			    .putd(bytesCovered)
			    .puts(Palette.DEFAULT)
			    .put1(" / %d ", totalBytes);
			OUT.puts("(").puts(Palette.SUCCESS);
			if (byteCovPercentage < 100) OUT.puts(Palette.WARN);
			if (byteCovPercentage < lowCoverageThreshold) OUT.puts(Palette.DANGER);
			TraceUtil.renderPercent(OUT, bytesCovered, totalBytes, 1);
			OUT.puts(Palette.DEFAULT).puts(")").outln()
			    .puts("Block coverage:\t")
			    .puts(Palette.ACTIVE)
			    .putd(blocksCovered)
			    .puts(Palette.DEFAULT)
			    .put1(" / %d ", totalBlocks);
			OUT.puts("(").puts(Palette.SUCCESS);
			if (blockCovPercentage < 100) OUT.puts(Palette.WARN);
			if (blockCovPercentage < lowCoverageThreshold) OUT.puts(Palette.DANGER);
			TraceUtil.renderPercent(OUT, blocksCovered, totalBlocks, 1);
			OUT.puts(Palette.DEFAULT).puts(")").outln();
		}
	}
}
class CoverageMonitorProbe(module: Module, func: FuncDecl, monitor: CoverageMonitor, start: int) extends Probe {
	def fire(dynamicLoc: DynamicLoc) -> Resumption {
		monitor.executed[dynamicLoc.pc + start] = true;
		module.removeProbeAt(dynamicLoc.func.decl.func_index, dynamicLoc.pc, this);
		return Resumption.Continue;
	}
}

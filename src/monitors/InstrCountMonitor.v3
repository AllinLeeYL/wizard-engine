// Copyright 2024 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def E_ = MonitorRegistry.register(
	"icount", "Tallies instruction counts per function.",
	InstrCountMonitor.new());

def countEveryInstr = false; // if true, use a probe on every single instruction

class InstrCountMonitor extends Monitor {
	def entries = Vector<(FuncDecl, CountProbe)>.new();

	def onParse(module: Module) {
		var ins = InstrCountInstrumenter.new(module);
		for (i < module.functions.length) {
			var func = module.functions[i];
			if (func.imp != null) continue;
			ins.run(func);
			entries.put(func, ins.probe);
		}
	}
	def onFinish(i: Instance) {
		var names = i.module.names;
		for (i < entries.length) {
			var e = entries[i], func = e.0, count = e.1.count;
			if (count == 0) continue;
			Trace.OUT.puts(Palette.FUNC)
				.put1("func %q:", func.render(names, _))
				.puts(Palette.DEFAULT)
				.put1(" %d instrs", count)
				.outln();
		}
	}
}

class InstrCountInstrumenter(module: Module) extends BytecodeVisitor {
	def bi = BytecodeIterator.new();
	var func: FuncDecl;
	var probe: CountProbe;
	var last_pc: int;
	var count: u32;

	def run(f: FuncDecl) {
		func = f;
		bi.reset(func);
		probe = CountProbe.new();
		while (bi.more()) {
			bi.dispatch(this);
			last_pc = bi.pc;
			bi.next();
		}
	}

	def visitControl(op: Opcode) {
		if (countEveryInstr) return visitOp(op);
		if (op == Opcode.LOOP || op == Opcode.END) { // target of a label
			if (count > 0) Instrumentation.insertLocalProbe(module, func.func_index, last_pc, CountMoreProbe.new(probe, count));
			Instrumentation.insertLocalProbe(module, func.func_index, bi.pc, probe);
		} else {
			count++;
			Instrumentation.insertLocalProbe(module, func.func_index, bi.pc, if(count > 1, CountMoreProbe.new(probe, count), probe));
		}
		count = 0;
	}

	def visitOp(op: Opcode) {
		if (countEveryInstr) Instrumentation.insertLocalProbe(module, func.func_index, bi.pc, probe);
		else count++;
	}
}
// Copyright 2023 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implements a simple monitor that counts the static and dynamic occurrences of each opcode.
def E = MonitorRegistry.register(
	"opcodes", "Tallies static and dynamic counts of each Wasm opcode.",
	OpcodeMonitor.new());

class OpcodeMonitor extends Monitor {
	def entries = Vector<OpcodeEntry>.new();
	def it = BytecodeIterator.new();
	var inCodeMode = false;

	def onParse(m: Module) {
		var mm = ModuleMonitor.new(m);
		mm.forEachFunc(MonitorUtil.isNotImport, monitorFunc(mm, _));
	}

	def onExit(val: int) {
		output(entries);
	}
	def onFinish(i: Instance) {
		output(entries);
	}

	private def monitorFunc(mm: ModuleMonitor, func: FuncDecl) {
		for (bi = it.reset(func); bi.more(); bi.next()) {
			var op = bi.current();
			var probe: CountProbe;
			if (op.tag >= entries.length) {
				probe = CountProbe.new();
				entries.set(op.tag, OpcodeEntry(op, 1, probe));
			} else {
				var e = entries[op.tag];
				probe = if(e.count != null, e.count, CountProbe.new());
				entries[op.tag] = OpcodeEntry(op, e.static_count + 1u, probe);
			}
			Instrumentation.insertLocalProbe(mm.module, func.func_index, bi.pc, probe);
		}
	}
}

type OpcodeEntry(op: Opcode, static_count: u32, count: CountProbe) #unboxed;

def compare(a: OpcodeEntry, b: OpcodeEntry) -> bool {
	if (a.count == null) return false;
	if (b.count == null) return true;
	return a.count.count > b.count.count;
}

def output(entries: Vector<OpcodeEntry>) {
	def out = Trace.OUT;
	if (MonitorOptions.csv) {
		out.puts("opcode,static,dynamic").outln();
	} else {
		out.puts(" Opcode                        static   dynamic").outln();
		out.puts("------------------------------------------------").outln();
	}
	var array = entries.copy();
	array = Arrays.sort(array, 0, array.length, compare);
	for (e in array) {
		if (e.count == null) continue;
		if (MonitorOptions.csv) {
			out
			   .puts(e.op.name)
			   .putc(',')
			   .putd(e.static_count)
			   .putc(',')
			   .putd(e.count.count)
			   .outln();
		} else {
			out
			   .puts(if(e.count.count > 0, Palette.COVERED, Palette.UNREACHABLE))
			   .sp()
			   .mark()
			   .puts(e.op.name)
			   .sp()
			   .ljustify_mark(29)
			   .puts(Palette.COUNT)
			   .putd_rjustified(7, e.static_count)
			   .sp()
			   .putd_rjustified(9, e.count.count)
			   .puts(Palette.DEFAULT)
			   .outln();
		   }
	}
}
// Copyright 2024 Wizard authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// This class implements a monitor that is implemented in WebAssembly, i.e. as a Whamm
// module. Such modules have exported functions whose names describe how to attach
// behavior to events.

// Event names supported:
//   wasm:opcode:<mnemonic>			Before matching opcodes execute

// TODO:
//  - type errors should be ignored, considered no match
//    arguments, locals, everything else Crash
//    OPTION to warn
//  - thread error reporter through monitor
//  - report callbacks
//  - binding callbacks
//  - define frame accessor methods
//  - externref in Virgil
//   before:opcode:call(<func pattern>)		Upon static direct calls to func
//   before:call:<func pattern>
//   before:enter:<func pattern>			Entry of function(s)
//   before:return:<func pattern>
//   before:unwind:<func pattern>
//   before:throw
//   before:catch
//   before:parse					Upon module parse
//   before:instantiate
//   before:start
//   before:main
//   before:exit
class WhammMonitor(whamm: Module) extends Monitor {
	var onParseF: int = -1;
	var onInstantiateF: int = -1;
	var onStartF: int = -1;
	var onMainF: int = -1;
	var onInstanceF: int = -1;
	var onExitF: int = -1;
	var opcodePatterns: Array<List<(Opcode, Array<WhammParam>, FuncDecl)>>;
	var whammInstances: List<(Module, Instance, InstanceRef)>; // XXX: leaky

	new() {
		if (Trace.whamm) Trace.OUT.put1("parsing whamm monitor: %s", whamm.filename).ln();
		for (i < whamm.exports.length) {
			var e = whamm.exports[i], name = e.0, decl = e.1;
			if (!FuncDecl.?(decl)) continue;
			if (Trace.whamm) Trace.OUT.put2("  export %d: \"%s\" = ", i, name).ln();
			var func = FuncDecl.!(decl);
			var r = TextReader.new(whamm.filename, name);
			var t = Whamm.parseOpcodePattern(r), op = t.0, params = t.1;
			if (!r.ok) {
				// parse error
				Trace.OUT.put1("whamm warning: export[%d] function name is invalid opcode pattern", i).ln();
				r.renderCurrentLineWithCaret(Trace.OUT, r.error_column);
				Trace.OUT.sp().puts(r.error_msg);
				Trace.OUT.ln();
				if (Trace.fatal) System.error("MonitorError", "failed parsing whamm monitor");
			} else if (t.0 == Opcode.INVALID) {
				// no events matched
				if (Trace.whamm) Trace.OUT.puts("no events matched").ln();
			} else {
				// ok, add opcode pattern to table
				if (Trace.whamm) {
					Trace.OUT.put1("opcode %s", op.mnemonic);
					if (params.length > 0) Trace.OUT.putTuple(params, WhammParam.render).ln();
				}
				if (opcodePatterns == null) opcodePatterns = Array.new(Opcodes.count);
				opcodePatterns[op.tag] = List.new((op, params, func), opcodePatterns[op.tag]);
			}
		}
	}
  // monitors called on parsed modules
	def onParse(module: Module, err: ErrorGen) {
	    // What extensions?
		var wi = getWhammInstance(module).0;
		if (wi == null) return;
		if (onParseF >= 0) {
			def moduleRef = ModuleRef.new(module);
			Execute.call(wi.functions[onParseF], [Value.Ref(moduleRef)]); // TODO: report traps
		}
		if (opcodePatterns == null) return;
		for (i < module.functions.length) {
		    // iterate over the functions in the module
			var func = module.functions[i];
			if (func.imp != null) continue; // imported

      // parsed module is already validated, so we don't expect a new error here
	    var cv = CodeValidator.new(Extension.WIZENG, Limits.new(), module, ErrorGen.new(""));
      cv.probe = bytecodeProbe(module, wi, func, _, _, _);
			cv.validateFunc(func);
		}
	}

	def bytecodeProbe(module: Module, wi: Instance, func: FuncDecl, cv: CodeValidator, opcode_pos: int, opcode: Opcode) {
    var bp = opcodePatterns[opcode.tag];

		for (l = bp; l != null; l = l.tail) { // for every probe
  		if (Trace.whamm) Trace.OUT.put3("  match func %q+%d: %s", func.render(module.names, _), opcode_pos, opcode.mnemonic).ln();
			var wf   = WasmFunction.!(wi.functions[bp.head.2.func_index]);
			var args = bindParams(cv, wf, wi, bp.head.1, opcode, false);
			Instrumentation.insertLocalProbe(module, func.func_index, opcode_pos, WhammProbe.new(wf, args));
		}
	}

	def bindParams(cv: CodeValidator, wf: WasmFunction, wi: Instance,
	               params: Array<WhammParam>, op: Opcode, nested: bool) -> Array<WhammArg> {
		var args = Array<WhammArg>.new(params.length);
	  def expParams = wf.sig.params;  // expected params of WasmFunction

	  if (expParams.length != args.length) {
      System.error("Whamm probe error", "arity mismatch");	    // TODO this is a true error
	  }

		for (i < args.length) {
			var arg: WhammArg;
			match (params[i]) {
				DynamicLoc     => ; // TODO
				FrameAccessor  => {
				  arg = WhammArg.FrameAccessor; // type externref
				  if (expParams[i] != ValueTypes.EXTERNREF) {
            System.error("Whamm probe error", "type mismatch"); // TODO true error
				  }
			  }
				Pc             => {
          arg = WhammArg.Val(Values.i_v(cv.opcode_pos));
				  if (expParams[i] != ValueType.I32) {
            System.error("Whamm probe error", "type mismatch"); // TODO true error
				  }
				}
				Func           => {
          arg = WhammArg.Val(Values.i_v(cv.func.func_index));
          if (expParams[i] != ValueType.I32) {
            System.error("Whamm probe error", "type mismatch"); // TODO true error
				  }
				}
				Imm(orig, j)   => {
				  def imms = op.imms;
	        def parser = dupParser(cv);
          def vals = Vector<Value>.new();

          for (i < imms.length) {
            match (imms[i]) {
            	ARRAY_TYPE_INDEX  => vals.put(Values.u_v(parser.readU32("array type index", u32.!(-1))));
            	BLOCK_TYPE        => vals.put(Values.i_v(parser.readTypeCode()));
            	DATA_INDEX        => vals.put(Values.u_v(parser.readU32("data index", u32.!(-1))));
            	ELEM_INDEX        => vals.put(Values.u_v(parser.readU32("elem index", u32.!(-1))));
            	TAG_INDEX         => vals.put(Values.u_v(parser.readU32("tag index", u32.!(-1))));
            	FIELD_INDEX       => vals.put(Values.u_v(parser.readU32("field index", u32.!(-1))));
            	FUNC_INDEX        => vals.put(Values.u_v(parser.readU32("func index", u32.!(-1))));
            	GLOBAL_INDEX      => vals.put(Values.u_v(parser.readU32("global index", u32.!(-1))));
            	LABEL             => vals.put(Values.u_v(parser.readLabel()));
            	LABELS            => {
            	  def labels = parser.readLabels();
            	  // NOTE hardcoded, because BR_TABLE is the only one that uses imm.LABELS
            	  vals.put(Values.i_v(labels.length - 1));
            	  vals.puta(Arrays.map(labels, Values.u_v));
          	  }
            	LOCAL_INDEX       => vals.put(Values.u_v(parser.readU32("local index", u32.!(-1))));
            	MEMARG            => {
            	  // TODO discuss memarg format
                def memarg = parser.readMemoryArg();
                vals.put(Values.u_v(memarg.flags));
                vals.put(Values.u_v(memarg.memory_index));
                vals.put(Values.u_v(u32.!(memarg.offset)));
            	}
            	MEMORY_INDEX      => vals.put(Values.u_v(parser.readU32("memory index", u32.!(-1))));
            	HEAP_TYPE         => vals.put(Values.i_v(parser.readTypeCode()));
            	SIG_INDEX         => vals.put(Values.u_v(parser.readU32("sig index", u32.!(-1))));
            	STRUCT_TYPE_INDEX => vals.put(Values.u_v(parser.readU32("struct type index", u32.!(-1))));
            	TABLE_INDEX       => vals.put(Values.u_v(parser.readU32("table index", u32.!(-1))));
            	VALUE_TYPES       => ;		// TODO
            	ZERO_BYTE         => vals.put(Values.u_v(parser.decoder.read1()));
            	U32               => vals.put(Values.u_v(parser.readU32("imm U32", u32.!(-1))));
            	I32               => vals.put(Values.i_v(parser.readI32()));
            	I64               => vals.put(Values.l_v(parser.readI64()));
            	F32               => vals.put(Values.f_v(parser.readF32()));
            	F64               => vals.put(Values.d_v(parser.readF64()));
            	V128              => vals.put(Values.s_v(parser.readF64(), parser.readF64()));  // TODO incorrect?
            	LANE_INDEX        => vals.put(Values.u_v(parser.decoder.read1()));
            	BR_CAST           => ;    // TODO
            	CATCHES           => ;		// TODO
            	CONT_INDEX        => ;		// TODO
            	HANDLERS          => ;		// TODO
            }
          }

          // TODO this is a true error on most opcodes, but an unmatch upcode on some (which ones? e.g. br_table)
          if (j >= vals.length) System.error("Whamm probe error", "immN out of bounds");

          arg = WhammArg.Val(vals[j]);
          var t: ValueType;
          match (vals[j]) {
            Ref(_)     => ; // TODO
            I31(_)     => ; // TODO
            I32(_)     => t = ValueType.I32;
            I64(_)     => t = ValueType.I64;
            F32(_)     => t = ValueType.F32;
            F64(_)     => t = ValueType.F64;
            V128(_, _) => t = ValueType.V128;
          }
          if (expParams[i] != t) {
            System.error("Whamm probe error", "type mismatch"); // TODO true error
          }
				}
				Arg(orig, i)   => {  // arg0 = first arg to bytecode
				  def io = Opcodes.stackDelta(cv.sig, op, dupParser(cv));
				  def args = io.0;
				  if (i >= args) {
            System.error("Whamm probe error", "argN out of bounds");
				  }
			    def stk = cv.val_stack.elems;
			    def top = cv.val_stack.top; // NOTE virgil comments state it might forbid this field access later
			    def t = stk[top - 1 - i];
			    arg = WhammArg.Operand(t, i - args + 1);
          if (expParams[i] != t) {
            System.error("Whamm probe error", "type mismatch");
          }
		    }
		    // TODO clarify what the local means (#s, args vs. true locals)
				Local(orig, i) => {
				  if (i >= cv.locals.length) {
            System.error("Whamm probe error", "localN out of bounds");
				  }
			    def t = cv.locals[i];
			    arg = WhammArg.Local(t, i);
          if (expParams[i] != t) {
            System.error("Whamm probe error", "type mismatch");
          }
		    }
				Call(target, params) => {
				  if (nested) System.error("Whamm probe error", "nested function calls");

          def exports = wi.module.exports;
          def lookupR = FuncDecl.!(Vectors.lookup(exports, target.image, Strings.equal, null));
          if (lookupR == null) {
            System.error("Whamm probe error", "Lookup for function failed");
          }
          def index = lookupR.func_index; // TODO virgil pr
//          def index = FuncDecl.!(lookup(exports, target.image)).func_index;
          def func = wi.functions[index];

          def whammArgs = bindParams(cv, WasmFunction.!(func), wi, params, op, true);
        	def args = if(whammArgs.length == 0, Values.NONE, Array<Value>.new(whammArgs.length));

      		for (i < whammArgs.length) {
      			var v: Value;
      			match (whammArgs[i]) {
      				FrameAccessor => System.error("Whamm probe error", "frame accessor used as param to call");
      				Val(val)      => v = val;
      				Operand(t, i) => System.error("Whamm probe error", "arg used as param to call");
      				Local(t, i)   => System.error("Whamm probe error", "local used as param to call");
      			}
      			args[i] = v;
    			}
    			// typecheck before execute
			    def result = Execute.call(func, args); // XXX: runs on a new stack
			    match (result) {
            Value(vals)       => {
              if (vals.length == 0) System.error("Whamm probe error", "call did not return value");
              arg = WhammArg.Val(vals[0]);
              var t: ValueType;
              match (vals[0]) {
                Ref(_)     => ; // TODO
                I31(_)     => ; // TODO
                I32(_)     => t = ValueType.I32;
                I64(_)     => t = ValueType.I64;
                F32(_)     => t = ValueType.F32;
                F64(_)     => t = ValueType.F64;
                V128(_, _) => t = ValueType.V128;
              }
              if (expParams[i] != t) {
                System.error("Whamm probe error", "type mismatch");
              }
            }
            Throw(throw)      => System.error("Whamm probe error", "call did not return value");
            StackSwitch(info) => System.error("Whamm probe error", "call did not return value");
			    }
				}
			}
			args[i] = arg;
		}

		return args;
	}
	def onInstantiate(i: Instance) {
		if (onInstanceF < 0) return;
		var t = getWhammInstance(i.module), wi = t.0;
		if (wi == null) return;
		def instRef = InstanceRef.new(i);
		Execute.call(wi.functions[onInstanceF], [Value.Ref(instRef)]); // TODO: report traps
	}
	private def getWhammInstance(module: Module) -> (Instance, InstanceRef) {
		for (l = whammInstances; l != null; l = l.tail) {
			if (l.head.0 == module) return (l.head.1, l.head.2);
		}
		if (Trace.whamm) Trace.OUT.put2("Instantiating whamm module %s for %s", whamm.filename, module.filename).ln();
		var imports = Array<Exportable>.new(whamm.imports.length), err = ErrorGen.new(whamm.filename);
		var i = Instantiator.new(Extension.set.all, whamm, imports, err);
		i.processors.put(WizengModule.new());
		var instance = i.run();
		if (!err.ok()) return ErrorBuilder.new()
			.render(err.error_code, whamm.filename, err.section, err.error_index, err.error_pos, err.error_msg)
			.exit((null, null));
		var instRef = InstanceRef.new(instance);
		whammInstances = List.new((module, instance, instRef), whammInstances);
		return (instance, instRef);
	}

	def onFinish(i: Instance, r: Result) {
    def wi = getWhammInstance(i.module).0;
    def exports = wi.module.exports;
    def index = FuncDecl.!(lookup(exports, "before:exit")).func_index;
    def func = wi.functions[index];

    Execute.call(func, Values.NONE);
	}
}

// A probe that adapts a Wasm function to be called by the engine-internal probing mechanism.
class WhammProbe(func: WasmFunction, sig: Array<WhammArg>) extends Probe {
	private def args = if(sig.length == 0, Values.NONE, Array<Value>.new(sig.length));

	def fire(loc: DynamicLoc) -> Resumption {
		for (i < sig.length) {
			var v: Value;
			match (sig[i]) {
				FrameAccessor => v = Value.Ref(loc.frame.getFrameAccessor().getMetaRef());
				Val(val)      => v = val;
				Operand(t, i) => v = loc.frame.getFrameAccessor().getOperand(i);
				Local(t, i)   => v = loc.frame.getFrameAccessor().getLocal(i);
			}
			args[i] = v;
		}
		Execute.call(func, args); // XXX: runs on a new stack
		return Resumption.Continue;
	}
}

def lookup<V>(vec: Vector<(string, V)>, key: string) -> V {
  for (i < vec.length) {
    if (Strings.equal(vec[i].0, key)) { return vec[i].1; }
  }
  System.error("Whamm probe error", "Lookup for function failed");
  return vec[0].1;
}

def dupParser(cv: CodeValidator) -> WasmParser {
  def decoder = cv.parser.decoder;
  def newDecoder = CodePtr.new(null);
  newDecoder.reset(Ranges.dup(decoder.data), decoder.pos, decoder.limit);
  return WasmParser.new(cv.parser.extensions, cv.parser.limits, cv.parser.module, cv.parser.err, newDecoder);
}

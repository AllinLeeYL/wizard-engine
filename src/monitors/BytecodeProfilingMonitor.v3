// Copyright 2023 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implements a profiler that targets wasm modules containing a generalized interpreter
// that evaluates compiled bytecode.
//
// This profiler aims to recover source level information, including hot functions, call graphs,
// and execution costs in terms of wasm instructions.
def E = MonitorRegistry.add(
	"profile_bytecode", "Recovers source level information from bytecode execution",
	BytecodeProfilingMonitor.new());

def OUT = Trace.OUT;

// the minimum number of cases contained in the "switch" statement of the dispatch
// function. This is used during static analysis to identify the most likely wasm function
// as dispatch.
var MIN_DISPATCH_CASE_COUNT = 100;

// the maximum size in bytes that separates 2 consecutive opcodes.
var MAX_OPERAND_LEN = 6;

class BytecodeProfilingMonitor extends Monitor {
	// all functions that could be the dispatch function.
	// kvp of function index to the (FuncDecl, bytecode_read_pc, profile_state) pair.
	var potential_dispatch_functions = HashMap<int, (FuncDecl, int, SourceProfileState)>.new(int.!<int>, int.==);
	var all_counters: List<DynamicLoc -> Resumption>;

	def configure(args: string) -> string {
		def argMap = MonitorUtil.argMapFrom(args);
		if (argMap.has("switch_size")) {
			var parse_result = Ints.parseDecimal(argMap["switch_size"], 0);
			if (parse_result.0 > 0) MIN_DISPATCH_CASE_COUNT = parse_result.1;
			return null;
		}
		if (argMap.has("operand_len")) {
			var parse_result = Ints.parseDecimal(argMap["operand_len"], 0);
			if (parse_result.0 > 0) MAX_OPERAND_LEN = parse_result.1;
			return null;
		}
		def buf = StringBuilder.new();
		buf.put1("invalid argument(s) \"%s\"", args);
		return buf.toString();
	}

	def onParse(module: Module) {
		var mi = ModuleInstrumenter.new(module);

		var bi = BytecodeIterator.new();
		for (i < module.functions.length) {
			var f = module.functions[i];
			if (f.imp != null) continue;
			bi = bi.reset(f);

			// We identify dispatch function through static analysis, by looking for:
			// 	1. a sequence of consequtive BLOCK instructions exceeding MIN_DISPATCH_CASE_COUNT.
			// 	   This corresponds to a switch statement over all possible opcode in the source code.
			// 	2. a I32_LOAD8_U instruction, followed by a BR_TABLE instruction, in the inner scope of the
			// 	   nested BLOCK chain.
			var prev_OPCODE_READ_pc = -1, bytecode_read_pc = -1;
			var last_block_chain = 0;
			var is_last_instr_block = false;
			while (bi.more()) {
				match (bi.current()) {
					BR_TABLE => {
						is_last_instr_block = false;
						if (prev_OPCODE_READ_pc >= 0 && last_block_chain > MIN_DISPATCH_CASE_COUNT) {
							var state = SourceProfileState.new(f.func_index, StringBuilder.new().put1("func_%d", f.func_index).toString());
							all_counters = List.new(state.count_probe.fire, all_counters);
							potential_dispatch_functions[f.func_index] = (f, prev_OPCODE_READ_pc, state);
							break;
						}
					}
					I32_LOAD8_U => {
						prev_OPCODE_READ_pc = bi.pc;
						is_last_instr_block = false;
					}
					BLOCK => {
						if (is_last_instr_block) {
							last_block_chain++;
						} else {
							last_block_chain = 0;
							is_last_instr_block = true;
						}
					}
					_ => is_last_instr_block = false;
				}
				bi.next();
			}
		}
		// insert byte read probe only at dispatch function.
		var memory_visitor = MemoryVisitor.new(module, beforeMemRead, null, null);
		memory_visitor.bi = BytecodeIterator.new();
		mi.forEachFuncMatching(isPossibleDispatch, ModuleInstrumenter.instrumentMemoryAccesses(_, _, memory_visitor));

		// insert entry/exit probe at dispatch function.
		mi.beforeAllFuncExecAndReturn(beforeFuncRun, beforeFuncReturn);

		// enable global count probe
		Instrumentation.insertGlobalProbe(CombinedCountProbe.new(all_counters));
	}

	def onFinish(i: Instance, r: Result) {
		var states = Maps.valueList(potential_dispatch_functions);
		while (states != null) {
			states.head.2.compactTrace();
			states.head.2.reportSourceFunctionTrace();
			states.head.2.reportRecoveredBytecodes();
			states.head.2.hotness.report();
			states = states.tail;
		}
	}

	private def beforeMemRead(dynamicLoc: DynamicLoc, mem: Memory, address: u64, size: u64) -> Resumption {
		var func_id = dynamicLoc.func.decl.func_index;
		if (!potential_dispatch_functions.has(func_id)) return Resumption.Continue;
		if (dynamicLoc.pc != potential_dispatch_functions[func_id].1) {
			// check for opcode operand read.
			for (i: u32 = 0; i < size; i++) {
				var b = mem.read_u8(u32.!(address + i), 0).result;
				potential_dispatch_functions[func_id].2.try_record_operand(u32.!(address + i), b);
			}
		} else { // opcode read
			var b = mem.read_u8(u32.!(address), 0).result;
			potential_dispatch_functions[func_id].2.step(u32.!(address), b);
		}
		return Resumption.Continue;
	}

	private def beforeFuncRun(dynamicLoc: DynamicLoc) -> Resumption {
		var func_id = dynamicLoc.func.decl.func_index;
		for (dispatch = Maps.keyList(potential_dispatch_functions); dispatch != null; dispatch = dispatch.tail) {
			if (dispatch.head == func_id) {
				potential_dispatch_functions[dispatch.head].2.sourceFuncStart();
			} else {
				potential_dispatch_functions[dispatch.head].2.wasmFuncEvent(func_id, true);
			}
		}
		return Resumption.Continue;
	}

	private def beforeFuncReturn(dynamicLoc: DynamicLoc) -> Resumption {
		var func_id = dynamicLoc.func.decl.func_index;
		for (dispatch = Maps.keyList(potential_dispatch_functions); dispatch != null; dispatch = dispatch.tail) {
			if (dispatch.head == func_id) {
				potential_dispatch_functions[dispatch.head].2.sourceFuncReturn();
			} else {
				potential_dispatch_functions[dispatch.head].2.wasmFuncEvent(func_id, false);
			}
		}
		return Resumption.Continue;
	}

	private def isPossibleDispatch(module: Module, func: FuncDecl) -> bool {
		return potential_dispatch_functions.has(func.func_index);
	}
}

private class SourceProfileState(dispatch_func_id: int, output_prefix: string) {
	var call_stack = ListStack<u32>.new();
	// complete execution trace.
	var trace: List<TraceEntry>;
	// the recovered bytecode for each source function.
	var recovered_bytecodes = HashMap<u32, HashMap<u32, u8>>.new(int.!<u32>, u32.==);
	// address of the last read bytecode.
	var last_opcode_addr: u32;
	// wasm instruction global counter, used to calculate cost.
	def count_probe: FuelCountProbe = FuelCountProbe.new();
	// total costs of each bytecode execution.
	def hotness: BytecodeHotness = BytecodeHotness.new(output_prefix);
	var last_probe_event: ProbeEvent = ProbeEvent.RETURN;
	var last_step_count: u32;
	var last_probe_event_count: u32;
	var cur_wasm_func_trace: List<WasmFuncTrace>;

	// updates profiler state upon wasm function invocation/return, during the execution of a
	// valid source opcode. This is used to understand which wasm functions are associated to
	// particular opcodes.
	def wasmFuncEvent(wasm_func_id: int, is_start: bool) {
		var wasm_trace = WasmFuncTrace(wasm_func_id, u32.!(count_probe.count) - last_step_count, is_start);
		cur_wasm_func_trace = List.new(wasm_trace, cur_wasm_func_trace);
	}

	// updates the profiler state upon source function invocation.
	def sourceFuncStart() {
		commonSetup();
		wasmFuncEvent(dispatch_func_id, true);
		trace = List.new(TraceEntry.CALL(0), trace);
		call_stack.push(0);
		last_probe_event = ProbeEvent.CALL;
	}

	// updates the profiler state upon source function return.
	def sourceFuncReturn() {
		commonSetup();
		wasmFuncEvent(dispatch_func_id, false);
		trace = List.new(TraceEntry.RETURN(call_stack.peek()), trace);
		call_stack.pop();
		last_probe_event = ProbeEvent.RETURN;
	}

	// records the profiling information for a single opcode execution
	def step(addr: u32, b: u8) {
		def cost = get_cost();
		last_opcode_addr = addr;
		match (last_probe_event) {
			CALL => { // first byte of a new function, rewrite func_id
				trace = List.new(TraceEntry.SYSTEM(cost, cur_wasm_func_trace),
							List.new(TraceEntry.CALL(addr), trace.tail));
				call_stack.pop();
				call_stack.push(addr);
			}
			RETURN => trace = List.new(TraceEntry.SYSTEM(cost, cur_wasm_func_trace), trace);
			OPCODE_READ(bytecode, offset) => 
				trace = List.new(TraceEntry.STEP(bytecode, offset, cost, cur_wasm_func_trace), trace);
		}

		// mark recovered bytecode
		if (!recovered_bytecodes.has(call_stack.peek())) {
			recovered_bytecodes[call_stack.peek()] = HashMap<u32, u8>.new(int.!<u32>, u32.==);
		}
		recovered_bytecodes[call_stack.peek()][addr] = b;
		last_probe_event = ProbeEvent.OPCODE_READ(b, addr - call_stack.peek());
		hotness.record(b, cost);
		last_step_count = u32.!(count_probe.count);
		last_probe_event_count = u32.!(count_probe.count);
		cur_wasm_func_trace = null;
	}

	// process memory read adjacent to the last opcode read, in order to recover possible operands
	// associated with the last read opcode.
	def try_record_operand(addr: u32, b: u8) {
		if (addr - last_opcode_addr <= MAX_OPERAND_LEN) {
			recovered_bytecodes[call_stack.peek()][addr] = b;
		}
	}

	// compact the trace by coalescing consecutive system events.
	def compactTrace() {
		var rev = Lists.reverse(trace);
		var new_trace: List<TraceEntry>;
		var valid_func_id_stack: List<u32>;
		while (rev != null) {
			match (rev.head) {
				CALL(func_id) => {
					if (func_id > 0) {
						new_trace = List.new(TraceEntry.CALL(func_id), new_trace);
						valid_func_id_stack = List.new(func_id, valid_func_id_stack);
					}
				}
				STEP => new_trace = List.new(rev.head, new_trace);
				RETURN(func_id) => {
					if (valid_func_id_stack != null && func_id == valid_func_id_stack.head) {
						new_trace = List.new(TraceEntry.RETURN(func_id), new_trace);
						valid_func_id_stack = valid_func_id_stack.tail;
					}
				}
				SYSTEM(cost, wasm_func_trace) => {
					if (new_trace != null) {
						match (new_trace.head) {
							SYSTEM(c, prev_wasm_trace) => {
								new_trace = List.new(TraceEntry.SYSTEM(c + cost, wasm_func_trace), new_trace.tail);
							}
							STEP(bytecode, offset, c, old_func_trace) => {
								hotness.update(bytecode, c, c + cost);
								new_trace = List.new(TraceEntry.STEP(bytecode, offset, c + cost, wasm_func_trace), new_trace.tail);
							}
							_ => new_trace = List.new(rev.head, new_trace);
						}
					} else {
						new_trace = List.new(rev.head, new_trace);
					}
				}
			}
			rev = rev.tail;
		}
		trace = new_trace;
	}

	def reportSourceFunctionTrace() {
		var fd = System.fileOpen(Strings.format1("%s_source_trace.csv", output_prefix), false);
		var rev = Lists.reverse(trace);
		var b = StringBuilder.new();
		b.puts("function_id,pc_offset,opcode,cost,wasm_func_trace\n");
		var stack = ListStack<u32>.new();
		while (rev != null) {
			match (rev.head) {
				CALL(func_id) => {
					stack.push(func_id);
					b.put1("%d,0,START,0,", stack.peek()).ln();
				}
				STEP(bytecode, offset, cost, wasm_func_trace) => {
					b.put3("%d,%d,%x,", stack.peek(), offset, u8.!(bytecode))
					.put1("%d,", cost);
					if (wasm_func_trace != null) {
						var wasm_trace = Lists.reverse(wasm_func_trace);
						while (wasm_trace != null) {
							b.puts(wasm_trace.head.toString());
							wasm_trace = wasm_trace.tail;
							if (wasm_trace != null) b.puts("|");
						}
					}
					b.ln();
				}
				RETURN(func_id) => {
					b.put1("%d,0,END,0,", stack.peek()).ln();
					stack.pop();
				}
				SYSTEM(cost, wasm_func_trace) => {
					if (stack.empty()) {
						b.put1("0,0,00,%d,", cost).ln();
					} else {
						b.put2("%d,0,00,%d,", stack.peek(), cost).ln();
					}
				}
			}
			rev = rev.tail;
		}
		System.write(fd, b.toString());
	}

	def reportRecoveredBytecodes() {
		var fd = System.fileOpen(Strings.format1("%s_recovered_bytecodes.csv", output_prefix), false);
		var function_ids = Maps.keyList(recovered_bytecodes);
		var b = StringBuilder.new();
		b.puts("function_id,bytecode\n"); // header
		while (function_ids != null) {
			var function_id = function_ids.head;
			b.put1("%d,", function_id);
			var bytecodes = recovered_bytecodes[function_id];
			var bytecode_addrs = Maps.keyList(bytecodes);
			var min_addr = u32.max;
			var max_addr: u32 = 0;
			while (bytecode_addrs != null) {
				var addr = bytecode_addrs.head;
				if (addr < min_addr) min_addr = addr;
				if (addr > max_addr) max_addr = addr;
				bytecode_addrs = bytecode_addrs.tail;
			}

			for (i = min_addr; i <= max_addr; i++) {
				b.put1("/%x", bytecodes[i]);
			}
			b.ln();
			function_ids = function_ids.tail;
		}
		System.write(fd, b.toString());
	}

	private def commonSetup() {
		def cost = get_cost();
		match (last_probe_event) {
			OPCODE_READ(bytecode, offset) => {
				trace = 
					List.new(TraceEntry.STEP(bytecode, offset, cost, cur_wasm_func_trace), trace);
				hotness.record(bytecode, cost);
			}
			_ => trace = List.new(TraceEntry.SYSTEM(cost, cur_wasm_func_trace), trace);
		}
		last_probe_event_count = u32.!(count_probe.count);
	}

	private def get_cost() -> u32 {
		return u32.!(count_probe.count) - last_probe_event_count;
	}
}

private class BytecodeHotness(output_prefix: string) {
	var bytecode_hotness: Array<HashMap<u32, u32>> = Array.new(256);

	def record(b: u8, cost: u32) {
		if (bytecode_hotness[b] == null) {
			bytecode_hotness[b] = HashMap<u32, u32>.new(int.!<u32>, u32.==);
		}
		if (!bytecode_hotness[b].has(cost)) {
			bytecode_hotness[b][cost] = 0;
		}
		bytecode_hotness[b][cost]++;
	}

	def update(b: u8, old_cost: u32, new_cost: u32) {
		if (bytecode_hotness[b] == null || !bytecode_hotness[b].has(old_cost)) {
			return;
		}
		bytecode_hotness[b][old_cost]--;
		bytecode_hotness[b][new_cost] = bytecode_hotness[b][new_cost] + 1;
	}

	def report() {
		var fd = System.fileOpen(Strings.format1("%s_global_hotness.csv", output_prefix), false);
		var b = StringBuilder.new();
		b.puts("bytecode,cost,count\n"); // header
		for (i = 0; i < bytecode_hotness.length; i++) {
			if (bytecode_hotness[i] != null) {
				var costs = Maps.keyList(bytecode_hotness[i]);
				while (costs != null) {
					var j = costs.head;
					if (bytecode_hotness[i][j] > 0)
						b.put3("%x,%d,%d", i, j, bytecode_hotness[i][j]).ln();
					costs = costs.tail;
				}
			}
		}
		System.write(fd, b.toString());
	}
}

private class CombinedCountProbe(all_counters: List<DynamicLoc -> Resumption>) extends CountProbe {
	def fire(dynamicLoc: DynamicLoc) -> Resumption {
		var counters = all_counters;
		while (counters != null) {
			counters.head(dynamicLoc);
			counters = counters.tail;
		}
		return Resumption.Continue;
	}
}

// custom counter that ignores certain instructions.
private class FuelCountProbe extends CountProbe {
	def fire(dynamicLoc: DynamicLoc) -> Resumption {
		var opcode_byte = dynamicLoc.func.decl.orig_bytecode[dynamicLoc.pc];
		var opcode = Opcodes.opcodes[opcode_byte];
		match (opcode) {
			BLOCK, LOOP, UNREACHABLE, RETURN, ELSE, END => count += 0;
			_ => count += 1;
		}
		return Resumption.Continue;
	}
}

private type TraceEntry {
	case CALL(func_id: u32);
	case STEP(bytecode: u8, offset: u32, cost: u32, wasm_func_trace: List<WasmFuncTrace>);
	case RETURN(func_id: u32);
	case SYSTEM(cost: u32, wasm_func_trace: List<WasmFuncTrace>);
}

// wasm function call/return events when the dispatch function is executing a valid source opcode.
private type WasmFuncTrace(func_id: int, instr_count: u32, is_start: bool) {
	def toString() -> string {
		return Strings.format3("%d:%s:%d", func_id, if (is_start, "S", "E"), instr_count);
	}
}

private type ProbeEvent {
	case OPCODE_READ(bytecode: u8, offset: u32);
	case CALL;
	case RETURN;
}

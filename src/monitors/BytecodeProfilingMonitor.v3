// Copyright 2023 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implements a profiler that targets wasm modules containing a generalized interpreter
// that evaluates compiled bytecode.
//
// This profiler aims to recover source level information, including hot functions, call graphs,
// and execution costs in terms of wasm instructions.
def E = MonitorRegistry.add(
	"profile_bytecode", "Recovers source level information from bytecode execution",
	BytecodeProfilingMonitor.new());

def OUT = Trace.OUT;

def MIN_DISPATCH_CASE_COUNT = 50;
def MAX_OPERAND_LEN = 4;

class BytecodeProfilingMonitor extends Monitor {
	// all functions that could be the dispatch function.
	// kvp of function index to the (FuncDecl, bytecode_read_pc, profile_state) pair.
	var potential_dispatch_functions = HashMap<int, (FuncDecl, int, SourceProfileState)>.new(int.!<int>, int.==);
	var all_counters: List<DynamicLoc -> Resumption>;

	def onParse(module: Module) {
		var mi = ModuleInstrumenter.new(module);

		var bi = BytecodeIterator.new();
		for (i < module.functions.length) {
			var f = module.functions[i];
			if (f.imp != null) continue;
			bi = bi.reset(f);

			// find the main dispatch function by checking for calls to the
			// dispatch marker function.
			var prev_byte_read_pc = -1, bytecode_read_pc = -1;
			var last_block_chain = 0;
			var is_last_instr_block = false;
			while (bi.more()) {
				match (bi.current()) {
					BR_TABLE => {
						is_last_instr_block = false;
						if (prev_byte_read_pc >= 0 && last_block_chain > MIN_DISPATCH_CASE_COUNT) {
							var state = SourceProfileState.new();
							all_counters = List.new(state.count_probe.fire, all_counters);
							potential_dispatch_functions[f.func_index] = (f, prev_byte_read_pc, state);
							break;
						}
					}
					I32_LOAD8_U => {
						prev_byte_read_pc = bi.pc;
						is_last_instr_block = false;
					}
					BLOCK => {
						if (is_last_instr_block) {
							last_block_chain++;
						} else {
							last_block_chain = 0;
							is_last_instr_block = true;
						}
					}
					_ => is_last_instr_block = false;
				}
				bi.next();
			}
		}
		// insert byte read probe only at dispatch function.
		var memory_visitor = MemoryVisitor.new(module, beforeMemRead, null, null);
		memory_visitor.bi = BytecodeIterator.new();
		mi.forEachFuncMatching(isPossibleDispatch, ModuleInstrumenter.instrumentMemoryAccesses(_, _, memory_visitor));

		// insert entry/exit probe at dispatch function.
		mi.beforeAllFuncExecAndReturn(beforeDispatchRun, beforeDispatchReturn);

		// enable global count probe
		Instrumentation.insertGlobalProbe(CombinedCountProbe.new(all_counters));
	}

	def onFinish(i: Instance, r: Result) {
		var states = Maps.valueList(potential_dispatch_functions);
		while (states != null) {
			states.head.2.compactTrace();
			states.head.2.reportSourceFunctionTrace();
			states.head.2.reportRecoveredBytecodes();
			states.head.2.hotness.report();
			states = states.tail;
		}
	}

	private def beforeMemRead(dynamicLoc: DynamicLoc, mem: Memory, address: u64, size: u64) -> Resumption {
		var func_id = dynamicLoc.func.decl.func_index;
		if (!potential_dispatch_functions.has(func_id)) return Resumption.Continue;
		if (dynamicLoc.pc != potential_dispatch_functions[func_id].1) {
			for (i: u32 = 0; i < size; i++) {
				var b = mem.read_u8(u32.!(address + i), 0).result;
				potential_dispatch_functions[func_id].2.try_record_operand(u32.!(address + i), b);
			}
		} else {
			var b = mem.read_u8(u32.!(address), 0).result;
			potential_dispatch_functions[func_id].2.step(u32.!(address), b);
		}
		return Resumption.Continue;
	}

	private def beforeDispatchRun(dynamicLoc: DynamicLoc) -> Resumption {
		var func_id = dynamicLoc.func.decl.func_index;
		if (!potential_dispatch_functions.has(func_id)) return Resumption.Continue;
		potential_dispatch_functions[func_id].2.funcStart();
		return Resumption.Continue;
	}

	private def beforeDispatchReturn(dynamicLoc: DynamicLoc) -> Resumption {
		var func_id = dynamicLoc.func.decl.func_index;
		if (!potential_dispatch_functions.has(func_id)) return Resumption.Continue;
		potential_dispatch_functions[func_id].2.funcReturn();
		return Resumption.Continue;
	}

	private def isPossibleDispatch(module: Module, func: FuncDecl) -> bool {
		return potential_dispatch_functions.has(func.func_index);
	}
}

private class SourceProfileState {
	var call_stack: List<u32>;
	// complete execution trace.
	var trace: List<TraceEntry>;
	// the recovered bytecode for each source function.
	var recovered_bytecodes = HashMap<u32, HashMap<u32, u8>>.new(int.!<u32>, u32.==);
	// address of the last read bytecode.
	var last_opcode_addr: u32;
	// wasm instruction global counter, used to calculate cost.
	def count_probe: FuelCountProbe = FuelCountProbe.new();
	// total costs of each bytecode execution.
	def hotness: BytecodeHotness = BytecodeHotness.new();
	var last_probe_event: ProbeEvent = ProbeEvent.RETURN;

	def funcStart() {
		commonSetup();
		trace = List.new(TraceEntry.CALL(0), trace);
		call_stack = List<u32>.new(0, call_stack);
		last_probe_event = ProbeEvent.CALL;
	}

	def funcReturn() {
		commonSetup();
		trace = List.new(TraceEntry.RETURN(call_stack.head), trace);
		call_stack = call_stack.tail;
		last_probe_event = ProbeEvent.RETURN;
	}

	def step(addr: u32, b: u8) {
		def cost = u32.!(count_probe.count);
		last_opcode_addr = addr;
		match (last_probe_event) {
			CALL => { // first byte of a new function, rewrite func_id
				trace = List.new(TraceEntry.SYSTEM(cost),
							List.new(TraceEntry.CALL(addr), trace.tail));
				call_stack = List.new(addr, call_stack.tail);
			}
			RETURN => trace = List.new(TraceEntry.SYSTEM(cost), trace);
			BYTE_READ(bytecode) => trace = List.new(TraceEntry.STEP(bytecode, cost), trace);
		}

		// mark recovered bytecode
		if (!recovered_bytecodes.has(call_stack.head)) {
			recovered_bytecodes[call_stack.head] = HashMap<u32, u8>.new(int.!<u32>, u32.==);
		}
		recovered_bytecodes[call_stack.head][addr] = b;
		last_probe_event = ProbeEvent.BYTE_READ(b);
		hotness.record(b, cost);
		count_probe.count = 0;
	}

	def try_record_operand(addr: u32, b: u8) {
		if (addr - last_opcode_addr <= MAX_OPERAND_LEN) {
			System.puts("try_record_operand\n");
			recovered_bytecodes[call_stack.head][addr] = b;
		}
	}

	def compactTrace() {
		var rev = Lists.reverse(trace);
		var new_trace: List<TraceEntry>;
		var valid_func_id_stack: List<u32>;
		while (rev != null) {
			match (rev.head) {
				CALL(func_id) => {
					if (func_id > 0) {
						new_trace = List.new(TraceEntry.CALL(func_id), new_trace);
						valid_func_id_stack = List.new(func_id, valid_func_id_stack);
					}
				}
				STEP(bytecode, cost) => new_trace = List.new(rev.head, new_trace);
				RETURN(func_id) => {
					if (valid_func_id_stack != null && func_id == valid_func_id_stack.head) {
						new_trace = List.new(TraceEntry.RETURN(func_id), new_trace);
						valid_func_id_stack = valid_func_id_stack.tail;
					}
				}
				SYSTEM(cost) => {
					if (new_trace != null) {
						match (new_trace.head) {
							SYSTEM(c) => new_trace = List.new(TraceEntry.SYSTEM(c + cost), new_trace.tail);
							_ => new_trace = List.new(rev.head, new_trace);
						}
					} else {
						new_trace = List.new(rev.head, new_trace);
					}
				}
			}
			rev = rev.tail;
		}
		trace = new_trace;
	}

	def reportSourceFunctionTrace() {
		var fd = System.fileOpen("source_trace.csv", false);
		var rev = Lists.reverse(trace);
		var b = StringBuilder.new();
		b.puts("function_id,bytecode,cost\n");
		var stack: List<u32>;
		while (rev != null) {
			match (rev.head) {
				CALL(func_id) => {
					stack = List.new(func_id, stack);
					b.put1("%d,START,0", stack.head).ln();
				}
				STEP(bytecode, cost) => {
					b.put3("%d,%x,%d", stack.head, u8.!(bytecode), cost).ln();
				}
				RETURN(func_id) => {
					b.put1("%d,END,0", stack.head).ln();
					stack = stack.tail;
				}
				SYSTEM(cost) => {
					if (stack == null) {
						b.put1("0,00,%d", cost).ln();
					} else {
						b.put2("%d,00,%d", stack.head, cost).ln();
					}
				}
			}
			rev = rev.tail;
		}
		System.write(fd, b.buf);
	}

	def reportRecoveredBytecodes() {
		var fd = System.fileOpen("recovered_bytecodes.csv", false);
		var function_ids = Maps.keyList(recovered_bytecodes);
		var b = StringBuilder.new();
		b.puts("function_id,bytecode\n"); // header
		while (function_ids != null) {
			var function_id = function_ids.head;
			b.put1("%d:", function_id);
			var bytecodes = recovered_bytecodes[function_id];
			var bytecode_addrs = Maps.keyList(bytecodes);
			var min_addr = u32.max;
			var max_addr: u32 = 0;
			while (bytecode_addrs != null) {
				var addr = bytecode_addrs.head;
				if (addr < min_addr) min_addr = addr;
				if (addr > max_addr) max_addr = addr;
				bytecode_addrs = bytecode_addrs.tail;
			}

			for (i = min_addr; i <= max_addr; i++) {
				b.put1("/%x", bytecodes[i]);
			}
			b.ln();
			function_ids = function_ids.tail;
		}
		System.write(fd, b.buf);
	}

	private def commonSetup() {
		match (last_probe_event) {
			BYTE_READ(bytecode) => {
				trace = List.new(TraceEntry.STEP(bytecode, u32.!(count_probe.count)), trace);
				hotness.record(bytecode, u32.!(count_probe.count));
			}
			_ => trace = List.new(TraceEntry.SYSTEM(u32.!(count_probe.count)), trace);
		}
		count_probe.count = 0;
	}
}

private class BytecodeHotness {
	var bytecode_hotness: Array<HashMap<u32, u32>> = Array.new(256);

	def record(b: u8, cost: u32) {
		if (bytecode_hotness[b] == null) {
			bytecode_hotness[b] = HashMap<u32, u32>.new(int.!<u32>, u32.==);
		}
		if (!bytecode_hotness[b].has(cost)) {
			bytecode_hotness[b][cost] = 0;
		}
		bytecode_hotness[b][cost]++;
	}

	def report() {
		var fd = System.fileOpen("global_hotness.csv", false);
		var b = StringBuilder.new();
		b.puts("bytecode,cost,count\n"); // header
		for (i = 0; i < bytecode_hotness.length; i++) {
			if (bytecode_hotness[i] != null) {
				var costs = Maps.keyList(bytecode_hotness[i]);
				while (costs != null) {
					var j = costs.head;
					b.put3("%x,%d,%d", i, j, bytecode_hotness[i][j]).ln();
					costs = costs.tail;
				}
			}
		}
		System.write(fd, b.buf);
	}
}

private class CombinedCountProbe(all_counters: List<DynamicLoc -> Resumption>) extends CountProbe {
	def fire(dynamicLoc: DynamicLoc) -> Resumption {
		var counters = all_counters;
		while (counters != null) {
			counters.head(dynamicLoc);
			counters = counters.tail;
		}
		return Resumption.Continue;
	}
}

private class FuelCountProbe extends CountProbe {
	def fire(dynamicLoc: DynamicLoc) -> Resumption {
		var opcode_byte = dynamicLoc.func.decl.orig_bytecode[dynamicLoc.pc];
		var opcode = Opcodes.opcodes[opcode_byte];
		match (opcode) {
			BLOCK, LOOP, UNREACHABLE, RETURN, ELSE, END => count += 0;
			_ => count += 1;
		}
		return Resumption.Continue;
	}
}

private type TraceEntry {
	case CALL(func_id: u32);
	case STEP(bytecode: u8, cost: u32);
	case RETURN(func_id: u32);
	case SYSTEM(cost: u32);
}

private type ProbeEvent {
	case BYTE_READ(bytecode: u8);
	case CALL;
	case RETURN;
}
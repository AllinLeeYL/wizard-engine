// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Code generator for X86-64, including the fast interpreter and baseline JIT.
class X86_64CodeGen {
	def w = DataWriter.new();
	def asm = X86_64Assemblers.create64(w);

	def genInterpreter() -> InterpreterCode {
		// Map some executable memory for the interpreter.
		var mapping = Mmap.reserve(4096, Mmap.PROT_READ | Mmap.PROT_WRITE |  Mmap.PROT_EXEC);
		if (mapping == null) return null;
		var ic = InterpreterCode.new(mapping);
		genInterpreterEntry(ic);
		genDispatchTable(ic);
		genOpcodeHandlers(ic);
		// copy code from Datawriter into memory range
		var p = mapping.range.start;
		for (i < w.pos) {
			p.store<u8>(w.data[i]);
			p++;
		}
		return ic;
	}
	def genInterpreterEntry(ic: InterpreterCode) {
		asm.movd_r_i(Regs.V3_RET_GPR, ExecState.TRAPPED.tag);
		asm.ret();
	}
	def genDispatchTable(ic: InterpreterCode) {
	}
	def genOpcodeHandlers(ic: InterpreterCode) {
	}
}

// The interpreter and baseline variables that are held in registers
enum IVar(gpr: X86_64Gpr, frameOffset: int, baseline: bool) {
	MEM0_BASE	(X86_64Regs.R10,	0,	true),
	TABLE0_BASE	(X86_64Regs.R11,	8,	true),
	VFP		(X86_64Regs.R11,	16,	false),
	VSP		(X86_64Regs.RSI,	24,	false),
	XIP		(X86_64Regs.RBX,	32,	false),
	IP		(X86_64Regs.RAX,	40,	false),
	FUNC		(X86_64Regs.R12,	48,	true),
	INSTANCE	(X86_64Regs.RDI,	56,	true),
}

// Register configuration and calling convention for execution tiers.
component Regs {
	def V3_RET_GPR = X86_64Regs.RAX;

	def BASELINE_GPRS = computeBaselineGprs(); // allocatable baseline registers

	def computeBaselineGprs() -> Array<X86_64Gpr> {
		var gprs = X86_64Regs.GPRs;
		var used = Array<bool>.new(gprs.length);
		for (v in IVar) {
			if (v.baseline) used[v.gpr.regnum] = true;
		}
		var v = Vector<X86_64Gpr>.new().grow(gprs.length);
		for (i < gprs.length) {
			if (!used[i]) v.put(gprs[i]);
		}
		return v.extract();
	}
}

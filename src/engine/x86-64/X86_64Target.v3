// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Contains target-specific factory functions.
component Target {
	def limit_memory_pages = 65536u;
	def newMemory = X86_64Memory.new;
	def forceGC = RiGc.forceGC;
	def reset = X86_64Interpreter.reset;
	def call = X86_64Interpreter.run;
	def getWasmTopFrame = X86_64Interpreter.getTopFrame;
	def getWasmCallStack = X86_64Interpreter.getCallStack;
	def getWasmCallDepth = X86_64Interpreter.getCallDepth;
	def tagging = Tagging.new(true, false);

	new() {
		Execute.probes.onEnable = X86_64Interpreter.onProbeEnable;
		Execute.probes.onDisable = X86_64Interpreter.onProbeDisable;
	}

	def setMode(m: EngineMode) -> bool {
		match (m) {
			JIT => return false;
			INT, FAST, DEBUG => {
				// x86-64 target has only one execution mode; interpreter only
				Execute.mode = Mode.INTERPRETER;
				return true;
			}
		}
	}
	def finishModule(m: Module, err: ErrorGen) {
		// x86-64 target needs no post-processing for a module
	}
	def genInterpreterIntoFile(filename: string) -> ErrorBuilder {
		var data = System.fileLoad(filename);
		var err = ErrorBuilder.new().puts("interpreter generator: ");
		if (data == null) return err.put1("could not load executable %s\n", filename);
		var ok = X86_64Interpreter.serializeInterpreterCodeIntoExecutable(data);
		if (ok == false) return err.put1("could not patch executable %s\n", filename);
		var fd = System.fileOpen(filename, false);
		if (fd < 0) return err.put1("could not write executable: %s\n", filename);
		System.fileWriteK(fd, data, 0, data.length);
		System.fileClose(fd);
		return null;
	}
}
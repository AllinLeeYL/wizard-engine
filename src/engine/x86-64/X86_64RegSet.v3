// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Describes the set of architectural registers for X86-64.
component X86_64Regs2 {
	// local state used during building of {SET} and {CONFIG}
	def NONE = Reg(0);
	private def GPRS = Array<X86_64Gpr>.new(256);	// fast mapping byte -> GPR
	private def XMMS = Array<X86_64Xmmr>.new(256);	// fast mapping byte -> XMM
	private var all = Vector<Reg>.new().grow(32).put(NONE);
	private var ints = Vector<Reg>.new().grow(16);
	private var floats = Vector<Reg>.new().grow(16);
	private var names = Vector<string>.new().grow(32).put(null);
	private var num: byte = 1;

	def RAX = addGpr(X86_64Regs.RAX, true);
	def RCX = addGpr(X86_64Regs.RCX, true);
	def RDX = addGpr(X86_64Regs.RDX, true);
	def RBX = addGpr(X86_64Regs.RBX, true);
	def RSP = addGpr(X86_64Regs.RSP, false);
	def RBP = addGpr(X86_64Regs.RBP, true);
	def RSI = addGpr(X86_64Regs.RSI, true);
	def RDI = addGpr(X86_64Regs.RDI, true);
	def R8 = addGpr(X86_64Regs.R8, true);
	def R9 = addGpr(X86_64Regs.R9, true);
	def R10 = addGpr(X86_64Regs.R10, true);
	def R11 = addGpr(X86_64Regs.R11, true);
	def R12 = addGpr(X86_64Regs.R12, true);
	def R13 = addGpr(X86_64Regs.R13, true);
	def R14 = addGpr(X86_64Regs.R14, true);
	def R15 = addGpr(X86_64Regs.R15, true);

	def XMM0 = addXmmr(X86_64Regs.XMM0);
	def XMM1 = addXmmr(X86_64Regs.XMM1);
	def XMM2 = addXmmr(X86_64Regs.XMM2);
	def XMM3 = addXmmr(X86_64Regs.XMM3);
	def XMM4 = addXmmr(X86_64Regs.XMM4);
	def XMM5 = addXmmr(X86_64Regs.XMM5);
	def XMM6 = addXmmr(X86_64Regs.XMM6);
	def XMM7 = addXmmr(X86_64Regs.XMM7);
	def XMM8 = addXmmr(X86_64Regs.XMM8);
	def XMM9 = addXmmr(X86_64Regs.XMM9);
	def XMM10 = addXmmr(X86_64Regs.XMM10);
	def XMM11 = addXmmr(X86_64Regs.XMM11);
	def XMM12 = addXmmr(X86_64Regs.XMM12);
	def XMM13 = addXmmr(X86_64Regs.XMM13);
	def XMM14 = addXmmr(X86_64Regs.XMM14);
	def XMM15 = addXmmr(X86_64Regs.XMM15);

	private def addGpr(gpr: X86_64Gpr, allocatable: bool) -> Reg {
		var reg = Reg(num++);
		all.put(reg);
		if (allocatable) ints.put(reg);
		names.put(gpr.name64);
		GPRS[reg.index] = gpr;
		return reg;
	}
	private def addXmmr(xmm: X86_64Xmmr) -> Reg {
		var reg = Reg(num++);
		all.put(reg);
		floats.put(reg);
		names.put(xmm.name);
		XMMS[reg.index] = xmm;
		return reg;
	}

	def SET = buildRegSet();
	def CONFIG = buildRegConfig();

	private def buildRegSet() -> RegSet {
		var intPool = RegPool.new(ints.extract());
		var floatPool = RegPool.new(floats.extract());
		var set = RegSet.new(all.extract(), names.extract());
		// XXX: reorganize the integer register pool for singlepass compiler
		set.pools[RegClass.I32.tag] = intPool;
		set.pools[RegClass.I64.tag] = intPool;
		set.pools[RegClass.F32.tag] = floatPool;
		set.pools[RegClass.F64.tag] = floatPool;
		set.pools[RegClass.V128.tag] = floatPool;
		set.pools[RegClass.REF.tag] = intPool;
		return set;
	}
	private def buildRegConfig() -> RegConfig {
		var config = RegConfig.new(SET);
		config.sp_reg = RSP;
//TODO		config.fp_reg = RBP;
//TODO		config.tls_reg = R15;
//TODO		config.spcFrameSize = 0;
		config.vsp_reg = RSI;
		config.vfp_reg = R11;
		config.ip_reg = RAX;
		config.eip_reg = R13;
		config.stp_reg = RBX;
		config.instance_reg = RDI;
		config.dispatch_reg = R14;
		config.func_reg = R12;
		config.mem_reg = R10;
		config.tmp_reg = RBP;
		def frame = IVarConfig.frame;
		
		config.spcFrameSize = frame.size;
		config.vsp_offset = frame.VSP.disp;
		config.vfp_offset = frame.VFP.disp;
		config.eip_offset = frame.EIP.disp;
		config.stp_offset = frame.STP.disp;
		config.instance_offset = frame.INSTANCE.disp;
		config.mem_offset = frame.MEM0_BASE.disp;
		return config;
	}

	def toGpr(reg: Reg) -> X86_64Gpr { return GPRS[reg.index]; }
	def toXmmr(reg: Reg) -> X86_64Xmmr { return XMMS[reg.index]; }
}

// Configuration of which register contains which interpreter variables.
class IVarRegs {
	def v3_WASM_FUNC	= Target.V3_PARAM_GPRS[1];
	def v3_VSP		= Target.V3_PARAM_GPRS[2];

	def DISPATCH_TABLE	= X86_64Regs.R14;
	def MEM0_BASE		= X86_64Regs.R10;
	def VFP			= X86_64Regs.R11;
	def VSP			= X86_64Regs.RSI;
	def STP			= X86_64Regs.RBX;
	def IP			= X86_64Regs.RAX;
	def EIP			= X86_64Regs.R13;
	def FUNC_DECL		= X86_64Regs.R12;
	def INSTANCE		= X86_64Regs.RDI;

	def IP_ptr		= IP.plus(0);

	def xmm0		= X86_64Regs.XMM0;
	def xmm1		= X86_64Regs.XMM1;
	
	def tmp0		= X86_64Regs.RCX;
	def tmp1		= X86_64Regs.RDX;
	def tmp2		= X86_64Regs.RBP;
	def tmp3		= X86_64Regs.R8;
	def tmp4		= X86_64Regs.R9;
	def tmp5		= X86_64Regs.R15;

	def scratch		= X86_64Regs.RBP; // XXX: just use tmp5?
}

class IVarFrame {
	def WASM_FUNC	= X86_64Regs.RSP.plus(0);
	def MEM0_BASE	= X86_64Regs.RSP.plus(8);
	def VFP		= X86_64Regs.RSP.plus(16);
	def VSP		= X86_64Regs.RSP.plus(24);
	def SIDETABLE	= X86_64Regs.RSP.plus(32);
	def STP		= X86_64Regs.RSP.plus(40);
	def CODE	= X86_64Regs.RSP.plus(48);
	def IP		= X86_64Regs.RSP.plus(56);
	def EIP		= X86_64Regs.RSP.plus(64);
	def FUNC_DECL	= X86_64Regs.RSP.plus(72);
	def INSTANCE	= X86_64Regs.RSP.plus(80);

	def size = 88;
}

component IVarConfig {
	def regs = IVarRegs.new();
	def frame = IVarFrame.new();
	def frameSize = frame.size;
}

// Copyright 2023 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Statically-allocated buffer for pre-generated code (in compiled binary).
def PAGE_SIZE = 4096u;
def PAGE_SIZE_i: int = 4096;
def PREGEN_MAGIC_WORD = 0x7ACEBEEF778899AAu;
def PREGEN_CODE_MARKER = 0x7FAACCEE;
def INL_SIZE = 60 * 1024;
def OOL_SIZE = 4 * 1024;
def TOTAL_SIZE = INL_SIZE + OOL_SIZE;
def pregen_buffer = Array<byte>.new(TOTAL_SIZE + PAGE_SIZE_i);
def pregen_header = Ref<X86_64PreGenHeader>.at(pregen_buffer, 0);
def X = pregen_header.magicWord = PREGEN_MAGIC_WORD;

// A layout over {pregen_buffer} for storing global offsets into the generated code.
layout X86_64PreGenHeader {
	+0	magicWord:			u64;	// magic word for finding in the binary
	+8	codeMarker:			i32;	// magic word for marking generated
	+12	fastDispatchTableOffset:	i32;	// dispatch table when probes disabled
	+16	probedDispatchTableOffset:	i32;	// dispatch table when probes enabled
	+20	codeStart:			i32;	// start of all executable code
	+24	intV3EntryOffset:		i32;	// entry into interpreter from V3 caller
	+28	intSpcEntryOffset:		i32;	// entry into interpreter from SPC caller
	+32	intIntEntryOffset:		i32;	// entry into interpreter from interpreter caller
	+36	deoptReentryOffset:		i32;	// re-enter interpreter from optimized code
	+40	oobMemoryHandlerOffset:		i32;	// handler for signals caused by OOB memory access
	+44	divZeroHandlerOffset:		i32;	// handler for signals caused by divide by zero
	+48	stackOverflowHandlerOffset:	i32;	// handler for signals caused by (value- or call-) stack overflow
	+52	spcV3EntryOffset:		i32;	// SPC jit entry from V3 calling code
	+56	spcLazyCompileOffset:		i32;	// SPC lazy compile stub offset
	+60	spcTierUpCompileOffset:		i32;	// SPC tierup compile stub offset
	+64	spcTrapsStubOffset:		i32;	// SPC traps stub offset
	+68	spcTrapsStubEnd:		i32;	// SPC traps stub end
	+72	rdtscOffset:			i32;	// address of rdstc function
	+76	codeEnd:			i32;	// end of all executable code
	=80;
}

// Interface to pre-generated code stubs.
def I: X86_64Interpreter;
component X86_64PreGenStubs {
	private var spcV3Entry: (WasmFunction, Pointer, Pointer) -> Throwable;
	// XXX: the RiUserCode objects must be pre-allocated.
	private def ic = X86_64InterpreterCode.new(Pointer.NULL, Pointer.NULL, pregen_header);
	private def spcLazyCompileStub = X86_64SpcCompileStub.new("lazy", Pointer.NULL, Pointer.NULL);
	private def spcTierUpCompileStub = X86_64SpcCompileStub.new("tierup", Pointer.NULL, Pointer.NULL);
	private def spcTrapsStub = X86_64SpcTrapsStub.new(Pointer.NULL, Pointer.NULL);
	private var rdtsc_func: () -> u64;

	def getInterpreterCode() -> X86_64InterpreterCode {
		return (gen(), I.interpreterCode).last;
	}
	def getIntV3Entry() -> (WasmFunction, Pointer) -> Throwable {
		return (gen(), I.interpreterCode.intV3Entry).last;
	}
	def getSpcV3Entry() -> (WasmFunction, Pointer, Pointer) -> Throwable {
		return (gen(), spcV3Entry).last;
	}
	def getSpcLazyCompileStub() -> X86_64SpcCompileStub {
		return (gen(), spcLazyCompileStub).last;
	}
	def getSpcTierUpCompileStub() -> X86_64SpcCompileStub {
		return (gen(), spcTierUpCompileStub).last;
	}
	def getSpcTrapsStub() -> X86_64SpcTrapsStub {
		return (gen(), spcTrapsStub).last;
	}
	def getSpcIntEntry() -> Pointer {
		gen();
		return I.interpreterCode.start + I.interpreterCode.header.intSpcEntryOffset;
	}
	def getRdtscFunc() -> () -> u64 {
		return (gen(), rdtsc_func).last;
	}

	def gen() {
		if (I.interpreterCode != null) return;
		// Deseralize or generate the pregen stubs
		I.interpreterCode = Metrics.pregen_time_us.run(deserializeOrGenerateCode, ());
		Metrics.pregen_bytes.val += u64.!(I.interpreterCode.end - I.interpreterCode.start);

		if (Debug.pregen) Trace.OUT.put1("Created pregen stubs in %d \xCE\xBCs.\n", Metrics.pregen_time_us.val).outln();
	}
	def genAndWriteIntoExecutable(executable: string) -> bool {
		// generate the code and write it into
		gen();
		// try to find {pregen_buffer} in {data}
		var d = DataReader.new(executable);
		// the pregen buffer contents will be at the same page alignment in the executable
		var ptr = Pointer.atRef(pregen_header) + X86_64PreGenHeader.magicWord.offset;
		var page_offset = int.!((ptr - Pointer.NULL) & (PAGE_SIZE - 1));
		var found = -1;
		for (pos = page_offset; pos < d.limit; pos += PAGE_SIZE_i) {
			var val = d.at(pos).read_u64();
			if (val == PREGEN_MAGIC_WORD) { found = pos; break; }
		}
		if (found < 0) {
			if (Debug.pregen) Trace.OUT.puts("Pregen buffer not found").outln();
			return false;
		}
		if (Debug.pregen) {
			Trace.OUT.put2("Pregen buffer in executable @+%d (0x%x)", found, found).outln();
		}
		// Write the executable code and the offsets of {InterpreterCode} into the executable.
		var w = DataWriter.new().reset(executable, found, found);
		w.puta(pregen_buffer);		// write machine code
		return true;
	}
	def deserializeOrGenerateCode() -> X86_64InterpreterCode {
		var start = Pointer.atContents(pregen_buffer);
		var range = MemoryRange.new(start, start + pregen_buffer.length);

		Debug.beforePregen();
		ic.start = range.start;

		// Try deserializing the pregen code offsets directly from the global buffer.
		var marker = pregen_header.codeMarker;
		if (Debug.pregen) {
			Trace.OUT.put2("Pregen buffer marker = 0x%x (0x%x indicates generated)",
				marker, PREGEN_CODE_MARKER).outln();
		}
		if (pregen_header.codeMarker == PREGEN_CODE_MARKER) {
			if (Debug.pregen) {
				Trace.OUT.put2("Pregen stubs exist in [0x%x ... 0x%x]",
					(range.start - Pointer.NULL),
					(range.end - Pointer.NULL));
				Trace.OUT.outln();
			}
		} else {
			//         pregen buffer v   [0 ...                                         TOTAL_SIZE  ]
			//      |xxxxxxxxxxxxxxxx|h|l|pregen_header|...|dispatch|...|inline_code|ool_code|___
			//      ^----elem0_offset----^
			// page ^                                1KiB  ^       page ^      page ^
			var mask = 4095L;
			var elem0_offset = (start - Pointer.NULL) & mask;
			var alloc_offset = elem0_offset + 8 + X86_64PreGenHeader.size;
			var aligned_offset = (alloc_offset + mask) & ~mask;
			var skip = int.!(aligned_offset - elem0_offset);

			if (Debug.pregen) {
				Trace.OUT.put3("Generating pregen stubs into [0x%x ... 0x%x], skipping %d bytes",
					(range.start - Pointer.NULL),
					(range.end - Pointer.NULL),
					skip);
				Trace.OUT.outln();
			}

			var w = DataWriter.new().reset(pregen_buffer, skip, skip);
			// Gen interpreter
			X86_64InterpreterGen.new(ic, w).gen(range);
			// Gen SPC entry
			ic.header.spcV3EntryOffset = w.atEnd().pos;
			X86_64Spc.genEntryStub(w);
			// Gen SPC lazy compile
			ic.header.spcLazyCompileOffset = w.atEnd().pos;
			X86_64Spc.genLazyCompileStub(w);
			// Gen SPC tierup compile
			ic.header.spcTierUpCompileOffset = w.atEnd().pos;
			X86_64Spc.genTierUpCompileStub(w, ic);
			// Gen SPC traps stub
			ic.header.spcTrapsStubOffset = w.atEnd().pos;
			X86_64Spc.genTrapsStub(w, spcTrapsStub);
			ic.header.spcTrapsStubEnd = w.atEnd().pos;
			// Gen rdtsc function
			ic.header.rdtscOffset = w.atEnd().pos;
			genRdtsc(w);
			ic.header.codeEnd = w.atEnd().pos;
			ic.header.codeMarker = PREGEN_CODE_MARKER;
		}
		// Finish the interpreter code.
		ic.end = range.start + ic.header.codeEnd;
		ic.setV3Entry();
		I.interpreterCode = ic;
		I.dispatchTable = ic.start +
			if(Instrumentation.probes.elem != null,
				ic.header.probedDispatchTableOffset,
				ic.header.fastDispatchTableOffset);

		// Write-protect the executable code for security and debugging
		Mmap.protect(range.start + ic.header.codeStart, u64.!(ic.header.codeEnd - ic.header.codeStart), Mmap.PROT_READ | Mmap.PROT_EXEC);

		// Register user code objects with the Virgil runtime.
		RiRuntime.registerUserCode(ic);

		// SPC entry point
		spcV3Entry = CiRuntime.forgeClosure<void,
			(WasmFunction, Pointer, Pointer), Throwable>(
				range.start + ic.header.spcV3EntryOffset, ());

		// SPC lazy compile
		spcLazyCompileStub.start = range.start + ic.header.spcLazyCompileOffset;
		spcLazyCompileStub.end = range.start + ic.header.spcTierUpCompileOffset;
		RiRuntime.registerUserCode(spcLazyCompileStub);

		// SPC tierup compile
		spcTierUpCompileStub.start = range.start + ic.header.spcTierUpCompileOffset;
		spcTierUpCompileStub.end = range.start + ic.header.spcTrapsStubOffset;
		RiRuntime.registerUserCode(spcTierUpCompileStub);

		// SPC traps stub
		spcTrapsStub.start = range.start + ic.header.spcTrapsStubOffset;
		spcTrapsStub.end = range.start + ic.header.spcTrapsStubEnd;
		RiRuntime.registerUserCode(spcTrapsStub);

		// RDTSC function
		var rdtscCode = range.start + ic.header.rdtscOffset;
		rdtsc_func = CiRuntime.forgeClosure<void, void, u64>(rdtscCode, ());

		// Trace results to help in debugging
		if (Debug.pregen || Debug.interpreter || Trace.compiler || Debug.compiler) {
			var s = range.start - Pointer.NULL;
			Trace.OUT
				.puts("Pregen interpreter and compiler stub addresses:\n")
				.put1("\tcode start:                0x%x\n", s + ic.header.codeStart)
				.put1("\tv3->int entry:      break *0x%x\n", s + ic.header.intV3EntryOffset)
				.put1("\tspc->int entry:     break *0x%x\n", s + ic.header.intSpcEntryOffset)
				.put1("\tint->int entry:     break *0x%x\n", s + ic.header.intIntEntryOffset)
				.put1("\tfast dispatch:             0x%x\n", s + ic.header.fastDispatchTableOffset)
				.put1("\tprobed dispatch:           0x%x\n", s + ic.header.probedDispatchTableOffset)
				.put1("\toob memory:         break *0x%x\n", s + ic.header.oobMemoryHandlerOffset)
				.put1("\tdivide by zero:     break *0x%x\n", s + ic.header.divZeroHandlerOffset)
				.put1("\tstack overflow:     break *0x%x\n", s + ic.header.stackOverflowHandlerOffset)
				.put1("\tv3->entry:          break *0x%x\n", s + ic.header.spcV3EntryOffset)
				.put1("\tspc lazy compile:   break *0x%x\n", s + ic.header.spcLazyCompileOffset)
				.put1("\tspc tierup compile: break *0x%x\n", s + ic.header.spcTierUpCompileOffset)
				.put2("\tspc traps stubs:           0x%x - 0x%x\n",
					s + ic.header.spcTrapsStubOffset, s + ic.header.spcTrapsStubEnd)
				.put1("\trdtsc:              break *0x%x\n", s + ic.header.rdtscOffset)
				.put1("\tcode end:                  0x%x\n", s + ic.header.codeEnd)
				.outln();
		}
		Debug.afterPregen();
		return ic;
	}
	def genRdtsc(w: DataWriter) {
		def asm = X86_64Assemblers.create64(w);
		asm.rdtsc();
		asm.q.shl_r_i(X86_64Regs.RDX, 32);
		asm.q.or_r_r(X86_64Regs.RAX, X86_64Regs.RDX); // XXX: use V3 return register symbolic constant
		asm.ret();
	}
}

// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

var interpreterCode: InterpreterCode;
def genInterpreterCode(i: InterpreterCallbacks) -> InterpreterCode {
	var gen = X86_64CodeGen.new();
	var ic = gen.genInterpreter(i);
	if (ic == null) fatal("failed to generate interpreter");
	if (Trace.interpreter) {
		var buf = TraceBuilder.new();
		var start = ic.mapping.range.start - Pointer.NULL;
		buf.put2("Generated asm interpreter @ (0x%x ... 0x%x)\n",
			start,
			(ic.mapping.range.end - Pointer.NULL));
		buf.put1("\tv3 entry     = 0x%x\n", start + ic.v3EntryOffset);
		buf.put1("\tcall entry   = 0x%x\n", start + ic.callEntryOffset);
		buf.put1("\tdispatch     = 0x%x\n", start + ic.firstDispatchOffset);
		buf.put1("\thandlers end = 0x%x\n", start + ic.handlerEndOffset);
		buf.put1("\tcode end     = 0x%x\n", start + ic.codeEndOffset);
		buf.put1("\toob mem      = 0x%x\n", start + ic.oobMemoryHandlerOffset);
		buf.put1("\tdivzero      = 0x%x\n", start + ic.divZeroHandlerOffset);
		buf.outln();
	}
	RiRuntime.userSignalHandler = handleSignal;
	return interpreterCode = ic;
}
// Signal-handling for traps
def ucontext_rip_offset = 168;
def ucontext_rsp_offset = 160;
def SIGFPE  = 8;
def SIGBUS  = 10;
def SIGSEGV = 11;
def handleSignal(signum: int, siginfo: Pointer, ucontext: Pointer) -> bool {
	var pip = ucontext + ucontext_rip_offset;
	var ip = pip.load<Pointer>();
	var r = interpreterCode.mapping.range;
	if (!r.contains(ip)) return false;
	if (Trace.interpreter) {
		TraceBuilder.new().put2("  !signal in interpreter %d @ 0x%x", signum, ip - Pointer.NULL).outln();
	}
	match (signum) {
		SIGFPE => {
			// presume divide/modulus by zero
			pip.store<Pointer>(r.start + interpreterCode.divZeroHandlerOffset);
			return true;
		}
		SIGBUS, SIGSEGV => {
			// TODO: distinguish OOB from stack overflow, from interpreter crash
			pip.store<Pointer>(r.start + interpreterCode.oobMemoryHandlerOffset);
			return true;
		}
	}
	return true;
}

class InterpreterCallbacks(i: X86_64FastInterpreter) {
	def callHost: Pointer = CiRuntime.unpackClosure<Interpreter, (Function, Pointer, Pointer), (ExecState, TrapReason)>(i.callHost).0;
}

// Implements a Wasm interpreter by running handwritten x86-64 interpreter loop.
class X86_64FastInterpreter extends Interpreter {
	def valueStack = ValueStack.new();
	var asmEntry: (/*wf: */ WasmFunction, /*sp: */ Pointer) -> (ExecState, TrapReason);

	new() {
		if (interpreterCode == null) interpreterCode = genInterpreterCode(InterpreterCallbacks.new(this));
		asmEntry = CiRuntime.forgeClosure<
			X86_64FastInterpreter,
				(/*wf: */ WasmFunction,
				/*sp: */ Pointer),
			(ExecState, TrapReason)>(interpreterCode.mapping.range.start + interpreterCode.v3EntryOffset, this);
	}

	def run(count: int, f: Function, args: Array<Value>) -> Result {
		if (!WasmFunction.?(f)) return Result.Trap(TrapReason.ERROR);
		var wf = WasmFunction.!(f);
		// Unpack arguments into value stack format.
		var fp = valueStack.sp;
		if (args != null) for (v in args) valueStack.push(v);

		// Invoke native (asm) entry.
		if (Trace.interpreter) {
			var buf = TraceBuilder.new();
			buf.put2("X86_64FastInterpreter.asmEntry(wf=0x%x, sp=0x%x)",
				Pointer.atObject(wf) - Pointer.NULL, valueStack.sp - Pointer.NULL);
			buf.outln();
		}
		var state = invoke(wf, valueStack.sp);

		// Unpack result(s).
		match (state.0) {
			STOPPED,
			RUNNING => return Result.Trap(TrapReason.UNIMPLEMENTED);
			TRAPPED => return Result.Trap(state.1);
			BREAKPOINT => return Result.Break;
			FINISHED => {
				valueStack.sp = fp + (wf.sig.results.length * SLOT_SIZE);
				return popResult(f.sig);
			}
			TIMEOUT => return Result.Break;
		}
	}
	def invoke(wf: WasmFunction, sp: Pointer) -> (ExecState, TrapReason) {
		return asmEntry(wf, sp);
	}
	def popResult(sig: SigDecl) -> Result {
		var rt = sig.results;
		var r = Array<Value>.new(rt.length);
		for (i = r.length - 1; i >= 0; i--) r[i] = valueStack.pop(rt[i]);
		return Result.Value(r);
	}
	def callHost(f: Function, vfp: Pointer, vsp: Pointer) -> (ExecState, TrapReason) {
		var r: HostResult;
		var prevSp = valueStack.sp;
		valueStack.sp = vsp;
		match (f) {
			hf: HostFunction0 => {
				r = hf.invoke0();
			}
			hf: HostFunction1 => {
				var a0 = valueStack.pop(hf.sig.params[0]);
				r = hf.invoke1(a0);
			}
			hf: HostFunction2 => {
				var a1 = valueStack.pop(hf.sig.params[1]);
				var a0 = valueStack.pop(hf.sig.params[0]);
				r = hf.invoke2(a0, a1);
			}
			hf: HostFunction3 => {
				var a2 = valueStack.pop(hf.sig.params[2]);
				var a1 = valueStack.pop(hf.sig.params[1]);
				var a0 = valueStack.pop(hf.sig.params[0]);
				r = hf.invoke3(a0, a1, a2);
			}
			hf: HostFunctionN => {
				var aN = valueStack.popN(hf.sig.params);
				r = hf.invokeN(aN);
			}
			_ => fatal("call to non-host function");

		}
		valueStack.sp = vfp;
		match (r) {
			Trap(reason) => return (ExecState.TRAPPED, reason);
			Error(msg) => {
				error_msg = msg;
				return (ExecState.TRAPPED, TrapReason.ERROR);
			}
			Value0 => ; // do nothing
			Value1(val) => valueStack.push(val);
			ValueN(vals) => {
				for (a in vals) val_stack.push(a);
			}
			TailCall(f, args) => {
				fatal("host tail call");
			}
		}
		return (ExecState.FINISHED, TrapReason.NONE);
	}
}

// Implements a value stack using raw (Pointer) memory, with explicitly tagged values.
// TODO: need custom scan extension for V3 garbage collector for reference values.
def SLOT_SIZE = 2 * Pointer.SIZE;
class ValueStack {
	def mapping = Mmap.reserve(DEFAULT_STACK_SIZE, Mmap.PROT_READ | Mmap.PROT_WRITE);
	var sp: Pointer;

	new() {
		if (mapping == null) fatal("out of memory allocating value stack");
		sp = mapping.range.start;
	}
	def push(v: Value) {
		match (v) {
			Ref(obj) => pushPair(BpTypecon.RefNullT.code, obj);
			I31(val) => pushPair(BpTypecon.I31REF.code, u64.view(val));
			I32(val) => pushPair(BpTypecon.I32.code, u64.view(val));
			I64(val) => pushPair(BpTypecon.I64.code, u64.view(val));
			F32(bits) => pushPair(BpTypecon.F32.code, u64.view(bits));
			F64(bits) => pushPair(BpTypecon.F64.code, u64.view(bits));
		}
	}
	def popN(t: Array<ValueType>) -> Array<Value> {
		var r = Array<Value>.new(t.length);
		for (i < t.length) {
			var j = r.length - i - 1;
			r[j] = pop(t[j]);
		}
		return r;
	}
	def pop(t: ValueType) -> Value {
		match (t) {
			I32 => return Value.I32(popb32(BpTypecon.I32.code));
			I64 => return Value.I64(popb64(BpTypecon.I64.code));
			F32 => return Value.F32(popb32(BpTypecon.F32.code));
			F64 => return Value.F64(popb64(BpTypecon.F64.code));
			RefStruct,
			RefArray,
			Host,
			EXTERNREF,
			EXTERNREF_NULL,
			ANYREF => return Value.Ref(popObject());
			I31REF => {
				if (peekTag() == BpTypecon.I31REF.code) return Value.I31(u31.view(popb32(BpTypecon.I31REF.code)));
				else return Value.Ref(popObject());
			}
			RefFunc,
			FUNCREF => return Value.Ref(popFunction());
			Rtt => return Value.Ref(popRtt());
			_ => fatal(Strings.format1("unexpected type: %s", t.name));
		}
		return Value.Ref(null);
	}
	def popb32(tag: byte) -> u32 {
		checkTag(tag);
		sp += -(SLOT_SIZE);
		return (sp + Pointer.SIZE).load<u32>();
	}
	def popb64(tag: byte) -> u64 {
		checkTag(tag);
		sp += -(SLOT_SIZE);
		return (sp + Pointer.SIZE).load<u64>();
	}
	def popObject() -> Object {
		var got = peekTag();
		match (got) {
			BpTypecon.ANYREF.code,
			BpTypecon.FUNCREF.code,
			BpTypecon.EXTERNREF.code,
			BpTypecon.RefNullT.code,
			BpTypecon.RefT.code,
			BpTypecon.I31REF.code => ;
			_ => fatal(Strings.format1("value stack tag mismatch, expected ref, got %x", got));
		}
		sp += -(SLOT_SIZE);
		return (sp + Pointer.SIZE).load<Object>();
	}
	def popFunction() -> Function {
		var obj = popObject();
//		if (!Function.?(obj)) { fatal("expected function object"); return null; }
		return Function.!(obj);
	}
	def popRtt() -> RttObject {
		var obj = popObject();
//		if (!RttObject.?(obj)) { fatal("expected RTT object"); return null; }
		return RttObject.!(obj);
	}
	def checkTag(tag: byte) -> byte {
		var got = peekTag();
		if (got == tag) return tag;
		fatal(Strings.format2("value stack tag mismatch, expected: %x, got %x", tag, got));
		return tag;
	}
	def peekTag() -> byte {
		return (sp + -(Pointer.SIZE * 2)).load<u8>() & '\x7F';
	}
	def pushPair<T>(tag: byte, bits: T) {
		sp.store<u8>(tag);
		(sp + Pointer.SIZE).store(bits);
		sp += (SLOT_SIZE);
	}
}

def fatal(msg: string) {
	System.error("X86_64FastInterpreter", msg);
}

def DEFAULT_STACK_SIZE = 128u * 1024u;
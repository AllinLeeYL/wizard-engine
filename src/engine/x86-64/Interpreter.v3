// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

var interpreterCode: InterpreterCode;

class InterpreterCode(mapping: Mapping) {
	var v3EntryOffset: int;
	var callEntryOffset: int;
	var firstDispatchOffset: int;
	var callOffset: int;
	var oobMemoryHandlerOffset: int;
	var divZeroHandlerOffset: int;
	var stackOverflowHandlerOffset: int;
	var invalidOpcodeOffset: int;
	var unimplementedOpcodeOffset: int;
	var codeEndOffset: int;
	var handlerEndOffset: int;

	var dispatchTable = DispatchTableRef.new();
	var oolULeb32Sites = Vector<OutOfLineLEB>.new();
	var oolSLeb32Sites = Vector<OutOfLineLEB>.new();
}

// Implements a Wasm interpreter by running handwritten x86-64 interpreter loop.
class X86_64FastInterpreter extends Interpreter {
	def valueStack = ValueStack.new();
	var asmEntry: (/*ip: */ Pointer, /*eip: */ Pointer, /*fp: */ Pointer, /*sp: */ Pointer) -> (ExecState, TrapReason);


	new() {
		if (interpreterCode == null) {
			var gen = X86_64CodeGen.new();
			var ic = gen.genInterpreter();
			if (ic == null) fatal("failed to generate interpreter");
			interpreterCode = ic;
			if (Trace.interpreter) {
				var buf = TraceBuilder.new();
				var start = interpreterCode.mapping.range.start - Pointer.NULL;
				buf.put2("Generated asm interpreter @ (0x%x ... 0x%x)\n",
					start,
					(interpreterCode.mapping.range.end - Pointer.NULL));
				buf.put1("\tv3 entry     = 0x%x\n", start + ic.v3EntryOffset);
				buf.put1("\tcall entry   = 0x%x\n", start + ic.callEntryOffset);
				buf.put1("\tdispatch     = 0x%x\n", start + ic.firstDispatchOffset);
				buf.put1("\thandlers end = 0x%x\n", start + ic.handlerEndOffset);
				buf.put1("\tcode end     = 0x%x\n", start + ic.codeEndOffset);
				buf.outln();
			}
		}
		asmEntry = CiRuntime.forgeClosure<
			X86_64FastInterpreter,
				(/*ip: */ Pointer,
				/*eip: */ Pointer,
				/*fp: */ Pointer,
				/*sp: */ Pointer),
			(ExecState, TrapReason)>(interpreterCode.mapping.range.start + interpreterCode.v3EntryOffset, this);
	}

	def run(count: int, ff: Function, args: Array<Value>) -> Result {
		if (!WasmFunction.?(ff)) return Result.Trap(TrapReason.ERROR);
		var f = WasmFunction.!(ff);
		// Unpack arguments into value stack format.
		var fp = valueStack.sp;
		if (args != null) for (v in args) valueStack.push(v);

		// Invoke native (asm) entry.
		var ip = Pointer.atContents(f.decl.code.code);
		var eip = ip + f.decl.code.code.length;
		if (Trace.interpreter) {
			var buf = TraceBuilder.new();
			buf.put2("X86_64FastInterpreter.asmEntry(ip=0x%x, eip=0x%x",
				ip - Pointer.NULL, eip - Pointer.NULL);
			buf.put2(", fp=0x%x, sp=0x%x)",
				fp - Pointer.NULL, valueStack.sp - Pointer.NULL);
			buf.outln();
		}
		var state = invoke(ip, eip, fp, valueStack.sp);

		// Unpack result(s).
		match (state.0) {
			STOPPED,
			RUNNING => return Result.Trap(TrapReason.UNIMPLEMENTED);
			TRAPPED => return Result.Trap(state.1);
			BREAKPOINT => return Result.Break;
			FINISHED => return popResult(f.sig);
			TIMEOUT => return Result.Break;
		}
	}
	def invoke(ip: Pointer, eip: Pointer, fp: Pointer, sp: Pointer) -> (ExecState, TrapReason) {
		return asmEntry(ip, eip, fp, sp);
	}
	def popResult(sig: SigDecl) -> Result {
		var rt = sig.results;
		var r = Array<Value>.new(rt.length);
		for (i = r.length - 1; i >= 0; i--) r[i] = valueStack.pop(rt[i]);
		return Result.Value(r);
	}
}

// Implements a value stack using raw (Pointer) memory, with explicit tags.
// TODO: need custom scan extension for V3 garbage collector.
class ValueStack {
	def mapping = Mmap.reserve(DEFAULT_STACK_SIZE, Mmap.PROT_READ | Mmap.PROT_WRITE);
	var sp: Pointer;

	new() {
		if (mapping == null) fatal("out of memory allocating value stack");
		sp = mapping.range.start;
	}
	def push(v: Value) {
		match (v) {
			Ref(obj) => {
				sp.store<i64>(i7.view(BpTypecon.RefNullT.code));
				(sp + Pointer.SIZE).store(obj);
			}
			FuncRef(func) => {
				sp.store<i64>(i7.view(BpTypecon.FUNCREF.code));
				(sp + Pointer.SIZE).store(func);
			}
			Rtt(heaptype, supers) => {
				sp.store<i64>(i7.view(BpTypecon.Rtt.code));
				(sp + Pointer.SIZE).store(v);
			}
			I31(val) => {
				sp.store<i64>(i7.view(BpTypecon.I31REF.code));
				(sp + Pointer.SIZE).store(u64.view(val));
			}
			I32(val) => {
				sp.store<i64>(i7.view(BpTypecon.I32.code));
				(sp + Pointer.SIZE).store(u64.view(val));
			}
			I64(val) => {
				sp.store<i64>(i7.view(BpTypecon.I64.code));
				(sp + Pointer.SIZE).store(u64.view(val));
			}
			F32(bits) => {
				sp.store<i64>(i7.view(BpTypecon.F32.code));
				(sp + Pointer.SIZE).store(u64.view(bits));
			}
			F64(bits) => {
				sp.store<i64>(i7.view(BpTypecon.F64.code));
				(sp + Pointer.SIZE).store(u64.view(bits));
			}
		}
		sp += Pointer.SIZE * 2;
	}
	def pop(t: ValueType) -> Value {
		match (t) {
			I32 => return Value.I32(popb32(BpTypecon.I32.code));
			I64 => return Value.I64(popb64(BpTypecon.I64.code));
			F32 => return Value.F32(popb32(BpTypecon.F32.code));
			F64 => return Value.F64(popb64(BpTypecon.F64.code));
			RefStruct,
			RefArray,
			Host,
			EXTERNREF,
			EXTERNREF_NULL,
			ANYREF => return Value.Ref(popObject());
			I31REF => {
				var tag = (sp + -(Pointer.SIZE * 2)).load<i64>();
				if (tag == i7.view(BpTypecon.I31REF.code)) return Value.I31(u31.view(popb32(BpTypecon.I31REF.code)));
				else return Value.Ref(popObject());
			}
			RefFunc,
			FUNCREF => return Value.FuncRef(popFunction());
			Rtt => return popRtt();
			VEC128 => fatal("unexpected vector type");
			FwRef => fatal("unexpected FwRef type");
			Abstract => fatal("unexpected abstract type");
		}
		return Value.Ref(null); // TODO
	}
	def popb32(tag: byte) -> u32 {
		sp += -(2 * Pointer.SIZE);
		var got = sp.load<i64>();
		if (got != i7.view(tag)) fatal("expected primitive");
		return (sp + Pointer.SIZE).load<u32>();
	}
	def popb64(tag: byte) -> u64 {
		sp += -(2 * Pointer.SIZE);
		var got = sp.load<i64>();
		if (got != i7.view(tag)) fatal("expected primitive");
		return (sp + Pointer.SIZE).load<u64>();
	}
	def popObject() -> Object {
		sp += -(2 * Pointer.SIZE);
		var got = sp.load<i64>();
		if (got != 0) fatal("expected reference"); // TODO
		return (sp + Pointer.SIZE).load<Object>();
	}
	def popFunction() -> Function {
		sp += -(2 * Pointer.SIZE);
		var tag = sp.load<i64>();
		if (tag != 0) fatal("expected reference"); // TODO
		return (sp + Pointer.SIZE).load<Function>();
	}
	def popRtt() -> Value.Rtt {
		sp += -(2 * Pointer.SIZE);
		var got = sp.load<i64>();
		if (got != i7.view(BpTypecon.Rtt.code)) fatal("expected RTT"); // TODO
		return (sp + Pointer.SIZE).load<Value.Rtt>();
	}
}

def fatal(msg: string) {
	System.error("X86_64FastInterpreter", msg);
}

def DEFAULT_STACK_SIZE = 128u * 1024u;
// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

var interpreterCode: InterpreterCode;

// Implements a Wasm interpreter by running handwritten x86-64 interpreter loop.
class X86_64FastInterpreter extends Interpreter {
	def valueStack = ValueStack.new();
	var asmEntry: (/*wf: */ WasmFunction,/*fp: */ Pointer, /*sp: */ Pointer) -> (ExecState, TrapReason);

	new() {
		if (interpreterCode == null) {
			var gen = X86_64CodeGen.new();
			var ic = gen.genInterpreter();
			if (ic == null) fatal("failed to generate interpreter");
			interpreterCode = ic;
			if (Trace.interpreter) {
				var buf = TraceBuilder.new();
				var start = interpreterCode.mapping.range.start - Pointer.NULL;
				buf.put2("Generated asm interpreter @ (0x%x ... 0x%x)\n",
					start,
					(interpreterCode.mapping.range.end - Pointer.NULL));
				buf.put1("\tv3 entry     = 0x%x\n", start + ic.v3EntryOffset);
				buf.put1("\tcall entry   = 0x%x\n", start + ic.callEntryOffset);
				buf.put1("\tdispatch     = 0x%x\n", start + ic.firstDispatchOffset);
				buf.put1("\thandlers end = 0x%x\n", start + ic.handlerEndOffset);
				buf.put1("\tcode end     = 0x%x\n", start + ic.codeEndOffset);
				buf.outln();
			}
		}
		asmEntry = CiRuntime.forgeClosure<
			X86_64FastInterpreter,
				(/*wf: */ WasmFunction,
				/*fp: */ Pointer,
				/*sp: */ Pointer),
			(ExecState, TrapReason)>(interpreterCode.mapping.range.start + interpreterCode.v3EntryOffset, this);
	}

	def run(count: int, f: Function, args: Array<Value>) -> Result {
		if (!WasmFunction.?(f)) return Result.Trap(TrapReason.ERROR);
		var wf = WasmFunction.!(f);
		// Unpack arguments into value stack format.
		var fp = valueStack.sp;
		if (args != null) for (v in args) valueStack.push(v);

		// Invoke native (asm) entry.
		if (Trace.interpreter) {
			var buf = TraceBuilder.new();
			buf.put3("X86_64FastInterpreter.asmEntry(wf=0x%x, fp=0x%x, sp=0x%x)",
				Pointer.atObject(wf) - Pointer.NULL, fp - Pointer.NULL, valueStack.sp - Pointer.NULL);
			buf.outln();
		}
		var state = invoke(wf, fp, valueStack.sp);

		// Unpack result(s).
		match (state.0) {
			STOPPED,
			RUNNING => return Result.Trap(TrapReason.UNIMPLEMENTED);
			TRAPPED => return Result.Trap(state.1);
			BREAKPOINT => return Result.Break;
			FINISHED => {
				valueStack.sp = fp + (wf.sig.results.length * SLOT_SIZE);
				return popResult(f.sig);
			}
			TIMEOUT => return Result.Break;
		}
	}
	def invoke(wf: WasmFunction, fp: Pointer, sp: Pointer) -> (ExecState, TrapReason) {
		return asmEntry(wf, fp, sp);
	}
	def popResult(sig: SigDecl) -> Result {
		var rt = sig.results;
		var r = Array<Value>.new(rt.length);
		for (i = r.length - 1; i >= 0; i--) r[i] = valueStack.pop(rt[i]);
		return Result.Value(r);
	}
}

// Implements a value stack using raw (Pointer) memory, with explicitly tagged values.
// TODO: need custom scan extension for V3 garbage collector for reference values.
def SLOT_SIZE = 2 * Pointer.SIZE;
class ValueStack {
	def mapping = Mmap.reserve(DEFAULT_STACK_SIZE, Mmap.PROT_READ | Mmap.PROT_WRITE);
	var sp: Pointer;

	new() {
		if (mapping == null) fatal("out of memory allocating value stack");
		sp = mapping.range.start;
	}
	def push(v: Value) {
		match (v) {
			Ref(obj) => pushPair(BpTypecon.RefNullT.code, obj);
			FuncRef(func) => pushPair(BpTypecon.FUNCREF.code, func);
			Rtt(heaptype, supers) => pushPair(BpTypecon.Rtt.code, v);
			I31(val) => pushPair(BpTypecon.I31REF.code, u64.view(val));
			I32(val) => pushPair(BpTypecon.I32.code, u64.view(val));
			I64(val) => pushPair(BpTypecon.I64.code, u64.view(val));
			F32(bits) => pushPair(BpTypecon.F32.code, u64.view(bits));
			F64(bits) => pushPair(BpTypecon.F64.code, u64.view(bits));
		}
	}
	def pop(t: ValueType) -> Value {
		match (t) {
			I32 => return Value.I32(popb32(BpTypecon.I32.code));
			I64 => return Value.I64(popb64(BpTypecon.I64.code));
			F32 => return Value.F32(popb32(BpTypecon.F32.code));
			F64 => return Value.F64(popb64(BpTypecon.F64.code));
			RefStruct,
			RefArray,
			Host,
			EXTERNREF,
			EXTERNREF_NULL,
			ANYREF => return Value.Ref(popObject());
			I31REF => {
				if (peekTag() == BpTypecon.I31REF.code) return Value.I31(u31.view(popb32(BpTypecon.I31REF.code)));
				else return Value.Ref(popObject());
			}
			RefFunc,
			FUNCREF => return Value.FuncRef(popFunction());
			Rtt => return popRtt();
			_ => fatal(Strings.format1("unexpected type: %s", t.name));
		}
		return Value.Ref(null);
	}
	def popb32(tag: byte) -> u32 {
		checkTag(tag);
		sp += -(SLOT_SIZE);
		return (sp + Pointer.SIZE).load<u32>();
	}
	def popb64(tag: byte) -> u64 {
		checkTag(tag);
		sp += -(SLOT_SIZE);
		return (sp + Pointer.SIZE).load<u64>();
	}
	def popObject() -> Object {
		checkTag(0); // TODO: many valid tags for objects
		sp += -(SLOT_SIZE);
		return (sp + Pointer.SIZE).load<Object>();
	}
	def popFunction() -> Function {
		checkTag(BpTypecon.FUNCREF.code);
		sp += -(SLOT_SIZE);
		return (sp + Pointer.SIZE).load<Function>();
	}
	def popRtt() -> Value.Rtt {
		checkTag(BpTypecon.Rtt.code);
		sp += -(SLOT_SIZE);
		return (sp + Pointer.SIZE).load<Value.Rtt>();
	}
	def checkTag(tag: byte) -> byte {
		var got = peekTag();
		if (got == tag) return tag;
		var buf = StringBuilder.new();
		buf.put2("value stack tag mismatch, expected: %x, got %x", tag, got);
		fatal(buf.toString());
		return tag;
	}
	def peekTag() -> byte {
		return (sp + -(Pointer.SIZE * 2)).load<u8>() & '\x7F';
	}
	def pushPair<T>(tag: byte, bits: T) {
		sp.store<u8>(tag);
		(sp + Pointer.SIZE).store(bits);
		sp += (SLOT_SIZE);
	}
}

def fatal(msg: string) {
	System.error("X86_64FastInterpreter", msg);
}

def DEFAULT_STACK_SIZE = 128u * 1024u;
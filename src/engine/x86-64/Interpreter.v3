// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

var interpreterCode: InterpreterCode;

class InterpreterCode(mapping: Mapping) {
	def entry: (Pointer, Pointer, Pointer) -> ExecState
		= CiRuntime.forgeClosure<void, (Pointer, Pointer, Pointer), ExecState>(mapping.range.start, ());
}

class X86_64FastInterpreter extends Interpreter {
	def valueStack = ValueStack.new();

	new() {
		if (interpreterCode == null) {
			var gen = X86_64CodeGen.new();
			interpreterCode = gen.genInterpreter();
			if (interpreterCode == null) fatal("failed to generate interpreter");
		}
	}

	def run(count: int, ff: Function, args: Array<Value>) -> Result {
		if (!WasmFunction.?(ff)) return Result.Trap(TrapReason.ERROR);
		var f = WasmFunction.!(ff);
		// 1. unpack arguments into value stack format
		var fp = valueStack.sp;
		if (args != null) for (v in args) valueStack.push(v);

		// 2. invoke entry
		var ip = Pointer.atContents(f.decl.code.code);
		var state = interpreterCode.entry(fp, valueStack.sp, ip);

		match (state) {
			STOPPED,
			RUNNING,
			TRAPPED => return Result.Trap(TrapReason.UNIMPLEMENTED); // TODO
			BREAKPOINT => return Result.Break;
			FINISHED => return popResult(f.sig);
			TIMEOUT => return Result.Break;
		}
	}
	def popResult(sig: SigDecl) -> Result {
		var rt = sig.results;
		var r = Array<Value>.new(rt.length);
		for (i = r.length - 1; i >= 0; i--) r[i] = valueStack.pop(rt[i]);
		return Result.Value(r);
	}
}

class ValueStack {
	def TAG_REF = 1uL;
	def TAG_PRIM = 0uL;

	def mapping = Mmap.reserve(128u * 1024u, Mmap.PROT_READ | Mmap.PROT_WRITE);
	var sp: Pointer;

	new() {
		if (mapping == null) fatal("out of memory allocating value stack");
		sp = mapping.range.start;
	}
	def push(v: Value) {
		match (v) {
			Ref(obj) => {
				sp.store(TAG_REF);
				(sp + Pointer.SIZE).store(obj);
			}
			FuncRef(func) => {
				sp.store(TAG_REF);
				(sp + Pointer.SIZE).store(func);
			}
			Rtt(heaptype, supers) => {
				sp.store(TAG_REF);
				(sp + Pointer.SIZE).store(v);
			}
			I31(val) => {
				sp.store(TAG_PRIM);
				(sp + Pointer.SIZE).store(u64.view(val));
			}
			I32(val) => {
				sp.store(TAG_PRIM);
				(sp + Pointer.SIZE).store(u64.view(val));
			}
			I64(val) => {
				sp.store(TAG_PRIM);
				(sp + Pointer.SIZE).store(u64.view(val));
			}
			F32(bits) => {
				sp.store(TAG_PRIM);
				(sp + Pointer.SIZE).store(u64.view(bits));
			}
			F64(bits) => {
				sp.store(TAG_PRIM);
				(sp + Pointer.SIZE).store(u64.view(bits));
			}
		}
		sp += Pointer.SIZE * 2;
	}
	def pop(t: ValueType) -> Value {
		match (t) {
			I32 => return Value.I32(popb32());
			I64 => return Value.I64(popb64());
			F32 => return Value.F32(popb32());
			F64 => return Value.F64(popb64());
			RefStruct,
			RefArray,
			Host,
			EXTERNREF,
			EXTERNREF_NULL,
			ANYREF => return Value.Ref(popObject());
			I31REF => {
				var tag = (sp + -(Pointer.SIZE * 2)).load<u64>();
				if (tag == TAG_PRIM) return Value.I31(u31.view(popb32()));
				else return Value.Ref(popObject());
			}
			RefFunc,
			FUNCREF => return Value.FuncRef(popFunction());
			Rtt => return popRtt();
			VEC128 => fatal("unexpected vector type");
			FwRef => fatal("unexpected FwRef type");
			Abstract => fatal("unexpected abstract type");
		}
		return Value.Ref(null); // TODO
	}
	def popb32() -> u32 {
		sp += -(2 * Pointer.SIZE);
		var tag = sp.load<u64>();
		if (tag != TAG_PRIM) fatal("expected primitive");
		return (sp + Pointer.SIZE).load<u32>();
	}
	def popb64() -> u64 {
		sp += -(2 * Pointer.SIZE);
		var tag = sp.load<u64>();
		if (tag != TAG_PRIM) fatal("expected primitive");
		return (sp + Pointer.SIZE).load<u64>();
	}
	def popObject() -> Object {
		sp += -(2 * Pointer.SIZE);
		var tag = sp.load<u64>();
		if (tag != TAG_REF) fatal("expected reference");
		return (sp + Pointer.SIZE).load<Object>();
	}
	def popFunction() -> Function {
		sp += -(2 * Pointer.SIZE);
		var tag = sp.load<u64>();
		if (tag != TAG_REF) fatal("expected reference");
		return (sp + Pointer.SIZE).load<Function>();
	}
	def popRtt() -> Value.Rtt {
		sp += -(2 * Pointer.SIZE);
		var tag = sp.load<u64>();
		if (tag != TAG_REF) fatal("expected RTT");
		return (sp + Pointer.SIZE).load<Value.Rtt>();
	}
}

def fatal(msg: string) {
	System.error("X86_64FastInterpreter", msg);
}
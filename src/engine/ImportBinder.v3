// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class ImportBinder(err: WasmErrorGen, module: Module) {
	def bindings = Array<Exportable>.new(module.imports.length);
	def types = Array<TypeBinding>.new(module.types.size());
	def var import_pos: int;
	private var type_pos: int;

	def getFuncSig(index: int) -> FuncSig {
		ensureTypeBindingsUpTo(index);
		match (types[index]) {
			Function(sig) => return sig;
			_ => return null;
		}
	}
	def bind(e: Exportable) {
		bindings[import_pos++] = e;
	}

	private def ensureTypeBindingsUpTo(index: int) {
		if (type_pos > index) return;
		for (i = type_pos; i <= index; i++) {
			var d = module.types[i];
			match (d) {
				Function(sig) => {
					types[i] = TypeBinding.Function(mapSig(sig));
				}
				Imported(it) => {
					var xt = mapImportedType(it);
					types[i] = if(xt != null, TypeBinding.ValueType(xt.rep),
						 TypeBinding.Imported(residual(it)));
				}
			}
		}
		type_pos = index + 1;
	}
	def mapSig(sig: FuncSig) -> FuncSig {
		var p = Arrays.map(sig.params, mapType);
		var r = Arrays.map(sig.results, mapType);
		return FuncSig.new(p, r);
	}
	def mapType(t: ValueType) -> ValueType {
		match (t) {
			RefFunc(sig) => return ValueType.RefFunc(mapSig(sig));
			RefNullFunc(sig) => return ValueType.RefFunc(mapSig(sig));
			Imported(it) => {
				var xt = mapImportedType(it);
				if (xt != null) return xt.rep;
				return ValueType.Imported(residual(it));
			}
			_ => return t;
		}
	}
	def mapImportedType(it: ImportedType) -> ExportedType {
		if (it.import_index >= import_pos) return null;
		var r = bindings[it.import_index];
		return if(ExportedType.?(r), ExportedType.!(r));
	}
	def residual(it: ImportedType) -> ImportedType {
		if (it.assignable.length == 0) return it;
		var assignable = Arrays.map(it.assignable, mapType);
		return ImportedType.new(it.import_index, it.type_index, assignable);
	}
}

type TypeBinding {
	case None;			 // uninitialized
	case Function(sig: FuncSig);	 // a (mapped) function sig
	case ValueType(vt: ValueType);   // completely bound type
	case Imported(it: ImportedType); // residual imported type
}
// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Extension point for import processing. An {ImportProcessor} lookups or materializes
// an {Exportable} for a given name and import kind. It can use the {binder} as a
// callback to access parts of the module that need polymorphic substitution.
class ImportProcessor(name: string, binder: ImportBinder) {
	new() {
		binder.processors.put(this); // install into binder's list of processors
	}
	def processCommand(name: string) -> Exportable { return null; }
	def processFunction(name: string, decl: FuncDecl) -> Exportable { return null; }
	def processTable(name: string, decl: TableDecl) -> Exportable { return null; }
	def processMemory(name: string, decl: MemoryDecl) -> Exportable { return null; }
	def processGlobal(name: string, decl: GlobalDecl) -> Exportable { return null; }
	def processType(name: string, decl: ImportedType) -> Exportable { return null; }
}

// Binding context and driver for import processing. Processes imports one by one, in
// order, dispatching to the various {ImportProcessor}s to try to resolve imports.
// Offers callbacks such as {getType()} and {getSig()} and {getFunc()} that perform
// polymorphic type substitution.
class ImportBinder(module: Module, error: WasmErrorGen) {
	def bindings = Array<Exportable>.new(module.imports.length);
	def processors = Vector<ImportProcessor>.new();
	private def sigs = Array<FuncSig>.new(module.deftypes.length); // cached substituted sigs
	private def funcs = Array<FuncDecl>.new(module.functions.length); // cached substituted funcs
	def var import_pos: int;

	// The main processing loop for all imports. Dispatches to various import processors.
	def process() {
		while (import_pos < bindings.length) {
			var imp = module.imports[import_pos];
			for (pi < processors.length) {
				if (error.error()) break;
				var p = processors[pi];
				if (!Strings.equals(p.name, imp.modname)) continue;
				var name = imp.name, exp: Exportable;
				match (imp.details) {
					Command		=> p.processCommand(name);
					Function(decl)	=> exp = p.processFunction(name, decl);
					Table(decl)	=> exp = p.processTable(name, decl);
					Memory(decl)	=> exp = p.processMemory(name, decl);
					Global(decl)	=> exp = p.processGlobal(name, decl);
					Type(decl)	=> exp = p.processType(name, decl);
				}
				if (exp != null) {
					bindings[import_pos] = exp;
					break;
				}
			}
			import_pos++;
		}
	}

	// Callbacks that perform polymorphic substitutions.
	def getFunc(index: int) -> FuncDecl {
		var func = funcs[index];
		if (func == null) {
			func = module.functions[index];
			func = FuncDecl.new(func.imported, func.index, func.sig_index, getSig(func.sig_index));
			funcs[index] = func;
		}
		return func;
	}
	def getFuncSig(index: int) -> FuncSig {
		return getSig(module.functions[index].sig_index);
	}
	def getSig(index: int) -> FuncSig {
		var sig = sigs[index];
		if (sig == null) {
			sig = DefType.Function.!(module.deftypes[index]).f;
			sig = mapSig(sig);
			sigs[index] = sig;
		}
		return sig;
	}
	def getType(index: int) -> Exportable {
		if (index >= module.types.length) return null;
		var t = module.types[index];
		return bindings[t.import_index];
	}

	// Substitution utilities.
	def mapSig(sig: FuncSig) -> FuncSig {
		if (sig == null) return null;
		var p = Arrays.map(sig.params, mapType);
		var r = Arrays.map(sig.results, mapType);
		return FuncSig.new(p, r);
	}
	def mapType(t: ValueType) -> ValueType {
		match (t) {
			RefFunc(sig) => return ValueType.RefFunc(mapSig(sig));
			RefNullFunc(sig) => return ValueType.RefFunc(mapSig(sig));
			Imported(it) => return mapImportedType(it);
			_ => return t;
		}
	}
	def mapImportedType(it: ImportedType) -> ValueType {
		if (it.import_index >= import_pos) return ValueType.Imported(residual(it));
		match (bindings[it.import_index]) {
			x: HostType => return ValueType.Host(x);
			x: ExportedValueType => return x.vt;
			_ => return ValueType.Imported(residual(it));
		}
	}
	def residual(it: ImportedType) -> ImportedType {
		if (it.assignable.length == 0) return it;
		var assignable = Arrays.map(it.assignable, mapType);
		return ImportedType.new(it.import_index, it.type_index, assignable);
	}
}

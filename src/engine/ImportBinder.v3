// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class ImportProcessor(name: string, binder: ImportBinder) {
	new() {
		binder.processors.put(this);
	}
	def processCommand(name: string) -> Exportable { return null; }
	def processFunction(name: string, decl: FuncDecl) -> Exportable { return null; }
	def processTable(name: string, decl: TableDecl) -> Exportable { return null; }
	def processMemory(name: string, decl: MemoryDecl) -> Exportable { return null; }
	def processGlobal(name: string, decl: GlobalDecl) -> Exportable { return null; }
	def processType(name: string, decl: ImportedType) -> Exportable { return null; }
}

class ImportBinder(module: Module, err: WasmErrorGen) {
	def bindings = Array<Exportable>.new(module.imports.length);
	def processors = Vector<ImportProcessor>.new();
	private def sigs = Array<FuncSig>.new(module.types.length);
	private def funcs = Array<FuncDecl>.new(module.functions.length);
	def var import_pos: int;

	def process() {
		while (import_pos < bindings.length) {
			var imp = module.imports[import_pos];
			for (pi < processors.length) {
				var p = processors[pi];
				if (!Strings.equals(p.name, imp.modname)) continue;
				var name = imp.name, exp: Exportable;
				match (imp.details) {
					Command		=> p.processCommand(name);
					Function(decl)	=> exp = p.processFunction(name, decl);
					Table(decl)	=> exp = p.processTable(name, decl);
					Memory(decl)	=> exp = p.processMemory(name, decl);
					Global(decl)	=> exp = p.processGlobal(name, decl);
					Type(decl)	=> exp = p.processType(name, decl);
				}
				if (exp != null) {
					bindings[import_pos] = exp;
					break;
				}
			}
			import_pos++;
		}
	}

	def getFunc(index: int) -> FuncDecl {
		var func = funcs[index];
		if (func == null) {
			func = module.functions[index];
			func = FuncDecl.new(func.imported, func.index, func.sig_index, getSig(func.sig_index));
			funcs[index] = func;
		}
		return func;
	}
	def getFuncSig(index: int) -> FuncSig {
		return getSig(module.functions[index].sig_index);
	}
	def getSig(index: int) -> FuncSig {
		var sig = sigs[index];
		if (sig == null) {
			sig = mapSig(sig);
			sigs[index] = sig;
		}
		return sig;
	}

	def mapSig(sig: FuncSig) -> FuncSig {
		var p = Arrays.map(sig.params, mapType);
		var r = Arrays.map(sig.results, mapType);
		return FuncSig.new(p, r);
	}
	def mapType(t: ValueType) -> ValueType {
		match (t) {
			RefFunc(sig) => return ValueType.RefFunc(mapSig(sig));
			RefNullFunc(sig) => return ValueType.RefFunc(mapSig(sig));
			Imported(it) => {
				var xt = mapImportedType(it);
				if (xt != null) return ValueType.Host(xt);
				return ValueType.Imported(residual(it));
			}
			_ => return t;
		}
	}
	def mapImportedType(it: ImportedType) -> HostType {
		if (it.import_index >= import_pos) return null;
		var r = bindings[it.import_index];
		return if(HostType.?(r), HostType.!(r));
	}
	def residual(it: ImportedType) -> ImportedType {
		if (it.assignable.length == 0) return it;
		var assignable = Arrays.map(it.assignable, mapType);
		return ImportedType.new(it.import_index, it.type_index, assignable);
	}
}

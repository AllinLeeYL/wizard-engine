// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Extension point for import processing. An {ImportProcessor} lookups or materializes
// an {Exportable} for a given name and import kind. It can use the {binder} as a
// callback to access parts of the module that need polymorphic substitution.
class ImportProcessor(name: string, binder: ImportBinder) {
	new() {
		binder.processors.put(this); // install into binder's list of processors
	}
	def processCommand(name: string) -> Exportable { return null; }
	def processFunction(name: string, decl: FuncDecl) -> Exportable { return null; }
	def processTable(name: string, decl: TableDecl) -> Exportable { return null; }
	def processMemory(name: string, decl: MemoryDecl) -> Exportable { return null; }
	def processGlobal(name: string, decl: GlobalDecl) -> Exportable { return null; }
	def processType(name: string, decl: AbsTypeDecl) -> Exportable { return null; }
}

// Binding context and driver for import processing. Processes imports one by one, in
// order, dispatching to the various {ImportProcessor}s to try to resolve imports.
// Offers callbacks such as {getType()} and {getSig()} and {getFunc()} that perform
// polymorphic type substitution.
class ImportBinder(module: Module, error: WasmErrorGen) {
	def bindings = Array<Exportable>.new(module.imports.length);
	def processors = Vector<ImportProcessor>.new();
	private def sigs = Array<FuncSig>.new(module.deftypes.length); // cached substituted sigs
	private def funcs = Array<FuncDecl>.new(module.functions.length); // cached substituted funcs
	def var import_pos: int;

	// The main processing loop for all imports. Dispatches to various import processors.
	def process() {
		while (import_pos < bindings.length) {
			var decl = module.imports[import_pos], imp = decl.imp;
			for (pi < processors.length) {
				if (error.error()) break;
				var p = processors[pi];
				if (!Strings.equals(p.name, imp.module_name)) continue;
				var name = imp.field_name, exp: Exportable;
				match (decl) {
					x: ImportCommandDecl => p.processCommand(name);
					x: FuncDecl	=> exp = p.processFunction(name, x);
					x: TableDecl	=> exp = p.processTable(name, x);
					x: MemoryDecl	=> exp = p.processMemory(name, x);
					x: GlobalDecl	=> exp = p.processGlobal(name, x);
					x: AbsTypeDecl	=> exp = p.processType(name, x);
				}
				if (exp != null) {
					bindings[import_pos] = exp;
					break;
				}
			}
			import_pos++;
		}
	}

	// Callbacks that perform polymorphic substitutions.
	def getFunc(index: int) -> FuncDecl {
		var func = funcs[index];
		if (func == null) {
			func = module.functions[index];
			var sig = SigDecl.new(getSig(func.sig.sig_index));
			var nf = FuncDecl.new(sig);
			nf.imp = func.imp;
			funcs[index] = func = nf;
		}
		return func;
	}
	def getFuncSig(index: int) -> FuncSig {
		return getSig(module.functions[index].sig.sig_index);
	}
	def getSig(index: int) -> FuncSig {
		var sig = sigs[index];
		if (sig == null) {
			sig = SigDecl.!(module.deftypes[index]).funcsig;
			sigs[index] = sig = mapSig(sig);
		}
		return sig;
	}
	def getType(index: int) -> Exportable {
		if (index >= module.abstypes.length) return null;
		var t = module.abstypes[index];
		return bindings[t.imp.import_index];
	}

	// Substitution utilities.
	def mapSig(sig: FuncSig) -> FuncSig {
		if (sig == null) return null;
		var p = Arrays.map(sig.params, mapType);
		var r = Arrays.map(sig.results, mapType);
		return FuncSig.new(p, r);
	}
	def mapType(t: ValueType) -> ValueType {
		match (t) {
			RefFunc(sig) => return ValueType.RefFunc(mapSig(sig));
			RefNullFunc(sig) => return ValueType.RefFunc(mapSig(sig));
			Abstract(it) => return mapAbsType(it);
			_ => return t;
		}
	}
	def mapAbsType(it: AbsTypeDecl) -> ValueType {
		if (it.imp.import_index >= import_pos) return ValueType.Abstract(residual(it));
		match (bindings[it.imp.import_index]) {
			x: HostType => return ValueType.Host(x);
			x: ExportedValueType => return x.vt;
			_ => return ValueType.Abstract(residual(it));
		}
	}
	def residual(it: AbsTypeDecl) -> AbsTypeDecl {
		if (it.assignable.length == 0) return it;
		var assignable = Arrays.map(it.assignable, mapType);
		var nt = AbsTypeDecl.new(assignable);
		nt.imp = it.imp;
		nt.abstype_index = it.abstype_index;
		return nt;
	}
}

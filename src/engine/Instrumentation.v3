// Copyright 2023 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Provides a common entrypoint to the engine's instrumentation capabilities, including
// the insertion/removal of probes, as well as firing probes during execution.
component Instrumentation {
	def probes = ProbeList.new();		// probes on the global interpreter loop

	// Reset the instrumentation to the default, i.e. only tracing probes.
	def reset() {
		probes.clear();
		if (Trace.interpreter) probes.add(TraceProbe.new());
	}

	// Called by the engine to fire probes on the global interpreter loop.
	def fireProbes(dynamicLoc: DynamicLoc) -> Throwable {
		Metrics.probe_fires.val++;
		var r = probes.fire(dynamicLoc);
		return resume(r);
	}
	// Called by the engine to fire probes on a specific dynamic location (instruction).
	def fireProbesAt(dynamicLoc: DynamicLoc) -> Throwable {
		var func = dynamicLoc.func;
		var pc = dynamicLoc.pc;
		var probes = func.instance.module.probes;
		if (probes == null) return null;
		var map = probes[func.decl.func_index];
		if (map == null) return null;
		var probe = map[pc];
		if (probe == null) return null;
		Metrics.probe_fires.val++;
		var r = probe.fire(dynamicLoc);
		return resume(r);
	}
	private def resume(r: Resumption) -> Throwable {
		match (r) {
			Continue => {
				return null;
			}
			Trap(reason, trace) => { // TODO: add exception backtrace
				return Trap.new(reason, null, null);
			}
		}
	}
}
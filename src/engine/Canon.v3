// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Canonicalizes signatures and structural types.
component Canon {
	private def map = HashMap<SigDecl, SigDecl>.new(SigDecl.hash, equalSigDecl);
	private var count = 0;

	def sigId(sig: SigDecl) -> int {
		if (sig.canon_id >= 0) return sig.canon_id;
		var prev = map[sig];
		if (prev != null) return prev.canon_id;
		map[sig] = sig;
		return sig.canon_id = ++count;
	}
	def equalSigDecl(a: SigDecl, b: SigDecl) -> bool {
		return ValueTypes.isEquivalentArray(a.params, b.params) && ValueTypes.isEquivalentArray(a.results, b.results);
	}
	def hashValueType(t: ValueType) -> int {
		return hashValueType0(t, true);
	}
	private def hashValueType0(t: ValueType, structural: bool) -> int {
		var h = int.view(t.tag);
		match (t) {
			Ref(nullable, heap) => {
				if (nullable) h *= 3;
				match (heap) {
					Struct(sdecl) => h += if(structural, hashStructDecl(sdecl), sdecl.recgrp_index);
					Array(array) => h += if(structural, hashArrayDecl(array), array.recgrp_index);
					Func(sig) => h += if(structural, hashSigDecl(sig), sig.recgrp_index);
					Rtt(depth, heaptype) => h += depth; // XXX: more hash bits for RTT
					_ => h += heap.tag;
				}
			}
			_ => ;
		}
		return h;
	}
	def hashHeapTypeDecl(decl: HeapTypeDecl) -> int {
		match (decl) {
			x: StructDecl => return hashStructDecl(x);
			x: ArrayDecl => return hashArrayDecl(x);
			x: SigDecl => return hashSigDecl(x);
		}
		return -1;
	}
	def hashSigDecl(sig: SigDecl) -> int {
		if (sig.hash >= 0) return sig.hash;
		var h = sig.params.length;
		for (t in sig.params) h = h * 31 + hashValueType(t);
		for (t in sig.results) h = h * 31 + hashValueType(t);
		return sig.hash = h & 0x7FFFFFFF;
	}
	def hashStructDecl(decl: StructDecl) -> int {
		var h = 1;
		for (st in decl.field_types) {
			h = h * 31 + hashValueType0(st.valtype, false) + st.packing.tag + if(st.mutable, 33);
		}
		return h;
	}
	def hashArrayDecl(decl: ArrayDecl) -> int {
		var h = 2;
		for (st in decl.elem_types) {
			h = h * 31 + hashValueType0(st.valtype, false) + st.packing.tag + if(st.mutable, 33);
		}
		return h;
	}
	def getRtt(decl: HeapTypeDecl) -> RttObject {
		return RttObject.new(decl, Values.NO_SUPERS); // TODO: canonicalize
	}
}

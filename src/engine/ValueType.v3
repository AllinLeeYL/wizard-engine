// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// The allowable types of any value in WebAssembly.
type ValueType {
	case I32;
	case I64;
	case F32;
	case F64;
	case VEC128;
	case ANYREF;
	case FUNCREF;
	case EXTERNREF;
	case EXTERNREF_NULL;
	case RefFunc(nullable: bool, sig: SigDecl);
	case RefStruct(nullable: bool, struct: StructDecl);
	case RefArray(nullable: bool, array: ArrayDecl);
	case FwRef(nullable: bool, index: u32);
	case Abstract(it: AbsTypeDecl);
	case Host(host: HostType);

	def render(buf: StringBuilder) -> StringBuilder {
		return render2(null, buf);
	}
	def render2(seen: List<Decl>, buf: StringBuilder) -> StringBuilder {
		var s: string;
		match (this) {
			I32 => s = "i32";
			I64 => s = "i64";
			F32 => s = "f32";
			F64 => s = "f64";
			VEC128 => s = "v128";
			Host(host) => return host.render(buf);
			Abstract(it) => {
				buf.puts("(abstract ");
				if (it != null) buf.put1("#%d", it.abstype_index);
				else buf.puts("<null>");
				return buf.puts(")");
			}
			ANYREF => s = "anyref";
			FUNCREF => s = "funcref";
			EXTERNREF => s = "externref";
			EXTERNREF_NULL => s = "externref null";
			RefFunc(nullable, sig) => {
				buf.puts("(ref ");
				if (nullable) buf.puts("null ");
				if (sig != null) sig.render2(seen, buf);
				else buf.puts("<null>");
				return buf.puts(")");
			}
			RefStruct(nullable, struct) => {
				buf.puts("(ref ");
				if (nullable) buf.puts("null ");
				buf.put1("struct #%d", struct.struct_index);
				return buf.puts(")");
			}
			RefArray(nullable, array) => {
				buf.puts("(ref ");
				if (nullable) buf.puts("null ");
				buf.put1("array #%d", array.array_index);
				return buf.puts(")");
			}
			FwRef(nullable, index) => {
				buf.puts("(ref ");
				if (nullable) buf.puts("null ");
				buf.put1("#%d)", index);
			}
		}
		return buf.puts(s);
	}
}
// Utility functions associated with value types.
component ValueTypes {
	def NONE = Array<ValueType>.new(0);
	def I31REF = ValueType.ANYREF; // TODO
	def isNumeric(t: ValueType) -> bool {
		match (t) {
			I32, I64, F32, F64 => return true;
			_ => return false;
		}
	}
	def isRef(t: ValueType) -> bool {
		match (t) {
			FUNCREF, EXTERNREF, RefFunc, RefStruct, RefArray, Host => return true;
			Abstract(abs) => return abs.is_externref;
			_ => return false;
		}
	}
	def isAssignable(from: ValueType, to: ValueType) -> bool {
		var c = TypeComparator.new();
		var eq = c.compare(from, to);
		return eq == TypeEquiv.EQUAL || eq == TypeEquiv.SUB;
	}
	def isEquivalent(x: ValueType, y: ValueType) -> bool {
		var c = TypeComparator.new();
		var eq = c.compare(x, y);
		return eq == TypeEquiv.EQUAL;
	}
	def hasDefaultValue(t: ValueType) -> bool {
		match (t) {
			RefFunc(nullable, sig) => return nullable;
			RefStruct(nullable, struct) => return nullable;
			RefArray(nullable, array) => return nullable;
			Abstract(abs) => return abs.has_default;
			_ => return true;
		}
	}
	def allHaveDefaultValues(at: Array<ValueType>) -> bool {
		for (t in at) if (!hasDefaultValue(t)) return false;
		return true;
	}
	def leastUpperBound = bound(true, _, _);

	// Upper/lower bound machinery. {up} indicates the types are being joined in the "up"
	// direction--i.e. two compatible subtypes become the common supertype. Handles
	// function co/contra-variance by recursing in the opposite direction on parameter lists.
	private def bound(up: bool, t: ValueType, f: ValueType) -> (bool, ValueType) {
		if (t == f) return (true, t);
		match (t) {
			FUNCREF => match(f) {
				RefFunc => return (true, if(up, t, f));
				_ => return (false, t);
			}
			RefFunc(tnullable, tsig) => match(f) {
				FUNCREF => return (true, if(up, f, t));
				RefFunc(fnullable, fsig) => {
					var nullable = if(up, tnullable | fnullable, tnullable & fnullable);
					return boundSig(up, tsig, fsig, nullable);
				}
				_ => return (false, t);
			}
			_ => return (false, t);
		}
	}
	private def boundSig(up: bool, tsig: SigDecl, fsig: SigDecl, nullable: bool) -> (bool, ValueType) {
		var np = joinUp(!up, tsig.params, fsig.params);  // contra-variance for func params
		var nr = joinUp(up, tsig.results, fsig.results); // co-variance for func results
		if (np.0 && nr.0) return (true, ValueType.RefFunc(nullable, SigDecl.new(np.1, nr.1)));
		if (up) return (true, ValueType.FUNCREF);
		else return (false, ValueType.I32);
	}
	private def joinUp(up: bool, t: Array<ValueType>, f: Array<ValueType>) -> (bool, Array<ValueType>) {
		if (t.length != f.length) return (false, null);
		var r = Array<ValueType>.new(t.length);
		for (i < t.length) {
			var e = bound(up, t[i], f[i]);
			if (!e.0) return (false, null);
			r[i] = e.1;
		}
		return (true, r);
	}
}

// Support for comparing recursive types. Computes the relation between
// two types that may be mutually recursive, including subtyping between
// structs, arrays, and functions.
enum TypeEquiv {
	UNRELATED,
	SUPER,
	EQUAL,
	SUB
}
class TypeComparator {
	private var stack: List<(Decl, Decl)>;
	def compare(from: ValueType, to: ValueType) -> TypeEquiv {
		if (from == to) return TypeEquiv.EQUAL;
		match (from) {
			EXTERNREF => match (to) {
				ANYREF => return TypeEquiv.SUB;
				EXTERNREF_NULL => return TypeEquiv.SUPER;
				_ => ;
			}
			EXTERNREF_NULL => match (to) {
				EXTERNREF, ANYREF => return TypeEquiv.SUB;
				Abstract(tabs) => {
					if (tabs.is_externref && tabs.has_default) return TypeEquiv.SUB;
					return TypeEquiv.UNRELATED;
				}
				_ => ;
			}
			FUNCREF => match (to) {
				ANYREF => return TypeEquiv.SUB;
				RefFunc => return TypeEquiv.SUPER;
				_ => ;
			}
			ANYREF => match (to) {
				EXTERNREF,
				EXTERNREF_NULL,
				FUNCREF,
				RefFunc,
				RefStruct,
				RefArray => return TypeEquiv.SUPER;
				_ => ;
			}
			RefFunc(fnullable, fsig) => match (to) {
				ANYREF, FUNCREF => return TypeEquiv.SUB;
				RefFunc(tnullable, tsig) => {
					var result = compareNullable(fnullable, tnullable);
					if (push(fsig, tsig)) {
						result = compareTypes(result, tsig.params, fsig.params);
						result = compareTypes(result, fsig.results, tsig.results);
						pop();
					}
					return result;
				}
				_ => return TypeEquiv.UNRELATED;
			}
			RefStruct(fnullable, fstruct) => match (to) {
				ANYREF => return TypeEquiv.SUB;
				RefStruct(tnullable, tstruct) => {
					var result = compareNullable(fnullable, tnullable);
					if (push(fstruct, tstruct)) {
						result = compareFields(result,
							fstruct.field_types, fstruct.field_mut,
							tstruct.field_types, tstruct.field_mut);
						pop();
					}
					return result;
				}
				_ => return TypeEquiv.UNRELATED;
			}
			RefArray(fnullable, farray) => match (to) {
				ANYREF => return TypeEquiv.SUB;
				RefArray(tnullable, tarray) => {
					var result = compareNullable(fnullable, tnullable);
					if (push(farray, tarray)) {
						result = compareFields(result,
							farray.elem_types, farray.elem_mut,
							tarray.elem_types, tarray.elem_mut);
						pop();
					}
					return result;
				}
				_ => return TypeEquiv.UNRELATED;
			}
			Abstract(fabs) => match (to) {
				Abstract(tabs) => {
					if (fabs.isAssignableTo(to)) return TypeEquiv.SUB;
					if (tabs.isAssignableTo(from)) return TypeEquiv.SUPER;
					return TypeEquiv.UNRELATED;
				}
				EXTERNREF_NULL => if (fabs.is_externref && fabs.has_default) return TypeEquiv.SUPER;
				_ => if (fabs.isAssignableTo(to)) return TypeEquiv.SUB;
			}
			Host(fhost) => match (to) {
				Host(thost) => {
					if (fhost.isAssignableTo(to)) return TypeEquiv.SUB;
					if (thost.isAssignableTo(from)) return TypeEquiv.SUPER;
					return TypeEquiv.UNRELATED;
				}
				_ => return if(fhost != null && fhost.isAssignableTo(to), TypeEquiv.SUB, TypeEquiv.UNRELATED);
			}
			_ => ;
		}
		// Left-hand side primitive, but right-hand side could still be abstract or host
		match (to) {
			Abstract(tabs) => if (tabs.isAssignableTo(from)) return TypeEquiv.SUPER;
			Host(thost) => if (thost.isAssignableTo(from)) return TypeEquiv.SUPER;
			_ => ;
		}
		return TypeEquiv.UNRELATED;
	}
	def compareTypes(eq: TypeEquiv, at: Array<ValueType>, bt: Array<ValueType>) -> TypeEquiv {
		if (at.length != bt.length) return TypeEquiv.UNRELATED;
		for (i < at.length) {
			if (eq == TypeEquiv.UNRELATED) break;
			var r = compare(at[i], bt[i]);
			eq = combineEq(eq, r);
		}
		return eq;
	}
	def compareFields(eq: TypeEquiv, at: Array<ValueType>, am: Array<bool>, bt: Array<ValueType>, bm: Array<bool>) -> TypeEquiv {
		var length = at.length;
		if (length < bt.length) {
			eq = combineEq(eq, TypeEquiv.SUPER);
		} else if (length > bt.length) {
			eq = combineEq(eq, TypeEquiv.SUB);
			length = bt.length;
		}

		for (i < length) {
			if (eq == TypeEquiv.UNRELATED) break;
			var r = compare(at[i], bt[i]);
			if (am[i]) {
				if (r != TypeEquiv.EQUAL) return TypeEquiv.UNRELATED;
				if (!bm[i]) return TypeEquiv.UNRELATED;
			} else {
				if (bm[i]) return TypeEquiv.UNRELATED;
				eq = combineEq(eq, r);
			}
		}
		return eq;
	}
	def compareNullable(f: bool, t: bool) -> TypeEquiv {
		return if(f,
			if(t, TypeEquiv.EQUAL, TypeEquiv.SUPER),
			if(t, TypeEquiv.SUB, TypeEquiv.EQUAL));
	}
	def combineEq(a: TypeEquiv, b: TypeEquiv) -> TypeEquiv {
		if (a == TypeEquiv.UNRELATED) return a;
		match (b) {
			UNRELATED => return TypeEquiv.UNRELATED;
			SUPER => return if(a == TypeEquiv.SUB, TypeEquiv.UNRELATED, TypeEquiv.SUPER);
			EQUAL => return a;
			SUB => return if(a == TypeEquiv.SUPER, TypeEquiv.UNRELATED, TypeEquiv.SUB);
		}
	}
	private def push(a: Decl, b: Decl) -> bool {
		if (a == b) return false;  // identity; no need to push on stack
		for (l = stack; l != null; l = l.tail) {
			var sa = l.head.0, sb = l.head.1;
			if (a == sa && b == sb) return false; // already on stack
		}
		stack = List.new((a, b), stack);
		return true; // pushed onto stack
	}
	private def pop() {
		if (stack != null) stack = stack.tail;
	}
}

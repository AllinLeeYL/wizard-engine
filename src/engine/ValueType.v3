// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// The allowable types of any value in WebAssembly.
type ValueType {
	case I32;
	case I64;
	case F32;
	case F64;
	case VEC128;
	case FUNCREF;
	case EXTERNREF;
	case RefFunc(sig: FuncSig);
	case RefNullFunc(sig: FuncSig);
	case Abstract(it: AbsType);
	case Host(host: HostType);
//	case Struct(fields: Array<ValueType>);
//	case Array(elem: ValueType);

	def render(buf: StringBuilder) -> StringBuilder {
		var s: string;
		match (this) {
			I32 => s = "i32";
			I64 => s = "i64";
			F32 => s = "f32";
			F64 => s = "f64";
			VEC128 => s = "v128";
			Host(host) => return host.render(buf);
			Abstract(it) => return it.render(buf);
			FUNCREF => s = "funcref";
			EXTERNREF => s = "externref";
			RefFunc(sig) => {
				buf.puts("(ref ");
				if (sig != null) sig.render(buf);
				else buf.puts("<null>");
				return buf.puts(")");
			}
			RefNullFunc(sig) => {
				buf.puts("(ref null ");
				if (sig != null) sig.render(buf);
				else buf.puts("<null>");
				return buf.puts(")");
			}
		}
		return buf.puts(s);
	}
}
// Utility functions associated with value types.
component ValueTypes {
	def NONE = Array<ValueType>.new(0);
	def isNumeric(t: ValueType) -> bool {
		match (t) {
			I32, I64, F32, F64 => return true;
			_ => return false;
		}
	}
	def isRef(t: ValueType) -> bool {
		match (t) {
			FUNCREF, EXTERNREF, RefFunc, RefNullFunc, Host => return true;
			_ => return false;
		}
	}
	def isAssignable(from: ValueType, to: ValueType) -> bool {
		match (from) {
			RefFunc(fsig) => {
				match (to) {
					RefFunc(tsig) => return fsig != null && fsig.isAssignableSig(tsig);
					RefNullFunc(tsig) => return fsig != null && fsig.isAssignableSig(tsig);
					FUNCREF => return true;
					_ => return false;
				}
			}
			RefNullFunc(fsig) => {
				match (to) {
					RefNullFunc(tsig) => return fsig != null && fsig.isAssignableSig(tsig);
					FUNCREF => return true;
					_ => return false;
				}
			}
			Host(host) => {
				return host != null && host.isAssignableTo(to);
			}
			Abstract(it) => {
				return it != null && it.isAssignableTo(to);
			}
			_ => return from == to;
		}
	}
	def leastUpperBound = bound(true, _, _);

	// Upper/lower bound machinery. {up} indicates the types are being joined in the "up"
	// direction--i.e. two compatible subtypes become the common supertype. Handles
	// function co/contra-variance by recursing in the opposite direction on parameter lists.
	private def bound(up: bool, t: ValueType, f: ValueType) -> (bool, ValueType) {
		if (t == f) return (true, t);
		match (t) {
			FUNCREF => match(f) {
				RefFunc, RefNullFunc => return (true, if(up, t, f));
				_ => return (false, t);
			}
			RefFunc(tsig) => match(f) {
				FUNCREF => return (true, if(up, f, t));
				RefFunc(fsig) => return boundSig(up, tsig, fsig, ValueType.RefFunc);
				RefNullFunc(fsig) => return boundSig(up, tsig, fsig,
					 if(up, ValueType.RefNullFunc, ValueType.RefFunc));
				_ => return (false, t);
			}
			RefNullFunc(tsig) => match(f) {
				FUNCREF => return (true, if(up, f, t));
				RefFunc(fsig) => return boundSig(up, tsig, fsig,
					 if(up, ValueType.RefNullFunc, ValueType.RefFunc));
				RefNullFunc(fsig) => return boundSig(up, tsig, fsig, ValueType.RefNullFunc);
				_ => return (false, t);
			}
			_ => return (false, t);
		}
	}
	private def boundSig(up: bool, tsig: FuncSig, fsig: FuncSig, k: FuncSig -> ValueType) -> (bool, ValueType) {
		var np = joinUp(!up, tsig.params, fsig.params);  // contra-variance for func params
		var nr = joinUp(up, tsig.results, fsig.results); // co-variance for func results
		if (np.0 && nr.0) return (true, k(FuncSig.new(np.1, nr.1)));
		if (up) return (true, ValueType.FUNCREF);
		else return (false, ValueType.I32);
	}
	private def joinUp(up: bool, t: Array<ValueType>, f: Array<ValueType>) -> (bool, Array<ValueType>) {
		if (t.length != f.length) return (false, null);
		var r = Array<ValueType>.new(t.length);
		for (i < t.length) {
			var e = bound(up, t[i], f[i]);
			if (!e.0) return (false, null);
			r[i] = e.1;
		}
		return (true, r);
	}
}

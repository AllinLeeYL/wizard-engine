// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// DataReader with additional utility methods for the interpreter.
class CodePtr extends DataReader {
	new(data: Array<byte>) super(data) { }

	def skip_block_type() {
		var b = read_sleb32();
		match (b) {
			BpTypeCode.REF.val,
			BpTypeCode.REF_NULL.val,
			BpTypeCode.ABS.val => skip_leb();
		}
	}
	def skip_label() {
		skip_leb();
	}
	def read_opcode() -> Opcode {
		var b = read1();
		return if(Opcodes.attributes[b].PREFIX, Opcodes.find(b, read_uleb32()), Opcodes.opcodes[b]);
	}
	def read_orig_opcode(b: byte) -> Opcode {
		skipN(1);
		return if(Opcodes.attributes[b].PREFIX, Opcodes.find(b, read_uleb32()), Opcodes.opcodes[b]);
	}
	def read_value_types() -> int {
		var count = int.!(read_uleb32()); // value count
		for (i < count) skip_value_type();
		return count;
	}
	def read_value_codes() -> Array<(int, u32)> {
		var count = int.!(read_uleb32()); // value count
		var result = Array<(int, u32)>.new(count);
		for (i < count) {
			var code = read_sleb32();
			var index = 0u;
			match (code) {
				BpTypeCode.REF.val,
				BpTypeCode.REF_NULL.val,
				BpTypeCode.ABS.val => index = read_uleb32();
			}
			result[i] = (code, index);
		}
		return result;
	}
	def read_labels() -> Array<u32> {
		var count = read_uleb32();
		var length = int.!(count + 1);
		var result = Array<u32>.new(length);
		for (i < length) result[i] = read_uleb32();
		return result;
	}
	def iterate_local_codes<T>(f: (u32, int, u32) -> T) -> int {
		var bcount = int.!(read_uleb32()); // pairs count
		for (i < bcount) {
			var count = read_uleb32();
			var code = read_sleb32();
			var index = 0u;
			if (BpConstants.typeCodeHasIndex(code)) index = read_uleb32();
			f(count, code, index);
		}
		return bcount;
	}
	def iterate_local_kinds<T>(instance: Instance, f: (u32, ValueKind) -> T) -> int {
		var bcount = int.!(read_uleb32()); // pairs count
		for (i < bcount) {
			var count = read_uleb32();
			f(count, read_value_kind(instance));
		}
		return bcount;
	}
	def read_value_kind(instance: Instance) -> ValueKind { // XXX: move to a common place
		var code = read_sleb32();
		match (code) {
			BpTypeCode.I32.val => return ValueKind.I32;
			BpTypeCode.I64.val => return ValueKind.I64;
			BpTypeCode.F32.val => return ValueKind.F32;
			BpTypeCode.F64.val => return ValueKind.F64;
			BpTypeCode.V128.val => return ValueKind.V128;
			BpTypeCode.FUNCREF.val,
			BpTypeCode.EXTERNREF.val,
			BpTypeCode.ANYREF.val,
			BpTypeCode.STRUCTREF.val,
			BpTypeCode.I31REF.val,
			BpTypeCode.NULLFUNCREF.val,
			BpTypeCode.NULLEXTERNREF.val,
			BpTypeCode.ARRAYREF.val,
			BpTypeCode.NULLREF.val => return ValueKind.REF;
			BpTypeCode.REF.val,
			BpTypeCode.REF_NULL.val => {
				skip_leb();
				return ValueKind.REF;
			}
			BpTypeCode.ABS.val => {
				var index = read_uleb32();
				return instance.abskinds[index];
			}
			_ => System.error("CodePtrError", "unknown or invalid value kind code");
		}
		return ValueKind.I32;
	}
	def read_MemArg() -> MemArg {
		var flags = read_uleb32();
		var mem_index = 0u;
		if ((flags & BpConstants.MEMARG_INDEX_FLAG) != 0) {
			mem_index = read_uleb32();
		}
		var offset = read_uleb32();
		return MemArg(byte.view(flags), mem_index, offset);
	}
	def skip_local_decls() {
		var count = read_uleb32();
		for (i < count) {
			skip_leb();
			skip_value_type();
		}
	}
	def skip_value_type() {
		var b = read1();
		match (b) {
			BpTypeCode.REF.code,
			BpTypeCode.REF_NULL.code,
			BpTypeCode.ABS.code => skip_leb();
		}
	}
}

// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// An enumeration of the WebAssembly opcodes, including their mnenomic names,
// the kind of immediate expected, and the (monomorphic) operator signature.
def sig_t: ValueType.Function;
def sig: SigCache;
enum Opcode(prefix: u8, code: u8, mnemonic: string, imm: ImmKind, sig: ValueType.Function) {
	// Control and calls.
	UNREACHABLE(0x00, 0x00, "unreachable", ImmKind.NONE, sig.none),
	NOP(0x00, 0x01, "nop", ImmKind.NONE, SigCache.v_v),
	BLOCK(0x00, 0x02, "block", ImmKind.BLOCK_TYPE, sig_t),
	LOOP(0x00, 0x03, "loop", ImmKind.BLOCK_TYPE, sig_t),
	IF(0x00, 0x04, "if", ImmKind.BLOCK_TYPE, sig_t),
	ELSE(0x00, 0x05, "else", ImmKind.NONE, sig.none),
	END(0x00, 0x0B, "end", ImmKind.NONE, sig.none),
	BR(0x00, 0x0C, "br", ImmKind.LABEL, sig.none),
	BR_IF(0x00, 0x0D, "br_if", ImmKind.LABEL, sig.none),
	BR_TABLE(0x00, 0x0E, "br_table", ImmKind.LABELS, sig.none),
	RETURN(0x00, 0x0F, "return", ImmKind.NONE, sig.none),
	CALL(0x00, 0x10, "call", ImmKind.FUNC_INDEX, sig.none),
	CALL_INDIRECT(0x00, 0x11, "call_indirect", ImmKind.SIG_TABLE_INDEX, sig.none),
	RETURN_CALL(0x00, 0x12, "return_call", ImmKind.FUNC_INDEX, sig.none),
	RETURN_CALL_INDIRECT(0x00, 0x13, "return_call_indirect", ImmKind.SIG_TABLE_INDEX, sig.none),
	CALL_REF(0x00, 0x14, "call_ref", ImmKind.NONE, sig.none),
	RETURN_CALL_REF(0x00, 0x15, "return_call_ref", ImmKind.NONE, sig.none),
	FUNC_BIND(0x00, 0x16, "func.bind", ImmKind.PARAM_INDEX, sig.none),
	LET(0x00, 0x17, "let", ImmKind.BLOCK_TYPE_LOCALS, sig.none),
	DROP(0x00, 0x1A, "drop", ImmKind.NONE, sig.none),
	SELECT(0x00, 0x1B, "select", ImmKind.NONE, sig.none),
	SELECT_T(0x00, 0x1C, "select", ImmKind.VALUE_TYPES, sig.none),
	// Locals.
	LOCAL_GET(0x00, 0x20, "local.get", ImmKind.LOCAL_INDEX, sig.none),
	LOCAL_SET(0x00, 0x21, "local.set", ImmKind.LOCAL_INDEX, sig.none),
	LOCAL_TEE(0x00, 0x22, "local.tee", ImmKind.LOCAL_INDEX, sig.none),
	// Globals.
	GLOBAL_GET(0x00, 0x23, "global.get", ImmKind.GLOBAL_INDEX, sig.none),
	GLOBAL_SET(0x00, 0x24, "global.set", ImmKind.GLOBAL_INDEX, sig.none),
	// Table elems.
	TABLE_GET(0x00, 0x25, "table.get", ImmKind.TABLE_INDEX, sig.none),
	TABLE_SET(0x00, 0x26, "table.set", ImmKind.TABLE_INDEX, sig.none),
	// Loads and stores.
	I32_LOAD(0x00, 0x28, "i32.load", ImmKind.MEMARG, sig.i_i),
	I64_LOAD(0x00, 0x29, "i64.load", ImmKind.MEMARG, sig.i_l),
	F32_LOAD(0x00, 0x2A, "f32.load", ImmKind.MEMARG, sig.i_f),
	F64_LOAD(0x00, 0x2B, "f64.load", ImmKind.MEMARG, sig.i_d),
	I32_LOAD8_S(0x00, 0x2C, "i32.load8_s", ImmKind.MEMARG, sig.i_i),
	I32_LOAD8_U(0x00, 0x2D, "i32.load8_u", ImmKind.MEMARG, sig.i_i),
	I32_LOAD16_S(0x00, 0x2E, "i32.load16_s", ImmKind.MEMARG, sig.i_i),
	I32_LOAD16_U(0x00, 0x2F, "i32.load16_u", ImmKind.MEMARG, sig.i_i),
	I64_LOAD8_S(0x00, 0x30, "i64.load8_s", ImmKind.MEMARG, sig.i_l),
	I64_LOAD8_U(0x00, 0x31, "i64.load8_u", ImmKind.MEMARG, sig.i_l),
	I64_LOAD16_S(0x00, 0x32, "i64.load16_s", ImmKind.MEMARG, sig.i_l),
	I64_LOAD16_U(0x00, 0x33, "i64.load16_u", ImmKind.MEMARG, sig.i_l),
	I64_LOAD32_S(0x00, 0x34, "i64.load32_s", ImmKind.MEMARG, sig.i_l),
	I64_LOAD32_U(0x00, 0x35, "i64.load32_u", ImmKind.MEMARG, sig.i_l),
	I32_STORE(0x00, 0x36, "i32.store", ImmKind.MEMARG, sig.ii_v),
	I64_STORE(0x00, 0x37, "i64.store", ImmKind.MEMARG, sig.il_v),
	F32_STORE(0x00, 0x38, "f32.store", ImmKind.MEMARG, sig.if_v),
	F64_STORE(0x00, 0x39, "f64.store", ImmKind.MEMARG, sig.id_v),
	I32_STORE8(0x00, 0x3A, "i32.store8", ImmKind.MEMARG, sig.ii_v),
	I32_STORE16(0x00, 0x3B, "i32.store16", ImmKind.MEMARG, sig.ii_v),
	I64_STORE8(0x00, 0x3C, "i64.store8", ImmKind.MEMARG, sig.il_v),
	I64_STORE16(0x00, 0x3D, "i64.store16", ImmKind.MEMARG, sig.il_v),
	I64_STORE32(0x00, 0x3E, "i64.store32", ImmKind.MEMARG, sig.il_v),
	// Misc memory.
	MEMORY_SIZE(0x00, 0x3F, "memory.size", ImmKind.MEMORY_INDEX, sig.v_i),
	MEMORY_GROW(0x00, 0x40, "memory.grow", ImmKind.MEMORY_INDEX, sig.i_i),
	// Constants.
	I32_CONST(0x00, 0x41, "i32.const", ImmKind.I32, sig.none),
	I64_CONST(0x00, 0x42, "i64.const", ImmKind.I64, sig.none),
	F32_CONST(0x00, 0x43, "f32.const", ImmKind.F32, sig.none),
	F64_CONST(0x00, 0x44, "f64.const", ImmKind.F64, sig.none),
	// Comparisons.
	I32_EQZ(0x00, 0x45, "i32.eqz", ImmKind.NONE, sig.i_i),
	I32_EQ(0x00, 0x46, "i32.eq", ImmKind.NONE, sig.ii_i),
	I32_NE(0x00, 0x47, "i32.ne", ImmKind.NONE, sig.ii_i),
	I32_LT_S(0x00, 0x48, "i32.lt_s", ImmKind.NONE, sig.ii_i),
	I32_LT_U(0x00, 0x49, "i32.lt_u", ImmKind.NONE, sig.ii_i),
	I32_GT_S(0x00, 0x4A, "i32.gt_s", ImmKind.NONE, sig.ii_i),
	I32_GT_U(0x00, 0x4B, "i32.gt_u", ImmKind.NONE, sig.ii_i),
	I32_LE_S(0x00, 0x4C, "i32.le_s", ImmKind.NONE, sig.ii_i),
	I32_LE_U(0x00, 0x4D, "i32.le_u", ImmKind.NONE, sig.ii_i),
	I32_GE_S(0x00, 0x4E, "i32.ge_s", ImmKind.NONE, sig.ii_i),
	I32_GE_U(0x00, 0x4F, "i32.ge_u", ImmKind.NONE, sig.ii_i),
	I64_EQZ(0x00, 0x50, "i64.eqz", ImmKind.NONE, sig.l_i),
	I64_EQ(0x00, 0x51, "i64.eq", ImmKind.NONE, sig.ll_i),
	I64_NE(0x00, 0x52, "i64.ne", ImmKind.NONE, sig.ll_i),
	I64_LT_S(0x00, 0x53, "i64.lt_s", ImmKind.NONE, sig.ll_i),
	I64_LT_U(0x00, 0x54, "i64.lt_u", ImmKind.NONE, sig.ll_i),
	I64_GT_S(0x00, 0x55, "i64.gt_s", ImmKind.NONE, sig.ll_i),
	I64_GT_U(0x00, 0x56, "i64.gt_u", ImmKind.NONE, sig.ll_i),
	I64_LE_S(0x00, 0x57, "i64.le_s", ImmKind.NONE, sig.ll_i),
	I64_LE_U(0x00, 0x58, "i64.le_u", ImmKind.NONE, sig.ll_i),
	I64_GE_S(0x00, 0x59, "i64.ge_s", ImmKind.NONE, sig.ll_i),
	I64_GE_U(0x00, 0x5A, "i64.ge_u", ImmKind.NONE, sig.ll_i),
	F32_EQ(0x00, 0x5B, "f32.eq", ImmKind.NONE, sig.ff_i),
	F32_NE(0x00, 0x5C, "f32.ne", ImmKind.NONE, sig.ff_i),
	F32_LT(0x00, 0x5D, "f32.lt", ImmKind.NONE, sig.ff_i),
	F32_GT(0x00, 0x5E, "f32.gt", ImmKind.NONE, sig.ff_i),
	F32_LE(0x00, 0x5F, "f32.le", ImmKind.NONE, sig.ff_i),
	F32_GE(0x00, 0x60, "f32.ge", ImmKind.NONE, sig.ff_i),
	F64_EQ(0x00, 0x61, "f64.eq", ImmKind.NONE, sig.dd_i),
	F64_NE(0x00, 0x62, "f64.ne", ImmKind.NONE, sig.dd_i),
	F64_LT(0x00, 0x63, "f64.lt", ImmKind.NONE, sig.dd_i),
	F64_GT(0x00, 0x64, "f64.gt", ImmKind.NONE, sig.dd_i),
	F64_LE(0x00, 0x65, "f64.le", ImmKind.NONE, sig.dd_i),
	F64_GE(0x00, 0x66, "f64.ge", ImmKind.NONE, sig.dd_i),
	// I32 arithmetic.
	I32_CLZ(0x00, 0x67, "i32.clz", ImmKind.NONE, sig.i_i),
	I32_CTZ(0x00, 0x68, "i32.ctz", ImmKind.NONE, sig.i_i),
	I32_POPCNT(0x00, 0x69, "i32.popcnt", ImmKind.NONE, sig.i_i),
	I32_ADD(0x00, 0x6A, "i32.add", ImmKind.NONE, sig.ii_i),
	I32_SUB(0x00, 0x6B, "i32.sub", ImmKind.NONE, sig.ii_i),
	I32_MUL(0x00, 0x6C, "i32.mul", ImmKind.NONE, sig.ii_i),
	I32_DIV_S(0x00, 0x6D, "i32.div_s", ImmKind.NONE, sig.ii_i),
	I32_DIV_U(0x00, 0x6E, "i32.div_u", ImmKind.NONE, sig.ii_i),
	I32_REM_S(0x00, 0x6F, "i32.rem_s", ImmKind.NONE, sig.ii_i),
	I32_REM_U(0x00, 0x70, "i32.rem_u", ImmKind.NONE, sig.ii_i),
	I32_AND(0x00, 0x71, "i32.and", ImmKind.NONE, sig.ii_i),
	I32_OR(0x00, 0x72, "i32.or", ImmKind.NONE, sig.ii_i),
	I32_XOR(0x00, 0x73, "i32.xor", ImmKind.NONE, sig.ii_i),
	I32_SHL(0x00, 0x74, "i32.shl", ImmKind.NONE, sig.ii_i),
	I32_SHR_S(0x00, 0x75, "i32.shr_s", ImmKind.NONE, sig.ii_i),
	I32_SHR_U(0x00, 0x76, "i32.shr_u", ImmKind.NONE, sig.ii_i),
	I32_ROTL(0x00, 0x77, "i32.rotl", ImmKind.NONE, sig.ii_i),
	I32_ROTR(0x00, 0x78, "i32.rotr", ImmKind.NONE, sig.ii_i),
	// I64 arithmetic.
	I64_CLZ(0x00, 0x79, "i64.clz", ImmKind.NONE, sig.l_l),
	I64_CTZ(0x00, 0x7A, "i64.ctz", ImmKind.NONE, sig.l_l),
	I64_POPCNT(0x00, 0x7B, "i64.popcnt", ImmKind.NONE, sig.l_l),
	I64_ADD(0x00, 0x7C, "i64.add", ImmKind.NONE, sig.ll_l),
	I64_SUB(0x00, 0x7D, "i64.sub", ImmKind.NONE, sig.ll_l),
	I64_MUL(0x00, 0x7E, "i64.mul", ImmKind.NONE, sig.ll_l),
	I64_DIV_S(0x00, 0x7F, "i64.div_s", ImmKind.NONE, sig.ll_l),
	I64_DIV_U(0x00, 0x80, "i64.div_u", ImmKind.NONE, sig.ll_l),
	I64_REM_S(0x00, 0x81, "i64.rem_s", ImmKind.NONE, sig.ll_l),
	I64_REM_U(0x00, 0x82, "i64.rem_u", ImmKind.NONE, sig.ll_l),
	I64_AND(0x00, 0x83, "i64.and", ImmKind.NONE, sig.ll_l),
	I64_OR(0x00, 0x84, "i64.or", ImmKind.NONE, sig.ll_l),
	I64_XOR(0x00, 0x85, "i64.xor", ImmKind.NONE, sig.ll_l),
	I64_SHL(0x00, 0x86, "i64.shl", ImmKind.NONE, sig.ll_l),
	I64_SHR_S(0x00, 0x87, "i64.shr_s", ImmKind.NONE, sig.ll_l),
	I64_SHR_U(0x00, 0x88, "i64.shr_u", ImmKind.NONE, sig.ll_l),
	I64_ROTL(0x00, 0x89, "i64.rotl", ImmKind.NONE, sig.ll_l),
	I64_ROTR(0x00, 0x8A, "i64.rotr", ImmKind.NONE, sig.ll_l),
	// F32 arithmetic.
	F32_ABS(0x00, 0x8B, "f32.abs", ImmKind.NONE, sig.f_f),
	F32_NEG(0x00, 0x8C, "f32.neg", ImmKind.NONE, sig.f_f),
	F32_CEIL(0x00, 0x8D, "f32.ceil", ImmKind.NONE, sig.f_f),
	F32_FLOOR(0x00, 0x8E, "f32.floor", ImmKind.NONE, sig.f_f),
	F32_TRUNC(0x00, 0x8F, "f32.trunc", ImmKind.NONE, sig.f_f),
	F32_NEAREST(0x00, 0x90, "f32.nearest", ImmKind.NONE, sig.f_f),
	F32_SQRT(0x00, 0x91, "f32.sqrt", ImmKind.NONE, sig.f_f),
	F32_ADD(0x00, 0x92, "f32.add", ImmKind.NONE, sig.ff_f),
	F32_SUB(0x00, 0x93, "f32.sub", ImmKind.NONE, sig.ff_f),
	F32_MUL(0x00, 0x94, "f32.mul", ImmKind.NONE, sig.ff_f),
	F32_DIV(0x00, 0x95, "f32.div", ImmKind.NONE, sig.ff_f),
	F32_MIN(0x00, 0x96, "f32.min", ImmKind.NONE, sig.ff_f),
	F32_MAX(0x00, 0x97, "f32.max", ImmKind.NONE, sig.ff_f),
	F32_COPYSIGN(0x00, 0x98, "f32.copysign", ImmKind.NONE, sig.ff_f),
	// F64 arithmetic.
	F64_ABS(0x00, 0x99, "f64.abs", ImmKind.NONE, sig.d_d),
	F64_NEG(0x00, 0x9A, "f64.neg", ImmKind.NONE, sig.d_d),
	F64_CEIL(0x00, 0x9B, "f64.ceil", ImmKind.NONE, sig.d_d),
	F64_FLOOR(0x00, 0x9C, "f64.floor", ImmKind.NONE, sig.d_d),
	F64_TRUNC(0x00, 0x9D, "f64.trunc", ImmKind.NONE, sig.d_d),
	F64_NEAREST(0x00, 0x9E, "f64.nearest", ImmKind.NONE, sig.d_d),
	F64_SQRT(0x00, 0x9F, "f64.sqrt", ImmKind.NONE, sig.d_d),
	F64_ADD(0x00, 0xA0, "f64.add", ImmKind.NONE, sig.dd_d),
	F64_SUB(0x00, 0xA1, "f64.sub", ImmKind.NONE, sig.dd_d),
	F64_MUL(0x00, 0xA2, "f64.mul", ImmKind.NONE, sig.dd_d),
	F64_DIV(0x00, 0xA3, "f64.div", ImmKind.NONE, sig.dd_d),
	F64_MIN(0x00, 0xA4, "f64.min", ImmKind.NONE, sig.dd_d),
	F64_MAX(0x00, 0xA5, "f64.max", ImmKind.NONE, sig.dd_d),
	F64_COPYSIGN(0x00, 0xA6, "f64.copysign", ImmKind.NONE, sig.dd_d),
	// Conversions and casts.
	I32_WRAP_I64(0x00, 0xA7, "i32.wrap_i64", ImmKind.NONE, sig.l_i),
	I32_TRUNC_F32_S(0x00, 0xA8, "i32.trunc_f32_s", ImmKind.NONE, sig.f_i),
	I32_TRUNC_F32_U(0x00, 0xA9, "i32.trunc_f32_u", ImmKind.NONE, sig.f_i),
	I32_TRUNC_F64_S(0x00, 0xAA, "i32.trunc_f64_s", ImmKind.NONE, sig.d_i),
	I32_TRUNC_F64_U(0x00, 0xAB, "i32.trunc_f64_u", ImmKind.NONE, sig.d_i),
	I64_EXTEND_I32_S(0x00, 0xAC, "i64.extend_i32_s", ImmKind.NONE, sig.i_l),
	I64_EXTEND_I32_U(0x00, 0xAD, "i64.extend_i32_u", ImmKind.NONE, sig.i_l),
	I64_TRUNC_F32_S(0x00, 0xAE, "i64.trunc_f32_s", ImmKind.NONE, sig.f_l),
	I64_TRUNC_F32_U(0x00, 0xAF, "i64.trunc_f32_u", ImmKind.NONE, sig.f_l),
	I64_TRUNC_F64_S(0x00, 0xB0, "i64.trunc_f64_s", ImmKind.NONE, sig.d_l),
	I64_TRUNC_F64_U(0x00, 0xB1, "i64.trunc_f64_u", ImmKind.NONE, sig.d_l),
	F32_CONVERT_I32_S(0x00, 0xB2, "f32.convert_i32_s", ImmKind.NONE, sig.i_f),
	F32_CONVERT_I32_U(0x00, 0xB3, "f32.convert_i32_u", ImmKind.NONE, sig.i_f),
	F32_CONVERT_I64_S(0x00, 0xB4, "f32.convert_i64_s", ImmKind.NONE, sig.l_f),
	F32_CONVERT_I64_U(0x00, 0xB5, "f32.convert_i64_u", ImmKind.NONE, sig.l_f),
	F32_DEMOTE_F64(0x00, 0xB6, "f32.demote_f64", ImmKind.NONE, sig.d_f),
	F64_CONVERT_I32_S(0x00, 0xB7, "f64.convert_i32_s", ImmKind.NONE, sig.i_d),
	F64_CONVERT_I32_U(0x00, 0xB8, "f64.convert_i32_u", ImmKind.NONE, sig.i_d),
	F64_CONVERT_I64_S(0x00, 0xB9, "f64.convert_i64_s", ImmKind.NONE, sig.l_d),
	F64_CONVERT_I64_U(0x00, 0xBA, "f64.convert_i64_u", ImmKind.NONE, sig.l_d),
	F64_PROMOTE_F32(0x00, 0xBB, "f64.promote_f32", ImmKind.NONE, sig.f_d),
	I32_REINTERPRET_F32(0x00, 0xBC, "i32.reinterpret_f32", ImmKind.NONE, sig.f_i),
	I64_REINTERPRET_F64(0x00, 0xBD, "i64.reinterpret_f64", ImmKind.NONE, sig.d_l),
	F32_REINTERPRET_I32(0x00, 0xBE, "f32.reinterpret_i32", ImmKind.NONE, sig.i_f),
	F64_REINTERPRET_I64(0x00, 0xBF, "f64.reinterpret_i64", ImmKind.NONE, sig.l_d),

	I32_EXTEND8_S(0x00, 0xC0, "i32.extend8_s", ImmKind.NONE, sig.i_i),
	I32_EXTEND16_S(0x00, 0xC1, "i32.extend16_s", ImmKind.NONE, sig.i_i),
	I64_EXTEND8_S(0x00, 0xC2, "i64.extend8_s", ImmKind.NONE, sig.l_l),
	I64_EXTEND16_S(0x00, 0xC3, "i64.extend16_s", ImmKind.NONE, sig.l_l),
	I64_EXTEND32_S(0x00, 0xC4, "i64.extend32_s", ImmKind.NONE, sig.l_l),

	REF_NULL(0x00, 0xD0, "ref.null", ImmKind.VALUE_TYPE, sig.none),
	REF_IS_NULL(0x00, 0xD1, "ref.is_null", ImmKind.NONE, sig.none),
	REF_FUNC(0x00, 0xD2, "ref.func", ImmKind.FUNC_INDEX, sig.none),
	REF_AS_NON_NULL(0x00, 0xD3, "ref.as_non_null", ImmKind.NONE, sig.none),
	BR_ON_NULL(0x00, 0xD4, "br_on_null", ImmKind.LABEL, sig.none),

	I32_TRUNC_SAT_F32_S(0xFC, 0x00, "i32.trunc_sat_f32_s", ImmKind.NONE, sig.f_i),
	I32_TRUNC_SAT_F32_U(0xFC, 0x01, "i32.trunc_sat_f32_u", ImmKind.NONE, sig.f_i),
	I32_TRUNC_SAT_F64_S(0xFC, 0x02, "i32.trunc_sat_f64_s", ImmKind.NONE, sig.d_i),
	I32_TRUNC_SAT_F64_U(0xFC, 0x03, "i32.trunc_sat_f64_u", ImmKind.NONE, sig.d_i),
	I64_TRUNC_SAT_F32_S(0xFC, 0x04, "i64.trunc_sat_f32_s", ImmKind.NONE, sig.f_l),
	I64_TRUNC_SAT_F32_U(0xFC, 0x05, "i64.trunc_sat_f32_u", ImmKind.NONE, sig.f_l),
	I64_TRUNC_SAT_F64_S(0xFC, 0x06, "i64.trunc_sat_f64_s", ImmKind.NONE, sig.d_l),
	I64_TRUNC_SAT_F64_U(0xFC, 0x07, "i64.trunc_sat_f64_u", ImmKind.NONE, sig.d_l),

	MEMORY_INIT(0xFC, 0x08, "memory.init", ImmKind.DATA_MEMORY_INDEX, sig.none),
	DATA_DROP(0xFC, 0x09, "data.drop", ImmKind.DATA_INDEX, sig.none),
	MEMORY_COPY(0xFC, 0x0A, "memory.copy", ImmKind.MEMORY_MEMORY_INDEX, sig.none),
	MEMORY_FILL(0xFC, 0x0B, "memory.fill", ImmKind.MEMORY_INDEX, sig.none),
	TABLE_INIT(0xFC, 0x0C, "table.init", ImmKind.ELEM_TABLE_INDEX, sig.none),
	ELEM_DROP(0xFC, 0x0D, "elem.drop", ImmKind.ELEM_INDEX, sig.none),
	TABLE_COPY(0xFC, 0x0E, "table.copy", ImmKind.TABLE_TABLE_INDEX, sig.none),
	TABLE_GROW(0xFC, 0x0F, "table.grow", ImmKind.TABLE_INDEX, sig.none),
	TABLE_SIZE(0xFC, 0x10, "table.size", ImmKind.TABLE_INDEX, sig.none),
	TABLE_FILL(0xFC, 0x11, "table.fill", ImmKind.TABLE_INDEX, sig.none),

}
// An enumeration of the different kinds of immediates to WebAssembly
// opcodes.
enum ImmKind {
	NONE,
	BLOCK_TYPE,
	BLOCK_TYPE_LOCALS,
	LABEL,
	LABELS,
	VALUE_TYPE,
	VALUE_TYPES,
	FUNC_INDEX,
	TABLE_INDEX,
	PARAM_INDEX,
	TABLE_TABLE_INDEX,
	ELEM_TABLE_INDEX,
	SIG_TABLE_INDEX,
	LOCAL_INDEX,
	GLOBAL_INDEX,
	MEMORY_INDEX,
	MEMORY_MEMORY_INDEX,
	DATA_MEMORY_INDEX,
	ELEM_INDEX,
	DATA_INDEX,
	MEMARG,
	I32,
	I64,
	F32,
	F64
}
// Various computed attributes about opcodes.
enum OpcodeAttribute {
	SHORT_OP,
	PREFIX,
	VALID
}
// Utilities for WebAssembly opcodes.
component Opcodes {
	def signatures = Array<ValueType.Function>.new(256);
	def attributes = Array<OpcodeAttribute.set>.new(256);
	def opcodes = Array<Opcode>.new(256);
	def prefixed = Array<Opcode>.new(100);  // TODO(fast,space): opted for space savings here
	var prefixed_count = 0;
	new() {
		for (op in Opcode) init(op);
	}
	def init(opcode: Opcode) {
		if (opcode.prefix != 0) {
			attributes[opcode.prefix] |= OpcodeAttribute.PREFIX;
			prefixed[prefixed_count++] = opcode;
			return;
		}
		var c = opcode.code;
		signatures[c] = opcode.sig;
		opcodes[c] = opcode;
		attributes[c] |= OpcodeAttribute.VALID;
		if (opcode.sig.params != null && opcode.imm == ImmKind.NONE) attributes[c] |= OpcodeAttribute.SHORT_OP;
	}
	def render(buf: StringBuilder, code: byte) -> StringBuilder {
		if (attributes[code].VALID) {
			return buf.puts(opcodes[code].mnemonic);
		} else if (attributes[code].PREFIX) {
			return buf.put1("%x prefix", code);
		} else {
			return buf.put1("%x <invalid>", code);
		}
	}
	def find(prefix: byte, code: byte) -> Opcode {
		if (prefix == 0) return opcodes[code];
		// TODO(fast): linear search for prefixed opcode
		for (i < prefixed_count) {
			var opcode = prefixed[i];
			if (opcode.prefix == prefix && opcode.code == code) return opcode;
		}
		return Opcode.NOP;
	}
	def renderInstr(buf: StringBuilder, m: Module, d: Decoder) -> StringBuilder {
		var prev = d.pos;
		var all = Extension.set.all;
		var limits = Limits.new().set(all);
		// TODO(fast): improve speed of rendering instructions by caching
		// the Error generator and parser.
		var err = WasmErrorGen.new("");
		var p = WasmParser.new(all, limits, m, err, d);
		var b = d.read_u8();
		var opcode: Opcode;
		if (attributes[b].PREFIX) {
			var b2 = d.read_u8();
			opcode = find(b, b2);
			if (opcode == Opcode.NOP) {
				buf.put2("%x %x (unknown)", b, b2);
			} else {
				buf.puts(opcode.mnemonic);
			}
		} else if (attributes[b].VALID) {
			opcode = opcodes[b];
			buf.puts(opcode.mnemonic);
		} else {
			d.at(prev);
			return buf;
		}
		match (opcode.imm) {
			NONE => ;
			BLOCK_TYPE => {
				var t = p.readBlockType();
				var pl = t.params.length, rl = t.results.length;
				if (pl == 0 && rl == 0) {
					// do nothing
				} else if (pl == 0 && rl == 1) {
					buf.puts("[");
					ValueTypes.render(buf, t.results[0]);
					buf.puts("]");
				} else {
					buf.puts("[");
					ValueTypes.renderSig(buf, t);
					buf.puts("]");
				}
			}
			BLOCK_TYPE_LOCALS => {
				System.error("Unimplemented", ""); // TODO(function-references)
			}
			LABEL => buf.put1("[depth=%d]", p.readLabel());
			LABELS => {
				var labels = p.readLabels();
				buf.put1("[%d...]", labels.length);
			}
			VALUE_TYPE => buf.put1("[type=%q]", ValueTypes.render(_, p.readValueType()));
			VALUE_TYPES => {
				var at = p.readValueTypes("select count", u32.max);
				buf.puts("[");
				for (i < at.length) {
					if (i > 0) buf.puts(" ");
					ValueTypes.render(buf, at[i]);
				}
				buf.puts("]");
			}
			FUNC_INDEX => buf.put1("[func=%d]", p.readFunc().0);
			TABLE_INDEX => buf.put1("[table=%d]", p.readTable().0);
			PARAM_INDEX => buf.put1("[param=%d]", p.decoder.read_u32leb());
			TABLE_TABLE_INDEX => buf.put2("[table1=%d,table2=%d]", p.readTable().0, p.readTable().0);
			ELEM_TABLE_INDEX => buf.put2("[elem=%d,table=%d]", p.readElemIndex(), p.readTable().0);
			SIG_TABLE_INDEX => {
				var sig_index = p.readSig().0;
				var table_index = p.readTable().0;
				if (table_index == 0) {
					buf.put1("[sig=%d]", sig_index);
				} else {
					buf.put2("[sig=%d,table=%d]", sig_index, table_index);
				}
			}
			LOCAL_INDEX => buf.put1("[%d]", p.readLocalIndex());
			GLOBAL_INDEX => buf.put1("[%d]", p.readGlobal().0);
			MEMORY_INDEX => buf.put1("[%d]", p.readMemoryIndex());
			MEMORY_MEMORY_INDEX => buf.put2("[mem1=%d,mem2=%d]", p.readMemoryIndex(), p.readMemoryIndex());
			DATA_MEMORY_INDEX => buf.put2("[data=%d,mem=%d]", p.readDataIndex(), p.readMemoryIndex());
			ELEM_INDEX => buf.put1("[elem=%d]", p.readElemIndex());
			DATA_INDEX => buf.put1("[data=%d]", p.readDataIndex());
			I32 => buf.put1("[%d]", p.decoder.read_i32leb());
			I64 => buf.put1("[%d]", p.decoder.read_i64leb());
			F32 => buf.put1("[0x%x]", p.readF32());
			F64 => buf.put1("[0x%x]", p.readF64());
			MEMARG => {
				var mem = p.readMemoryArg();
				var align = 1 << byte.!(mem.0 >> 1);
				var offset = mem.1;
				buf.put2("[align=%d,offset=%d]", align, offset);
			}
		}
		d.at(prev);
		return buf;
	}
}

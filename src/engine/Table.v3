// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// An instantiated table. Internally, a table may be specialized to store
// function references, which improves efficiency of indirect calls in
// the interpreter.
class Table(elemtype: ValueType, decl: TableDecl) extends Exportable {
	var oom = false;
	var func_elems: Array<Function>;  // for tables with funcref type
	var value_elems: Array<Value>;	  // for all other tables

	new() {
		var initial = int.view(decl.initial);
		match (elemtype) {
			FUNCREF, RefFunc => func_elems = Array.new(initial);
			_ => value_elems = Array.new(initial);
		}
	}

	// Read an element from this table.
	def [i: int] -> Value {
		return if(value_elems != null, value_elems[i], Value.FuncRef(func_elems[i]));
	}
	// Write an element to this table.
	def [i: int] = val: Value {
		if (value_elems != null) value_elems[i] = val;
		else func_elems[i] = Value.FuncRef.!(val).val;
	}
	// Grow this table by {more} elements.
	def grow(more: u32, val: Value) -> int {
		var prev = size();
		var total = u64.view(prev) + more;
		if (total > EngineLimits.limit_table_size) return -1;
		if (!decl.maximum.check(total)) return -1;
		if (func_elems != null) {
			func_elems = Arrays.growV(func_elems, int.!(total), v2f(val));
		} else {
			value_elems = Arrays.growV(value_elems, int.!(total), val);
		}
		return prev;
	}
	// Fill the given range of this table with the given value.
	def fill(dst_offset: u32, val: Value, size: u32) -> TrapReason {
		var i = boundsCheck(dst_offset, size);
		if (i < 0) return TrapReason.TABLE_OUT_OF_BOUNDS;
		if (func_elems != null) {
			var f = v2f(val);
			for (k < int.!(size)) func_elems[i + k] = f;
		} else {
			for (k < int.!(size)) value_elems[i + k] = val;
		}
		return TrapReason.NONE;
	}
	// Copy into this table from the given source table.
	def copyT(dst_offset: u32, src: Table, src_offset: u32, size: u32) -> TrapReason {
		var r: bool;
		if (func_elems != null) {
			r = if(src.func_elems != null,
					Arrays.safeCopy(func_elems, dst_offset, src.func_elems, src_offset, size),
					Arrays.safeCopyF(func_elems, dst_offset, src.value_elems, src_offset, size, v2f));
		} else {
			r = if(src.func_elems != null,
					Arrays.safeCopyF(value_elems, dst_offset,
								src.func_elems, src_offset, size, Value.FuncRef),
					Arrays.safeCopy(value_elems, dst_offset, src.value_elems, src_offset, size));
		}
		return if(r, TrapReason.NONE, TrapReason.TABLE_OUT_OF_BOUNDS);
	}
	// Copy elements into this table.
	def copyE(instance: Instance, dst_offset: u32, elem: ElemDecl, src_offset: u32, size: u32) -> TrapReason {
		if (elem == null) {
			if (boundsCheck(dst_offset, size) < 0) return TrapReason.TABLE_OUT_OF_BOUNDS;
			if (Arrays.boundsCheck<byte>(null, src_offset, 0, size) < 0) return TrapReason.TABLE_OUT_OF_BOUNDS;
			return TrapReason.NONE;
		}
		var r: bool;
		match (elem.details) {
			FuncRefs(vals) => {
				r = if(func_elems != null,
					Arrays.safeCopyF(func_elems, dst_offset, vals, src_offset, size, instance.getFunction),
					Arrays.safeCopyF(value_elems, dst_offset, vals, src_offset, size, instance.getFunctionAsVal));
			}
			Exprs(vals) => {
				r = if(func_elems != null,
					Arrays.safeCopyF(func_elems, dst_offset, vals, src_offset, size, instance.evalInitExprAsFunc),
					Arrays.safeCopyF(value_elems, dst_offset, vals, src_offset, size, instance.evalInitExpr));
			}
		}
		return if(r, TrapReason.NONE, TrapReason.TABLE_OUT_OF_BOUNDS);
	}
	// Get the size of this table.
	def size() -> int {
		if (func_elems != null) return func_elems.length;
		if (value_elems != null) return value_elems.length;
		return 0;
	}
	// Bounds check a range in this table.
	def boundsCheck(index: u32, size: u32) -> int {
		var length = u64.!(this.size());
		var x = u64.!(index);
		return if(x + size > length, int.min, int.view(x));
	}
}
def v2f(v: Value) -> Function {
	return if(Value.FuncRef.?(v), Value.FuncRef.!(v).val);
}

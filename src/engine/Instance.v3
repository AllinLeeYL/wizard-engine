// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Superclass of all import/exportable objects.
class Exportable {
	def render(buf: StringBuilder) -> StringBuilder {
		return buf.puts("<exportable>");
	}
}
// Abstract base class of host and wasm functions.
class Function(sig: SigDecl) extends Exportable {
}
// A function from a wasm instance.
class WasmFunction(instance: Instance, decl: FuncDecl) extends Function {
	new() super(decl.sig) { }
	def render(buf: StringBuilder) -> StringBuilder {
		return buf.put1("<wasm func %q>", renderShort);
	}
	def renderShort(buf: StringBuilder) -> StringBuilder {
		var names = if(instance != null, instance.module.names);
		return decl.render(names, buf);
	}
}
class Global(valtype: ValueType, decl: GlobalDecl) extends Exportable {
	var value: Value;
}
class ExportedType extends Exportable {
}
class ExportedValueType(src: ExportedType, vt: ValueType) extends ExportedType {
	def render(buf: StringBuilder) -> StringBuilder {
		if (src != null) buf.put2("<exported_type %q, %q>", src.render, vt.render);
		else buf.put1("<exported_type %q>", vt.render);
		return buf;
	}
}

// An instantiated module, including memories, tables, functions, etc.
class Instance(module: Module, imports: Array<Exportable>) {
	def memories = Array<Memory>.new(module.memories.length);
	def functions = Array<Function>.new(module.functions.length);
	def sigs = Array<SigDecl>.new(module.heaptypes.length);
	var globals = Array<Global>.new(module.globals.length);
	def tables = Array<Table>.new(module.tables.length);
	def exports = Array<Exportable>.new(module.exports.length);
	def heaptypes = module.heaptypes; // TODO: instantiate heap types too
	def abstypes = Array<ExportedType>.new(module.abstypes.length);
	def dropped_elems = Array<bool>.new(module.elems.length);
	def dropped_data = Array<bool>.new(module.data.length);

	def getFunctionAsVal(func_index: int) -> Value.FuncRef {
		return Value.FuncRef(functions[func_index]);
	}
	def evalInitExpr(init: InitExpr) -> Value {
		match (init) {
			I32(val) => return Value.I32(u32.!(val));
			I64(val) => return Value.I64(u64.!(val));
			F32(val) => return Value.F32(val);
			F64(val) => return Value.F64(val);
			FuncRefNull => return Values.FUNCREF_NULL;
			ExternRefNull => return Values.EXTERNREF_NULL;
			Global(global_index, g) => {
				return globals[global_index].value;
			}
			FuncRef(func_index, f) => {
				return Value.FuncRef(functions[func_index]);
			}
			Const(val) => return val;
		}
	}
}

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Superclass of all import/exportable objects.
class Exportable {
	def render(buf: StringBuilder) -> StringBuilder {
		return buf.puts("<exportable>");
	}
}
// Abstract base class of host and wasm functions.
class Function(sig: FuncSig) extends Exportable {
}
// A function from a wasm instance.
class WasmFunction(instance: Instance, decl: FuncDecl) extends Function {
	new() super(decl.sig.funcsig) { }
}
class Table(decl: TableDecl) extends Exportable {
	var oom = false;
	def grow(more: u32, val: Value) -> int;
	def fill(dst_offset: u32, val: Value, size: u32) -> TrapReason;
	def copyT(dst_offset: u32, src: Table, src_offset: u32, size: u32) -> TrapReason;
	def copyE(instance: Instance, dst_offset: u32, elem: ElemDecl, src_offset: u32, size: u32) -> TrapReason;
	def size() -> int;
}
def v2f(v: Value) -> Function {
	return if(Value.FuncRef.?(v), Value.FuncRef.!(v).val);
}
def initFunc(instance: Instance, e: InitExpr) -> Function {
	var val = instance.evalInitExpr(e);
	return if(Value.FuncRef.?(val), Value.FuncRef.!(val).val);
}
class FunctionTable extends Table {
	var elems: Array<Function>;
	new(decl: TableDecl) super(decl) {
		elems = Array.new(int.view(decl.initial));
	}
	def grow(more: u32, val: Value) -> int {
		var total = u64.view(elems.length) + more;
		if (total > EngineLimits.limit_table_size) return -1;
		if (!decl.maximum.check(total)) return -1;
		var prev = elems.length, nlength = int.!(total);
		var nelems = Arrays.grow(elems, nlength);
		var fv = v2f(val);
		for (i = prev; i < nlength; i++) nelems[i] = fv;
		elems = nelems;
		return prev;
	}
	def fill(dst_offset: u32, val: Value, size: u32) -> TrapReason {
		var i = Arrays.boundsCheck(elems, 0, dst_offset, size);
		if (i < 0) return TrapReason.TABLE_OUT_OF_BOUNDS;
		var f = v2f(val);
		for (k < int.!(size)) elems[i + k] = f;
		return TrapReason.NONE;
	}
	def copyT(dst_offset: u32, src: Table, src_offset: u32, size: u32) -> TrapReason {
		var r: bool;
		match (src) {
			ft: FunctionTable => r = Arrays.safeCopy(elems, dst_offset, ft.elems, src_offset, size);
			vt: ValueTable => r = Arrays.safeCopyF(elems, dst_offset, vt.elems, src_offset, size, v2f);
		}
		return if(r, TrapReason.NONE, TrapReason.TABLE_OUT_OF_BOUNDS);
	}
	def copyE(instance: Instance, dst_offset: u32, elem: ElemDecl, src_offset: u32, size: u32) -> TrapReason {
		if (elem == null) {
			if (Arrays.boundsCheck(elems, dst_offset, 0, size) < 0) return TrapReason.TABLE_OUT_OF_BOUNDS;
			if (Arrays.boundsCheck<byte>(null, src_offset, 0, size) < 0) return TrapReason.TABLE_OUT_OF_BOUNDS;
			return TrapReason.NONE;
		}
		var r: bool;
		match (elem.details) {
			FuncRefs(vals) => {
				r = Arrays.safeCopyF(elems, dst_offset, vals, src_offset, size, instance.getFunction);
			}
			Exprs(vals) => r = Arrays.safeCopyF(elems, dst_offset, vals, src_offset, size, initFunc(instance, _));
		}
		return if(r, TrapReason.NONE, TrapReason.TABLE_OUT_OF_BOUNDS);
	}
	def size() -> int { return elems.length; }
}
class ValueTable extends Table {
	var elems: Array<Value>;
	new(decl: TableDecl) super(decl) {
		elems = Array.new(int.view(decl.initial));
	}
	def grow(more: u32, val: Value) -> int {
		var total = u64.view(elems.length) + more;
		if (total > EngineLimits.limit_table_size) return -1;
		if (!decl.maximum.check(total)) return -1;
		var prev = elems.length, nlength = int.!(total);
		var nelems = Arrays.grow(elems, nlength);
		for (i = prev; i < nlength; i++) nelems[i] = val;
		elems = nelems;
		return prev;
	}
	def fill(dst_offset: u32, val: Value, size: u32) -> TrapReason {
		var i = Arrays.boundsCheck(elems, 0, dst_offset, size);
		if (i < 0) return TrapReason.TABLE_OUT_OF_BOUNDS;
		for (k < int.!(size)) elems[i + k] = val;
		return TrapReason.NONE;
	}
	def copyT(dst_offset: u32, src: Table, src_offset: u32, size: u32) -> TrapReason {
		var r: bool;
		match (src) {
			ft: FunctionTable => r = Arrays.safeCopyF(elems, dst_offset, ft.elems, src_offset, size, Value.FuncRef);
			vt: ValueTable => r = Arrays.safeCopy(elems, dst_offset, vt.elems, src_offset, size);
		}
		return if(r, TrapReason.NONE, TrapReason.TABLE_OUT_OF_BOUNDS);
	}
	def copyE(instance: Instance, dst_offset: u32, elem: ElemDecl, src_offset: u32, size: u32) -> TrapReason {
		if (elem == null) {
			if (Arrays.boundsCheck(elems, dst_offset, 0, size) < 0) return TrapReason.TABLE_OUT_OF_BOUNDS;
			if (Arrays.boundsCheck<byte>(null, src_offset, 0, size) < 0) return TrapReason.TABLE_OUT_OF_BOUNDS;
			return TrapReason.NONE;
		}
		var r: bool;
		match (elem.details) {
			FuncRefs(vals) => r = Arrays.safeCopyF(elems, dst_offset, vals, src_offset, size, instance.getFunctionAsVal);
			Exprs(vals) => r = Arrays.safeCopyF(elems, dst_offset, vals, src_offset, size, instance.evalInitExpr);
		}
		return if(r, TrapReason.NONE, TrapReason.TABLE_OUT_OF_BOUNDS);
	}
	def size() -> int { return elems.length; }
}
class Global(decl: GlobalDecl) extends Exportable {
	var value: Value;
}
class ExportedType extends Exportable {
}
class ExportedValueType(vt: ValueType) extends ExportedType {
}

// An instantiated module, including memories, tables, functions, etc.
class Instance(module: Module, imports: Array<Exportable>) {
	def memories = Array<Memory>.new(module.memories.length);
	def functions = Array<Function>.new(module.functions.length);
	def sigs = Array<FuncSig>.new(module.deftypes.length);
	def globals = Array<Global>.new(module.globals.length);
	def tables = Array<Table>.new(module.tables.length);
	def exports = Array<Exportable>.new(module.exports.length);
	def abstypes = Array<ExportedType>.new(module.abstypes.length);
	def dropped_elems = Array<bool>.new(module.elems.length);
	def dropped_data = Array<bool>.new(module.data.length);

	def getFunction(func_index: int) -> Function {
		return functions[func_index];
	}
	def getFunctionAsVal(func_index: int) -> Value.FuncRef {
		return Value.FuncRef(functions[func_index]);
	}
	def evalInitExpr(init: InitExpr) -> Value {
		match (init) {
			I32(val) => return Value.I32(u32.!(val));
			I64(val) => return Value.I64(u64.!(val));
			F32(val) => return Value.F32(val);
			F64(val) => return Value.F64(val);
			FuncRefNull => return Values.FUNCREF_NULL;
			ExternRefNull => return Values.EXTERNREF_NULL;
			Global(global_index, g) => {
				return globals[global_index].value;
			}
			FuncRef(func_index, f) => {
				return Value.FuncRef(functions[func_index]);
			}
		}
	}
}

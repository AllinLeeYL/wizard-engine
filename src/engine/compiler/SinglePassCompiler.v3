// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

var config_TrackFloatZeroConst = false;
def INITIAL = 16;
def OUT = Trace.OUT;
var offsets: V3Offsets;

def getOffsets() -> V3Offsets {
	if (offsets == null) offsets = V3Offsets.new();
	return offsets;
}

// TODO: unreachable
// TODO: traps in JIT code
// Compiles Wasm bytecode to machine code in a single pass via a MacroAssembler.
class SinglePassCompiler(masm: MacroAssembler, extensions: Extension.set, limits: Limits, module: Module) {
	def err = ErrorGen.new(module.name);
	def codeptr = Decoder.new(null, err);
	def parser = WasmParser.new(extensions, limits, module, err, codeptr);
	def instrTracer = if(Trace.compiler, InstrTracer.new());

	// Abstract state of the value stack
	def state = SpcAbstractState.new(masm.regAlloc);
	// Other state
	var sig: SigDecl;
	var start_pos: int;
	var opcode_pos: int;
	var success = true;
	var trap_label: MasmLabel;

	new() {
		masm.unimplemented = unsupported;
	}

	def gen(func: FuncDecl) -> bool {
		if (Trace.compiler) OUT.put1("begin compile: %q", func.render(module.names, _)).outln();
		var d = codeptr.reset(func.code.code, 0, func.code.code.length);

		start_pos = 0;
		sig = func.sig;
		trap_label = null;

		// Initialize parameters, locals, and first control stack entry.
		var ret_label = masm.newLabel(func.code.code.length);
		state.reset(sig, ret_label);
		initLocals();
		opcode_pos = codeptr.pos;

		// Emit prologue, which allocates the frame and initializes various registers.
		emitPrologue();

		// Emit instructions.
		success = true;
		while (d.pos < d.limit) {
			emitInstr();
		}
		// Emit epilogue
		if (trap_label != null) emitTrapEpilogue();
		return success;
	}
	def emitPrologue() {
		var c = masm.regAlloc.regConfig;
		var regs = c.regs;

		var offsets = getOffsets();
		// Allocate stack frame
		masm.emit_sub_r_l(regs.sp, c.spcFrameSize);

		// Spill VSP
		masm.emit_mov_m_r(MasmAddr(regs.sp, c.vsp_offset), regs.vsp, ValueKind.REF); // XXX: track VSP-spilled state
		// Load wf.instance and spill
		masm.emit_mov_r_m(regs.instance, ValueKind.REF, MasmAddr(regs.func_arg, offsets.WasmFunction_instance));
		masm.emit_mov_m_r(MasmAddr(regs.sp, c.instance_offset), regs.instance, ValueKind.REF);
		// Load wf.decl and spill
		masm.emit_mov_r_m(regs.func, ValueKind.REF, MasmAddr(regs.func_arg, offsets.WasmFunction_decl));
		masm.emit_mov_m_r(MasmAddr(regs.sp, c.instance_offset), regs.func, ValueKind.REF);
		// spill 0 for EIP, STP
		masm.emit_mov_m_l(MasmAddr(regs.sp, c.eip_offset), 0);
		masm.emit_mov_m_l(MasmAddr(regs.sp, c.stp_offset), 0);

		// Compute VFP = VSP - sig.params.length * SLOT_SIZE
		masm.emit_mov_r_r(regs.vfp, regs.vsp); // XXX: use 3-addr adjustment of VFP
		masm.emit_sub_r_l(regs.vfp, sig.params.length * masm.valuerep.slot_size);

		// Load instance.memories[0].start into MEM0_BASE and spill
		if (module.memories.length > 0) {
			// XXX: skip loading memory base if function doesn't access memory
			masm.emit_mov_r_m(regs.mem0, ValueKind.REF, MasmAddr(regs.instance, offsets.Instance_memories));
			masm.emit_mov_r_m(regs.mem0, ValueKind.REF, MasmAddr(regs.mem0, offsets.Array_contents));
			masm.emit_mov_m_r(MasmAddr(regs.sp, c.mem_offset), regs.mem0, ValueKind.REF);
		} else {
			masm.emit_mov_m_l(MasmAddr(regs.sp, c.mem_offset), 0);
		}
	}
	def initLocals() {
		var max = limits.max_num_locals;
		var dcount = parser.readU32("local decl count", max);
		for (i < dcount) {
			var count = parser.readU32("local count", max);
			var ltype = parser.readValueType();
			state.addLocals(count, ltype);
		}
		state.num_locals = state.sp;
	}
	def emitInstr() {
		opcode_pos = codeptr.pos;
		var opcode = codeptr.read1();
		if (Trace.compiler) { traceStack(); traceOpcode(); }
		match (opcode) {
			Opcode.UNREACHABLE.code => {
				emitTrap(TrapReason.UNREACHABLE);
				state.setUnreachable();
			}
			Opcode.NOP.code => {
				// emit nothing
			}
			Opcode.BLOCK.code => {
				var pr = parser.readBlockType(), params = pr.0, results = pr.1;
				state.pushBlock(params, results, masm.newLabel(opcode_pos));
			}
			Opcode.LOOP.code => {
				var pr = parser.readBlockType(), params = pr.0, results = pr.1;
				state.pushLoop(params, results, masm.newLabel(opcode_pos));
				var ctl_top = state.ctl_stack.peek();
				masm.bindLabel(ctl_top.label);
			}
			Opcode.IF.code => {
				var pr = parser.readBlockType(), params = pr.0, results = pr.1;
				var sv = state.pop();
				state.pushIf(params, results, masm.newLabel(opcode_pos), masm.newLabel(opcode_pos));
				var ctl_top = state.ctl_stack.peek();
				emitBrIf(sv, false, ctl_top.else_label, null, true);
			}
			Opcode.ELSE.code => {
				var ctl_top = state.ctl_stack.peek();
				state.emitFallthru(emitSlotTransfer);
				masm.emit_br(ctl_top.label);
				masm.bindLabel(ctl_top.else_label);
				state.doElse();
				ctl_top.opcode = Opcode.ELSE.code;
			}
			Opcode.END.code => {
				var ctl_top = state.ctl_stack.peek();
				if (ctl_top.opcode == Opcode.LOOP.code) {
					state.ctl_stack.pop();
					state.ctl_stack.peek().reachable = ctl_top.reachable;
				} else if (ctl_top.opcode == Opcode.IF.code) {
					// simulate empty if-true block
					state.emitFallthru(emitSlotTransfer);
					masm.emit_br(ctl_top.label);
					masm.bindLabel(ctl_top.else_label);
					state.doElse();
					ctl_top.opcode = Opcode.ELSE.code;
					state.emitFallthru(emitSlotTransfer);
					masm.bindLabel(ctl_top.label);
					state.resetToMerge(ctl_top);
					state.ctl_stack.pop();
				} else if (ctl_top.opcode == Opcode.BLOCK.code || ctl_top.opcode == Opcode.ELSE.code) {
					state.emitFallthru(emitSlotTransfer);
					masm.bindLabel(ctl_top.label);
					state.resetToMerge(ctl_top);
					state.ctl_stack.pop();
				} else if (ctl_top.opcode == Opcode.RETURN.code) {
					state.emitFallthru(emitSlotTransfer);
					masm.bindLabel(ctl_top.label);
					if (ctl_top.merge_count > 1) emitReturn(ctl_top);
					state.ctl_stack.pop();
				}
			}
			Opcode.BR.code => {
				var depth = parser.readLabel();
				var target = state.getControl(depth);
				state.emitTransfer(target, emitSlotTransfer);
				masm.emit_br(target.label);
				state.setUnreachable();
			}
			Opcode.BR_IF.code => {
				var depth = parser.readLabel();
				var target = state.getControl(depth);
				var sv = state.pop();
				emitBrIf(sv, true, target.label, target, state.isTransferEmpty(target));
			}
			Opcode.BR_TABLE.code => {
				var depths = parser.readLabels();
				var sv = state.pop();
				emitBrTable(sv, depths);
				state.setUnreachable();
			}
			Opcode.RETURN.code => {
				var target = state.ctl_stack.elems[0];
				state.emitTransfer(target, emitSlotTransfer);
				masm.emit_br(target.label);
				state.setUnreachable();
			}
			Opcode.DROP.code => {
				state.sp--;
			}
			Opcode.SELECT.code => {
				var sv = state.pop();
				var fv = state.pop();
				var tv = state.pop();
				emitSelect1(sv, fv, tv);
				freeVal(sv);
			}
			Opcode.LOCAL_GET.code => {
				var index = codeptr.read_uleb32();
				var lv = state.get(index);
				if (lv.isConst()) {
					if (lv.inReg()) {
						state.push(lv.kindFlags(IS_CONST | IN_REG), lv.reg, lv.const); // steal reg
						state.setNoReg(index);
					} else {
						state.push(lv.kindFlags(IS_CONST), NO_REG, lv.const);
					}
				} else if (lv.inReg()) {
					if (!lv.isStored()) {
						masm.emit_mov_s_r(index, lv.reg, lv.kind());
						state.setStored(index);
					}
					state.setNoReg(index); // steal reg
					state.push(lv.kindFlags(IN_REG), lv.reg, 0);
				} else {
					var reg = allocReg(lv.kind());
					emit_read_slot_r(index, reg);
					state.push(lv.kindFlags(IN_REG), reg.reg, 0);
				}
			}
			Opcode.LOCAL_SET.code => {
				var index = codeptr.read_uleb32();
				var lv = state.get(index);
				var sv = state.pop();
				if (sv.isConst() || sv.inReg()) {
					var flags = (lv.flags & (KIND_MASK | TAG_STORED)) | (sv.flags & (IN_REG | IS_CONST));
					state.set(index, flags, sv.reg, sv.const);
				} else {
					var reg = allocReg(lv.kind());
					emit_read_slot_r(state.sp, reg);
					var flags = (lv.flags & (KIND_MASK | TAG_STORED)) | IN_REG;
					state.set(index, flags, reg.reg, 0);
				}
			}
			Opcode.LOCAL_TEE.code => {
				var index = codeptr.read_uleb32();
				var lv = state.get(index);
				var sv = state.peek();
				if (sv.isConst()) {
					var flags = (lv.flags & (KIND_MASK | TAG_STORED)) | IS_CONST;
					state.set(index, flags, NO_REG, sv.const);
				} else if (sv.inReg()) {
					masm.emit_mov_s_r(index, sv.reg, sv.kind());
					var flags = (lv.flags & (KIND_MASK | TAG_STORED));
					state.set(index, flags, NO_REG, 0);
				} else {
					var tos = state.sp - 1;
					var reg = allocReg(lv.kind());
					emit_read_slot_r(tos, reg);
					emit_write_slot_r(index, reg);
					var flags = (lv.flags & (KIND_MASK | TAG_STORED));
					state.set(index, flags, NO_REG, 0);
					state.overwrite(lv.kindFlags(IN_REG), reg.reg, 0);
				}
			}
			Opcode.I32_CONST.code => {
				var val = codeptr.read_sleb32();
				state.push(KIND_I32 | IS_CONST, NO_REG, val);
			}
			Opcode.I64_CONST.code => {
				var val = codeptr.read_sleb64();
				if (i32.view(val) == val) {
					state.push(KIND_I64 | IS_CONST, NO_REG, i32.view(val));
				} else {
					var tos = state.sp;
					var addr = masm.slotAddr(tos);
					masm.emit_mov_m_i(addr, int.view(val));
					masm.emit_mov_m_i(addr.plus(4), int.view(val >> 32));
					state.push(KIND_I64 | IS_STORED, NO_REG, 0);
				}
			}
			Opcode.F32_CONST.code => {
				var val = codeptr.read_u32();
				if (val == 0 && config_TrackFloatZeroConst) {
					state.push(KIND_F32 | IS_CONST, NO_REG, 0);
				} else {
					var tos = state.sp;
					masm.emit_mov_m_i(masm.slotAddr(tos), int.view(val));
					state.push(KIND_F32 | IS_STORED, NO_REG, 0);
				}
			}
			Opcode.F64_CONST.code => {
				var val = codeptr.read_u64();
				if (val == 0 && config_TrackFloatZeroConst) {
					state.push(KIND_F64 | IS_CONST, NO_REG, 0);
				} else {
					var tos = state.sp;
					var addr = masm.slotAddr(tos);
					masm.emit_mov_m_i(addr, int.view(val));
					masm.emit_mov_m_i(addr.plus(4), int.view(val >> 32));
					state.push(KIND_F64 | IS_STORED, NO_REG, 0);
				}
			}
			Opcode.I32_CLZ.code 	=> emitUnop(SpcUnop.I32_CLZ);
			Opcode.I32_CTZ.code 	=> emitUnop(SpcUnop.I32_CTZ);
			Opcode.I32_POPCNT.code 	=> emitUnop(SpcUnop.I32_POPCNT);
			Opcode.I32_ADD.code 	=> emitBinop(SpcBinop.I32_ADD);
			Opcode.I32_SUB.code 	=> emitBinop(SpcBinop.I32_SUB);
			Opcode.I32_MUL.code 	=> emitBinop(SpcBinop.I32_MUL);
			Opcode.I32_DIV_S.code 	=> emitBinop(SpcBinop.I32_DIV_S);
			Opcode.I32_DIV_U.code 	=> emitBinop(SpcBinop.I32_DIV_U);
			Opcode.I32_REM_S.code 	=> emitBinop(SpcBinop.I32_REM_S);
			Opcode.I32_REM_U.code 	=> emitBinop(SpcBinop.I32_REM_U);
			Opcode.I32_AND.code 	=> emitBinop(SpcBinop.I32_AND);
			Opcode.I32_XOR.code 	=> emitBinop(SpcBinop.I32_XOR);
			Opcode.I32_OR.code 	=> emitBinop(SpcBinop.I32_OR);
			Opcode.I32_SHL.code 	=> emitBinop(SpcBinop.I32_SHL);
			Opcode.I32_SHR_S.code 	=> emitBinop(SpcBinop.I32_SHR_S);
			Opcode.I32_SHR_U.code 	=> emitBinop(SpcBinop.I32_SHR_U);
			Opcode.I32_ROTL.code 	=> emitBinop(SpcBinop.I32_ROTL);
			Opcode.I32_ROTR.code 	=> emitBinop(SpcBinop.I32_ROTR);

			Opcode.I32_EQZ.code	=> emitUnop(SpcUnop.I32_EQZ);
			Opcode.I32_EQ.code 	=> emitBinop(SpcBinop.I32_EQ);
			Opcode.I32_NE.code 	=> emitBinop(SpcBinop.I32_NE);
			Opcode.I32_LT_S.code 	=> emitBinop(SpcBinop.I32_LT_S);
			Opcode.I32_LT_U.code 	=> emitBinop(SpcBinop.I32_LT_U);
			Opcode.I32_GT_S.code 	=> emitBinop(SpcBinop.I32_GT_S);
			Opcode.I32_GT_U.code 	=> emitBinop(SpcBinop.I32_GT_U);
			Opcode.I32_LE_S.code 	=> emitBinop(SpcBinop.I32_LE_S);
			Opcode.I32_LE_U.code 	=> emitBinop(SpcBinop.I32_LE_U);
			Opcode.I32_GE_S.code 	=> emitBinop(SpcBinop.I32_GE_S);
			Opcode.I32_GE_U.code 	=> emitBinop(SpcBinop.I32_GE_U);

			Opcode.I64_CLZ.code 	=> emitUnop(SpcUnop.I64_CLZ);
			Opcode.I64_CTZ.code 	=> emitUnop(SpcUnop.I64_CTZ);
			Opcode.I64_POPCNT.code 	=> emitUnop(SpcUnop.I64_POPCNT);
			Opcode.I64_ADD.code 	=> emitBinop(SpcBinop.I64_ADD);
			Opcode.I64_SUB.code 	=> emitBinop(SpcBinop.I64_SUB);
			Opcode.I64_MUL.code 	=> emitBinop(SpcBinop.I64_MUL);
			Opcode.I64_DIV_S.code 	=> emitBinop(SpcBinop.I64_DIV_S);
			Opcode.I64_DIV_U.code 	=> emitBinop(SpcBinop.I64_DIV_U);
			Opcode.I64_REM_S.code 	=> emitBinop(SpcBinop.I64_REM_S);
			Opcode.I64_REM_U.code 	=> emitBinop(SpcBinop.I64_REM_U);
			Opcode.I64_AND.code 	=> emitBinop(SpcBinop.I64_AND);
			Opcode.I64_XOR.code 	=> emitBinop(SpcBinop.I64_XOR);
			Opcode.I64_OR.code 	=> emitBinop(SpcBinop.I64_OR);
			Opcode.I64_SHL.code 	=> emitBinop(SpcBinop.I64_SHL);
			Opcode.I64_SHR_S.code 	=> emitBinop(SpcBinop.I64_SHR_S);
			Opcode.I64_SHR_U.code 	=> emitBinop(SpcBinop.I64_SHR_U);
			Opcode.I64_ROTL.code 	=> emitBinop(SpcBinop.I64_ROTL);
			Opcode.I64_ROTR.code 	=> emitBinop(SpcBinop.I64_ROTR);

			Opcode.I64_EQZ.code	=> emitUnop(SpcUnop.I64_EQZ);
			Opcode.I64_EQ.code 	=> emitBinop(SpcBinop.I64_EQ);
			Opcode.I64_NE.code 	=> emitBinop(SpcBinop.I64_NE);
			Opcode.I64_LT_S.code 	=> emitBinop(SpcBinop.I64_LT_S);
			Opcode.I64_LT_U.code 	=> emitBinop(SpcBinop.I64_LT_U);
			Opcode.I64_GT_S.code 	=> emitBinop(SpcBinop.I64_GT_S);
			Opcode.I64_GT_U.code 	=> emitBinop(SpcBinop.I64_GT_U);
			Opcode.I64_LE_S.code 	=> emitBinop(SpcBinop.I64_LE_S);
			Opcode.I64_LE_U.code 	=> emitBinop(SpcBinop.I64_LE_U);
			Opcode.I64_GE_S.code 	=> emitBinop(SpcBinop.I64_GE_S);
			Opcode.I64_GE_U.code 	=> emitBinop(SpcBinop.I64_GE_U);

			Opcode.I32_WRAP_I64.code	=> emitUnop(SpcUnop.I32_WRAP_I64);
			Opcode.I64_EXTEND_I32_S.code	=> emitUnop(SpcUnop.I64_EXTEND_I32_S);
			Opcode.I64_EXTEND_I32_U.code	=> emitUnop(SpcUnop.I64_EXTEND_I32_U);
			Opcode.I32_EXTEND8_S.code	=> emitUnop(SpcUnop.I32_EXTEND8_S);
			Opcode.I32_EXTEND16_S.code	=> emitUnop(SpcUnop.I32_EXTEND16_S);
			Opcode.I64_EXTEND8_S.code	=> emitUnop(SpcUnop.I64_EXTEND8_S);
			Opcode.I64_EXTEND16_S.code	=> emitUnop(SpcUnop.I64_EXTEND16_S);
			Opcode.I64_EXTEND32_S.code	=> emitUnop(SpcUnop.I64_EXTEND32_S);
			_ => unsupported();
		}
	}
	def emitSelect1(sv: SpcAbstractVal, fv: SpcAbstractVal, tv: SpcAbstractVal) {
		var tagStored = tv.flags & TAG_STORED;
		var label = masm.newLabel(opcode_pos);
		if (tv.isConst() && fv.isConst() && tv.const == fv.const) {
			// select K K v => K
			freeVal(tv);
			freeVal(fv);
			state.push(tv.kindFlags(IS_CONST), NO_REG, tv.const);
			return;
		}
		if (sv.isConst()) {
			// select v v K => v
			if (sv.const != 0) {
				freeVal(fv);
				state.pushV(tv);
			} else {
				freeVal(tv);
				if (fv.isConst() || fv.inReg()) state.push(fv.flags & ~IS_STORED, fv.reg, fv.const);
				else {
					var kind = fv.kind();
					var reg = allocReg(kind);
					emit_read_slot_r(state.sp + 1, reg);
					state.push(fv.kindFlags(IN_REG | tagStored), reg.reg, 0);
				}
			}
			return;
		}
		if (tv.inReg()) {
			// reuse register for true value
			var nonzero = true;
			if (sv.inReg()) masm.emit_br_r(sv.reg, nonzero, label);
			else masm.emit_br_m(masm.slotAddr(state.sp + 2), nonzero, label);

			if (fv.isConst()) masm.emit_mov_r_k(tv.reg, tv.kind(), fv.const);
			else if (fv.inReg()) masm.emit_mov_r_r(tv.reg, fv.reg);
			else masm.emit_mov_r_s(tv.reg, tv.kind(), state.sp + 1);
			masm.bindLabel(label);
			state.push(tv.kindFlags(IN_REG | tagStored), tv.reg, 0);
			freeVal(fv);
		} else {
			// load const true value into slot first
			if (!tv.isStored()) masm.emit_mov_s_k(state.sp, tv.const, tv.kind());

			var nonzero = true; // XXX: reuse the false register and flip branch if possible
			if (sv.inReg()) masm.emit_br_r(sv.reg, nonzero, label);
			else masm.emit_br_m(masm.slotAddr(state.sp + 2), nonzero, label);

			if (fv.isConst()) masm.emit_mov_s_k(state.sp, fv.const, tv.kind());
			else if (fv.inReg()) masm.emit_mov_s_r(state.sp, fv.reg, tv.kind());
			else masm.emit_mov_s_s(state.sp, state.sp + 1, tv.kind());
			masm.bindLabel(label);
			state.push(tv.kindFlags(IS_STORED | tagStored), NO_REG, 0);
			freeVal(fv);
		}
	}
	def tryNop(isNop: int -> bool) -> bool {
		var sv = state.peek();
		if (sv.isConst() && isNop(sv.const)) {
			state.pop();
			freeVal(sv);
			return true;
		}
		return false;
	}
	def emitBrIf(sv: SpcAbstractVal, nonzero: bool, label: MasmLabel, target: SpcControl, emptyTransfer: bool) {
		if (sv.isConst()) {
			if (sv.const != 0) {
				if (!emptyTransfer) state.emitTransfer(target, emitSlotTransfer);
				masm.emit_br(target.label);
			}
		} else if (sv.inReg()) {
			if (emptyTransfer) {
				masm.emit_br_r(sv.reg, nonzero, label);
			} else {
				var skip = masm.newLabel(opcode_pos);
				masm.emit_br_r(sv.reg, !nonzero, skip);
				state.emitTransfer(target, emitSlotTransfer);
				masm.emit_br(label);
				masm.bindLabel(skip);
			}
		} else {
			if (emptyTransfer) {
				masm.emit_br_m(masm.slotAddr(state.sp), nonzero, label);
			} else {
				var skip = masm.newLabel(opcode_pos);
				masm.emit_br_m(masm.slotAddr(state.sp), !nonzero, skip);
				state.emitTransfer(target, emitSlotTransfer);
				masm.emit_br(label);
				masm.bindLabel(skip);
			}
		}
		freeVal(sv);
	}
	def emitBrTable(sv: SpcAbstractVal, depths: Array<u32>) {
		var labels = Array<MasmLabel>.new(state.ctl_stack.top);
		var targets = Array<MasmLabel>.new(depths.length);
		for (i < targets.length) { // create labels for all targets involved in this br_table
			var depth = depths[i];
			var l = labels[depth];
			if (l == null) l = labels[depth] = masm.newLabel(opcode_pos);
			targets[i] = l;
		}
		if (sv.isConst()) {
			// constant-fold br_table into a br
			var key = sv.const;
			var depth = if(key >= depths.length, depths[depths.length - 1], depths[key]);
			var target = state.ctl_stack.elems[depth];
			state.emitTransfer(target, emitSlotTransfer);
			masm.emit_br(target.label);
		} else {
			var reg = SpcReg(sv.reg, ValueKind.I32);
			if (!sv.inReg()) {
				reg = allocReg(ValueKind.I32);
				masm.emit_mov_r_s(reg.reg, reg.kind, state.sp);
			}
			masm.emit_br_table_r(reg.reg, targets);
			freeReg(reg);

			for (depth < labels.length) {
				var l = labels[depth];
				if (l == null) continue;
				masm.bindLabel(l);
				var target = state.getControl(u32.view(depth));
				state.emitTransfer(target, emitSlotTransfer);
				masm.emit_br(target.label);
			}
		}
	}
	def emitReturn(ctl: SpcControl) {
		var results = sig.results;
		if (masm.valuerep.tagged) {
			// update mismatched value tags
			var params = sig.params;
			for (i < results.length) {
				var rtag = toTag(results[i]);
				if (i < params.length && rtag == toTag(params[i])) continue; // tag already correct
				masm.emit_mov_m_i(masm.tagAddr(u32.view(i)), rtag.code);
			}
		}
		// Compute VSP = VFP + sig.results.length
		var c = masm.regAlloc.regConfig;
		masm.emit_mov_r_r(c.regs.vsp, c.regs.vfp); // XXX: use 3-addr adjustment of VSP
		if (results.length > 0)	masm.emit_add_r_l(c.regs.vsp, results.length * masm.valuerep.slot_size);
		// Deallocate stack frame
		masm.emit_add_r_l(c.regs.sp, c.spcFrameSize);
		// Return to caller
		masm.emit_mov_r_i(c.regs.ret_ExecState, ExecState.FINISHED.tag);
		masm.emit_ret();
	}
	def emitTrap(reason: TrapReason) {
		var c = masm.regAlloc.regConfig;
		masm.emit_mov_r_i(c.regs.ret_TrapReason, reason.tag);
		if (trap_label == null) trap_label = masm.newLabel(opcode_pos); // XXX: proper pos?
		masm.emit_br(trap_label);
	}
	def emitTrapEpilogue() {
		if (trap_label == null) return;
		var c = masm.regAlloc.regConfig;
		masm.bindLabel(trap_label);
		masm.emit_mov_r_i(c.regs.ret_ExecState, ExecState.TRAPPED.tag);
		masm.emit_add_r_l(c.regs.sp, c.spcFrameSize);
		// Return to caller
		masm.emit_ret();
	}
	def emitSlotTransfer(to: (u32, SpcAbstractVal), from: (u32, SpcAbstractVal)) {
		if (Trace.compiler) {
			Trace.OUT.put1("    emitSlotTransfer slot=%d ", to.0);
			traceAbstractVal(to.1);
			Trace.OUT.put1(" <- slot=%d ", from.0);
			traceAbstractVal(from.1);
			Trace.OUT.outln();
		}
		var tv = to.1, fv = from.1;
		if (masm.valuerep.tagged && tv.tagStored()) {
			if (from.0 != to.0 || !fv.tagStored()) {
				// store the tag into to-slot
				masm.emit_mov_m_i(masm.tagAddr(to.0), fv.kind().code);
			}
		}
		if (tv.isStored()) {
			// store the value into slot
			if (from.0 != to.0 || !fv.isStored()) {
				if (fv.isConst()) {
					masm.emit_mov_s_k(to.0, fv.const, fv.kind());
				} else if (fv.inReg()) {
					masm.emit_mov_s_r(to.0, fv.reg, fv.kind());
				} else {
					masm.emit_mov_s_s(to.0, from.0, tv.kind());
				}
			}
		} else if (tv.inReg()) {
			// load or move the value into appropriate register
			if (fv.isConst()) {
				masm.emit_mov_r_i(tv.reg, fv.const);
			} else if (fv.inReg()) {
				if (tv.reg != fv.reg) {
					// XXX: perform reg-reg move instead of storing to slot
					masm.emit_mov_s_r(to.0, fv.reg, fv.kind());
					masm.emit_mov_r_s(tv.reg, fv.kind(), to.0);
				}
			} else {
				masm.emit_mov_r_s(tv.reg, tv.kind(), from.0);
			}
		}
	}
	def emitUnop(unop: SpcUnop) {
		var a = state.peek();
		var tos = u32.!(state.sp - 1);
		var flags = (a.flags & unop.kind_sig.preserve_flags) | unop.kind_sig.add_flags;
		if (a.isConst() && unop.fold != null) {
			state.overwrite(flags | IS_CONST, NO_REG, unop.fold(a.const));
			return;
		}
		var reg_a: Reg;
		if (a.inReg()) {
			reg_a = a.reg;
		} else {
			var kind = unop.kind_sig.a_kind;
			reg_a = allocReg(unop.kind_sig.a_kind).reg;
			if (a.isConst()) {
				masm.emit_mov_r_k(reg_a, kind, a.const);
			} else {
				masm.emit_mov_r_s(reg_a, kind, tos);
			}
		}
		masm.emit_unop_r(unop.op, a.reg);
		state.overwrite(flags | IN_REG, a.reg, 0);
	}
	def emitBinop(binop: SpcBinop) {
		var b = state.pop();
		var a = state.peek();
		var tos = u32.!(state.sp - 1);
		var flags = (a.flags & binop.kind_sig.preserve_flags) | binop.kind_sig.add_flags;
		if (binop.isNop != null && b.isConst() && binop.isNop(b.const)) {
			freeVal(b);
			return;
		}
		if (a.inReg()) {
			// reg const? op x
			if (b.isConst()) {
				if (a.isConst() && binop.fold != null) {
					// fold: const op const
					var val = binop.fold(a.const, b.const);
					state.overwrite(flags | IS_CONST, NO_REG, val);
					freeVal(a);
					freeVal(b);
				} else {
					// reg op const
					masm.emit_binop_r_i(binop.op, a.reg, b.const);
					state.overwrite(flags | IN_REG, a.reg, 0);
					freeVal(b);
				}
			} else if (b.inReg()) {
				if (binop.commute != Opcode.UNREACHABLE && a.isConst()) {
					// commute: const op reg -> reg op const
					masm.emit_binop_r_i(binop.commute, b.reg, a.const);
					state.overwrite(flags | IN_REG, b.reg, 0);
					freeVal(a);
				} else {
					// reg op reg
					masm.emit_binop_r_r(binop.op, a.reg, b.reg);
					state.overwrite(flags | IN_REG, a.reg, 0);
					freeVal(b);
				}
			} else {
				// reg op slot
				masm.emit_binop_r_m(binop.op, a.reg, masm.slotAddr(tos+1));
				state.overwrite(flags | IN_REG, a.reg, 0);
			}
		} else if (a.isConst()) {
			// const op x
			if (b.isConst()) {
				if (binop.fold != null) {
					// fold: const op const
					var val = binop.fold(a.const, b.const);
					state.overwrite(flags | IS_CONST, NO_REG, val);
					freeVal(a);
					freeVal(b);
				} else if (binop.commute != Opcode.UNREACHABLE && b.inReg()) {
					// commute const op reg -> reg op const
					masm.emit_binop_r_i(binop.commute, b.reg, a.const);
					state.overwrite(flags | IN_REG, b.reg, 0);
				} else {
					// load: a reg -> reg op reg
					var reg_a = allocReg(binop.kind_sig.a_kind);
					masm.emit_mov_r_i(reg_a.reg, a.const);
					masm.emit_binop_r_i(binop.op, reg_a.reg, b.const);
					state.overwrite(flags | IN_REG, reg_a.reg, 0);
					freeVal(b);
				}
			} else if (b.inReg()) {
				// const op reg
				if (binop.commute != Opcode.UNREACHABLE && b.inReg()) {
					// commute const op reg -> reg op const
					masm.emit_binop_r_i(binop.commute, b.reg, a.const);
					state.overwrite(flags | IN_REG, b.reg, 0);
				} else {
					var reg_a = allocReg(ValueKind.I32);
					masm.emit_mov_r_i(reg_a.reg, a.const);
					masm.emit_binop_r_r(binop.op, reg_a.reg, b.reg);
					state.overwrite(flags | IN_REG, reg_a.reg, 0);
					freeVal(b);
				}
			} else {
				// const op slot
				var reg_a = allocReg(binop.kind_sig.a_kind);
				masm.emit_mov_r_i(reg_a.reg, a.const);
				masm.emit_binop_r_m(binop.op, reg_a.reg, masm.slotAddr(tos+1));
				state.overwrite(flags | IN_REG, reg_a.reg, 0);
				// XXX: if commute: load rb, binop_r_i
			}
		} else {
			var reg_a = allocReg(binop.kind_sig.a_kind);
			emit_read_slot_r(tos, reg_a);
			// slot op x
			if (b.isConst()) {
				// slot op const
				masm.emit_binop_r_i(binop.op, reg_a.reg, b.const);
			} else if (b.inReg()) {
				// slot op reg
				masm.emit_binop_r_r(binop.op, reg_a.reg, b.reg);
			} else {
				// slot op slot
				masm.emit_binop_r_m(binop.op, reg_a.reg, masm.slotAddr(tos+1));
			}
			// XXX: if commute: binop_r_m
			state.overwrite(flags | IN_REG, reg_a.reg, 0);
			freeVal(b);
		}
	}
	def unsupported() {
		success = false; // XXX: add opcode
		codeptr.atl(codeptr.pos, codeptr.pos); // set limit to break out of loop
	}
	def bailout(msg: string) {
		success = false;
		codeptr.atl(codeptr.pos, codeptr.pos); // set limit to break out of loop
		err.rel(codeptr, codeptr.pos).set(msg);
	}

	//====================================================================
	// codegen operations
	//====================================================================
	def emit_read_slot_r(slot: u32, reg: SpcReg) {
		masm.emit_mov_r_s(reg.reg, reg.kind, slot);
	}
	def emit_read_tos_r(reg: SpcReg) {
		masm.emit_mov_r_s(reg.reg, reg.kind, state.sp - 1);
	}
	def emit_write_tos_tag(tag: ValueKind) {
		if (masm.valuerep.tagged) {
			masm.emit_mov_m_i(masm.tagAddr(state.sp - 1), tag.code);
		}
	}
	def emit_write_slot_tag(slot: u32, tag: ValueKind) {
		if (masm.valuerep.tagged) {
			masm.emit_mov_m_i(masm.tagAddr(slot), tag.code);
		}
	}
	def emit_write_slot_r(slot: u32, reg: SpcReg) {
		masm.emit_mov_s_r(slot, reg.reg, reg.kind);
	}
	def emit_write_slot_i(slot: u32, val: int, kind: ValueKind) {
		// TODO: handle in macro assembler instead?
		match (kind) {
			I32 => masm.emit_mov_s_i(slot, val);
			I64 => masm.emit_mov_s_l(slot, val);
			REF => {
				if (val != 0) bailout("error, non-zero ref const");
				masm.emit_mov_s_l(slot, 0);
			}
			F32 => masm.emit_mov_s_f(slot, u32.view(val));
			F64 => masm.emit_mov_s_d(slot, u64.view(long.view(val)));
			V128 => masm.emit_mov_s_q(slot, u64.view(long.view(val)), if(val < 0, u64.max, 0));
		}

	}

	//====================================================================
	// register allocation operations
	//====================================================================
	def freeReg(reg: SpcReg) {
		masm.regAlloc.free(reg.reg);
	}
	def freeVal(sv: SpcAbstractVal) {
		if (sv.inReg()) masm.regAlloc.free(sv.reg);
	}
	def allocReg(kind: ValueKind) -> SpcReg {
		// TODO: handle running out of registers
		var reg = masm.regAlloc.alloc(kind, 2);
		return SpcReg(reg, kind);
	}

	//====================================================================
	// abstract stack operations
	//====================================================================
	def labelArgs(ctl: SpcControl) -> Array<ValueType> {
		if (ctl.opcode == Opcode.LOOP.code) return ctl.params;
		else return ctl.results;
	}
	def traceOpcode() {
		OUT.put2("  %x(+%d): ", opcode_pos, opcode_pos - start_pos);
		var prev = codeptr.pos;
		codeptr.at(opcode_pos);
		instrTracer.putInstr(OUT, module, codeptr);
		codeptr.at(prev);
		OUT.outln();
	}
	def traceStack() {
		OUT.put1("sp=%d ", state.sp);
		for (i < state.sp) traceAbstractVal(state.state[i]);
		OUT.outln();
	}
	def traceAbstractVal(sv: SpcAbstractVal) {
		OUT.put3("[%s %s%s: ",
			sv.kind().name,
			if(sv.tagStored(), "T", ""),
			if(sv.isStored(), "S", ""));
		if (sv.inReg()) OUT.put1(" @%s", masm.regAlloc.regConfig.regSet.getName(sv.reg));
		if (sv.isConst()) OUT.put1(" $%d", sv.const);
		OUT.puts("]");
	}
}

// States in which a local slot or operand stack slot could be in.
type SpcState {
	case Uncached;
	case Register(reg: SpcReg);
	case Const(val: int);
}

type SpcReg(reg: Reg, kind: ValueKind) #unboxed { }

// Abstract values tracked during single-pass compilation.
def IS_STORED: byte = 0x01;
def IS_CONST: byte = 0x02;
def IN_REG: byte = 0x04;
def TAG_STORED: byte = 0x08;
def KIND_MASK: byte = 0xF0;
def KIND_I32: byte = byte.view(ValueKind.I32.tag) << 4;
def KIND_I64: byte = byte.view(ValueKind.I64.tag) << 4;
def KIND_F32: byte = byte.view(ValueKind.F32.tag) << 4;
def KIND_F64: byte = byte.view(ValueKind.F64.tag) << 4;
def KIND_V128: byte = byte.view(ValueKind.V128.tag) << 4;
def KIND_REF: byte = byte.view(ValueKind.REF.tag) << 4;
def NO_REG = Reg(0);
def kinds: Array<ValueKind> = [ValueKind.I32, ValueKind.I64, ValueKind.F32, ValueKind.F64, ValueKind.V128, ValueKind.REF];

type SpcAbstractVal(flags: byte, reg: Reg, const: int) #unboxed {
	def kind() -> ValueKind {
		return kinds[flags >> 4];
	}
	def kindFlags(add: byte) -> byte {
		return (flags & KIND_MASK) | add;
	}
	def isStored() -> bool {
		return (flags & IS_STORED) != 0;
	}
	def isConst() -> bool {
		return (flags & IS_CONST) != 0;
	}
	def inReg() -> bool {
		return (flags & IN_REG) != 0;
	}
	def tagStored() -> bool {
		return (flags & TAG_STORED) != 0;
	}
}

type SpcBinopSig(a_kind: ValueKind, b_kind: ValueKind, preserve_flags: byte, add_flags: byte);
type SpcUnopSig(a_kind: ValueKind, preserve_flags: byte, add_flags: byte);

def kind_ii_i = SpcBinopSig(ValueKind.I32, ValueKind.I32, KIND_MASK | TAG_STORED, 0);
def kind_ll_l = SpcBinopSig(ValueKind.I64, ValueKind.I64, KIND_MASK | TAG_STORED, 0);
def kind_ll_i = SpcBinopSig(ValueKind.I64, ValueKind.I64, 0, KIND_I32);

def kind_i_i = SpcUnopSig(ValueKind.I32, KIND_MASK | TAG_STORED, 0);
def kind_l_i = SpcUnopSig(ValueKind.I32, 0, KIND_I32);
def kind_i_l = SpcUnopSig(ValueKind.I32, 0, KIND_I64);
def kind_l_l = SpcUnopSig(ValueKind.I64, KIND_MASK | TAG_STORED, 0);

enum SpcBinop(op: Opcode, commute: Opcode, kind_sig: SpcBinopSig, isNop: int -> bool, fold: (int, int) -> int) {
	I32_ADD		(Opcode.I32_ADD,	Opcode.I32_ADD,		kind_ii_i, isZero, int.+)
	I32_SUB		(Opcode.I32_SUB,	Opcode.UNREACHABLE,	kind_ii_i, isZero, int.-),
	I32_MUL		(Opcode.I32_MUL,	Opcode.I32_MUL,		kind_ii_i, isOne, int.*),
	I32_DIV_S	(Opcode.I32_DIV_S,	Opcode.UNREACHABLE,	kind_ii_i, null, null),
	I32_DIV_U	(Opcode.I32_DIV_U,	Opcode.UNREACHABLE,	kind_ii_i, null, null),
	I32_REM_S	(Opcode.I32_REM_S,	Opcode.UNREACHABLE,	kind_ii_i, null, null),
	I32_REM_U	(Opcode.I32_REM_U,	Opcode.UNREACHABLE,	kind_ii_i, isMinusOne, null),
	I32_AND		(Opcode.I32_AND,	Opcode.I32_AND,		kind_ii_i, isMinusOne, int.&),
	I32_XOR		(Opcode.I32_XOR,	Opcode.I32_XOR,		kind_ii_i, isZero, int.^),
	I32_OR		(Opcode.I32_OR,		Opcode.I32_OR,		kind_ii_i, isZero, int.|),
	I32_SHL		(Opcode.I32_SHL,	Opcode.UNREACHABLE,	kind_ii_i, isZero, Execute.I32_SHL),
	I32_SHR_S	(Opcode.I32_SHR_S,	Opcode.UNREACHABLE,	kind_ii_i, isZero, Execute.I32_SHR_S),
	I32_SHR_U	(Opcode.I32_SHR_U,	Opcode.UNREACHABLE,	kind_ii_i, isZero, Execute.I32_SHR_U),
	I32_ROTL	(Opcode.I32_ROTL,	Opcode.UNREACHABLE,	kind_ii_i, isZero, I32_ROTL),
	I32_ROTR	(Opcode.I32_ROTR,	Opcode.UNREACHABLE,	kind_ii_i, isZero, I32_ROTR),
	I32_EQ		(Opcode.I32_EQ,		Opcode.UNREACHABLE,	kind_ii_i, null, Fold_ii_i.I32_EQ),
	I32_NE		(Opcode.I32_NE,		Opcode.UNREACHABLE,	kind_ii_i, null, Fold_ii_i.I32_NE),
	I32_LT_S	(Opcode.I32_LT_S,	Opcode.I32_GT_S, kind_ii_i, null, Fold_ii_i.I32_LT_S),
	I32_LT_U	(Opcode.I32_LT_U,	Opcode.I32_GT_U, kind_ii_i, null, Fold_ii_i.I32_LT_U),
	I32_GT_S	(Opcode.I32_GT_S,	Opcode.I32_LT_S, kind_ii_i, null, Fold_ii_i.I32_GT_S),
	I32_GT_U	(Opcode.I32_GT_U,	Opcode.I32_LT_U, kind_ii_i, null, Fold_ii_i.I32_GT_U),
	I32_LE_S	(Opcode.I32_LE_S,	Opcode.I32_GE_S, kind_ii_i, null, Fold_ii_i.I32_LE_S),
	I32_LE_U	(Opcode.I32_LE_U,	Opcode.I32_GE_U, kind_ii_i, null, Fold_ii_i.I32_LE_U),
	I32_GE_S	(Opcode.I32_GE_S,	Opcode.I32_LE_S, kind_ii_i, null, Fold_ii_i.I32_GE_S),
	I32_GE_U	(Opcode.I32_GE_U,	Opcode.I32_LE_U, kind_ii_i, null, Fold_ii_i.I32_GE_U),

	I64_ADD		(Opcode.I64_ADD,	Opcode.I64_ADD,		kind_ll_l, isZero, null)
	I64_SUB		(Opcode.I64_SUB,	Opcode.UNREACHABLE,	kind_ll_l, isZero, null),
	I64_MUL		(Opcode.I64_MUL,	Opcode.I64_MUL,		kind_ll_l, isOne, null),
	I64_DIV_S	(Opcode.I64_DIV_S,	Opcode.UNREACHABLE,	kind_ll_l, null, null),
	I64_DIV_U	(Opcode.I64_DIV_U,	Opcode.UNREACHABLE,	kind_ll_l, null, null),
	I64_REM_S	(Opcode.I64_REM_S,	Opcode.UNREACHABLE,	kind_ll_l, null, null),
	I64_REM_U	(Opcode.I64_REM_U,	Opcode.UNREACHABLE,	kind_ll_l, isMinusOne, null),
	I64_AND		(Opcode.I64_AND,	Opcode.I64_AND,		kind_ll_l, isMinusOne, null),
	I64_XOR		(Opcode.I64_XOR,	Opcode.I64_XOR,		kind_ll_l, isZero, null),
	I64_OR		(Opcode.I64_OR,		Opcode.I64_OR,		kind_ll_l, isZero, null),
	I64_SHL		(Opcode.I64_SHL,	Opcode.UNREACHABLE,	kind_ll_l, isZero, null),
	I64_SHR_S	(Opcode.I64_SHR_S,	Opcode.UNREACHABLE,	kind_ll_l, isZero, null),
	I64_SHR_U	(Opcode.I64_SHR_U,	Opcode.UNREACHABLE,	kind_ll_l, isZero, null),
	I64_ROTL	(Opcode.I64_ROTL,	Opcode.UNREACHABLE,	kind_ll_l, isZero, null),
	I64_ROTR	(Opcode.I64_ROTR,	Opcode.UNREACHABLE,	kind_ll_l, isZero, null),
	I64_EQ		(Opcode.I64_EQ,		Opcode.UNREACHABLE,	kind_ll_i, null, null),
	I64_NE		(Opcode.I64_NE,		Opcode.UNREACHABLE,	kind_ll_i, null, null),
	I64_LT_S	(Opcode.I64_LT_S,	Opcode.I64_GT_S, kind_ll_i, null, null),
	I64_LT_U	(Opcode.I64_LT_U,	Opcode.I64_GT_U, kind_ll_i, null, null),
	I64_GT_S	(Opcode.I64_GT_S,	Opcode.I64_LT_S, kind_ll_i, null, null),
	I64_GT_U	(Opcode.I64_GT_U,	Opcode.I64_LT_U, kind_ll_i, null, null),
	I64_LE_S	(Opcode.I64_LE_S,	Opcode.I64_GE_S, kind_ll_i, null, null),
	I64_LE_U	(Opcode.I64_LE_U,	Opcode.I64_GE_U, kind_ll_i, null, null),
	I64_GE_S	(Opcode.I64_GE_S,	Opcode.I64_LE_S, kind_ll_i, null, null),
	I64_GE_U	(Opcode.I64_GE_U,	Opcode.I64_LE_U, kind_ll_i, null, null)
}

enum SpcUnop(op: Opcode, kind_sig: SpcUnopSig, fold: int -> int) {
	I32_CLZ(Opcode.I32_CLZ, kind_i_i, null), // XXX: fold
	I32_CTZ(Opcode.I32_CTZ, kind_i_i, null), // XXX: fold
	I32_POPCNT(Opcode.I32_POPCNT, kind_i_i, null), // XXX: fold
	I32_EQZ(Opcode.I32_EQZ, kind_i_i, null), // XXX: fold
	I64_EQZ(Opcode.I64_EQZ, kind_l_i, null), // XXX: fold
	I64_CLZ(Opcode.I64_CLZ, kind_l_l, null), // XXX: fold
	I64_CTZ(Opcode.I64_CTZ, kind_l_l, null), // XXX: fold
	I64_POPCNT(Opcode.I64_POPCNT, kind_l_l, null), // XXX: fold
	I32_WRAP_I64(Opcode.I32_WRAP_I64, kind_l_i, null), // XXX: fold
	I64_EXTEND_I32_S(Opcode.I64_EXTEND_I32_S, kind_i_l, null), // XXX: fold
	I64_EXTEND_I32_U(Opcode.I64_EXTEND_I32_U, kind_i_l, null), // XXX: fold
	I32_EXTEND8_S(Opcode.I32_EXTEND8_S, kind_i_i, null), // XXX: fold
	I32_EXTEND16_S(Opcode.I32_EXTEND16_S, kind_i_i, null), // XXX: fold
	I64_EXTEND8_S(Opcode.I64_EXTEND8_S, kind_l_l, null), // XXX: fold
	I64_EXTEND16_S(Opcode.I64_EXTEND16_S, kind_l_l, null), // XXX: fold
	I64_EXTEND32_S(Opcode.I64_EXTEND32_S, kind_l_l, null), // XXX: fold
}

// An entry in the abstract control stack.
class SpcControl {
	var opcode: byte;
	var params: Array<ValueType>;
	var results: Array<ValueType>;
	var reachable = true;
	var val_stack_top: u32;
	var label: MasmLabel;
	var else_label: MasmLabel;
	// the state at the merge (label)
	var merge_count: byte;
	var merge_state: Array<SpcAbstractVal>;
	// the state used to reset back to before the true branch of an if
	var reset_state: Array<SpcAbstractVal>;

	def clearMerge() {
		merge_count = 0;
		merge_state = null;
	}
	def clearReset() {
		reset_state = null;
	}
}

def isZero = int.==(0, _);
def isOne = int.==(1, _);
def isMinusOne = int.==(-1, _);
def to_ii_i(f: (u32, u32) -> u32, a: int, b: int) -> int {
	return int.view(f(u32.view(a), u32.view(b)));
}
def I32_ROTL = to_ii_i(Execute.I32_ROTL, _, _);
def I32_ROTR = to_ii_i(Execute.I32_ROTR, _, _);

// Contains both the abstract control and abstract value stack.
class SpcAbstractState(regAlloc: RegAlloc) {
	// Abstract state of the value stack
	var state = Array<SpcAbstractVal>.new(INITIAL);
	var sp: u32;
	var ctl_stack = ArrayStack<SpcControl>.new();
	var num_locals: u32;

	// Reset the state for starting a new function.
	def reset(sig: SigDecl, ret_label: MasmLabel) {
		sp = 0;
		ctl_stack.clear();
		// manually set up first control entry and return merge state
		var results = sig.results;
		var ctl = pushControl(Opcode.RETURN.code, ValueTypes.NONE, results, ret_label);
		var merge_state = Array<SpcAbstractVal>.new(results.length);
		for (i < results.length) {
			// request the merged values be stored to the stack, but don't require tags
			merge_state[i] = SpcAbstractVal(typeToKindFlags(results[i]) | IS_STORED, NO_REG, 0);
		}
		ctl.merge_state = merge_state;
		ctl.merge_count = 1;
		// initialize parameters
		var params = sig.params;
		grow(params.length);
		for (i < params.length) {
			// params start on the stack and already have tags
			state[i] = SpcAbstractVal(typeToKindFlags(params[i]) | TAG_STORED | IS_STORED, NO_REG, 0);
		}
		sp = u32.view(params.length);
	}
	// Add the specified number of locals of the specified type.
	def addLocals(count: u32, ltype: ValueType) {
		var nlength = sp + count;
		if (nlength > state.length) grow(int.view(nlength + sp * 2));
		var flags = typeToKindFlags(ltype) | TAG_STORED | IS_STORED | IS_CONST;
		for (j < count) {
			var k = j + sp;
			state[k] = SpcAbstractVal(flags, NO_REG, 0);
		}
		sp = nlength;
	}
	def pushBlock(params: Array<ValueType>, results: Array<ValueType>, end_label: MasmLabel) -> SpcControl {
		return pushControl(Opcode.BLOCK.code, params, results, end_label);
	}
	def pushLoop(params: Array<ValueType>, results: Array<ValueType>, start_label: MasmLabel) -> SpcControl {
		var ctl = pushControl(Opcode.LOOP.code, params, results, start_label);
		return ctl;
	}
	def pushIf(params: Array<ValueType>, results: Array<ValueType>, else_label: MasmLabel, end_label: MasmLabel) -> SpcControl {
		var ctl = pushControl(Opcode.IF.code, params, results, end_label);
		ctl.else_label = else_label;
		ctl.reset_state = Arrays.dup(state);
		return ctl;
	}
	def doElse() {
		var c = ctl_stack.peek();
		c.else_label = null;
		// reset state to start of if
		var max = c.val_stack_top + u32.view(c.params.length);
		resetTo(max, c.reset_state);
		c.clearReset();
		if (ctl_stack.top > 1) c.reachable = ctl_stack.elems[ctl_stack.top - 2].reachable;
		else c.reachable = true;
	}
	def resetToMerge(ctl: SpcControl) {
		if (ctl.merge_count > 0) {
			var max = ctl.val_stack_top + u32.view(ctl.results.length);
			resetTo(max, ctl.merge_state);
		}
	}
	def isTransferEmpty(target: SpcControl) -> bool {
		return false; // XXX: approximate
	}
	def emitFallthru(emitSlotTransfer: ((u32, SpcAbstractVal), (u32, SpcAbstractVal)) -> void) {
		emitTransfer(ctl_stack.peek(), emitSlotTransfer);
	}
	def emitTransfer(target: SpcControl, emitSlotTransfer: ((u32, SpcAbstractVal), (u32, SpcAbstractVal)) -> void) {
		if (!ctl_stack.peek().reachable) {
			if (Trace.compiler) OUT.puts("    xfer not reachable").outln();
			return; // do nothing
		}
		if (Trace.compiler) OUT.puts("    xfer").outln();
		var vals = u32.view(target.results.length), top = target.val_stack_top, max = top + vals;
		if (target.merge_count == 0) {
			if (Trace.compiler) OUT.puts("    merge_count=1").outln();
			target.merge_count = 1;
			target.merge_state = Arrays.range(state, 0, int.view(max));
			for (i < top) {
				var from = state[i], to = toMergeVal(from);
				target.merge_state[i] = to;
				if (from != to) emitSlotTransfer((i, to), (i, from));
			}
			for (i < vals) {
				var f = (sp - vals + i), t = top + i;
				var from = state[f], to = toMergeVal(from);
				target.merge_state[t] = to;
				emitSlotTransfer((t, to), (f, from));
			}
		} else {
			if (Trace.compiler) OUT.puts("    merge_count=2+").outln();
			target.merge_count = 2;
			// XXX: allow matching constants in merges
			for (i < top) {
				var from = state[i], to = target.merge_state[i];
				if (from != to) emitSlotTransfer((i, to), (i, from));
			}
			for (i < vals) {
				var f = (sp - vals + i), t = top + i;
				var from = state[f], to = target.merge_state[t];
				// TODO: write tag based on mismatch on this stack's target slot
				emitSlotTransfer((t, to), (f, from));
			}
		}
	}
	private def toMergeVal(from: SpcAbstractVal) -> SpcAbstractVal {
		// XXX: allow constants in merges
		var force_store = if(!from.inReg(), IS_STORED);
		return SpcAbstractVal((from.flags & ~(IS_CONST)) | force_store, from.reg, 0);
	}
	private def resetTo(max: u32, nstate: Array<SpcAbstractVal>) {
		regAlloc.clear();
		for (i < max) {
			var sv = nstate[i];
			if (sv.inReg()) regAlloc.unfree(sv.reg, int.!(i));
			state[i] = sv;
		}
		sp = max;
	}
	private def pushControl(opcode: byte, params: Array<ValueType>, results: Array<ValueType>, label: MasmLabel) -> SpcControl {
		var ctl = ctl_stack.next();
		var reachable = if(ctl_stack.top > 0, ctl_stack.peek().reachable, true);
		if (ctl != null) { // FAST: reuse previous SpcControl object
			ctl_stack.top++;
			ctl.clearMerge();
			ctl.clearReset();
		} else { // allocate and cache new SpcControl object
			ctl = SpcControl.new();
			ctl_stack.push(ctl);
		}
		ctl.opcode = opcode;
		ctl.label = label;
		ctl.params = params;
		ctl.results = results;
		ctl.val_stack_top = sp - u32.view(params.length);
		ctl.reachable = reachable;
		ctl.merge_count = 0;
		return ctl;
	}
	def getControl(depth: u32) -> SpcControl {
		var result = ctl_stack.elems[ctl_stack.top - int.!(depth) - 1];
		return result;
	}
	def push(flags: byte, reg: Reg, const: int) {
		var sp = this.sp;
		if (sp >= state.length) grow(8 + state.length * 2);
		state[sp] = SpcAbstractVal(flags, reg, const);
		this.sp++;
	}
	def pushV(v: SpcAbstractVal) {
		var sp = this.sp;
		if (sp >= state.length) grow(8 + state.length * 2);
		state[sp] = v;
		this.sp++;
	}
	def get(slot: u32) -> SpcAbstractVal {
		return state[slot];
	}
	def pop() -> SpcAbstractVal {
		if (sp == 0) {
// TODO			err.at(codeptr).set("stack underflow");
			var d: SpcAbstractVal;
			return d;
		}
		var result = state[--this.sp];
		return result;
	}
	def peek() -> SpcAbstractVal {
		return state[this.sp - 1];
	}
	def overwrite(flags: byte, reg: Reg, const: int) {
		state[this.sp - 1] = SpcAbstractVal(flags, reg, const);
	}
	def set(slot: u32, flags: byte, reg: Reg, const: int) {
		state[slot] = SpcAbstractVal(flags, reg, const);
	}
	def setStored(slot: u32) {
		var b = state[slot];
		state[slot] = SpcAbstractVal(b.flags | IS_STORED, b.reg, b.const);
	}
	def setUnreachable() {
		ctl_stack.peek().reachable = false;
	}
	def setNoReg(slot: u32) {
		var b = state[slot];
		state[slot] = SpcAbstractVal(b.flags & ~IN_REG, NO_REG, b.const);
	}
	def grow(nlength: int) {
		state = Arrays.grow(state, nlength);
	}
}
def toTag(vt: ValueType) -> ValueKind {
	match (vt) {
		I32 => return ValueKind.I32;
		I64 => return ValueKind.I64;
		F32 => return ValueKind.F32;
		F64 => return ValueKind.F64;
		V128 => return ValueKind.V128;
		_ => return ValueKind.REF;
	}
}
def typeToKindFlags(vt: ValueType) -> byte {
	match (vt) {
		I32 => return KIND_I32;
		I64 => return KIND_I64;
		F32 => return KIND_F32;
		F64 => return KIND_F64;
		V128 => return KIND_V128;
		_ => return KIND_REF;
	}
}

// Specialized routines that work on i32, rather than values.
component Fold_ii_i {
	private def do_ii_z(f: (int, int) -> bool, a: int, b: int) -> int {
		return if(f(a, a), 1);
	}
	private def do_uu_z(f: (u32, u32) -> bool, a: int, b: int) -> int {
		return if(f(u32.view(a), u32.view(b)), 1);
	}
	def I32_EQ = do_ii_z(int.==, _, _);
	def I32_NE = do_ii_z(int.!=, _, _);
	def I32_LT_S = do_ii_z(int.<, _, _);
	def I32_LT_U = do_uu_z(u32.<, _, _);
	def I32_GT_S = do_ii_z(int.>, _, _);
	def I32_GT_U = do_uu_z(u32.>, _, _);
	def I32_LE_S = do_ii_z(int.<=, _, _);
	def I32_LE_U = do_uu_z(u32.<=, _, _);
	def I32_GE_S = do_ii_z(int.>=, _, _);
	def I32_GE_U = do_uu_z(u32.>=, _, _);
}

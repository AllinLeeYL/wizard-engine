// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

var config_TrackFloatZeroConst = false;
def INITIAL = 16;
def OUT = Trace.OUT;
var offsets: V3Offsets;

def getOffsets() -> V3Offsets {
	if (offsets == null) offsets = V3Offsets.new();
	return offsets;
}

// Compiles Wasm bytecode to machine code in a single pass via a MacroAssembler.
class SinglePassCompiler(masm: MacroAssembler, extensions: Extension.set, limits: Limits, module: Module) {
	def err = ErrorGen.new(module.name);
	def codeptr = Decoder.new(null, err);
	def parser = WasmParser.new(extensions, limits, module, err, codeptr);
	def instrTracer = if(Trace.compiler, InstrTracer.new());

	// Abstract state of the value stack
	def state = SpcAbstractState.new(masm.regSet, masm.regConfig);
	// Other state
	var sig: SigDecl;
	var start_pos: int;
	var opcode_pos: int;
	var success = true;

	new() {
		masm.unimplemented = unsupported;
	}

	def gen(func: FuncDecl) -> bool {
		var d = codeptr.reset(func.code.code, 0, func.code.code.length);

		start_pos = 0;
		sig = func.sig;

		// Initialize parameters, locals, and first control stack entry.
		state.reset(sig);
		initLocals();
		opcode_pos = codeptr.pos;
		var ret_label = masm.newLabel(opcode_pos);
		state.pushEntry(sig.results, ret_label);

		// Emit prologue, which allocates the frame and initializes various registers.
		emitPrologue();

		// Emit instructions.
		success = true;
		while (d.pos < d.limit) {
			emitInstr();
		}
		return success;
	}
	def emitPrologue() {
		var c = masm.regConfig, offsets = getOffsets();
		// Allocate stack frame
		masm.emit_sub_r_l(c.sp_reg, c.spcFrameSize);

		// Spill VSP
		masm.emit_mov_m_r(MasmAddr(c.sp_reg, c.vsp_offset), c.vsp_reg, RegClass.REF); // XXX: track VSP-spilled state
		// Load wf.instance and spill
		masm.emit_mov_r_m(c.instance_reg, RegClass.REF, MasmAddr(c.tmp_reg, offsets.WasmFunction_instance));
		masm.emit_mov_m_r(MasmAddr(c.sp_reg, c.instance_offset), c.instance_reg, RegClass.REF);
		// Load wf.decl and spill
		masm.emit_mov_r_m(c.func_reg, RegClass.REF, MasmAddr(c.tmp_reg, offsets.WasmFunction_decl));
		masm.emit_mov_m_r(MasmAddr(c.sp_reg, c.instance_offset), c.func_reg, RegClass.REF);
		// spill 0 for EIP, STP
		masm.emit_mov_m_l(MasmAddr(c.sp_reg, c.eip_offset), 0);
		masm.emit_mov_m_l(MasmAddr(c.sp_reg, c.stp_offset), 0);

		// Compute VFP = VSP - sig.params.length * SLOT_SIZE
		masm.emit_mov_r_r(c.vfp_reg, c.vsp_reg); // XXX: use 3-addr adjustment of VFP
		masm.emit_sub_r_l(c.vfp_reg, sig.params.length * masm.valuerep.slot_size);

		// Load instance.memories[0].start into MEM0_BASE and spill
		if (module.memories.length > 0) {
			// XXX: skip loading memory base if function doesn't access memory
			masm.emit_mov_r_m(c.mem_reg, RegClass.REF, MasmAddr(c.instance_reg, offsets.Instance_memories));
			masm.emit_mov_r_m(c.mem_reg, RegClass.REF, MasmAddr(c.mem_reg, offsets.Array_contents));
			masm.emit_mov_m_r(MasmAddr(c.sp_reg, c.mem_offset), c.mem_reg, RegClass.REF);
		} else {
			masm.emit_mov_m_l(MasmAddr(c.sp_reg, c.mem_offset), 0);
		}
	}
	def initLocals() {
		var max = limits.max_num_locals;
		var dcount = parser.readU32("local decl count", max);
		for (i < dcount) {
			var count = parser.readU32("local count", max);
			var ltype = parser.readValueType();
			state.addLocals(count, ltype);
		}
	}
	def emitInstr() {
		opcode_pos = codeptr.pos;
		var opcode = codeptr.read1();
		if (Trace.compiler) { traceStack(); traceOpcode(); }
		match (opcode) {
			Opcode.NOP.code => {
				// emit nothing
			}
			Opcode.BLOCK.code => {
				var pr = parser.readBlockType(), params = pr.0, results = pr.1;
				state.pushBlock(params, results, masm.newLabel(opcode_pos));
			}
			Opcode.LOOP.code => {
				var pr = parser.readBlockType(), params = pr.0, results = pr.1;
				state.pushLoop(params, results, masm.newLabel(opcode_pos));
				var ctl_top = state.ctl_stack.peek();
				masm.bindLabel(ctl_top.label);
			}
			Opcode.IF.code => {
				var pr = parser.readBlockType(), params = pr.0, results = pr.1;
				var t = state.pop();
				state.pushIf(params, results, masm.newLabel(opcode_pos), masm.newLabel(opcode_pos));
				var tag = t.1, st = t.2;
				var ctl_top = state.ctl_stack.peek();
				emitBrIf(st, false, ctl_top.else_label, null, true);
			}
			Opcode.ELSE.code => {
				var ctl_top = state.ctl_stack.peek();
				state.emitFallthru(masm);
				masm.emit_br(ctl_top.label);
				masm.bindLabel(ctl_top.else_label);
				state.doElse();
			}
			Opcode.END.code => {
				var ctl_top = state.ctl_stack.peek();
				if (ctl_top.opcode != Opcode.LOOP.code) {
					state.emitFallthru(masm);
					masm.bindLabel(ctl_top.label);
				}
				var ctl = state.doEnd(masm);
				if (ctl.opcode == Opcode.RETURN.code && ctl.reachable) emitReturn();
			}
			Opcode.BR.code => {
				var depth = parser.readLabel();
				var target = state.getControl(depth);
				state.emitTransfer(target, masm);
				masm.emit_br(target.label);
				var ctl = state.ctl_stack.peek();
				ctl.reachable = false;
			}
			Opcode.BR_IF.code => {
				var depth = parser.readLabel();
				var target = state.getControl(depth);
				var t = state.pop(), tag = t.1, st = t.2;
				emitBrIf(st, true, target.label, target, state.isTransferEmpty(target));
			}
			Opcode.RETURN.code => {
				var target = state.ctl_stack.elems[0];
				state.emitTransfer(target, masm);
				masm.emit_br(target.label);
				var ctl = state.ctl_stack.peek();
				ctl.reachable = false;
			}
			Opcode.DROP.code => {
				state.sp--;
			}
			Opcode.LOCAL_GET.code => {
				var index = codeptr.read_uleb32();
				var st = state.state[index];
				var tag = state.regClass[index];
				match (st) {
					Uncached => { // alloc reg and load
						var reg = allocReg(tag);
						emit_read_slot_r(index, reg);
						state.push(tag, SpcState.Register(reg));
					}
					Register(reg) => { // store + steal reg
						if (!state.stored[index]) {
							emit_write_slot_r(index, reg);
							state.stored[index] = true;
						}
						state.state[index] = SpcState.Uncached;
						state.push(tag, st);
					}
					Const(val) => { // copy constant state
						state.push(tag, st);
					}
				}
			}
			Opcode.LOCAL_SET.code => {
				var index = codeptr.read_uleb32();
				var t = state.pop(), tag = t.1, st = t.2;
				match (st) {
					Uncached => { // alloc reg and load
						var reg = allocReg(tag);
						emit_read_slot_r(state.sp, reg);
						state.state[index] = SpcState.Register(reg);
						state.stored[index] = false;
					}
					Register(reg) => { // steal reg
						state.state[index] = st;
						state.stored[index] = false;
					}
					Const(val) => { // copy constant state
						state.state[index] = st;
						state.stored[index] = false;
					}
				}
			}
			Opcode.LOCAL_TEE.code => {
				var index = codeptr.read_uleb32();
				var tos = state.sp - 1;
				var t = state.peek(), tag = t.1, st = t.2;
				match (st) {
					Uncached => { // alloc reg, load, write
						var reg = allocReg(tag);
						emit_read_slot_r(tos, reg);
						emit_write_slot_r(index, reg);
						state.state[index] = SpcState.Uncached;
						state.stored[index] = true;
						state.state[tos] = SpcState.Register(reg);
					}
					Register(reg) => { // simply write local
						emit_write_slot_r(index, reg);
						state.state[index] = SpcState.Uncached;
						state.stored[index] = true;
					}
					Const(val) => { // copy constant state
						state.state[index] = st;
						state.stored[index] = false;
					}
				}
			}
			Opcode.I32_CONST.code => {
				var val = codeptr.read_sleb32();
				state.push(RegClass.I32, SpcState.Const(val));
			}
			Opcode.I64_CONST.code => {
				var val = codeptr.read_sleb64();
				if (i32.view(val) == val) {
					state.push(RegClass.I64, SpcState.Const(i32.view(val)));
				} else {
					var tos = state.sp;
					var addr = masm.slotAddr(tos);
					masm.emit_mov_m_i(addr, int.view(val));
					masm.emit_mov_m_i(addr.plus(4), int.view(val >> 32));
					state.push(RegClass.I64, SpcState.Uncached); // XXX: load i64 constants into reg
					state.stored[tos] = true;
				}
			}
			Opcode.F32_CONST.code => {
				var val = codeptr.read_u32();
				if (val == 0 && config_TrackFloatZeroConst) {
					state.push(RegClass.F32, SpcState.Const(0));
				} else {
					var tos = state.sp;
					masm.emit_mov_m_i(masm.slotAddr(tos), int.view(val));
					state.push(RegClass.F32, SpcState.Uncached); // XXX: load f32 constants into reg
					state.stored[tos] = true;
				}
			}
			Opcode.F64_CONST.code => {
				var val = codeptr.read_u64();
				if (val == 0 && config_TrackFloatZeroConst) {
					state.push(RegClass.F64, SpcState.Const(0));
				} else {
					var tos = state.sp;
					var addr = masm.slotAddr(tos);
					masm.emit_mov_m_i(addr, int.view(val));
					masm.emit_mov_m_i(addr.plus(4), int.view(val >> 32));
					state.push(RegClass.F64, SpcState.Uncached); // XXX: load f64 constants into reg
					state.stored[tos] = true;
				}
			}
			Opcode.I32_ADD.code 	=> emitCommutable(Opcode.I32_ADD, isZero, int.+);
			Opcode.I32_SUB.code 	=> emitBinopNoCommute(Opcode.I32_SUB, isZero, int.-);
			Opcode.I32_MUL.code 	=> emitCommutable(Opcode.I32_MUL, isOne, int.*);
			Opcode.I32_DIV_S.code 	=> emitBinopNoFold(Opcode.I32_DIV_S, isOne);
			Opcode.I32_DIV_U.code 	=> emitBinopNoFold(Opcode.I32_DIV_U, isOne);
			Opcode.I32_REM_S.code 	=> emitBinopNoFold(Opcode.I32_REM_S, isNeverNop);
			Opcode.I32_REM_U.code 	=> emitBinopNoFold(Opcode.I32_REM_U, isMinusOne);
			Opcode.I32_AND.code 	=> emitCommutable(Opcode.I32_AND, isMinusOne, int.&);
			Opcode.I32_XOR.code 	=> emitCommutable(Opcode.I32_XOR, isZero, int.^);
			Opcode.I32_OR.code 	=> emitCommutable(Opcode.I32_OR, isZero, int.|);
			Opcode.I32_SHL.code 	=> emitBinop(Opcode.I32_SHL, isZero, Opcode.UNREACHABLE, Execute.I32_SHL);
			Opcode.I32_SHR_S.code 	=> emitBinop(Opcode.I32_SHR_S, isZero, Opcode.UNREACHABLE, Execute.I32_SHR_S);
			Opcode.I32_SHR_U.code 	=> emitBinop(Opcode.I32_SHR_U, isZero, Opcode.UNREACHABLE, Execute.I32_SHR_U);
			Opcode.I32_ROTL.code 	=> emitBinopNoFold(Opcode.I32_ROTL, isZero);
			Opcode.I32_ROTR.code 	=> emitBinopNoFold(Opcode.I32_ROTR, isZero);
			Opcode.I32_EQ.code 	=> emitBinop(Opcode.I32_EQ, isNeverNop, Opcode.I32_EQ, Fold_ii_i.I32_EQ);
			Opcode.I32_NE.code 	=> emitBinop(Opcode.I32_NE, isNeverNop, Opcode.I32_NE, Fold_ii_i.I32_NE);
			Opcode.I32_LT_S.code 	=> emitBinop(Opcode.I32_LT_S, isNeverNop, Opcode.I32_GT_S, Fold_ii_i.I32_LT_S);
			Opcode.I32_LT_U.code 	=> emitBinop(Opcode.I32_LT_U, isNeverNop, Opcode.I32_GT_U, Fold_ii_i.I32_LT_U);
			Opcode.I32_GT_S.code 	=> emitBinop(Opcode.I32_GT_S, isNeverNop, Opcode.I32_LT_S, Fold_ii_i.I32_GT_S);
			Opcode.I32_GT_U.code 	=> emitBinop(Opcode.I32_GT_U, isNeverNop, Opcode.I32_LT_U, Fold_ii_i.I32_GT_U);
			Opcode.I32_LE_S.code 	=> emitBinop(Opcode.I32_LE_S, isNeverNop, Opcode.I32_GE_S, Fold_ii_i.I32_LE_S);
			Opcode.I32_LE_U.code 	=> emitBinop(Opcode.I32_LE_U, isNeverNop, Opcode.I32_GE_U, Fold_ii_i.I32_LE_U);
			Opcode.I32_GE_S.code 	=> emitBinop(Opcode.I32_GE_S, isNeverNop, Opcode.I32_LE_S, Fold_ii_i.I32_GE_S);
			Opcode.I32_GE_U.code 	=> emitBinop(Opcode.I32_GE_U, isNeverNop, Opcode.I32_LE_U, Fold_ii_i.I32_GE_U);

			Opcode.I64_ADD.code 	=> emitBinop(Opcode.I64_ADD, isZero, Opcode.I64_ADD, noFold);
			Opcode.I64_SUB.code 	=> emitBinop(Opcode.I64_SUB, isZero, Opcode.I64_SUB, noFold);
			Opcode.I64_MUL.code 	=> emitBinop(Opcode.I64_MUL, isOne, Opcode.I64_MUL, noFold);
			Opcode.I64_DIV_S.code 	=> emitBinop(Opcode.I64_DIV_S, isOne, Opcode.UNREACHABLE, noFold);
			Opcode.I64_DIV_U.code 	=> emitBinop(Opcode.I64_DIV_U, isOne, Opcode.UNREACHABLE, noFold);
			Opcode.I64_REM_S.code 	=> emitBinop(Opcode.I64_REM_S, isNeverNop, Opcode.UNREACHABLE, noFold);
			Opcode.I64_REM_U.code 	=> emitBinop(Opcode.I64_REM_U, isMinusOne, Opcode.UNREACHABLE, noFold);
			Opcode.I64_AND.code 	=> emitBinop(Opcode.I64_AND, isMinusOne, Opcode.I64_AND, noFold);
			Opcode.I64_XOR.code 	=> emitBinop(Opcode.I64_XOR, isZero, Opcode.I64_XOR, noFold);
			Opcode.I64_OR.code 	=> emitBinop(Opcode.I64_OR, isZero, Opcode.I64_OR, noFold);
			Opcode.I64_SHL.code 	=> emitBinop(Opcode.I64_SHL, isNeverNop, Opcode.UNREACHABLE, noFold);
			Opcode.I64_SHR_S.code 	=> emitBinop(Opcode.I64_SHR_S, isNeverNop, Opcode.UNREACHABLE, noFold);
			Opcode.I64_SHR_U.code 	=> emitBinop(Opcode.I64_SHR_U, isNeverNop, Opcode.UNREACHABLE, noFold);
			Opcode.I64_ROTL.code 	=> emitBinop(Opcode.I64_ROTL, isNeverNop, Opcode.UNREACHABLE, noFold);
			Opcode.I64_ROTR.code 	=> emitBinop(Opcode.I64_ROTR, isNeverNop, Opcode.UNREACHABLE, noFold);
			Opcode.I64_EQ.code 	=> emitBinop(Opcode.I64_EQ, isNeverNop, Opcode.I64_EQ, noFold);
			Opcode.I64_NE.code 	=> emitBinop(Opcode.I64_NE, isNeverNop, Opcode.I64_NE, noFold);
			Opcode.I64_LT_S.code 	=> emitBinop(Opcode.I64_LT_S, isNeverNop, Opcode.I64_GT_S, noFold);
			Opcode.I64_LT_U.code 	=> emitBinop(Opcode.I64_LT_U, isNeverNop, Opcode.I64_GT_U, noFold);
			Opcode.I64_GT_S.code 	=> emitBinop(Opcode.I64_GT_S, isNeverNop, Opcode.I64_LT_S, noFold);
			Opcode.I64_GT_U.code 	=> emitBinop(Opcode.I64_GT_U, isNeverNop, Opcode.I64_LT_U, noFold);
			Opcode.I64_LE_S.code 	=> emitBinop(Opcode.I64_LE_S, isNeverNop, Opcode.I64_GE_S, noFold);
			Opcode.I64_LE_U.code 	=> emitBinop(Opcode.I64_LE_U, isNeverNop, Opcode.I64_GE_U, noFold);
			Opcode.I64_GE_S.code 	=> emitBinop(Opcode.I64_GE_S, isNeverNop, Opcode.I64_LE_S, noFold);
			Opcode.I64_GE_U.code 	=> emitBinop(Opcode.I64_GE_U, isNeverNop, Opcode.I64_LE_U, noFold);
			_ => unsupported();
		}
	}
	def emitBrIf(st: SpcState, nonzero: bool, label: MasmLabel, target: SpcControl, emptyTransfer: bool) {
		match (st) {
			Uncached => {
				if (emptyTransfer) {
					masm.emit_br_m(masm.slotAddr(state.sp), nonzero, label);
				} else {
					var skip = masm.newLabel(opcode_pos);
					masm.emit_br_m(masm.slotAddr(state.sp), !nonzero, skip);
					state.emitTransfer(target, masm);
					masm.emit_br(label);
					masm.bindLabel(skip);
				}
			}
			Register(reg) => {
				if (emptyTransfer) {
					masm.emit_br_r(reg.reg, nonzero, label);
				} else {
					var skip = masm.newLabel(opcode_pos);
					masm.emit_br_r(reg.reg, !nonzero, skip);
					state.emitTransfer(target, masm);
					masm.emit_br(label);
					masm.bindLabel(skip);
				}
			}
			Const(val) => {
				if (val != 0) {
					state.emitTransfer(target, masm);
					masm.emit_br(target.label);
				}
				// fall through
			}
		}
	}
	def emitReturn() {
		var c = masm.regConfig;
		var len = sig.results.length;
		// Copy values back to VSP
		for (i = len - 1; i >= 0; i--) {
			var index = u32.view(i);
			var t = state.pop(), tag = t.1, st = t.2;
			var slot = masm.slotAddr(index);
			match (st) {
				Uncached => { // alloc reg, load, store
					var reg = allocReg(tag);
					emit_read_slot_r(state.sp, reg);
					masm.emit_mov_m_r(slot, reg.reg, reg.regClass);
				}
				Register(reg) => { // store
					masm.emit_mov_m_r(slot, reg.reg, reg.regClass);
				}
				Const(val) => { // store immediate
					masm.emit_mov_m_l(slot, val);
				}
			}
			// Update the slot's tag byte if necessary
			var rtag = toTag(sig.results[i]);
			if (masm.valuerep.tagged && !state.tagged[i] || state.regClass[i] != rtag) {
				masm.emit_mov_m_i(masm.tagAddr(index), rtag.code);
			}
		}
		// Compute VSP = VFP + sig.resultslength
		masm.emit_mov_r_r(c.vsp_reg, c.vfp_reg); // XXX: use 3-addr adjustment of VSP
		masm.emit_add_r_l(c.vsp_reg, sig.results.length * masm.valuerep.slot_size);
		// Deallocate stack frame
		masm.emit_add_r_l(c.sp_reg, c.spcFrameSize);
		// Return to caller
		masm.emit_ret();
	}
	def emitTransfer(target: SpcControl) {
		emit_store_all(target.val_stack_top, true); // XXX uncaching everything first
		var arity = u32.view(labelArgs(target).length);
		if (state.sp == target.val_stack_top + arity) return; // stack height match
		var from = state.sp - arity, to = target.val_stack_top;
		while (from < state.sp) {
			match (state.state[from]) {
				Uncached => {
					masm.emit_mov_s_s(to, from, state.regClass[to]);
				}
				Register(reg_b) => {
					masm.emit_mov_s_r(to, reg_b.reg, reg_b.regClass);
				}
				Const(val_b) => {
					masm.emit_mov_s_i(to, val_b);
				}
			}
			if (!state.tagged[from]) emit_write_slot_tag(to, state.regClass[to]);
			from++;
			to++;
		}
	}
	def emitBinopNoFold(op: Opcode, isNop: int -> bool) {
		return emitBinop(op, isNop, Opcode.UNREACHABLE, null);
	}
	def emitBinopNoCommute(op: Opcode, isNop: int -> bool, fold: (int, int) -> int) {
		return emitBinop(op, isNop, Opcode.UNREACHABLE, fold);
	}
	def emitCommutable(op: Opcode, isNop: int -> bool, fold: (int, int) -> int) {
		return emitBinop(op, isNop, op, fold);
	}
	def emitBinop(op: Opcode, isNop: int -> bool, commute_op: Opcode, fold: (int, int) -> int) {
		var b = state.pop();
		var a = state.peek();
		var tos = u32.!(state.sp - 1);
		match (a.2) {
			Uncached => match (b.2) {
				Uncached => {
					var reg_a = allocReg(RegClass.I32);
					emit_read_slot_r(tos, reg_a);
					masm.emit_binop_r_m(op, reg_a.reg, masm.slotAddr(tos+1));
					state.state[tos] = SpcState.Register(reg_a);
					state.stored[tos] = false;
				}
				Register(reg_b) => {
					var reg_a = allocReg(RegClass.I32);
					emit_read_slot_r(tos, reg_a);
					masm.emit_binop_r_r(op, reg_a.reg, reg_b.reg);
					state.state[tos] = SpcState.Register(reg_a);
					freeReg(reg_b);
					state.stored[tos] = false;
				}
				Const(val_b) => {
					if (isNop != null && isNop(val_b)) return;
					var reg_a = allocReg(RegClass.I32);
					emit_read_slot_r(tos, reg_a);
					masm.emit_binop_r_i(op, reg_a.reg, val_b);
					state.state[tos] = SpcState.Register(reg_a);
					state.stored[tos] = false;
				}
			}
			Register(reg_a) => match (b.2) {
				Uncached => {
					masm.emit_binop_r_m(op, reg_a.reg, masm.slotAddr(tos+1));
					state.stored[tos] = false;
				}
				Register(reg_b) => {
					masm.emit_binop_r_r(op, reg_a.reg, reg_b.reg);
					freeReg(reg_b);
					state.stored[tos] = false;
				}
				Const(val_b) => {
					if (isNop != null && isNop(val_b)) return;
					masm.emit_binop_r_i(op, reg_a.reg, val_b);
					state.stored[tos] = false;
				}
			}
			Const(val_a) => if (isNop != null && !isNop(val_a)) match (b.2) {
				Uncached => {
					var reg_a = allocReg(RegClass.I32);
					emit_read_slot_r(tos+1, reg_a);
					masm.emit_binop_r_i(op, reg_a.reg, val_a);
					state.state[tos] = SpcState.Register(reg_a);
					state.stored[tos] = false;
				}
				Register(reg_b) => {
					if (commute_op != Opcode.UNREACHABLE) {
						masm.emit_binop_r_i(commute_op, reg_b.reg, val_a); // commuted
					} else {
						var reg_a = allocReg(RegClass.I32);
						masm.emit_mov_r_i(reg_a.reg, val_a);
						masm.emit_binop_r_r(op, reg_a.reg, reg_b.reg);
						freeReg(reg_b);
						state.state[tos] = SpcState.Register(reg_a);
					}
					state.stored[tos] = false;
				}
				Const(val_b) => {
					if (fold != null) {
						state.state[tos] = SpcState.Const(fold(val_a, val_b)); // constant fold
					} else {
						var reg_a = allocReg(RegClass.I32);
						masm.emit_mov_r_i(reg_a.reg, val_a);
						masm.emit_binop_r_i(op, reg_a.reg, val_b);
						state.state[tos] = SpcState.Register(reg_a);
					}
					state.stored[tos] = false;
				}
			}
		}
	}
	def unsupported() {
		success = false; // XXX: add opcode
		codeptr.atl(codeptr.pos, codeptr.pos); // set limit to break out of loop
	}

	//====================================================================
	// codegen operations
	//====================================================================
	def emit_read_slot_r(slot: u32, reg: SpcReg) {
		masm.emit_mov_r_s(reg.reg, reg.regClass, slot);
	}
	def emit_read_tos_r(reg: SpcReg) {
		masm.emit_mov_r_s(reg.reg, reg.regClass, state.sp - 1);
	}
	def emit_write_tos_tag(tag: RegClass) {
		if (masm.valuerep.tagged) {
			masm.emit_mov_m_i(masm.tagAddr(state.sp - 1), tag.code);
		}
	}
	def emit_write_slot_tag(slot: u32, tag: RegClass) {
		if (masm.valuerep.tagged) {
			masm.emit_mov_m_i(masm.tagAddr(slot), tag.code);
		}
	}
	def emit_write_slot_r(slot: u32, reg: SpcReg) {
		masm.emit_mov_s_r(slot, reg.reg, reg.regClass);
	}
	def emit_write_slot_i(slot: u32, val: int, tag: RegClass) {
		masm.emit_mov_s_i(slot, val);
	}
	def emit_store_all(limit: u32, uncache: bool) {
		for (i < limit) {
			if (!state.tagged[i]) emit_write_slot_tag(i, state.regClass[i]);
			if (state.stored[i]) continue; // nothing to do
			var t = state.state[i];
			match (t) {
				Uncached => ; // nothing to do
				Register(reg) => {
					emit_write_slot_r(i, reg);
					if (uncache) {
						state.state[i] = SpcState.Uncached;
						freeReg(reg);
					}
				}
				Const(val) => {
					emit_write_slot_i(i, val, state.regClass[i]);
				}
			}
			state.stored[i] = true;
		}
	}
	def uncache_all(limit: u32) {
		for (i < limit) {
			var t = state.state[i];
			match (t) {
				Register(reg) => {
					state.state[i] = SpcState.Uncached;
					freeReg(reg);
				}
				_ => ;
			}
		}
	}


	//====================================================================
	// register allocation operations
	//====================================================================
	def freeReg(reg: SpcReg) {
		return masm.regSet.pools[reg.regClass.tag].free(reg.reg);
	}
	def allocReg(regClass: RegClass) -> SpcReg {
		var reg = masm.regSet.pools[regClass.tag].alloc(0);
		return SpcReg(reg, regClass);
	}

	//====================================================================
	// abstract stack operations
	//====================================================================
	def labelArgs(ctl: SpcControl) -> Array<ValueType> {
		if (ctl.opcode == Opcode.LOOP.code) return ctl.params;
		else return ctl.results;
	}
	def traceOpcode() {
		OUT.put2("  %x(+%d): ", opcode_pos, opcode_pos - start_pos);
		var prev = codeptr.pos;
		codeptr.at(opcode_pos);
		instrTracer.putInstr(OUT, module, codeptr);
		codeptr.at(prev);
		OUT.outln();
	}
	def traceStack() {
		OUT.put1("sp=%d ", state.sp);
		for (i < state.sp) {
			OUT.put3("[%s %s%s: ",
				state.regClass[i].name,
				if(state.tagged[i], "T", ""),
				if(state.stored[i], "S", ""));
			match (state.state[i]) {
				Uncached => OUT.puts("uncached");
				Register(reg) => OUT.put1("@%s", masm.regSet.getName(reg.reg));
				Const(val) => OUT.put1("#%d", val);
			}
			OUT.puts("]");
		}
		OUT.outln();
	}
}

// States in which a local slot or operand stack slot could be in.
type SpcState {
	case Uncached;
	case Register(reg: SpcReg);
	case Const(val: int);
}

type SpcReg(reg: Reg, regClass: RegClass) #unboxed { }

// An entry in the abstract control stack.
class SpcControl {
	var opcode: byte;
	var params: Array<ValueType>;
	var results: Array<ValueType>;
	var reachable = true;
	var val_stack_top: u32;
	var label: MasmLabel;
	var else_label: MasmLabel;
}

def isNeverNop: int -> bool = null;
def noFold: (int, int) -> int = null;
def isZero = int.==(0, _);
def isOne = int.==(1, _);
def isMinusOne = int.==(-1, _);
def to_ii_i(f: (u32, u32) -> u32, a: int, b: int) -> int {
	return int.view(f(u32.view(a), u32.view(b)));
}
def I32_ROTL = to_ii_i(Execute.I32_ROTL, _, _);
def I32_ROTR = to_ii_i(Execute.I32_ROTR, _, _);

// Contains both the abstract control and abstract value stack.
class SpcAbstractState(regSet: RegSet, regConfig: RegConfig) {
	// Abstract state of the value stack
	var state = Array<SpcState>.new(INITIAL);	// uncached, in a register, or a constant
	var tagged = Array<bool>.new(INITIAL);	// tag is written properly into memory
	var stored = Array<bool>.new(INITIAL);	// value is written into memory
	var regClass = Array<RegClass>.new(INITIAL);	// type of the slot
	var sp: u32;
	var ctl_stack = ArrayStack<SpcControl>.new();

	// Reset the state for starting a new function.
	def reset(sig: SigDecl) {
		sp = 0;
		ctl_stack.clear();
		for (p in regConfig.regSet.pools) p.reset();
		// initialize parameters
		var params = sig.params;
		grow(params.length);
		for (i < params.length) {
			state[i] = SpcState.Uncached;
			tagged[i] = true;
			stored[i] = true;
			regClass[i] = toTag(params[i]);
		}
		sp = u32.view(params.length);
	}
	// Add the specified number of locals of the specified type.
	def addLocals(count: u32, ltype: ValueType) {
		var nlength = sp + count;
		if (nlength > state.length) grow(int.view(nlength + sp * 2));
		for (j < count) {
			var k = j + sp;
			state[k] = SpcState.Const(0); // TODO: use default
			tagged[k] = false;
			stored[k] = false;
			regClass[k] = toTag(ltype);
		}
		sp = nlength;
	}
	def pushEntry(results: Array<ValueType>, ret_label: MasmLabel) -> SpcControl {
		return pushControl(Opcode.RETURN.code, ValueTypes.NONE, results, ret_label);
	}
	def pushBlock(params: Array<ValueType>, results: Array<ValueType>, end_label: MasmLabel) -> SpcControl {
		return pushControl(Opcode.BLOCK.code, params, results, end_label);
	}
	def pushLoop(params: Array<ValueType>, results: Array<ValueType>, start_label: MasmLabel) -> SpcControl {
		var ctl = pushControl(Opcode.LOOP.code, params, results, start_label);
		saveStackAtStart(ctl);
		return ctl;
	}
	def pushIf(params: Array<ValueType>, results: Array<ValueType>, else_label: MasmLabel, end_label: MasmLabel) -> SpcControl {
		var ctl = pushControl(Opcode.LOOP.code, params, results, end_label);
		ctl.else_label = else_label;
		return ctl;
	}
	def doElse() {
		// TODO: reset stack to start of if
		var ctl_top = ctl_stack.peek();
		ctl_top.else_label = null;
	}
	def doEnd(masm: MacroAssembler) -> SpcControl {
		// TODO: reset stack to merge
		return ctl_stack.pop();
	}
	def popControl() {
		ctl_stack.pop();
	}
	def isTransferEmpty(target: SpcControl) -> bool {
		return false;
	}
	def emitTransfer(target: SpcControl, masm: MacroAssembler) {
		// TODO: recognize transfers to opcode == RETURN, don't bother storing anything but results
	}
	def emitFallthru(masm: MacroAssembler) {
	}
	private def saveStackAtStart(ctl: SpcControl) {
//		emit_store_all(ctl.val_stack_top, false); // XXX: actually save instead
	}
	private def resetStackToStart(ctl: SpcControl) {
		sp = ctl.val_stack_top; // TODO: set uncached, tagged, etc
	}
	private def pushControl(opcode: byte, params: Array<ValueType>, results: Array<ValueType>, label: MasmLabel) -> SpcControl {
		var ctl = ctl_stack.next();
		if (ctl != null) { // FAST: reuse previous SpcControl object
			ctl_stack.top++;
		} else { // allocate and cache new SpcControl object
			ctl = SpcControl.new();
			ctl_stack.push(ctl);
		}
		ctl.opcode = opcode;
		ctl.label = label;
		ctl.params = params;
		ctl.results = results;
		ctl.val_stack_top = sp - u32.view(params.length);
		ctl.reachable = true;
		return ctl;
	}
	def getControl(depth: u32) -> SpcControl {
		var result = ctl_stack.elems[ctl_stack.top - int.!(depth) - 1];
		return result;
	}
	def push(tag: RegClass, st: SpcState) {
		var sp = this.sp;
		if (sp >= state.length) grow(8 + state.length * 2);
		tagged[sp] = false;
		stored[sp] = false;
		regClass[sp] = tag;
		state[sp] = st;
		this.sp++;
	}
	def pop() -> (bool, RegClass, SpcState) {
		if (sp == 0) {
// TODO			err.at(codeptr).set("stack underflow");
			return (false, RegClass.I32, SpcState.Uncached);
		}
		var sp = this.sp - 1;
		var result = (stored[sp], regClass[sp], state[sp]);
		this.sp = sp;
		return result;
	}
	def peek() -> (bool, RegClass, SpcState) {
		var sp = sp - 1;
		return (stored[sp], regClass[sp], state[sp]);
	}
	def grow(nlength: int) {
		state = Arrays.grow(state, nlength);
		tagged = Arrays.grow(tagged, nlength);
		stored = Arrays.grow(stored, nlength);
		regClass = Arrays.grow(regClass, nlength);
	}
	def prepareForLoop(limit: u32) {
// TODO		emit_store_all(limit, true);
		for (i < limit) {
			var t = state[i];
			match (t) {
				Const(val) => state[i] = SpcState.Uncached;
				_ => ;
			}
		}
	}
}
def toTag(vt: ValueType) -> RegClass {
	match (vt) {
		I32 => return RegClass.I32;
		I64 => return RegClass.I64;
		F32 => return RegClass.F32;
		F64 => return RegClass.F64;
		V128 => return RegClass.V128;
		_ => return RegClass.REF;
	}
}

// Specialized routines that work on i32, rather than values.
component Fold_ii_i {
	private def do_ii_z(f: (int, int) -> bool, a: int, b: int) -> int {
		return if(f(a, a), 1);
	}
	private def do_uu_z(f: (u32, u32) -> bool, a: int, b: int) -> int {
		return if(f(u32.view(a), u32.view(b)), 1);
	}
	def I32_EQ = do_ii_z(int.==, _, _);
	def I32_NE = do_ii_z(int.!=, _, _);
	def I32_LT_S = do_ii_z(int.<, _, _);
	def I32_LT_U = do_uu_z(u32.<, _, _);
	def I32_GT_S = do_ii_z(int.>, _, _);
	def I32_GT_U = do_uu_z(u32.>, _, _);
	def I32_LE_S = do_ii_z(int.<=, _, _);
	def I32_LE_U = do_uu_z(u32.<=, _, _);
	def I32_GE_S = do_ii_z(int.>=, _, _);
	def I32_GE_U = do_uu_z(u32.>=, _, _);
}

// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

var config_TrackFloatZeroConst = false;
def INITIAL = 16;
def OUT = Trace.OUT;

// TODO: unreachable
// TODO: traps in JIT code
// Compiles Wasm bytecode to machine code in a single pass via a MacroAssembler.
class SinglePassCompiler(masm: MacroAssembler, extensions: Extension.set, limits: Limits, module: Module) {
	def err = ErrorGen.new(module.name);
	def codeptr = CodePtr.new(null);
	def parser = WasmParser.new(extensions, limits, module, err, codeptr);
	def instrTracer = if(Trace.compiler, InstrTracer.new());
	def regs = masm.regAlloc.regConfig.regs;

	// Abstract state of the value stack
	def state = SpcAbstractState.new(masm.regAlloc);
	// Other state
	var sig: SigDecl;
	var start_pos: int;
	var opcode_pos: int;
	var success = true;
	var trap_label: MasmLabel;
	var unwind_label: MasmLabel;

	new() {
		masm.unimplemented = unsupported;
		var c = masm.regAlloc.regConfig;
		masm.scratchStackSlot1 = c.eip_offset;
		masm.scratchStackSlot2 = c.stp_offset;
	}

	def gen(func: FuncDecl) -> bool {
		if (Trace.compiler) OUT.put1("==== begin compile: %q ========================", func.render(module.names, _)).outln();
		var d = codeptr.reset(func.cur_bytecode, 0, func.cur_bytecode.length);

		start_pos = 0;
		sig = func.sig;
		trap_label = null;
		unwind_label = null;

		// Initialize parameters, locals, and first control stack entry.
		var ret_label = masm.newLabel(func.cur_bytecode.length);
		state.reset(sig, ret_label);
		initLocals();
		opcode_pos = codeptr.pos;

		// Emit prologue, which allocates the frame and initializes various registers.
		emitPrologue();

		// Emit instructions.
		success = true;
		while (d.pos < d.limit) {
			emitInstr();
		}
		// Emit epilogue
		if (trap_label != null) emitTrapEpilogue();
		return success;
	}
	def emitPrologue() {
		var c = masm.regAlloc.regConfig;

		var offsets = masm.getOffsets();
		// Allocate stack frame
		masm.emit_sub_r_l(regs.sp, c.spcFrameSize);

		// Spill VSP
		masm.emit_mov_m_r(MasmAddr(regs.sp, c.vsp_offset), regs.vsp, ValueKind.REF); // XXX: track VSP-spilled state
		// Load wf.instance and spill
		masm.emit_mov_r_m(regs.instance, ValueKind.REF, MasmAddr(regs.func_arg, offsets.WasmFunction_instance));
		masm.emit_mov_m_r(MasmAddr(regs.sp, c.instance_offset), regs.instance, ValueKind.REF);
		// Load wf.decl and spill
		masm.emit_mov_r_m(regs.func, ValueKind.REF, MasmAddr(regs.func_arg, offsets.WasmFunction_decl));
		masm.emit_mov_m_r(MasmAddr(regs.sp, c.func_decl_offset), regs.func, ValueKind.REF);

		// Compute VFP = VSP - sig.params.length * SLOT_SIZE
		masm.emit_mov_r_r(regs.vfp, regs.vsp); // XXX: use 3-addr adjustment of VFP
		masm.emit_sub_r_l(regs.vfp, sig.params.length * masm.valuerep.slot_size);
		// XXX: skip spilling of VFP
		masm.emit_mov_m_r(MasmAddr(regs.sp, c.vfp_offset), regs.vfp, ValueKind.REF);

		// Load instance.memories[0].start into MEM0_BASE and spill
		if (module.memories.length > 0) {
			// XXX: skip loading memory base if function doesn't access memory
			masm.emit_mov_r_m(regs.mem0, ValueKind.REF, MasmAddr(regs.instance, offsets.Instance_memories));
			masm.emit_read_v3_array_r_i(regs.mem0, regs.mem0, 0, ValueKind.REF);
			masm.emit_read_v3_mem_base(regs.mem0, regs.mem0);
			masm.emit_mov_m_r(MasmAddr(regs.sp, c.mem_offset), regs.mem0, ValueKind.REF);
		}
	}
	def initLocals() {
		var max = limits.max_num_locals;
		var dcount = parser.readU32("local decl count", max);
		for (i < dcount) {
			var count = parser.readU32("local count", max);
			var ltype = parser.readValueType();
			state.addLocals(count, ltype);
		}
		state.num_locals = u16.!(state.sp);
	}
	def emitInstr() {
		opcode_pos = codeptr.pos;
		var opcode = codeptr.read_opcode();
		if (Trace.compiler) { traceStack(); traceOpcode(); }
		match (opcode) {
			UNREACHABLE => {
				emitTrap(TrapReason.UNREACHABLE);
				state.setUnreachable();
			}
			NOP => {
				// emit nothing
			}
			BLOCK => {
				var pr = parser.readBlockType(), params = pr.0, results = pr.1;
				state.pushBlock(params, results, masm.newLabel(opcode_pos));
			}
			LOOP => {
				var pr = parser.readBlockType(), params = pr.0, results = pr.1;
				state.pushLoop(params, results, masm.newLabel(opcode_pos));
				var ctl_top = state.ctl_stack.peek();
				state.prepareLoop(emitSlotTransfer);
				masm.bindLabel(ctl_top.label);
			}
			IF => {
				var pr = parser.readBlockType(), params = pr.0, results = pr.1;
				var sv = state.pop();
				state.pushIf(params, results, masm.newLabel(opcode_pos), masm.newLabel(opcode_pos));
				var ctl_top = state.ctl_stack.peek();
				emitBrIf(sv, MasmBrCond.I32_ZERO, ctl_top.else_label, null, true);
			}
			ELSE => {
				var ctl_top = state.ctl_stack.peek();
				state.emitFallthru(emitSlotTransfer);
				masm.emit_br(ctl_top.label);
				masm.bindLabel(ctl_top.else_label);
				state.doElse();
				ctl_top.opcode = Opcode.ELSE.code;
			}
			END => {
				var ctl_top = state.ctl_stack.peek();
				if (ctl_top.opcode == Opcode.LOOP.code) {
					state.ctl_stack.pop();
					state.ctl_stack.peek().reachable = ctl_top.reachable;
				} else if (ctl_top.opcode == Opcode.IF.code) {
					// simulate empty if-true block
					state.emitFallthru(emitSlotTransfer);
					masm.emit_br(ctl_top.label);
					masm.bindLabel(ctl_top.else_label);
					state.doElse();
					ctl_top.opcode = Opcode.ELSE.code;
					state.emitFallthru(emitSlotTransfer);
					masm.bindLabel(ctl_top.label);
					state.resetToMerge(ctl_top);
					state.ctl_stack.pop();
				} else if (ctl_top.opcode == Opcode.BLOCK.code || ctl_top.opcode == Opcode.ELSE.code) {
					state.emitFallthru(emitSlotTransfer);
					masm.bindLabel(ctl_top.label);
					state.resetToMerge(ctl_top);
					state.ctl_stack.pop();
				} else if (ctl_top.opcode == Opcode.RETURN.code) {
					state.emitFallthru(emitSlotTransfer);
					masm.bindLabel(ctl_top.label);
					if (ctl_top.merge_count > 1) emitReturn(ctl_top);
					state.ctl_stack.pop();
				}
			}
			BR => {
				var depth = parser.readLabel();
				var target = state.getControl(depth);
				state.emitTransfer(target, emitSlotTransfer);
				masm.emit_br(target.label);
				state.setUnreachable();
			}
			BR_IF => {
				var depth = parser.readLabel();
				var target = state.getControl(depth);
				var sv = state.pop();
				emitBrIf(sv, MasmBrCond.I32_NONZERO, target.label, target, state.isTransferEmpty(target));
			}
			BR_ON_NULL => {
				var depth = parser.readLabel();
				var target = state.getControl(depth);
				var sv = state.pop();
				emitBrIf(sv, MasmBrCond.REF_NULL, target.label, target, state.isTransferEmpty(target));
			}
			BR_ON_NON_NULL => {
				var depth = parser.readLabel();
				var target = state.getControl(depth);
				var sv = state.pop();
				emitBrIf(sv, MasmBrCond.REF_NONNULL, target.label, target, state.isTransferEmpty(target));
			}
			BR_TABLE => {
				var depths = parser.readLabels();
				var sv = state.pop();
				emitBrTable(sv, depths);
				state.setUnreachable();
			}
			RETURN => {
				var target = state.ctl_stack.elems[0];
				state.emitTransfer(target, emitSlotTransfer);
				masm.emit_br(target.label);
				state.setUnreachable();
			}
			CALL => {
				var func = parser.readFuncRef();
				var offsets = masm.getOffsets();
				var retpt = masm.newLabel(opcode_pos), wasmcall_label = masm.newLabel(opcode_pos);
				state.emitSpill(emitSlotTransfer);
				var c = masm.regAlloc.regConfig;
				masm.emit_mov_r_m(regs.instance, ValueKind.REF, MasmAddr(regs.sp, c.instance_offset));
				// XXX: skip loading the target function for direct intra-module calls?
				masm.emit_mov_r_m(regs.func_arg, ValueKind.REF, MasmAddr(regs.instance, offsets.Instance_functions));
				masm.emit_read_v3_array_r_i(regs.func_arg, regs.func_arg, func.func_index, ValueKind.REF);

				emit_compute_vsp(state.sp);

				var tmp = regs.ip; // TODO: more robust register choice for indirect call
				if (func.imp != null) {
					// call to imported function must first check for WasmFunction
					masm.emit_mov_r_m(tmp, ValueKind.I32, MasmAddr(regs.func_arg, 0));
					masm.emit_breq_r_i(tmp, offsets.WasmFunction_typeId, wasmcall_label);
					masm.emit_write_runtime_vsp(regs.vsp);
					masm.emit_mov_r_r(regs.runtime_arg_0, regs.func_arg);
					masm.emit_call_runtime_callHost(regs.func_arg);
					masm.emit_br(retpt);
				}
				masm.bindLabel(wasmcall_label);
				masm.emit_mov_r_m(tmp, ValueKind.REF, MasmAddr(regs.func_arg, offsets.WasmFunction_decl));
				masm.emit_mov_r_m(tmp, ValueKind.REF, MasmAddr(tmp, offsets.FuncDecl_target_code));
				masm.emit_call_r(tmp);
				masm.bindLabel(retpt);
				emit_unwind_check();
				emit_reload_regs();

				state.popArgsAndPushResults(func.sig);
			}
			CALL_INDIRECT => {
				var sig = parser.readSigRef();
				var offsets = masm.getOffsets();
				var table_index = codeptr.read_uleb32();
				var sv = state.pop();
				var retpt = masm.newLabel(opcode_pos), wasmcall_label = masm.newLabel(opcode_pos);
				state.emitSpill(emitSlotTransfer);
				ensure_reg(sv, state.sp, regs.func_arg);
				// reload instance from frame
				var c = masm.regAlloc.regConfig;
				masm.emit_mov_r_m(regs.instance, ValueKind.REF, MasmAddr(regs.sp, c.instance_offset));

				var tmp1 = regs.stp; // TODO: allocate and release temp regs
				var tmp2 = regs.ip;

				// load table[table_index] from instance
				masm.emit_mov_r_m(tmp1, ValueKind.REF, MasmAddr(regs.instance, offsets.Instance_tables));
				masm.emit_read_v3_array_r_i(tmp1, tmp1, int.!(table_index), ValueKind.REF);
				// bounds check
				masm.emit_mov_r_m(tmp2, ValueKind.REF, MasmAddr(tmp1, offsets.Table_ids));
				masm.emit_bounds_check_v3_array(tmp2, regs.func_arg, masm.newTrapLabel(TrapReason.FUNC_INVALID));
				// signature check
				masm.emit_mov_r_m(tmp2, ValueKind.REF, MasmAddr(tmp1, offsets.Table_ids));
				masm.emit_read_v3_array_r_r(tmp2, tmp2, regs.func_arg, ValueKind.I32);
				masm.emit_breq_r_i(tmp2, -1, masm.newTrapLabel(TrapReason.FUNC_INVALID));
				masm.emit_brne_r_i(tmp2, sig.canon_id, masm.newTrapLabel(TrapReason.FUNC_SIG_MISMATCH));
				// load from table
				masm.emit_mov_r_m(tmp2, ValueKind.REF, MasmAddr(tmp1, offsets.Table_funcs));
				masm.emit_read_v3_array_r_r(regs.func_arg, tmp2, regs.func_arg, ValueKind.REF);

				emit_compute_vsp(state.sp);

				// check for WasmFunction
				masm.emit_mov_r_m(tmp1, ValueKind.I32, MasmAddr(regs.func_arg, 0));
				masm.emit_breq_r_i(tmp1, offsets.WasmFunction_typeId, wasmcall_label);
				masm.emit_write_runtime_vsp(regs.vsp);
				masm.emit_mov_r_r(regs.runtime_arg_0, regs.func_arg);
				masm.emit_call_runtime_callHost(regs.func_arg);
				masm.emit_br(retpt);

				masm.bindLabel(wasmcall_label);
				masm.emit_mov_r_m(tmp1, ValueKind.REF, MasmAddr(regs.func_arg, offsets.WasmFunction_decl));
				masm.emit_mov_r_m(tmp1, ValueKind.REF, MasmAddr(tmp1, offsets.FuncDecl_target_code));
				masm.emit_call_r(tmp1);
				// merge point for both returns
				masm.bindLabel(retpt);
				emit_unwind_check();
				emit_reload_regs();

				state.popArgsAndPushResults(sig);
				freeVal(sv);
			}
			CALL_REF => {
				var sig = parser.readSigRef();
				var offsets = masm.getOffsets();
				var regs = masm.regAlloc.regConfig.regs;
				var sv = state.pop();
				var c = masm.regAlloc.regConfig;
				if (sv.isConst() && sv.const == 0) {
					emitTrap(TrapReason.NULL_DEREF);
					state.setUnreachable();
					return;
				}
				ensure_reg(sv, state.sp, regs.func_arg);
				var retpt = masm.newLabel(opcode_pos), wasmcall_label = masm.newLabel(opcode_pos);
				state.emitSpill(emitSlotTransfer);

				emit_compute_vsp(state.sp);
				// check for null
				masm.emit_breq_r_l(regs.func_arg, 0, masm.newTrapLabel(TrapReason.NULL_DEREF));

				var tmp = regs.ip; // TODO: allocate and release tmp regs
				masm.emit_mov_r_m(tmp, ValueKind.I32, MasmAddr(regs.func_arg, 0));
				masm.emit_breq_r_i(tmp, offsets.WasmFunction_typeId, wasmcall_label);
				// not a WasmFunction
				masm.emit_write_runtime_vsp(regs.vsp);
				masm.emit_mov_r_r(regs.runtime_arg_0, regs.func_arg);
				masm.emit_call_runtime_callHost(regs.func_arg);
				masm.emit_br(retpt);

				// WasmFunction
				masm.bindLabel(wasmcall_label);
				masm.emit_mov_r_m(tmp, ValueKind.REF, MasmAddr(regs.func_arg, offsets.WasmFunction_decl));
				masm.emit_mov_r_m(tmp, ValueKind.REF, MasmAddr(tmp, offsets.FuncDecl_target_code));
				masm.emit_call_r(tmp);

				masm.bindLabel(retpt);
				emit_unwind_check();
				emit_reload_regs();

				state.popArgsAndPushResults(sig);
				freeVal(sv);
			}
			DROP => {
				state.sp--;
			}
			SELECT => {
				var sv = state.pop();
				var fv = state.pop();
				var tv = state.pop();
				emitSelect1(sv, fv, tv);
				freeVal(sv);
			}
			LOCAL_GET => {
				var index = codeptr.read_uleb32();
				var lv = state.get(index);
				if (lv.isConst()) {
					if (lv.inReg()) {
						state.push(lv.kindFlags(IS_CONST | IN_REG), lv.reg, lv.const); // steal reg
						state.setNoReg(index);
					} else {
						state.push(lv.kindFlags(IS_CONST), NO_REG, lv.const);
					}
				} else if (lv.inReg()) {
					if (!lv.isStored()) {
						masm.emit_mov_s_r(index, lv.reg, lv.kind());
						state.setStored(index);
					}
					state.setNoReg(index); // steal reg
					state.push(lv.kindFlags(IN_REG), lv.reg, 0);
				} else {
					var reg = allocReg(lv.kind());
					emit_read_slot_r(index, reg);
					state.push(lv.kindFlags(IN_REG), reg.reg, 0);
				}
			}
			LOCAL_SET => {
				var index = codeptr.read_uleb32();
				var lv = state.get(index);
				var sv = state.pop();
				if (sv.isConst() || sv.inReg()) {
					var flags = (lv.flags & (KIND_MASK | TAG_STORED)) | (sv.flags & (IN_REG | IS_CONST));
					state.set(index, flags, sv.reg, sv.const);
				} else {
					var reg = allocReg(lv.kind());
					emit_read_slot_r(state.sp, reg);
					var flags = (lv.flags & (KIND_MASK | TAG_STORED)) | IN_REG;
					state.set(index, flags, reg.reg, 0);
				}
			}
			LOCAL_TEE => {
				var index = codeptr.read_uleb32();
				var lv = state.get(index);
				var sv = state.peek();
				if (sv.isConst()) {
					var flags = lv.kindFlags(TAG_STORED | IS_CONST);
					state.set(index, flags, NO_REG, sv.const);
				} else if (sv.inReg()) {
					masm.emit_mov_s_r(index, sv.reg, sv.kind());
					var flags = lv.kindFlags(TAG_STORED | IS_STORED);
					state.set(index, flags, NO_REG, 0);
				} else {
					var tos = state.sp - 1;
					var reg = allocReg(lv.kind());
					emit_read_slot_r(tos, reg);
					emit_write_slot_r(index, reg);
					var flags = lv.kindFlags(TAG_STORED | IS_STORED);
					state.set(index, flags, NO_REG, 0);
					state.overwrite(lv.kindFlags(IN_REG), reg.reg, 0);
				}
			}
			GLOBAL_GET => {
				var global = parser.readGlobalRef();
				if (!global.mutable && global.imp == null && global.valtype == ValueType.I32) {
					state.push(KIND_I32 | IS_CONST, NO_REG, InitExpr.I32.!(global.init).val);
				} else {
					var c = masm.regAlloc.regConfig;
					state.emitSpill(emitSlotTransfer);
					emit_compute_vsp(state.sp);
					masm.emit_write_runtime_vsp(regs.vsp);
					masm.emit_mov_r_m(regs.runtime_arg_0, ValueKind.REF, MasmAddr(regs.sp, c.instance_offset));
					masm.emit_mov_r_i(regs.runtime_arg_1, global.global_index);
					masm.emit_call_runtime_GLOBAL_GET();
					emit_reload_regs();
					state.push(typeToKindFlags(global.valtype) | TAG_STORED | IS_STORED, NO_REG, 0);
				}
			}
			GLOBAL_SET => {
				var global = parser.readGlobalRef();
				var c = masm.regAlloc.regConfig;
				state.emitSpill(emitSlotTransfer);
				emit_compute_vsp(state.sp);
				masm.emit_write_runtime_vsp(regs.vsp);
				masm.emit_mov_r_m(regs.runtime_arg_0, ValueKind.REF, MasmAddr(regs.sp, c.instance_offset));
				masm.emit_mov_r_i(regs.runtime_arg_1, global.global_index);
				masm.emit_call_runtime_GLOBAL_SET();
				emit_reload_regs();
				var sv = state.pop();
				freeVal(sv);
			}

			I32_LOAD => emitLoad(ValueKind.I32, masm.emit_load_r_r_r_i);
			I64_LOAD => emitLoad(ValueKind.I64, masm.emit_load_r_r_r_i);
			F32_LOAD => emitLoad(ValueKind.F32, masm.emit_load_r_r_r_i);
			F64_LOAD => emitLoad(ValueKind.F64, masm.emit_load_r_r_r_i);
			I32_LOAD8_S => emitLoad(ValueKind.I32, masm.emit_loadbsx_r_r_r_i);
			I32_LOAD8_U => emitLoad(ValueKind.I32, masm.emit_loadbzx_r_r_r_i);
			I32_LOAD16_S => emitLoad(ValueKind.I32, masm.emit_loadwsx_r_r_r_i);
			I32_LOAD16_U => emitLoad(ValueKind.I32, masm.emit_loadwzx_r_r_r_i);
			I64_LOAD8_S => emitLoad(ValueKind.I64, masm.emit_loadbsx_r_r_r_i);
			I64_LOAD8_U => emitLoad(ValueKind.I64, masm.emit_loadbzx_r_r_r_i);
			I64_LOAD16_S => emitLoad(ValueKind.I64, masm.emit_loadwsx_r_r_r_i);
			I64_LOAD16_U => emitLoad(ValueKind.I64, masm.emit_loadwzx_r_r_r_i);
			I64_LOAD32_S => emitLoad(ValueKind.I64, masm.emit_loaddsx_r_r_r_i);
			I64_LOAD32_U => emitLoad(ValueKind.I64, masm.emit_loaddzx_r_r_r_i);
			I32_STORE => emitStore(ValueKind.I32, masm.emit_store_r_r_r_i);
			I64_STORE => emitStore(ValueKind.I64, masm.emit_store_r_r_r_i);
			F32_STORE => emitStore(ValueKind.F32, masm.emit_store_r_r_r_i);
			F64_STORE => emitStore(ValueKind.F64, masm.emit_store_r_r_r_i);
			I32_STORE8 => emitStore(ValueKind.I32, masm.emit_storeb_r_r_r_i);
			I32_STORE16 => emitStore(ValueKind.I32, masm.emit_storew_r_r_r_i);
			I64_STORE8 => emitStore(ValueKind.I64, masm.emit_storeb_r_r_r_i);
			I64_STORE16 => emitStore(ValueKind.I64, masm.emit_storew_r_r_r_i);
			I64_STORE32 => emitStore(ValueKind.I32, masm.emit_store_r_r_r_i);
			I32_CONST => {
				var val = codeptr.read_sleb32();
				state.push(KIND_I32 | IS_CONST, NO_REG, val);
			}
			I64_CONST => {
				var val = codeptr.read_sleb64();
				if (i32.view(val) == val) {
					state.push(KIND_I64 | IS_CONST, NO_REG, i32.view(val));
				} else {
					var tos = state.sp;
					var addr = masm.slotAddr(tos);
					masm.emit_mov_m_i(addr, int.view(val));
					masm.emit_mov_m_i(addr.plus(4), int.view(val >> 32));
					state.push(KIND_I64 | IS_STORED, NO_REG, 0);
				}
			}
			F32_CONST => {
				var val = codeptr.read_u32();
				if (val == 0 && config_TrackFloatZeroConst) {
					state.push(KIND_F32 | IS_CONST, NO_REG, 0);
				} else {
					var tos = state.sp;
					masm.emit_mov_m_i(masm.slotAddr(tos), int.view(val));
					state.push(KIND_F32 | IS_STORED, NO_REG, 0);
				}
			}
			F64_CONST => {
				var val = codeptr.read_u64();
				if (val == 0 && config_TrackFloatZeroConst) {
					state.push(KIND_F64 | IS_CONST, NO_REG, 0);
				} else {
					var tos = state.sp;
					var addr = masm.slotAddr(tos);
					masm.emit_mov_m_i(addr, int.view(val));
					masm.emit_mov_m_i(addr.plus(4), int.view(val >> 32));
					state.push(KIND_F64 | IS_STORED, NO_REG, 0);
				}
			}
			I32_CLZ 	=> emitUnop(SpcUnop.I32_CLZ);
			I32_CTZ 	=> emitUnop(SpcUnop.I32_CTZ);
			I32_POPCNT 	=> emitUnop(SpcUnop.I32_POPCNT);
			I32_ADD 	=> emitBinop(SpcBinop.I32_ADD);
			I32_SUB 	=> emitBinop(SpcBinop.I32_SUB);
			I32_MUL 	=> emitBinop(SpcBinop.I32_MUL);
			I32_DIV_S 	=> emitBinop(SpcBinop.I32_DIV_S);
			I32_DIV_U 	=> emitBinop(SpcBinop.I32_DIV_U);
			I32_REM_S 	=> emitBinop(SpcBinop.I32_REM_S);
			I32_REM_U 	=> emitBinop(SpcBinop.I32_REM_U);
			I32_AND 	=> emitBinop(SpcBinop.I32_AND);
			I32_XOR 	=> emitBinop(SpcBinop.I32_XOR);
			I32_OR 	=> emitBinop(SpcBinop.I32_OR);
			I32_SHL 	=> emitBinop(SpcBinop.I32_SHL);
			I32_SHR_S 	=> emitBinop(SpcBinop.I32_SHR_S);
			I32_SHR_U 	=> emitBinop(SpcBinop.I32_SHR_U);
			I32_ROTL 	=> emitBinop(SpcBinop.I32_ROTL);
			I32_ROTR 	=> emitBinop(SpcBinop.I32_ROTR);

			I32_EQZ	=> emitUnop(SpcUnop.I32_EQZ);
			I32_EQ 	=> emitBinop(SpcBinop.I32_EQ);
			I32_NE 	=> emitBinop(SpcBinop.I32_NE);
			I32_LT_S 	=> emitBinop(SpcBinop.I32_LT_S);
			I32_LT_U 	=> emitBinop(SpcBinop.I32_LT_U);
			I32_GT_S 	=> emitBinop(SpcBinop.I32_GT_S);
			I32_GT_U 	=> emitBinop(SpcBinop.I32_GT_U);
			I32_LE_S 	=> emitBinop(SpcBinop.I32_LE_S);
			I32_LE_U 	=> emitBinop(SpcBinop.I32_LE_U);
			I32_GE_S 	=> emitBinop(SpcBinop.I32_GE_S);
			I32_GE_U 	=> emitBinop(SpcBinop.I32_GE_U);

			I64_CLZ 	=> emitUnop(SpcUnop.I64_CLZ);
			I64_CTZ 	=> emitUnop(SpcUnop.I64_CTZ);
			I64_POPCNT 	=> emitUnop(SpcUnop.I64_POPCNT);
			I64_ADD 	=> emitBinop(SpcBinop.I64_ADD);
			I64_SUB 	=> emitBinop(SpcBinop.I64_SUB);
			I64_MUL 	=> emitBinop(SpcBinop.I64_MUL);
			I64_DIV_S 	=> emitBinop(SpcBinop.I64_DIV_S);
			I64_DIV_U 	=> emitBinop(SpcBinop.I64_DIV_U);
			I64_REM_S 	=> emitBinop(SpcBinop.I64_REM_S);
			I64_REM_U 	=> emitBinop(SpcBinop.I64_REM_U);
			I64_AND 	=> emitBinop(SpcBinop.I64_AND);
			I64_XOR 	=> emitBinop(SpcBinop.I64_XOR);
			I64_OR 	=> emitBinop(SpcBinop.I64_OR);
			I64_SHL 	=> emitBinop(SpcBinop.I64_SHL);
			I64_SHR_S 	=> emitBinop(SpcBinop.I64_SHR_S);
			I64_SHR_U 	=> emitBinop(SpcBinop.I64_SHR_U);
			I64_ROTL 	=> emitBinop(SpcBinop.I64_ROTL);
			I64_ROTR 	=> emitBinop(SpcBinop.I64_ROTR);

			I64_EQZ	=> emitUnop(SpcUnop.I64_EQZ);
			I64_EQ 	=> emitBinop(SpcBinop.I64_EQ);
			I64_NE 	=> emitBinop(SpcBinop.I64_NE);
			I64_LT_S 	=> emitBinop(SpcBinop.I64_LT_S);
			I64_LT_U 	=> emitBinop(SpcBinop.I64_LT_U);
			I64_GT_S 	=> emitBinop(SpcBinop.I64_GT_S);
			I64_GT_U 	=> emitBinop(SpcBinop.I64_GT_U);
			I64_LE_S 	=> emitBinop(SpcBinop.I64_LE_S);
			I64_LE_U 	=> emitBinop(SpcBinop.I64_LE_U);
			I64_GE_S 	=> emitBinop(SpcBinop.I64_GE_S);
			I64_GE_U 	=> emitBinop(SpcBinop.I64_GE_U);

			I32_WRAP_I64	=> emitUnop(SpcUnop.I32_WRAP_I64);
			I64_EXTEND_I32_S	=> emitUnop(SpcUnop.I64_EXTEND_I32_S);
			I64_EXTEND_I32_U	=> emitUnop(SpcUnop.I64_EXTEND_I32_U);
			I32_EXTEND8_S	=> emitUnop(SpcUnop.I32_EXTEND8_S);
			I32_EXTEND16_S	=> emitUnop(SpcUnop.I32_EXTEND16_S);
			I64_EXTEND8_S	=> emitUnop(SpcUnop.I64_EXTEND8_S);
			I64_EXTEND16_S	=> emitUnop(SpcUnop.I64_EXTEND16_S);
			I64_EXTEND32_S	=> emitUnop(SpcUnop.I64_EXTEND32_S);
			REF_NULL => {
				var vt = codeptr.read_sleb32();
				state.push(KIND_REF | IS_CONST, NO_REG, 0);
			}
			REF_IS_NULL => emitUnop(SpcUnop.REF_IS_NULL);
			REF_FUNC => {
				var c = masm.regAlloc.regConfig;
				var offsets = masm.getOffsets();
				var func_index = codeptr.read_uleb32();
				var reg = allocReg(ValueKind.REF).reg;
				masm.emit_mov_r_m(reg, ValueKind.REF, MasmAddr(regs.sp, c.instance_offset));
				// XXX: skip loading the target function for direct intra-module calls?
				masm.emit_mov_r_m(reg, ValueKind.REF, MasmAddr(reg, offsets.Instance_functions));
				masm.emit_read_v3_array_r_i(reg, reg, int.!(func_index), ValueKind.REF);
				state.push(KIND_REF | IN_REG, reg, 0);
			}
			REF_EQ => emitBinop(SpcBinop.REF_EQ);
			_ => unhandled(opcode);
		}
	}
	def unhandled(opcode: Opcode) {
		bailout(Strings.format1("unimplemented opcode: %s", opcode.name));
	}
	def emitSelect1(sv: SpcAbstractVal, fv: SpcAbstractVal, tv: SpcAbstractVal) {
		var tagStored = tv.flags & TAG_STORED;
		var label = masm.newLabel(opcode_pos);
		if (tv.isConst() && fv.isConst() && tv.const == fv.const) {
			// select K K v => K
			freeVal(tv);
			freeVal(fv);
			state.push(tv.kindFlags(IS_CONST), NO_REG, tv.const);
			return;
		}
		if (sv.isConst()) {
			// select v v K => v
			if (sv.const != 0) {
				freeVal(fv);
				state.pushV(tv);
			} else {
				freeVal(tv);
				if (fv.isConst() || fv.inReg()) state.push(fv.flags & ~IS_STORED, fv.reg, fv.const);
				else {
					var kind = fv.kind();
					var reg = allocReg(kind);
					emit_read_slot_r(state.sp + 1, reg);
					state.push(fv.kindFlags(IN_REG | tagStored), reg.reg, 0);
				}
			}
			return;
		}
		if (tv.inReg()) {
			// reuse register for true value
			var cond = MasmBrCond.I32_NONZERO;
			if (sv.inReg()) masm.emit_br_r(sv.reg, cond, label);
			else masm.emit_br_m(masm.slotAddr(state.sp + 2), cond, label);

			if (fv.isConst()) masm.emit_mov_r_k(tv.reg, tv.kind(), fv.const);
			else if (fv.inReg()) masm.emit_mov_r_r(tv.reg, fv.reg);
			else masm.emit_mov_r_s(tv.reg, tv.kind(), state.sp + 1);
			masm.bindLabel(label);
			state.push(tv.kindFlags(IN_REG | tagStored), tv.reg, 0);
			freeVal(fv);
		} else {
			// load const true value into slot first
			if (!tv.isStored()) masm.emit_mov_s_k(state.sp, tv.const, tv.kind());

			// XXX: reuse the false register and flip branch if possible
			var cond = MasmBrCond.I32_NONZERO;
			if (sv.inReg()) masm.emit_br_r(sv.reg, cond, label);
			else masm.emit_br_m(masm.slotAddr(state.sp + 2), cond, label);

			if (fv.isConst()) masm.emit_mov_s_k(state.sp, fv.const, tv.kind());
			else if (fv.inReg()) masm.emit_mov_s_r(state.sp, fv.reg, tv.kind());
			else masm.emit_mov_s_s(state.sp, state.sp + 1, tv.kind());
			masm.bindLabel(label);
			state.push(tv.kindFlags(IS_STORED | tagStored), NO_REG, 0);
			freeVal(fv);
		}
	}
	def tryNop(isNop: int -> bool) -> bool {
		var sv = state.peek();
		if (sv.isConst() && isNop(sv.const)) {
			state.pop();
			freeVal(sv);
			return true;
		}
		return false;
	}
	def emitBrIf(sv: SpcAbstractVal, cond: MasmBrCond, label: MasmLabel, target: SpcControl, emptyTransfer: bool) {
		if (sv.isConst()) {
			var taken = (sv.const == 0) == cond.zero;
			if (taken) {
				if (!emptyTransfer) state.emitTransfer(target, emitSlotTransfer);
				masm.emit_br(target.label);
			}
		} else if (sv.inReg()) {
			if (emptyTransfer) {
				masm.emit_br_r(sv.reg, cond, label);
			} else {
				var skip = masm.newLabel(opcode_pos);
				masm.emit_br_r(sv.reg, masm.negate(cond), skip);
				state.emitTransfer(target, emitSlotTransfer);
				masm.emit_br(label);
				masm.bindLabel(skip);
			}
		} else {
			if (emptyTransfer) {
				masm.emit_br_m(masm.slotAddr(state.sp), cond, label);
			} else {
				var skip = masm.newLabel(opcode_pos);
				masm.emit_br_m(masm.slotAddr(state.sp), masm.negate(cond), skip);
				state.emitTransfer(target, emitSlotTransfer);
				masm.emit_br(label);
				masm.bindLabel(skip);
			}
		}
		freeVal(sv);
	}
	def emitBrTable(sv: SpcAbstractVal, depths: Array<u32>) {
		var labels = Array<MasmLabel>.new(state.ctl_stack.top);
		var targets = Array<MasmLabel>.new(depths.length);
		for (i < targets.length) { // create labels for all targets involved in this br_table
			var depth = depths[i];
			var l = labels[depth];
			if (l == null) l = labels[depth] = masm.newLabel(opcode_pos);
			targets[i] = l;
		}
		if (sv.isConst()) {
			// constant-fold br_table into a br
			var key = sv.const;
			var depth = if(key >= depths.length, depths[depths.length - 1], depths[key]);
			var target = state.ctl_stack.elems[depth];
			state.emitTransfer(target, emitSlotTransfer);
			masm.emit_br(target.label);
		} else {
			var reg = ensure_reg(sv, state.sp, NO_REG);
			masm.emit_br_table_r(reg, targets);
			freeReg(reg);

			for (depth < labels.length) {
				var l = labels[depth];
				if (l == null) continue;
				masm.bindLabel(l);
				var target = state.getControl(u32.view(depth));
				state.emitTransfer(target, emitSlotTransfer);
				masm.emit_br(target.label);
			}
		}
	}
	def emitReturn(ctl: SpcControl) {
		var results = sig.results;
		if (masm.valuerep.tagged) {
			// update mismatched value tags
			var params = sig.params;
			for (i < results.length) {
				var rtag = toTag(results[i]);
				if (i < params.length && rtag == toTag(params[i])) continue; // tag already correct
				masm.emit_mov_m_i(masm.tagAddr(u32.view(i)), rtag.code);
			}
		}
		// Compute VSP = VFP + sig.results.length
		var c = masm.regAlloc.regConfig;
		masm.emit_mov_r_r(regs.vsp, regs.vfp); // XXX: use 3-addr adjustment of VSP
		if (results.length > 0)	masm.emit_add_r_l(regs.vsp, results.length * masm.valuerep.slot_size);
		// Return to caller
		masm.emit_mov_r_i(regs.ret_ExecState, ExecState.FINISHED.tag);
		// Deallocate stack frame
		if (unwind_label != null) masm.bindLabel(unwind_label);
		masm.emit_add_r_l(regs.sp, c.spcFrameSize);
		masm.emit_ret();
	}
	def emitTrap(reason: TrapReason) {
		var label = masm.newTrapLabel(reason);
		masm.emit_br(label);
	}
	def emitTrapReturn(label: MasmLabel, reason: TrapReason) {
		if (label != null) masm.bindLabel(label);
		var c = masm.regAlloc.regConfig;
		masm.emit_mov_r_i(regs.ret_TrapReason, reason.tag);
		masm.emit_mov_r_i(regs.ret_ExecState, ExecState.TRAPPED.tag);
		masm.emit_add_r_l(regs.sp, c.spcFrameSize);
		masm.emit_ret();
	}
	def emitTrapEpilogue() {
		if (trap_label == null) return;
		var c = masm.regAlloc.regConfig;
		masm.bindLabel(trap_label);
		masm.emit_mov_r_i(regs.ret_ExecState, ExecState.TRAPPED.tag);
		masm.emit_add_r_l(regs.sp, c.spcFrameSize);
		// Return to caller
		masm.emit_ret();
	}
	def emitSlotTransfer(to: (u32, SpcAbstractVal), from: (u32, SpcAbstractVal)) {
		if (Trace.compiler) {
			Trace.OUT.put1("    emitSlotTransfer slot=%d ", to.0);
			traceAbstractVal(to.1);
			Trace.OUT.put1(" <- slot=%d ", from.0);
			traceAbstractVal(from.1);
			Trace.OUT.outln();
		}
		var tv = to.1, fv = from.1;
		if (masm.valuerep.tagged && tv.tagStored()) {
			if (from.0 != to.0 || !fv.tagStored()) {
				// store the tag into to-slot
				masm.emit_mov_m_i(masm.tagAddr(to.0), fv.kind().code);
			}
		}
		if (tv.isStored()) {
			// store the value into slot
			if (from.0 != to.0 || !fv.isStored()) {
				if (fv.isConst()) {
					masm.emit_mov_s_k(to.0, fv.const, fv.kind());
				} else if (fv.inReg()) {
					masm.emit_mov_s_r(to.0, fv.reg, fv.kind());
				} else {
					masm.emit_mov_s_s(to.0, from.0, tv.kind());
				}
			}
		} else if (tv.inReg()) {
			// load or move the value into appropriate register
			if (fv.isConst()) {
				masm.emit_mov_r_i(tv.reg, fv.const);
			} else if (fv.inReg()) {
				if (tv.reg != fv.reg) {
					// XXX: perform reg-reg move instead of storing to slot
					masm.emit_mov_s_r(to.0, fv.reg, fv.kind());
					masm.emit_mov_r_s(tv.reg, fv.kind(), to.0);
				}
			} else {
				masm.emit_mov_r_s(tv.reg, tv.kind(), from.0);
			}
		}
	}
	def emitUnop(unop: SpcUnop) {
		var a = state.peek();
		var tos = u32.!(state.sp - 1);
		var flags = (a.flags & unop.kind_sig.preserve_flags) | unop.kind_sig.add_flags;
		if (a.isConst() && unop.fold != null) {
			state.overwrite(flags | IS_CONST, NO_REG, unop.fold(a.const));
			return;
		}
		var reg_a: Reg;
		if (a.inReg()) {
			reg_a = a.reg;
		} else {
			var kind = unop.kind_sig.a_kind;
			reg_a = allocReg(unop.kind_sig.a_kind).reg;
			if (a.isConst()) {
				masm.emit_mov_r_k(reg_a, kind, a.const);
			} else {
				masm.emit_mov_r_s(reg_a, kind, tos);
			}
		}
		masm.emit_unop_r(unop.op, reg_a);
		state.overwrite(flags | IN_REG, reg_a, 0);
	}
	def emitBinop(binop: SpcBinop) {
		var b = state.pop();
		var a = state.peek();
		var tos = u32.!(state.sp - 1);
		var flags = (a.flags & binop.kind_sig.preserve_flags) | binop.kind_sig.add_flags;
		if (binop.isNop != null && b.isConst() && binop.isNop(b.const)) {
			freeVal(b);
			return;
		}
		if (a.inReg()) {
			// reg const? op x
			if (b.isConst()) {
				if (a.isConst() && binop.fold != null) {
					// fold: const op const
					var val = binop.fold(a.const, b.const);
					state.overwrite(flags | IS_CONST, NO_REG, val);
					freeVal(a);
					freeVal(b);
				} else {
					// reg op const
					masm.emit_binop_r_i(binop.op, a.reg, b.const);
					state.overwrite(flags | IN_REG, a.reg, 0);
					freeVal(b);
				}
			} else if (b.inReg()) {
				if (binop.commute != Opcode.UNREACHABLE && a.isConst()) {
					// commute: const op reg -> reg op const
					masm.emit_binop_r_i(binop.commute, b.reg, a.const);
					state.overwrite(flags | IN_REG, b.reg, 0);
					freeVal(a);
				} else {
					// reg op reg
					masm.emit_binop_r_r(binop.op, a.reg, b.reg);
					state.overwrite(flags | IN_REG, a.reg, 0);
					freeVal(b);
				}
			} else {
				// reg op slot
				masm.emit_binop_r_m(binop.op, a.reg, masm.slotAddr(tos+1));
				state.overwrite(flags | IN_REG, a.reg, 0);
			}
		} else if (a.isConst()) {
			// const op x
			if (b.isConst()) {
				if (binop.fold != null) {
					// fold: const op const
					var val = binop.fold(a.const, b.const);
					state.overwrite(flags | IS_CONST, NO_REG, val);
					freeVal(a);
					freeVal(b);
				} else if (binop.commute != Opcode.UNREACHABLE && b.inReg()) {
					// commute const op reg -> reg op const
					masm.emit_binop_r_i(binop.commute, b.reg, a.const);
					state.overwrite(flags | IN_REG, b.reg, 0);
				} else {
					// load: a reg -> reg op reg
					var reg_a = allocReg(binop.kind_sig.a_kind);
					masm.emit_mov_r_i(reg_a.reg, a.const);
					masm.emit_binop_r_i(binop.op, reg_a.reg, b.const);
					state.overwrite(flags | IN_REG, reg_a.reg, 0);
					freeVal(b);
				}
			} else if (b.inReg()) {
				// const op reg
				if (binop.commute != Opcode.UNREACHABLE && b.inReg()) {
					// commute const op reg -> reg op const
					masm.emit_binop_r_i(binop.commute, b.reg, a.const);
					state.overwrite(flags | IN_REG, b.reg, 0);
				} else {
					var reg_a = allocReg(ValueKind.I32);
					masm.emit_mov_r_i(reg_a.reg, a.const);
					masm.emit_binop_r_r(binop.op, reg_a.reg, b.reg);
					state.overwrite(flags | IN_REG, reg_a.reg, 0);
					freeVal(b);
				}
			} else {
				// const op slot
				var reg_a = allocReg(binop.kind_sig.a_kind);
				masm.emit_mov_r_i(reg_a.reg, a.const);
				masm.emit_binop_r_m(binop.op, reg_a.reg, masm.slotAddr(tos+1));
				state.overwrite(flags | IN_REG, reg_a.reg, 0);
				// XXX: if commute: load rb, binop_r_i
			}
		} else {
			var reg_a = allocReg(binop.kind_sig.a_kind);
			emit_read_slot_r(tos, reg_a);
			// slot op x
			if (b.isConst()) {
				// slot op const
				masm.emit_binop_r_i(binop.op, reg_a.reg, b.const);
			} else if (b.inReg()) {
				// slot op reg
				masm.emit_binop_r_r(binop.op, reg_a.reg, b.reg);
			} else {
				// slot op slot
				masm.emit_binop_r_m(binop.op, reg_a.reg, masm.slotAddr(tos+1));
			}
			// XXX: if commute: binop_r_m
			state.overwrite(flags | IN_REG, reg_a.reg, 0);
			freeVal(b);
		}
	}
	def unsupported() {
		success = false; // XXX: add opcode
		codeptr.atl(codeptr.pos, codeptr.pos); // set limit to break out of loop
	}
	def bailout(msg: string) {
		success = false;
		if (Trace.compiler) Trace.OUT.put1("------------ bailout: %s", msg).outln();
		codeptr.atl(codeptr.pos, codeptr.pos); // set limit to break out of loop
		err.rel(codeptr, codeptr.pos).set(msg);
	}

	//====================================================================
	// codegen operations
	//====================================================================
	def emit_read_slot_r(slot: u32, reg: SpcReg) {
		masm.emit_mov_r_s(reg.reg, reg.kind, slot);
	}
	def emit_write_slot_r(slot: u32, reg: SpcReg) {
		masm.emit_mov_s_r(slot, reg.reg, reg.kind);
	}
	def emit_unwind_check() {
		if (unwind_label == null) unwind_label = masm.newLabel(codeptr.limit);
		masm.emit_brne_r_i(regs.ret_ExecState, ExecState.FINISHED.tag, unwind_label);
	}
	def emit_compute_vsp(slots: u32) {
		masm.emit_mov_r_r(regs.vsp, regs.vfp); // XXX: use 3-addr adjustment of VSP (i.e. lea)
		if (slots > 0) masm.emit_add_r_l(regs.vsp, int.view(slots) * masm.valuerep.slot_size);
	}
	def emit_reload_regs() {
		// XXX: recompute VFP from VSP - #slots?
		masm.emit_mov_r_m(regs.vfp, ValueKind.REF, MasmAddr(regs.sp, masm.regAlloc.regConfig.vfp_offset));
		if (module.memories.length > 0) {
			masm.emit_mov_r_m(regs.mem0, ValueKind.REF, MasmAddr(regs.sp, masm.regAlloc.regConfig.mem_offset));
		}
	}
	def ensure_reg(sv: SpcAbstractVal, slot: u32, reg: Reg) -> Reg {
		if (!sv.inReg()) {
			if (reg == NO_REG) reg = allocReg(sv.kind()).reg;
			if (sv.isConst()) masm.emit_mov_r_i(reg, sv.const);
			else masm.emit_mov_r_s(reg, sv.kind(), slot);
			return reg;
		}
		if (reg == NO_REG) return sv.reg;
		masm.emit_mov_r_r(reg, sv.reg);
		return reg;
	}
	def emitLoad(kind: ValueKind, meth: (Reg, Reg, Reg, u32, ValueKind) -> ())  {
		var flags = codeptr.read1();
		var mem_index = if((flags & BpConstants.MEMARG_INDEX_FLAG) != 0, codeptr.read_uleb32());
		if (mem_index != 0) bailout("unsupported multi-memory operation");
		var offset = codeptr.read_uleb32();
		var iv = state.pop();
		var index_reg: Reg;
		if (iv.isConst()) {
			var sum = u64.view(offset) + u32.view(iv.const); // fold offset calculation
			if (sum > u32.max) {
				masm.emit_br(masm.newTrapLabel(TrapReason.MEM_OUT_OF_BOUNDS)); // statically OOB
				state.setUnreachable();
				state.push(kindToFlags(kind), NO_REG, 0);
				return;
			}
			offset = u32.view(sum);
		} else {
			index_reg = ensure_reg(iv, state.sp, NO_REG);
		}
		var dest = index_reg;
		if (kind != ValueKind.I32 || dest == NO_REG) dest = allocReg(kind).reg;
		meth(dest, regs.mem0, index_reg, offset, kind);
		if (dest != index_reg) freeReg(index_reg);
		var nflags = IN_REG | kindToFlags(kind);
		if (kind == ValueKind.I32) nflags |= (iv.flags & TAG_STORED); // tag may already be stored for index
		state.push(nflags, dest, 0);
	}
	def emitStore(kind: ValueKind, meth: (Reg, Reg, Reg, u32, ValueKind) -> ()) {
		var flags = codeptr.read1();
		var mem_index = if((flags & BpConstants.MEMARG_INDEX_FLAG) != 0, codeptr.read_uleb32());
		if (mem_index != 0) bailout("unsupported multi-memory operation");
		var offset = codeptr.read_uleb32();
		var sv = state.pop();
		var val_reg = ensure_reg(sv, state.sp, NO_REG); // XXX: support store immediate
		var iv = state.pop();
		var index_reg: Reg;
		if (iv.isConst()) {
			var sum = u64.view(offset) + u32.view(iv.const); // fold offset calculation
			if (sum > u32.max) {
				masm.emit_br(masm.newTrapLabel(TrapReason.MEM_OUT_OF_BOUNDS)); // statically OOB
				state.setUnreachable();
				return;
			}
			offset = u32.view(sum);
		} else {
			index_reg = ensure_reg(iv, state.sp, NO_REG);
		}
		meth(val_reg, regs.mem0, index_reg, offset, kind);
		freeReg(val_reg);
		freeReg(index_reg);
	}

	//====================================================================
	// register allocation operations
	//====================================================================
	def freeReg(reg: Reg) {
		if (reg.index > 0) masm.regAlloc.free(reg);
	}
	def freeVal(sv: SpcAbstractVal) {
		if (sv.inReg()) masm.regAlloc.free(sv.reg);
	}
	def allocReg(kind: ValueKind) -> SpcReg {
		// TODO: handle running out of registers
		var reg = masm.regAlloc.alloc(kind, 2);
		if (reg == NO_REG) bailout("out of registers");
		return SpcReg(reg, kind);
	}

	//====================================================================
	// abstract stack operations
	//====================================================================
	def labelArgs(ctl: SpcControl) -> Array<ValueType> {
		if (ctl.opcode == Opcode.LOOP.code) return ctl.params;
		else return ctl.results;
	}
	def traceOpcode() {
		OUT.put2("  %x(+%d): ", opcode_pos, opcode_pos - start_pos);
		var prev = codeptr.pos;
		codeptr.at(opcode_pos);
		instrTracer.putInstr(OUT, module, codeptr);
		codeptr.at(prev);
		OUT.outln();
	}
	def traceStack() {
		OUT.put1("sp=%d ", state.sp);
		for (i < state.sp) traceAbstractVal(state.state[i]);
		OUT.outln();
	}
	def traceAbstractVal(sv: SpcAbstractVal) {
		OUT.put3("[%s %s%s: ",
			sv.kind().name,
			if(sv.tagStored(), "T", ""),
			if(sv.isStored(), "S", ""));
		if (sv.inReg()) OUT.put1(" @%s", masm.regAlloc.regConfig.regSet.getName(sv.reg));
		if (sv.isConst()) OUT.put1(" $%d", sv.const);
		OUT.puts("]");
	}
}

// States in which a local slot or operand stack slot could be in.
type SpcState {
	case Uncached;
	case Register(reg: SpcReg);
	case Const(val: int);
}

type SpcReg(reg: Reg, kind: ValueKind) #unboxed { }

// Abstract values tracked during single-pass compilation.
def IS_STORED: byte = 0x01;
def IS_CONST: byte = 0x02;
def IN_REG: byte = 0x04;
def TAG_STORED: byte = 0x08;
def KIND_MASK: byte = 0xF0;
def KIND_I32: byte = byte.view(ValueKind.I32.tag) << 4;
def KIND_I64: byte = byte.view(ValueKind.I64.tag) << 4;
def KIND_F32: byte = byte.view(ValueKind.F32.tag) << 4;
def KIND_F64: byte = byte.view(ValueKind.F64.tag) << 4;
def KIND_V128: byte = byte.view(ValueKind.V128.tag) << 4;
def KIND_REF: byte = byte.view(ValueKind.REF.tag) << 4;
def NO_REG = Reg(0);
def kinds: Array<ValueKind> = [ValueKind.I32, ValueKind.I64, ValueKind.F32, ValueKind.F64, ValueKind.V128, ValueKind.REF];

type SpcAbstractVal(flags: byte, reg: Reg, const: int) #unboxed {
	def kind() -> ValueKind {
		return kinds[flags >> 4];
	}
	def kindFlags(add: byte) -> byte {
		return (flags & KIND_MASK) | add;
	}
	def isStored() -> bool {
		return (flags & IS_STORED) != 0;
	}
	def isConst() -> bool {
		return (flags & IS_CONST) != 0;
	}
	def inReg() -> bool {
		return (flags & IN_REG) != 0;
	}
	def tagStored() -> bool {
		return (flags & TAG_STORED) != 0;
	}
}

type SpcBinopSig(a_kind: ValueKind, b_kind: ValueKind, preserve_flags: byte, add_flags: byte);
type SpcUnopSig(a_kind: ValueKind, preserve_flags: byte, add_flags: byte);

def kind_ii_i = SpcBinopSig(ValueKind.I32, ValueKind.I32, KIND_MASK | TAG_STORED, 0);
def kind_ll_l = SpcBinopSig(ValueKind.I64, ValueKind.I64, KIND_MASK | TAG_STORED, 0);
def kind_ll_i = SpcBinopSig(ValueKind.I64, ValueKind.I64, 0, KIND_I32);
def kind_rr_i = SpcBinopSig(ValueKind.REF, ValueKind.REF, 0, KIND_I32);

def kind_i_i = SpcUnopSig(ValueKind.I32, KIND_MASK | TAG_STORED, 0);
def kind_l_i = SpcUnopSig(ValueKind.I64, 0, KIND_I32);
def kind_i_l = SpcUnopSig(ValueKind.I32, 0, KIND_I64);
def kind_l_l = SpcUnopSig(ValueKind.I64, KIND_MASK | TAG_STORED, 0);
def kind_r_i = SpcUnopSig(ValueKind.REF, 0, KIND_I32);

enum SpcBinop(op: Opcode, commute: Opcode, kind_sig: SpcBinopSig, isNop: int -> bool, fold: (int, int) -> int) {
	I32_ADD		(Opcode.I32_ADD,	Opcode.I32_ADD,		kind_ii_i, isZero, int.+)
	I32_SUB		(Opcode.I32_SUB,	Opcode.UNREACHABLE,	kind_ii_i, isZero, int.-),
	I32_MUL		(Opcode.I32_MUL,	Opcode.I32_MUL,		kind_ii_i, isOne, int.*),
	I32_DIV_S	(Opcode.I32_DIV_S,	Opcode.UNREACHABLE,	kind_ii_i, null, null),
	I32_DIV_U	(Opcode.I32_DIV_U,	Opcode.UNREACHABLE,	kind_ii_i, null, null),
	I32_REM_S	(Opcode.I32_REM_S,	Opcode.UNREACHABLE,	kind_ii_i, null, null),
	I32_REM_U	(Opcode.I32_REM_U,	Opcode.UNREACHABLE,	kind_ii_i, isMinusOne, null),
	I32_AND		(Opcode.I32_AND,	Opcode.I32_AND,		kind_ii_i, isMinusOne, int.&),
	I32_XOR		(Opcode.I32_XOR,	Opcode.I32_XOR,		kind_ii_i, isZero, int.^),
	I32_OR		(Opcode.I32_OR,		Opcode.I32_OR,		kind_ii_i, isZero, int.|),
	I32_SHL		(Opcode.I32_SHL,	Opcode.UNREACHABLE,	kind_ii_i, isZero, V3Eval.I32_SHL),
	I32_SHR_S	(Opcode.I32_SHR_S,	Opcode.UNREACHABLE,	kind_ii_i, isZero, V3Eval.I32_SHR_S),
	I32_SHR_U	(Opcode.I32_SHR_U,	Opcode.UNREACHABLE,	kind_ii_i, isZero, V3Eval.I32_SHR_U),
	I32_ROTL	(Opcode.I32_ROTL,	Opcode.UNREACHABLE,	kind_ii_i, isZero, I32_ROTL),
	I32_ROTR	(Opcode.I32_ROTR,	Opcode.UNREACHABLE,	kind_ii_i, isZero, I32_ROTR),
	I32_EQ		(Opcode.I32_EQ,		Opcode.I32_EQ,		kind_ii_i, null, Fold_ii_i.I32_EQ),
	I32_NE		(Opcode.I32_NE,		Opcode.I32_NE,		kind_ii_i, null, Fold_ii_i.I32_NE),
	I32_LT_S	(Opcode.I32_LT_S,	Opcode.I32_GT_S, 	kind_ii_i, null, Fold_ii_i.I32_LT_S),
	I32_LT_U	(Opcode.I32_LT_U,	Opcode.I32_GT_U, 	kind_ii_i, null, Fold_ii_i.I32_LT_U),
	I32_GT_S	(Opcode.I32_GT_S,	Opcode.I32_LT_S, 	kind_ii_i, null, Fold_ii_i.I32_GT_S),
	I32_GT_U	(Opcode.I32_GT_U,	Opcode.I32_LT_U, 	kind_ii_i, null, Fold_ii_i.I32_GT_U),
	I32_LE_S	(Opcode.I32_LE_S,	Opcode.I32_GE_S, 	kind_ii_i, null, Fold_ii_i.I32_LE_S),
	I32_LE_U	(Opcode.I32_LE_U,	Opcode.I32_GE_U, 	kind_ii_i, null, Fold_ii_i.I32_LE_U),
	I32_GE_S	(Opcode.I32_GE_S,	Opcode.I32_LE_S, 	kind_ii_i, null, Fold_ii_i.I32_GE_S),
	I32_GE_U	(Opcode.I32_GE_U,	Opcode.I32_LE_U, 	kind_ii_i, null, Fold_ii_i.I32_GE_U),

	I64_ADD		(Opcode.I64_ADD,	Opcode.I64_ADD,		kind_ll_l, isZero, null)
	I64_SUB		(Opcode.I64_SUB,	Opcode.UNREACHABLE,	kind_ll_l, isZero, null),
	I64_MUL		(Opcode.I64_MUL,	Opcode.I64_MUL,		kind_ll_l, isOne, null),
	I64_DIV_S	(Opcode.I64_DIV_S,	Opcode.UNREACHABLE,	kind_ll_l, null, null),
	I64_DIV_U	(Opcode.I64_DIV_U,	Opcode.UNREACHABLE,	kind_ll_l, null, null),
	I64_REM_S	(Opcode.I64_REM_S,	Opcode.UNREACHABLE,	kind_ll_l, null, null),
	I64_REM_U	(Opcode.I64_REM_U,	Opcode.UNREACHABLE,	kind_ll_l, isMinusOne, null),
	I64_AND		(Opcode.I64_AND,	Opcode.I64_AND,		kind_ll_l, isMinusOne, null),
	I64_XOR		(Opcode.I64_XOR,	Opcode.I64_XOR,		kind_ll_l, isZero, null),
	I64_OR		(Opcode.I64_OR,		Opcode.I64_OR,		kind_ll_l, isZero, null),
	I64_SHL		(Opcode.I64_SHL,	Opcode.UNREACHABLE,	kind_ll_l, isZero, null),
	I64_SHR_S	(Opcode.I64_SHR_S,	Opcode.UNREACHABLE,	kind_ll_l, isZero, null),
	I64_SHR_U	(Opcode.I64_SHR_U,	Opcode.UNREACHABLE,	kind_ll_l, isZero, null),
	I64_ROTL	(Opcode.I64_ROTL,	Opcode.UNREACHABLE,	kind_ll_l, isZero, null),
	I64_ROTR	(Opcode.I64_ROTR,	Opcode.UNREACHABLE,	kind_ll_l, isZero, null),
	I64_EQ		(Opcode.I64_EQ,		Opcode.I64_EQ,		kind_ll_i, null, null),
	I64_NE		(Opcode.I64_NE,		Opcode.I64_NE,		kind_ll_i, null, null),
	I64_LT_S	(Opcode.I64_LT_S,	Opcode.I64_GT_S, 	kind_ll_i, null, null),
	I64_LT_U	(Opcode.I64_LT_U,	Opcode.I64_GT_U, 	kind_ll_i, null, null),
	I64_GT_S	(Opcode.I64_GT_S,	Opcode.I64_LT_S, 	kind_ll_i, null, null),
	I64_GT_U	(Opcode.I64_GT_U,	Opcode.I64_LT_U, 	kind_ll_i, null, null),
	I64_LE_S	(Opcode.I64_LE_S,	Opcode.I64_GE_S, 	kind_ll_i, null, null),
	I64_LE_U	(Opcode.I64_LE_U,	Opcode.I64_GE_U, 	kind_ll_i, null, null),
	I64_GE_S	(Opcode.I64_GE_S,	Opcode.I64_LE_S, 	kind_ll_i, null, null),
	I64_GE_U	(Opcode.I64_GE_U,	Opcode.I64_LE_U, 	kind_ll_i, null, null)

	REF_EQ		(Opcode.REF_EQ,		Opcode.REF_EQ,		kind_rr_i, null, null),
}

enum SpcUnop(op: Opcode, kind_sig: SpcUnopSig, fold: int -> int) {
	I32_CLZ(Opcode.I32_CLZ, kind_i_i, null), // XXX: fold
	I32_CTZ(Opcode.I32_CTZ, kind_i_i, null), // XXX: fold
	I32_POPCNT(Opcode.I32_POPCNT, kind_i_i, null), // XXX: fold
	I32_EQZ(Opcode.I32_EQZ, kind_i_i, null), // XXX: fold
	I64_EQZ(Opcode.I64_EQZ, kind_l_i, null), // XXX: fold
	I64_CLZ(Opcode.I64_CLZ, kind_l_l, null), // XXX: fold
	I64_CTZ(Opcode.I64_CTZ, kind_l_l, null), // XXX: fold
	I64_POPCNT(Opcode.I64_POPCNT, kind_l_l, null), // XXX: fold
	I32_WRAP_I64(Opcode.I32_WRAP_I64, kind_l_i, null), // XXX: fold
	I64_EXTEND_I32_S(Opcode.I64_EXTEND_I32_S, kind_i_l, null), // XXX: fold
	I64_EXTEND_I32_U(Opcode.I64_EXTEND_I32_U, kind_i_l, null), // XXX: fold
	I32_EXTEND8_S(Opcode.I32_EXTEND8_S, kind_i_i, null), // XXX: fold
	I32_EXTEND16_S(Opcode.I32_EXTEND16_S, kind_i_i, null), // XXX: fold
	I64_EXTEND8_S(Opcode.I64_EXTEND8_S, kind_l_l, null), // XXX: fold
	I64_EXTEND16_S(Opcode.I64_EXTEND16_S, kind_l_l, null), // XXX: fold
	I64_EXTEND32_S(Opcode.I64_EXTEND32_S, kind_l_l, null), // XXX: fold
	REF_IS_NULL(Opcode.REF_IS_NULL, kind_r_i, null), // XXX: fold
}

// An entry in the abstract control stack.
class SpcControl {
	var opcode: byte;
	var params: Array<ValueType>;
	var results: Array<ValueType>;
	var reachable = true;
	var val_stack_top: u32;
	var label: MasmLabel;
	var else_label: MasmLabel;
	// the state at the merge (label)
	var merge_count: byte;
	var merge_state: Array<SpcAbstractVal>;
	// the state used to reset back to before the true branch of an if
	var reset_state: Array<SpcAbstractVal>;

	def clearMerge() {
		merge_count = 0;
		merge_state = null;
	}
	def clearReset() {
		reset_state = null;
	}
}

def isZero = int.==(0, _);
def isOne = int.==(1, _);
def isMinusOne = int.==(-1, _);
def to_ii_i(f: (u32, u32) -> u32, a: int, b: int) -> int {
	return int.view(f(u32.view(a), u32.view(b)));
}
def I32_ROTL = to_ii_i(V3Eval.I32_ROTL, _, _);
def I32_ROTR = to_ii_i(V3Eval.I32_ROTR, _, _);

// Contains both the abstract control and abstract value stack.
class SpcAbstractState(regAlloc: RegAlloc) {
	// Abstract state of the value stack
	var state = Array<SpcAbstractVal>.new(INITIAL);
	var sp: u32;
	var ctl_stack = ArrayStack<SpcControl>.new();
	var num_locals: u16;

	// Reset the state for starting a new function.
	def reset(sig: SigDecl, ret_label: MasmLabel) {
		sp = 0;
		ctl_stack.clear();
		// manually set up first control entry and return merge state
		var results = sig.results;
		var ctl = pushControl(Opcode.RETURN.code, ValueTypes.NONE, results, ret_label);
		var merge_state = Array<SpcAbstractVal>.new(results.length);
		for (i < results.length) {
			// request the merged values be stored to the stack, but don't require tags
			merge_state[i] = SpcAbstractVal(typeToKindFlags(results[i]) | IS_STORED, NO_REG, 0);
		}
		ctl.merge_state = merge_state;
		ctl.merge_count = 1;
		// initialize parameters
		var params = sig.params;
		grow(params.length);
		for (i < params.length) {
			// params start on the stack and already have tags
			state[i] = SpcAbstractVal(typeToKindFlags(params[i]) | TAG_STORED | IS_STORED, NO_REG, 0);
		}
		sp = u32.view(params.length);
	}
	// Add the specified number of locals of the specified type.
	def addLocals(count: u32, ltype: ValueType) {
		var nlength = sp + count;
		if (nlength > state.length) grow(int.view(nlength + sp * 2));
		var flags = typeToKindFlags(ltype) | TAG_STORED | IS_CONST; // TODO: store tag of locals
		for (j < count) {
			var k = j + sp;
			state[k] = SpcAbstractVal(flags, NO_REG, 0);
		}
		sp = nlength;
	}
	def pushBlock(params: Array<ValueType>, results: Array<ValueType>, end_label: MasmLabel) -> SpcControl {
		return pushControl(Opcode.BLOCK.code, params, results, end_label);
	}
	def pushLoop(params: Array<ValueType>, results: Array<ValueType>, start_label: MasmLabel) -> SpcControl {
		var ctl = pushControl(Opcode.LOOP.code, params, results, start_label);
		return ctl;
	}
	def prepareLoop(emitSlotTransfer: ((u32, SpcAbstractVal), (u32, SpcAbstractVal)) -> void) {
		var target = ctl_stack.peek();
		target.merge_count = 1;
		target.merge_state = Arrays.range(state, 0, int.view(sp));
		for (i < sp) {
			var from = state[i], to = toMergeVal(from);
			target.merge_state[i] = to;
			state[i] = to;
			if (from != to) emitSlotTransfer((i, to), (i, from));
		}
	}
	def pushIf(params: Array<ValueType>, results: Array<ValueType>, else_label: MasmLabel, end_label: MasmLabel) -> SpcControl {
		var ctl = pushControl(Opcode.IF.code, params, results, end_label);
		ctl.else_label = else_label;
		ctl.reset_state = Arrays.dup(state);
		return ctl;
	}
	def doElse() {
		var c = ctl_stack.peek();
		c.else_label = null;
		// reset state to start of if
		var max = c.val_stack_top + u32.view(c.params.length);
		resetTo(max, c.reset_state);
		c.clearReset();
		if (ctl_stack.top > 1) c.reachable = ctl_stack.elems[ctl_stack.top - 2].reachable;
		else c.reachable = true;
	}
	def resetToMerge(ctl: SpcControl) {
		if (ctl.merge_count > 0) {
			var max = ctl.val_stack_top + u32.view(ctl.results.length);
			resetTo(max, ctl.merge_state);
		}
	}
	def isTransferEmpty(target: SpcControl) -> bool {
		return false; // XXX: approximate
	}
	def emitFallthru(emitSlotTransfer: ((u32, SpcAbstractVal), (u32, SpcAbstractVal)) -> void) {
		emitTransfer(ctl_stack.peek(), emitSlotTransfer);
	}
	def emitTransfer(target: SpcControl, emitSlotTransfer: ((u32, SpcAbstractVal), (u32, SpcAbstractVal)) -> void) {
		if (!ctl_stack.peek().reachable) {
			if (Trace.compiler) OUT.puts("    xfer not reachable").outln();
			return; // do nothing
		}
		if (Trace.compiler) OUT.puts("    xfer").outln();
		var vals = u32.view(if(target.opcode == Opcode.LOOP.code, target.params, target.results).length);
		var top = target.val_stack_top, max = top + vals;
		if (target.merge_count == 0) {
			if (Trace.compiler) OUT.puts("    merge_count=1").outln();
			target.merge_count = 1;
			target.merge_state = Arrays.range(state, 0, int.view(max));
			for (i < top) {
				var from = state[i], to = toMergeVal(from);
				target.merge_state[i] = to;
				if (from != to) emitSlotTransfer((i, to), (i, from));
			}
			for (i < vals) {
				var f = (sp - vals + i), t = top + i;
				var from = state[f], to = toMergeVal(from);
				target.merge_state[t] = to;
				emitSlotTransfer((t, to), (f, from));
			}
		} else {
			if (Trace.compiler) OUT.puts("    merge_count=2+").outln();
			target.merge_count = 2;
			// XXX: allow matching constants in merges
			for (i < top) {
				var from = state[i], to = target.merge_state[i];
				if (from != to) emitSlotTransfer((i, to), (i, from));
			}
			for (i < vals) {
				var f = (sp - vals + i), t = top + i;
				var from = state[f], to = target.merge_state[t];
				// TODO: write tag based on mismatch on this stack's target slot
				emitSlotTransfer((t, to), (f, from));
			}
		}
	}
	def emitSpill(emitSlotTransfer: ((u32, SpcAbstractVal), (u32, SpcAbstractVal)) -> void) {
		if (Trace.compiler) OUT.puts("    spill all").outln();
		for (i < sp) {
			var sv = state[i];
			var stored = IS_STORED | TAG_STORED;
			if (stored == (sv.flags & stored)) continue;
			var tv = SpcAbstractVal(sv.kindFlags(stored), NO_REG, 0);
			var slot = u32.view(i);
			emitSlotTransfer((slot, tv), (slot, sv));
			if (sv.inReg()) regAlloc.free(sv.reg);
		}
	}
	private def toMergeVal(from: SpcAbstractVal) -> SpcAbstractVal {
		// XXX: allow constants in merges
		var force_store = if(!from.inReg(), IS_STORED);
		return SpcAbstractVal((from.flags & ~(IS_CONST)) | force_store, from.reg, 0);
	}
	private def resetTo(max: u32, nstate: Array<SpcAbstractVal>) {
		regAlloc.clear();
		for (i < max) {
			var sv = nstate[i];
			if (sv.inReg()) regAlloc.unfree(sv.reg, int.!(i));
			state[i] = sv;
		}
		sp = max;
	}
	private def pushControl(opcode: byte, params: Array<ValueType>, results: Array<ValueType>, label: MasmLabel) -> SpcControl {
		var ctl = ctl_stack.next();
		var reachable = if(ctl_stack.top > 0, ctl_stack.peek().reachable, true);
		if (ctl != null) { // FAST: reuse previous SpcControl object
			ctl_stack.top++;
			ctl.clearMerge();
			ctl.clearReset();
		} else { // allocate and cache new SpcControl object
			ctl = SpcControl.new();
			ctl_stack.push(ctl);
		}
		ctl.opcode = opcode;
		ctl.label = label;
		ctl.params = params;
		ctl.results = results;
		ctl.val_stack_top = sp - u32.view(params.length);
		ctl.reachable = reachable;
		ctl.merge_count = 0;
		return ctl;
	}
	def getControl(depth: u32) -> SpcControl {
		var result = ctl_stack.elems[ctl_stack.top - int.!(depth) - 1];
		return result;
	}
	def push(flags: byte, reg: Reg, const: int) {
		var sp = this.sp;
		if (sp >= state.length) grow(8 + state.length * 2);
		state[sp] = SpcAbstractVal(flags, reg, const);
		this.sp++;
	}
	def pushV(v: SpcAbstractVal) {
		var sp = this.sp;
		if (sp >= state.length) grow(8 + state.length * 2);
		state[sp] = v;
		this.sp++;
	}
	def get(slot: u32) -> SpcAbstractVal {
		return state[slot];
	}
	def pop() -> SpcAbstractVal {
		if (sp == 0) {
// TODO			err.at(codeptr).set("stack underflow");
			var d: SpcAbstractVal;
			return d;
		}
		var result = state[--this.sp];
		return result;
	}
	def popArgsAndPushResults(sig: SigDecl) {
		sp -= u32.view(sig.params.length); // note: assume registers have been freed
		for (t in sig.results) {
			push(typeToKindFlags(t) | TAG_STORED | IS_STORED, NO_REG, 0);
		}
	}
	def peek() -> SpcAbstractVal {
		return state[this.sp - 1];
	}
	def overwrite(flags: byte, reg: Reg, const: int) {
		state[this.sp - 1] = SpcAbstractVal(flags, reg, const);
	}
	def set(slot: u32, flags: byte, reg: Reg, const: int) {
		state[slot] = SpcAbstractVal(flags, reg, const);
	}
	def setStored(slot: u32) {
		var b = state[slot];
		state[slot] = SpcAbstractVal(b.flags | IS_STORED, b.reg, b.const);
	}
	def setUnreachable() {
		ctl_stack.peek().reachable = false;
	}
	def setNoReg(slot: u32) {
		var b = state[slot];
		state[slot] = SpcAbstractVal(b.flags & ~IN_REG, NO_REG, b.const);
	}
	def grow(nlength: int) {
		state = Arrays.grow(state, nlength);
	}
}
def toTag(vt: ValueType) -> ValueKind {
	match (vt) {
		I32 => return ValueKind.I32;
		I64 => return ValueKind.I64;
		F32 => return ValueKind.F32;
		F64 => return ValueKind.F64;
		V128 => return ValueKind.V128;
		_ => return ValueKind.REF;
	}
}
def typeToKindFlags(vt: ValueType) -> byte {
	match (vt) {
		I32 => return KIND_I32;
		I64 => return KIND_I64;
		F32 => return KIND_F32;
		F64 => return KIND_F64;
		V128 => return KIND_V128;
		_ => return KIND_REF;
	}
}
def kindToFlags(kind: ValueKind) -> byte {
	match (kind) {
		I32 => return KIND_I32;
		I64 => return KIND_I64;
		F32 => return KIND_F32;
		F64 => return KIND_F64;
		V128 => return KIND_V128;
		_ => return KIND_REF;
	}
}

// Specialized routines that work on i32, rather than values.
component Fold_ii_i {
	private def do_ii_z(f: (int, int) -> bool, a: int, b: int) -> int {
		return if(f(a, a), 1);
	}
	private def do_uu_z(f: (u32, u32) -> bool, a: int, b: int) -> int {
		return if(f(u32.view(a), u32.view(b)), 1);
	}
	def I32_EQ = do_ii_z(int.==, _, _);
	def I32_NE = do_ii_z(int.!=, _, _);
	def I32_LT_S = do_ii_z(int.<, _, _);
	def I32_LT_U = do_uu_z(u32.<, _, _);
	def I32_GT_S = do_ii_z(int.>, _, _);
	def I32_GT_U = do_uu_z(u32.>, _, _);
	def I32_LE_S = do_ii_z(int.<=, _, _);
	def I32_LE_U = do_uu_z(u32.<=, _, _);
	def I32_GE_S = do_ii_z(int.>=, _, _);
	def I32_GE_U = do_uu_z(u32.>=, _, _);
}

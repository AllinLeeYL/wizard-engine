// Copyright 2023 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Allocates register from a pool in a fixed priority order, given by the order in {regs}.
// Handles a maximum of 32 registers.
class PriorityRegPool {
	def regs: Array<Reg>;
	private var map: Array<u5>;
	private var freebits = 0xFFFFFFFF;

	new(regs, prev: PriorityRegPool) {
		if (prev == null) {
			var max = int.min;
			for (r in regs) if (r.index > max) max = r.index;
			map = Array<u5>.new(max + 1);
			for (i < regs.length) map[regs[i].index] = u5.!(i);
		} else {
			this.map = prev.map;
			this.freebits = prev.freebits;
		}
	}

	def alloc() -> Reg {
		var f = freebits, i = 0;
		// XXX: use CTZ (count trailing zeroes) instruction
		if ((f & 0xFFFF) == 0) { i += 16; f >>= 16; }
		if ((f & 0xFF) == 0) { i += 8; f >>= 8; }
		if ((f & 0xF) == 0) { i += 4; f >>= 4; }
		if ((f & 0x3) == 0) { i += 2; f >>= 2; }
		if ((f & 0x1) == 0) { i += 1; f >>= 1; }
		if (i >= regs.length) return NO_REG;
		freebits = freebits & ~(1 << u5.view(i));
		return regs[i];
	}
	def unfree(r: Reg) {
		var i = map[r.index];
		freebits = freebits & ~(1 << i);
	}
	def isFree(r: Reg) -> bool {
		if (r.index >= map.length) return true;
		var m = 1 << map[r.index];
		return (freebits & m) == m;
	}
	def free(r: Reg) {
		var i = map[r.index];
		freebits = freebits | (1 << i);
	}
	def copy() -> PriorityRegPool {
		return PriorityRegPool.new(this.regs, this);
	}
	def clear() -> this {
		freebits = 0xFFFFFFFF;
	}
	def unfreeAll() -> this {
		freebits = 0;
	}
}

// A register allocator that has different pools for different register classes.
// When initially allocated, a register configuration has empty priority register
// pools; they must be set with {setPool(i)}.
class RegAlloc {
	def regConfig: RegConfig;
	private var pools: Array<PriorityRegPool>;
	private var assign: Array<int>;

	new(regConfig, prev: RegAlloc) {
		if (prev == null) {
			pools = Array<PriorityRegPool>.new(regConfig.numRegPools);
			assign = Array<int>.new(regConfig.regSet.regs.length);
			for (i < assign.length) assign[i] = -1;
		} else {
			pools = Arrays.dup(prev.pools);
			for (i < pools.length) pools[i] = pools[i].copy();
			assign = Arrays.dup(prev.assign);
		}
	}
	def setPool(i: int, p: PriorityRegPool) {
		pools[i] = p;
	}
	def alloc(kind: ValueKind, assignment: int) -> Reg {
		var pool_index = regConfig.kindToPool[kind.tag];
		if (pool_index < 0) return Reg(0);
		var r = pools[pool_index].alloc();
		if (r.index > 0) assign[r.index] = assignment;
		return r;
	}
	def get(reg: Reg) -> int {
		if (reg.index >= assign.length) return -1;
		return assign[reg.index];
	}
	def free(reg: Reg) {
		var pool_index = regConfig.regToPool[reg.index];
		assign[reg.index] = -1;
		return pools[pool_index].free(reg);
	}
	def isFree(reg: Reg) -> bool {
		return assign[reg.index] < 0;
	}
	def unfree(reg: Reg, assignment: int) {
		var pool_index = regConfig.regToPool[reg.index];
		assign[reg.index] = assignment;
		return pools[pool_index].unfree(reg);
	}
	def clear() -> this {
		for (p in pools) p.clear();
		for (i < assign.length) assign[i] = -1;
	}
	def copy() -> RegAlloc {
		return RegAlloc.new(regConfig, this);
	}
	// Finds the allocated register with the lowest assignment.
	def findSpillCandidate(kind: ValueKind) -> Reg {
		var lowest = int.max, reg: Reg;
		var p = pools[regConfig.kindToPool[kind.tag]];
		var alloc = ~p.freebits;
		var i = 0;
		while (alloc != 0) {
			if (1 == (alloc & 1)) {
				var candidate = p.regs[i];
				var assignment = assign[candidate.index];
				if (assignment < lowest) {
					lowest = assignment;
					reg = candidate;
				}
			}
			alloc = alloc >> 1;
			i++;
		}
		return reg;
	}
}
def NO_REG = Reg(0);

//                 alloc  free   unfree   clear   copy     iter free   iter alloc
// PriorityRegPool     5     1        1       1      1            32           32
// SpcRaPool           1     1        1       a      ?             f            a

// Allocates registers from pool number {poolIndex} from {regConfig}.
//
// Internally, both allocated and free registers are maintained in one doubly-linked list.
// The {freeCursor} points at the first free register, and the free list follows {.next} links.
// Allocated registers are kept in the list pointed to by {freeCursor.prev} and can be iterated by
// following {.prev} links.
//
// links [0, rax,       rbx,     rcx     .... ]
//            v          v         v
//           [rax] <-> [rbx] <-> [rcx]
//                                 ^
//   (allocated registers) <--  freeCursor  --> (free registers)
class SpcRaPool(regConfig: RegConfig, poolIndex: int) {
	private def links = Array<SpcRaPoolLink>.new(regConfig.regSet.regs.length);
	private var freeCursor: SpcRaPoolLink;
	private var last: SpcRaPoolLink;

	new() {
		freeCursor = null;
		freeAll();
	}

	// Free all allocated registers and reset their state in {regState} to be {freeVal}.
	def freeAllAndResetState<T>(regState: Array<T>, freeVal: T) {
		var l = freeCursor;
		while (l.prev != null) {
			var n = l.prev;
			regState[n.reg.index] = freeVal;
			l = n;
		}
		freeCursor = l;
	}
	// Free all registers and reset the order back to the default order in {this.regConfig}.
	def freeAll() {
		freeAllAndResetOrder(regConfig.regSet.regs);
	}
	// Free all registers and reset the allocation order of registers to the order specified in {order}.
	def freeAllAndResetOrder(order: Array<Reg>) {
		var prev: SpcRaPoolLink;
		for (reg in order) {
			if (reg == NO_REG) continue;
			if (regConfig.regToPool[reg.index] != poolIndex) continue; // skip regs not in pool
			var link = links[reg.index];
			if (link != null) link.remove(); // reuse link if possible
			else link = SpcRaPoolLink.new(reg, prev, null);
			if (prev != null) prev.next = link;
			else freeCursor = link;
			links[reg.index] = link;
			prev = link;
		}
		// TODO: what about dangling links not in {order}?
		if (last == null) last = SpcRaPoolLink.new(NO_REG, prev, null);
		else last.prev = prev;
		prev.next = last;
	}
	// Allocate the a register from this pool. Returns {NO_REG} if none available.
	def alloc() -> Reg {
		var result = freeCursor.reg;
		if (result != NO_REG) freeCursor = freeCursor.next;
		return result;
	}
	// Free the given register {reg}.
	def free(reg: Reg) {
		var link = links[reg.index];
		if (link == freeCursor) return; // already free; ok
		if (link == freeCursor.prev) {
			freeCursor = freeCursor.prev; // cheap bump-back of freeCursor
		} else {
			link.remove();
			link.insertBefore(freeCursor); // remove and reinsert before prev
			freeCursor = link;
		}
	}
	// Set the given register {reg} as allocated.
	def unfree(reg: Reg) {
		var link = links[reg.index];
		if (link == freeCursor) {
			freeCursor = freeCursor.next;
		} else {
			link.remove();
			link.insertBefore(freeCursor); // remove and reinsert before prev
		}
	}
	// Call {allocated} and {free} with all appropriate registers.
	def apply<T>(allocated: Reg -> T, free: Reg -> T) {
		for (l = freeCursor.prev; l != null; l = l.prev) allocated(l.reg);
		for (l = freeCursor; l.reg != NO_REG; l = l.next) free(l.reg);
	}
	// Search the allocated list for the register with the minimum associated {cost}.
	// Does not alter the allocation status of the register.
	def findMinAllocated(cost: Reg -> int) -> Reg {
		var minimum = int.max;
		var minReg = NO_REG;
		for (l = freeCursor.prev; l != null; l = l.prev) {
			var reg = l.reg, c = cost(reg);
			if (c == 0) return reg; // can't do better than 0.
			if (c < minimum) {
				minimum = c;
				minReg = reg;
			}
		}
		return minReg;
	}
	// Verify internal states and report errors to {out}. Returns {true} if the verification passed.
	def verify(out: TraceBuilder) -> bool {
		return true;
	}
}

private class SpcRaPoolLink(reg: Reg, var prev: SpcRaPoolLink, var next: SpcRaPoolLink) {
	def remove() -> this {
		var n = next, p = prev;
		if (p != null) p.next = n;
		if (n != null) n.prev = p;
		next = prev = null;
	}
	def insertBefore(that: SpcRaPoolLink) -> this {
		// TODO assert prev == null;
		// TODO assert next == null;
		next = that;
		var p = that.prev;
		prev = p;
		if (p != null) p.next = this;
		that.prev = this;
	}
}

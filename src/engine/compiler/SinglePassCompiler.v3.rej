@@ -521,9 +521,6 @@
 		}
 	}
 
-	def visit_I64_DIV_S() { emitBinop(SpcBinop.I64_DIV_S); }
-	def visit_I64_DIV_U() { emitBinop(SpcBinop.I64_DIV_U); }
-
 	def visit_REF_NULL(ht_index: u31) {
 		state.push(KIND_REF | IS_CONST, NO_REG, 0);
 	}
@@ -554,8 +551,8 @@
 			state.overwrite(sv.kindFlags(IN_REG | (sv.flags & IS_STORED)), reg.reg, 0);
 		}
 	}
-	def visit_EXTERN_INTERNALIZE() { }
-	def visit_EXTERN_EXTERNALIZE() { }
+	def visit_EXTERN_INTERNALIZE() { } // nop
+	def visit_EXTERN_EXTERNALIZE() { } // nop
 
 	def emitSelect1(sv: SpcAbstractVal, fv: SpcAbstractVal, tv: SpcAbstractVal) {
 		var tagStored = tv.flags & TAG_STORED;
@@ -613,15 +610,6 @@
 			freeVal(fv);
 		}
 	}
-	def tryNop(isNop: int -> bool) -> bool {
-		var sv = state.peek();
-		if (sv.isConst() && isNop(sv.const)) {
-			state.pop();
-			freeVal(sv);
-			return true;
-		}
-		return false;
-	}
 	def emitBrIf(sv: SpcAbstractVal, cond: MasmBrCond, label: MasmLabel, target: SpcControl, emptyTransfer: bool) {
 		if (sv.isConst()) {
 			var taken = (sv.const == 0) == cond.zero;
@@ -757,108 +745,6 @@
 			}
 		}
 	}
-	def emitBinop(binop: SpcBinop) {
-		var b = state.pop();
-		var a = state.peek();
-		var tos = u32.!(state.sp - 1);
-		var flags = (a.flags & binop.kind_sig.preserve_flags) | binop.kind_sig.add_flags;
-		if (binop.isNop != null && b.isConst() && binop.isNop(b.const)) {
-			freeVal(b);
-			return;
-		}
-		if (a.inReg()) {
-			// reg const? op x
-			if (b.isConst()) {
-				if (a.isConst() && binop.fold != null) {
-					// fold: const op const
-					var val = binop.fold(a.const, b.const);
-					state.overwrite(flags | IS_CONST, NO_REG, val);
-					freeVal(a);
-					freeVal(b);
-				} else {
-					// reg op const
-					masm.emit_binop_r_i(binop.op, a.reg, b.const);
-					state.overwrite(flags | IN_REG, a.reg, 0);
-					freeVal(b);
-				}
-			} else if (b.inReg()) {
-				if (binop.commute != Opcode.UNREACHABLE && a.isConst()) {
-					// commute: const op reg -> reg op const
-					masm.emit_binop_r_i(binop.commute, b.reg, a.const);
-					state.overwrite(flags | IN_REG, b.reg, 0);
-					freeVal(a);
-				} else {
-					// reg op reg
-					masm.emit_binop_r_r(binop.op, a.reg, b.reg);
-					state.overwrite(flags | IN_REG, a.reg, 0);
-					freeVal(b);
-				}
-			} else {
-				// reg op slot
-				masm.emit_binop_r_m(binop.op, a.reg, masm.slotAddr(tos+1));
-				state.overwrite(flags | IN_REG, a.reg, 0);
-			}
-		} else if (a.isConst()) {
-			// const op x
-			if (b.isConst()) {
-				if (binop.fold != null) {
-					// fold: const op const
-					var val = binop.fold(a.const, b.const);
-					state.overwrite(flags | IS_CONST, NO_REG, val);
-					freeVal(a);
-					freeVal(b);
-				} else if (binop.commute != Opcode.UNREACHABLE && b.inReg()) {
-					// commute const op reg -> reg op const
-					masm.emit_binop_r_i(binop.commute, b.reg, a.const);
-					state.overwrite(flags | IN_REG, b.reg, 0);
-				} else {
-					// load: a reg -> reg op reg
-					var reg_a = allocReg(binop.kind_sig.a_kind);
-					masm.emit_mov_r_i(reg_a.reg, a.const);
-					masm.emit_binop_r_i(binop.op, reg_a.reg, b.const);
-					state.overwrite(flags | IN_REG, reg_a.reg, 0);
-					freeVal(b);
-				}
-			} else if (b.inReg()) {
-				// const op reg
-				if (binop.commute != Opcode.UNREACHABLE && b.inReg()) {
-					// commute const op reg -> reg op const
-					masm.emit_binop_r_i(binop.commute, b.reg, a.const);
-					state.overwrite(flags | IN_REG, b.reg, 0);
-				} else {
-					var reg_a = allocReg(ValueKind.I32);
-					masm.emit_mov_r_i(reg_a.reg, a.const);
-					masm.emit_binop_r_r(binop.op, reg_a.reg, b.reg);
-					state.overwrite(flags | IN_REG, reg_a.reg, 0);
-					freeVal(b);
-				}
-			} else {
-				// const op slot
-				var reg_a = allocReg(binop.kind_sig.a_kind);
-				masm.emit_mov_r_i(reg_a.reg, a.const);
-				masm.emit_binop_r_m(binop.op, reg_a.reg, masm.slotAddr(tos+1));
-				state.overwrite(flags | IN_REG, reg_a.reg, 0);
-				// XXX: if commute: load rb, binop_r_i
-			}
-		} else {
-			var reg_a = allocReg(binop.kind_sig.a_kind);
-			emit_read_slot_r(tos, reg_a);
-			// slot op x
-			if (b.isConst()) {
-				// slot op const
-				masm.emit_binop_r_i(binop.op, reg_a.reg, b.const);
-			} else if (b.inReg()) {
-				// slot op reg
-				masm.emit_binop_r_r(binop.op, reg_a.reg, b.reg);
-			} else {
-				// slot op slot
-				masm.emit_binop_r_m(binop.op, reg_a.reg, masm.slotAddr(tos+1));
-			}
-			// XXX: if commute: binop_r_m
-			state.overwrite(flags | IN_REG, reg_a.reg, 0);
-			freeVal(b);
-		}
-	}
 	def unsupported() {
 		success = false; // XXX: add opcode
 	}

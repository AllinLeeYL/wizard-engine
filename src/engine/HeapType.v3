// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Heap type declarations.
class HeapTypeDecl(supertypes: Array<HeapType>) extends Decl {
	var hash = 0;
	var canon_id = -1;
	var recgrp_index = 0;
	var rttObject: RttObject;

	def render(buf: StringBuilder) -> StringBuilder;
}

// Packedness and mutability for fields and array elements. (ext:gc)
enum Packedness { UNPACKED, PACKED_I8, PACKED_I16 }
type StorageType(valtype: ValueType, packing: Packedness, mutable: bool) { }

// Struct type declaration. (ext:gc)
class StructDecl extends HeapTypeDecl {
	def field_types: Array<StorageType>;
	var struct_index = -1;
	def defaultable = allHaveDefaultValues(field_types);

	new(supertypes: Array<HeapType>, field_types) super(supertypes) {}

	def render(buf: StringBuilder) -> StringBuilder {
		return buf.put1("struct #%d", struct_index);
	}
}

// Array type declaration. (ext:gc)
class ArrayDecl extends HeapTypeDecl {
	def elem_types: Array<StorageType>;
	var array_index = -1;
	def defaultable = allHaveDefaultValues(elem_types);

	new(supertypes: Array<HeapType>, elem_types) super(supertypes) {}

	def render(buf: StringBuilder) -> StringBuilder {
		return buf.put1("array #%d", array_index);
	}
}

// Signature of a function.
class SigDecl extends HeapTypeDecl {
	def params: Array<ValueType>;
	def results: Array<ValueType>;
	var sig_index = -1;

	new(supertypes: Array<HeapType>, params, results) super(supertypes) {}

	def bindLeft(count: int) -> SigDecl {
		var p = params, np = Array<ValueType>.new(p.length - count);
		for (i < np.length) np[i] = p[i + count];
		return SigDecl.new(ValueTypes.NO_HEAPTYPES, np, results); // TODO: bindLeft of SigDecl.supertypes
	}
	def isAssignableSig(that: SigDecl) -> bool {
		if (that == null) return false;
		var fp = this.params, tp = that.params;
		if (fp.length != tp.length) return false;
		var fr = this.results, tr = that.results;
		if (fr.length != tr.length) return false;
		for (i < fp.length) {
			if (!ValueTypes.isAssignable(tp[i], fp[i])) return false; // contra-variant
		}
		for (i < fr.length) {
			if (!ValueTypes.isAssignable(fr[i], tr[i])) return false; // co-variant
		}
		return true;
	}
	def render(buf: StringBuilder) -> StringBuilder {
		return render2(null, buf);
	}
	def render2(seen: List<Decl>, buf: StringBuilder) -> StringBuilder {
		for (l = seen; l != null; l = l.tail) {
			if (l.head == this) return buf.put1("#%d", sig_index);
		}
		seen = List.new(this, seen);
		buf.puts("[");
		for (i < params.length) {
			if (i > 0) buf.puts(" ");
			ValueTypes.render(params[i], seen, buf);
		}
		buf.puts("] -> [");
		for (i < results.length) {
			if (i > 0) buf.puts(" ");
			ValueTypes.render(results[i], seen, buf);
		}
		buf.puts("]");
		return buf;
	}
	def dup() -> SigDecl {
		return SigDecl.new(supertypes, params, results);
	}
}

def allHaveDefaultValues(at: Array<StorageType>) -> bool {
	for (t in at) if (!ValueTypes.hasDefaultValue(t.valtype)) return false;
	return true;
}

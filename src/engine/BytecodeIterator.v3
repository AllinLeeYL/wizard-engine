// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A simple iterator for bytecodes in a function.
class BytecodeIterator(func: FuncDecl) {
	private def codeptr = CodePtr.new(func.code.orig, null);
	private var pc: int;
	new() {
		// skip local declarations
		codeptr.skip_local_decls();
		pc = codeptr.pos;
	}
	def immptr() -> Decoder {
		return codeptr.at(pc + 1);
	}
	def more() -> bool {
		return pc < codeptr.limit;
	}
	def current() -> Opcode {
		if (more()) {
			var b = codeptr.at(pc).read_u8();
			if (Opcodes.attributes[b].PREFIX) return Opcodes.find(b, codeptr.read_u8());
			else return Opcodes.opcodes[b];
		}
		return Opcode.NOP;
	}
	def next() {
		if (more()) {
			var p = codeptr.at(pc);
			for (imm in current().imms) {
				match (imm) {
					BLOCK_TYPE,
					FUNC_INDEX,
					TABLE_INDEX,
					PARAM_INDEX,
					LOCAL_INDEX,
					GLOBAL_INDEX,
					MEMORY_INDEX,
					ELEM_INDEX,
					DATA_INDEX,
					SIG_INDEX,
					STRUCT_TYPE_INDEX,
					ARRAY_TYPE_INDEX,
					HEAP_TYPE_INDEX,
					FIELD_INDEX,
					SUPER_COUNT,
					LABEL => p.read_u32leb();
					VALUE_TYPES => codeptr.read_value_types();
					LABELS => {
						var count = p.read_u32leb();
						for (i < count + 1) p.read_u32leb();
					}
					MEMARG => {
						p.read_u32leb();
						p.read_u32leb();
					}
					REF_NULL_TYPE,
					I32 => p.read_i32leb();
					I64 => p.read_i64leb();
					F32 => p.skip_bytes(4);
					F64 => p.skip_bytes(8);
					LOCAL_DECL => p.skip_local_decls();
					ZERO_BYTE => p.read_u8();
				}
			}
			pc = p.pos;
		}
	}
}

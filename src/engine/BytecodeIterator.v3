// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A simple iterator for bytecodes in a function.
class BytecodeIterator(func: FuncDecl) {
	private def decoder = Decoder.new(func.code.orig, null);
	private var pc: int;
	new() {
		var codeptr = decoder;
		// skip local declarations
		var count = codeptr.read_u32leb();
		for (i < count) {
			var d = codeptr.read_u32leb();
			var t = codeptr.read_u32leb();
		}
		pc = codeptr.pos;
	}
	def immptr() -> Decoder {
		return decoder.at(pc + 1);
	}
	def more() -> bool {
		return pc < decoder.limit;
	}
	def current() -> Opcode {
		if (more()) {
			var b = decoder.at(pc).read_u8();
			if (Opcodes.attributes[b].PREFIX) return Opcodes.find(b, decoder.read_u8());
			else return Opcodes.opcodes[b];
		}
		return Opcode.NOP;
	}
	def next() {
		if (more()) {
			var p = decoder.at(pc);
			match (current().imm) {
				NONE => ;
				BLOCK_TYPE,
				FUNC_INDEX,
				TABLE_INDEX,
				PARAM_INDEX,
				LOCAL_INDEX,
				GLOBAL_INDEX,
				MEMORY_INDEX,
				ELEM_INDEX,
				DATA_INDEX,
				LABEL => p.read_u32leb();
				VALUE_TYPE => p.read_i32leb();
				VALUE_TYPES => {
					var count = p.read_u32leb();
					for (i < count) p.read_i32leb();
				}
				LABELS => {
					var count = p.read_u32leb();
					for (i < count + 1) {
						p.read_u32leb();
					}
				}
				TABLE_TABLE_INDEX,
				ELEM_TABLE_INDEX,
				SIG_TABLE_INDEX,
				MEMORY_MEMORY_INDEX,
				DATA_MEMORY_INDEX,
				MEMARG => {
					p.read_u32leb();
					p.read_u32leb();
				}
				I32 => p.read_i32leb();
				I64 => p.read_i64leb();
				F32 => p.skip_bytes(4);
				F64 => p.skip_bytes(8);
				BLOCK_TYPE_LOCALS => {
					p.read_u32leb(); // block type
					var count = p.read_u32leb(); // local count
					for (i < count) {
						var c = p.read_u32leb(); // count
						var t = p.read_i32leb(); // value type
					}
				}
			}
			pc = p.pos;
		}
	}
}

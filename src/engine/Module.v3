// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Mutable in-memory representation of a WebAssembly module.
class Module(filename: string) {
	def types = IndexSpace<TypeDecl>.new();
	def imports = Vector<ImportDecl>.new();
	def functions = IndexSpace<FunctionDecl>.new();
	def tables = IndexSpace<TableDecl>.new();
	def memories = IndexSpace<MemoryDecl>.new();
	def globals = IndexSpace<GlobalDecl>.new();
	def events = Vector<EventDecl>.new(); /* ext:exception-handling */
	def exports = Vector<ExportDecl>.new();
	var start_function = -1;
	var explicit_data_count = -1;
	def elems = Vector<ElemDecl>.new();
	def data = Vector<DataDecl>.new();
	def custom_sections = Vector<CustomSection>.new();
}

// An index space may have a number of imported entities, which get indices
// before declared entities.
class IndexSpace<T> {
	def imported = Vector<T>.new();
	def declared = Vector<T>.new();
	def [i: int] -> T {
		if (i < imported.length) return imported[i];
		else return declared[i - imported.length];
	}
	def size() -> int {
		return imported.length + declared.length;
	}
	def usize() -> u32 {
		return u32.!(imported.length + declared.length);
	}
}

// Signature of a function.
class FuncSig(params: Array<ValueType>, results: Array<ValueType>) {
	def bindParam(index: u32) -> FuncSig {
		var p = params, np = Array<ValueType>.new(p.length-1);
		for (i < index) np[i] = p[i];
		for (i = index + 1; i < p.length; i++) np[i-1] = p[i];
		return FuncSig.new(np, results);
	}
	def isAssignableSig(that: FuncSig) -> bool {
		if (that == null) return false;
		var fp = this.params, tp = that.params;
		if (fp.length != tp.length) return false;
		var fr = this.results, tr = that.results;
		if (fr.length != tr.length) return false;
		for (i < fp.length) {
			if (!ValueTypes.isAssignable(tp[i], fp[i])) return false; // contra-variant
		}
		for (i < fr.length) {
			if (!ValueTypes.isAssignable(fr[i], tr[i])) return false; // co-variant
		}
		return true;
	}
	def render(buf: StringBuilder) -> StringBuilder {
		buf.puts("[");
		for (i < params.length) {
			if (i > 0) buf.puts(" ");
			ValueTypes.render(buf, params[i]);
		}
		buf.puts("] -> [");
		for (i < results.length) {
			if (i > 0) buf.puts(" ");
			ValueTypes.render(buf, results[i]);
		}
		buf.puts("]");
		return buf;
	}
}

// A type declaration that can occur in the types section.
type TypeDecl {
	case Function(f: FuncSig);
	case Imported(import_index: int, t: ImportedType);
	/* ext:gc case Struct() */
}

// Import declaration, including module name, element name, and details,
// including kind.
class ImportDecl(modname: string, name: string, details: ImportDetails) {
}

// The details for each of the different kinds of imports.
type ImportDetails {
	case Function(decl: FunctionDecl);
	case Table(decl: TableDecl);
	case Memory(decl: MemoryDecl);
	case Global(decl: GlobalDecl);
	case Type(decl: TypeDecl.Imported);
	/* ext:exception-handling Event() */
}
class ImportedType(assignable: Array<ValueType>) extends ExternType {
	def isAssignableTo(t: ValueType) -> bool {
		match (t) {
			Extern(ext) => if (this == ext) return true;
			EXTERNREF => return true;
			_ => ;
		}
		for (s in assignable) {
			if (ValueTypes.isAssignable(s, t)) return true;
		}
		return false;
	}
}
// A function declaration than can occur in the function section.
class FunctionDecl(index: int, sig_index: int, var sig: FuncSig) {
	var code: FunctionCode;
	var reffed: bool;
}
// A table declaration that can occur in the tables section.
class TableDecl(index: int, elemtype: ValueType, initial: int, maximum: int) {
}

// A memory declaration that can occur in the memories section.
class MemoryDecl(index: int, initial: int, maximum: int, /* ext: threads */ shared: bool) {
}

// A global declaration that can occur in the globals section.
class GlobalDecl(index: int, valtype: ValueType, mutable: bool, init: InitExpr) {
}

// ext:exception-handling
class EventDecl(attribute: int, evntype_index: int, evntype: FuncSig) {
}

// An export declaration for a module.
class ExportDecl(name: string, details: ExportDetails) {
}

// The details for each of the different kinds of exports.
type ExportDetails {
	case Function(index: int);
	case Table(index: int);
	case Memory(index: int);
	case Global(index: int);
	/* ext:type-imports case Type() */
	/* ext:exception-handling Event() */
}

// An element declaration that can occur in the elements section.
class ElemDecl(elemtype: ValueType, mode: SegmentMode, details: ElemDetails) {
}
type ElemDetails {
	case FuncRefs(vals: Array<int>);
	case Exprs(vals: Array<InitExpr>); /* ext:reference-types */
	def length() -> int {
		match (this) {
			FuncRefs(vals) => return vals.length;
			Exprs(vals) => return vals.length;
		}
	}
}
type SegmentMode {
	case Passive;
	case Active(index: int, offset: InitExpr);
	case Declarative;
}

// A data segment declaration that can occur in the data section.
class DataDecl(mode: SegmentMode, data: Array<byte>) {
}

// An uninterpreted custom section.
class CustomSection(name: string, payload: Array<byte>) {
}

// The names section is a special custom section that is interpreted by
// engines to aid in debugging.
class NamesSection extends CustomSection {
	new(data: Array<byte>) super("names", data) { }
}

// A special kind of expression that can be used in initialization.
type InitExpr {
	case I32(val: i32);
	case I64(val: i64);
	case F32(val: u32);
	case F64(val: u64);
	case FuncRefNull;
	case ExternRefNull;
	case Global(global_index: int, decl: GlobalDecl);
	case FuncRef(func_index: int, decl: FunctionDecl);
}

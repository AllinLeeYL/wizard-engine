// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class ImportInfo(module_name: string, field_name: string, import_index: int, args: Array<Decl>) {
}

class Decl {
	var imp: ImportInfo;
	var decl_index: int;
	def imported() -> bool { return imp != null; }
}

class DefTypeDecl extends Decl {
}

class StructDecl(field_types: Array<ValueType>, field_mut: Array<bool>) extends DefTypeDecl {
	var struct_index: int;
}

class ArrayDecl(elem_types: Array<ValueType>, elem_mut: Array<bool>) extends DefTypeDecl {
	var array_index: int;
}

class AbsTypeDecl(assignable: Array<ValueType>) extends Decl {
	var abstype_index: int;
	def isAssignableTo(t: ValueType) -> bool {
		match (t) {
			Abstract(it) => if (this == it) return true;
			EXTERNREF => return true;
			_ => ;
		}
		for (s in assignable) {
			if (ValueTypes.isAssignable(s, t)) return true;
		}
		return false;
	}
}

class FuncDecl(sig: SigDecl) extends Decl {
	var func_index: int;
	var code: Code;
	var reffed: bool;
}

class TableDecl(elemtype: ValueType, initial: u32, maximum: Max) extends Decl {
	var table_index: int;
}

class MemoryDecl(initial: u32, maximum: Max, shared: bool) extends Decl {
	var memory_index: int;
}

class GlobalDecl(valtype: ValueType, mutable: bool, init: InitExpr) extends Decl {
	var global_index: int;
}

class EventDecl(fieldTypes: Array<ValueType>) extends Decl {
	var event_index: int;
}

class ImportCommandDecl extends Decl {
}

// Representation of a module, including its various index spaces of declarations.
// Keeps the original order of declarations in order to perform polymorphic
// import binding.
class Module(filename: string) {
	def decls = Vector<Decl>.new();  // all declarations
	def imports = Vector<Decl>.new(); // all imports

	def deftypes = Vector<DefTypeDecl>.new();
	def abstypes = Vector<AbsTypeDecl>.new();
	def functions = Vector<FuncDecl>.new();
	def tables = Vector<TableDecl>.new();
	def memories = Vector<MemoryDecl>.new();
	def globals = Vector<GlobalDecl>.new();
	def events = Vector<EventDecl>.new();

	def exports = Vector<(string, Decl)>.new();

	var start_function = -1;
	var explicit_data_count = -1;
	def elems = Vector<ElemDecl>.new();
	def data = Vector<DataDecl>.new();
	def custom_sections = Vector<CustomSection>.new();

	// Add a new declaration to this module. Automatically manages the various
	// index spaces and updates {d.decl_index} and any space-specific indexes.
	def addDef(d: Decl) {
		d.decl_index = decls.length;
		decls.put(d);
		match (d) {
			x: SigDecl => { x.sig_index = deftypes.length; deftypes.put(x); }
			x: StructDecl => { x.struct_index = deftypes.length; deftypes.put(x); }
			x: ArrayDecl => { x.array_index = deftypes.length; deftypes.put(x); }
			x: AbsTypeDecl => { x.abstype_index = abstypes.length; abstypes.put(x); }
			x: FuncDecl => { x.func_index = functions.length; functions.put(x); }
			x: TableDecl => { x.table_index = tables.length; tables.put(x); }
			x: MemoryDecl => { x.memory_index = memories.length; memories.put(x); }
			x: GlobalDecl => { x.global_index = globals.length; globals.put(x); }
			x: EventDecl => { x.event_index = events.length; events.put(x); }
		}
	}
	// Add a new import declaration to this module. Adds this declaration to {imports} as well.
	def addImport(module_name: string, field_name: string, args: Array<Decl>, d: Decl) {
		if (d == null) return;
		if (args == null) args = Modules.NO_IMPORT_ARGS;
		d.imp = ImportInfo.new(module_name, field_name, imports.length, args);
		addDef(d);
		imports.put(d);
	}

	def getSig(sig_index: int) -> SigDecl {
		return SigDecl.!(deftypes[sig_index]);
	}
	def isAbstract() -> bool {
		return abstypes.length > 0;
	}
	def getRefType(nullable: bool, type_index: int) -> ValueType {
		var decl = deftypes[type_index];
		match (decl) {
			x: SigDecl => return ValueType.RefFunc(nullable, x);
			x: StructDecl => return ValueType.RefStruct(nullable, x);
			x: ArrayDecl => return ValueType.RefArray(nullable, x);
		}
		System.error("InternalError", "unexpected def type");
		return ValueType.EXTERNREF;
	}
}


// Signature of a function.
class SigDecl(params: Array<ValueType>, results: Array<ValueType>) extends DefTypeDecl {
	var sig_index: int;
	def bindParam(index: u32) -> SigDecl {
		var p = params, np = Array<ValueType>.new(p.length-1);
		for (i < index) np[i] = p[i];
		for (i = index + 1; i < p.length; i++) np[i-1] = p[i];
		return SigDecl.new(np, results);
	}
	def isAssignableSig(that: SigDecl) -> bool {
		if (that == null) return false;
		var fp = this.params, tp = that.params;
		if (fp.length != tp.length) return false;
		var fr = this.results, tr = that.results;
		if (fr.length != tr.length) return false;
		for (i < fp.length) {
			if (!ValueTypes.isAssignable(tp[i], fp[i])) return false; // contra-variant
		}
		for (i < fr.length) {
			if (!ValueTypes.isAssignable(fr[i], tr[i])) return false; // co-variant
		}
		return true;
	}
	def render(buf: StringBuilder) -> StringBuilder {
		buf.puts("[");
		for (i < params.length) {
			if (i > 0) buf.puts(" ");
			params[i].render(buf);
		}
		buf.puts("] -> [");
		for (i < results.length) {
			if (i > 0) buf.puts(" ");
			results[i].render(buf);
		}
		buf.puts("]");
		return buf;
	}
	def dup() -> SigDecl {
		return SigDecl.new(params, results);
	}
}

// An element declaration that can occur in the elements section.
class ElemDecl(elemtype: ValueType, mode: SegmentMode, details: ElemDetails) {
}
type ElemDetails {
	case FuncRefs(vals: Array<int>);
	case Exprs(vals: Array<InitExpr>); /* ext:reference-types */
	def length() -> int {
		match (this) {
			FuncRefs(vals) => return vals.length;
			Exprs(vals) => return vals.length;
		}
	}
}
type SegmentMode {
	case Passive;
	case Active(index: int, offset: InitExpr);
	case Declarative;
}

// A data segment declaration that can occur in the data section.
class DataDecl(mode: SegmentMode, data: Array<byte>) {
}

// An uninterpreted custom section.
class CustomSection(name: string, payload: Array<byte>) {
}

// The names section is a special custom section that is interpreted by
// engines to aid in debugging.
class NamesSection extends CustomSection {
	new(data: Array<byte>) super("names", data) { }
}

// A special kind of expression that can be used in initialization.
type InitExpr {
	case I32(val: i32);
	case I64(val: i64);
	case F32(val: u32);
	case F64(val: u64);
	case FuncRefNull;
	case ExternRefNull;
	case Global(global_index: int, decl: GlobalDecl);
	case FuncRef(func_index: int, decl: FuncDecl);
}
// Optional maximum for a table or memory.
type Max {
	case None;
	case Set(max: u32);

	def min(that: u32) -> u32 {
		match (this) {
			None => return that;
			Set(max) => return if(max < that, max, that);
		}
	}
	def check(val: u64) -> bool {
		match (this) {
			None => return true;
			Set(max) => return val <= max;
		}
	}
}

// Globals associated with modules.
component Modules {
	def NO_IMPORT_ARGS: Array<Decl> = [];
}
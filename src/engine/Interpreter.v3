// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Executes wasm code.
class Interpreter {
	var state: ExecState;			// current execution state
	var trap_reason: TrapReason;		// trap reason, if any
	var error_msg: string;			// error message associated with trap

	// overwrite these fields to handle breaks, traps and timeouts
	var handleTrap: (TrapReason) -> Resumption = defaultTrap;

	// Reset the interpreter state and run the function {f} on the arguments {args}.
	// Limits the execution to maximum {count} bytecodes. If {count < 0}, run
	// until exhausting, trap, or break.
	def run(f: Function, args: Array<Value>) -> Result;

	// Get the top frame of the interpreter.
	def getTopFrame() -> Frame;
	def getCallStack() -> ArrayStack<Frame>;

	// Traces calls to host functions.
	def traceCallHostFunction(hf: HostFunction) {
		var c = getCallStack();
		for (i < c.top) Trace.OUT.sp();
		Trace.OUT.put2("callHost(\"%q\": %q)", hf.render, hf.sig.render).outln();
	}
	// Fires probes on the global interpreter loop
	def fireProbes(func: WasmFunction, pc: int) -> bool {
		state = ExecState.PROBING;
		var r = Execute.probes.fire(func, pc);
		return resume(r);
	}
	// Fires probes on a specific instruction
	def fireProbesAt(func: WasmFunction, pc: int) -> bool {
		var probes = func.instance.module.probes;
		if (probes == null) return true;
		var map = probes[func.decl.func_index];
		if (map == null) return true;
		state = ExecState.PROBING;
		var list = map[pc];
		var r = list.fire(func, pc);
		if (list.elem == null) map[pc] = null;
		return resume(r);
	}
	def resume(r: Resumption) -> bool {
		match (r) {
			Continue => {
				state = if(Execute.probes.elem == null, ExecState.RUN_FAST, ExecState.RUN_SLOW);
				return true;
			}
			Trap(reason, trace) => { // TODO: add exception backtrace
				trap_reason = reason;
				state = ExecState.TRAPPED;
				return false;
			}
		}
	}
}

// Internal execution states of the interpreter.
enum ExecState {
	STOPPED,	// not yet begun
	RUN_FAST,	// running instructions
	RUN_SLOW,	// running instructions, with per-instruction probe
	FINISHED,	// finished bottom-most invocation
	TRAPPED		// finished with a trap
	TRAPPING,	// handling trap in synchronous handleTrap()
	PROBING,	// executing synchronous probe code
}

// Internal representation of execution frames.
class Frame { // TODO: move to V3Interpreter
	var func: WasmFunction;
	var fp: int;
	var pc: int;
	var xip: int;
}

// The various ways user code can resume from a break, trap, or timeout
type Resumption {
	case Continue;
	case Trap(reason: TrapReason, trace: bool);
}

def defaultBreak() -> Resumption {
	return Resumption.Continue;
}
def defaultTrap(reason: TrapReason) -> Resumption {
	return Resumption.Trap(reason, false);
}

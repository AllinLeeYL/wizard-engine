// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Executes wasm code.
class Interpreter {
	var state: ExecState;			// current execution state
	var trap_reason: TrapReason;		// trap reason, if any
	var error_msg: string;			// error message associated with trap
	var step_count: int;			// total number of steps executed
	var limits = Limits.new();		// limits on execution/memory

	// overwrite these fields to handle breaks, traps and timeouts
	var handleBreak: () -> Resumption = defaultBreak;
	var handleTrap: (TrapReason) -> Resumption = defaultTrap;

	// Reset the interpreter state and run the function {f} on the arguments {args}.
	// Limits the execution to maximum {count} bytecodes. If {count < 0}, run
	// until exhausting, trap, or break.
	def run(count: int, f: Function, args: Array<Value>) -> Result;

	// Get the top frame of the interpreter.
	def getTopFrame() -> Frame;
	def getCallStack() -> ArrayStack<Frame>;

	// Traces calls to host functions.
	def traceCallHostFunction(hf: HostFunction) {
		var c = getCallStack();
		for (i < c.top) Trace.OUT.sp();
		Trace.OUT.put2("callHost(\"%q\": %q)", hf.render, hf.sig.render).outln();
	}
	def insertProbeBefore(p: Probe);
	def removeProbeBefore(p: Probe);
}

// Internal execution states of the interpreter.
enum ExecState {
	STOPPED,	// not yet begun
	RUN_FAST,	// running instructions
	RUN_SLOW,	// running instructions, with per-instruction probe
	FINISHED,	// finished bottom-most invocation
	TRAPPED		// finished with a trap
	BREAKPOINT,	// handling breakpoint in synchronous handleBreak()
	TRAPPING,	// handling trap in synchronous handleTrap()
	PROBING,	// executing synchronous probe code
}

// Reasons a WebAssembly execution has trapped.
enum TrapReason {
	NONE,
	UNREACHABLE,
	MEM_OUT_OF_BOUNDS,
	UNALIGNED_ACCESS,
	DIV_BY_ZERO,
	DIV_UNREPRESENTABLE,
	FLOAT_UNREPRESENTABLE,
	FUNC_INVALID,
	FUNC_SIG_MISMATCH,
	DATA_SEGMENT_DROPPED,
	ELEM_SEGMENT_DROPPED,
	TABLE_OUT_OF_BOUNDS,
	STACK_OVERFLOW,
	NULL_DEREF,
	UNIMPLEMENTED,
	ARRAY_INDEX_OOB,
	OOM,
	FAILED_CAST,
	INVALID_OPCODE,
	TIMEOUT,
	BREAK,
	ERROR
}

type Result {
	case Break {}
	case Value(vals: Array<Value>) {}
	case Trap(reason: TrapReason) {}
	def equals(that: Result) -> bool {
		if (this == that) return true;
		if (Result.Value.?(this) && Result.Value.?(that)) {
			var a = Result.Value.!(this).vals;
			var b = Result.Value.!(that).vals;
			if (a == b) return true;
			if (a == null) return false;
			if (b == null) return false;
			if (a.length != b.length) return false;
			for (i < a.length) if (a[i] != b[i]) return false;
			return true;
		}
		return false;
	}
	def render(buf: StringBuilder) -> StringBuilder {
		match (this) {
			Break => buf.puts("break");
			Value(vals) => {
				if (vals == null) {
					buf.puts("<null>");
				} else if (vals.length == 1) {
					vals[0].render(buf);
				} else {
					Values.renderVals(buf, vals);
				}
			}
			Trap(reason) => buf.put1("trap %s", reason.name);
		}
		return buf;
	}
}

// Internal representation of execution frames.
class Frame { // TODO: move to V3Interpreter
	var func: WasmFunction;
	var fp: int;
	var pc: int;
	var xip: int;
}

// The various ways user code can resume from a break, trap, or timeout
type Resumption {
	case Continue;
	case Trap(reason: TrapReason, trace: bool);
}

def defaultBreak() -> Resumption {
	return Resumption.Continue;
}
def defaultTrap(reason: TrapReason) -> Resumption {
	return Resumption.Trap(reason, false);
}

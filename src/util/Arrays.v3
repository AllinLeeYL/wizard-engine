// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Utility methods for arrays.
component Arrays {
	def clear<T>(array: Array<T>) {
		var d: T;
		for (i < array.length) array[i] = d;
	}
	def grow<T>(array: Array<T>, nlength: int) -> Array<T> {
		var narray = Array<T>.new(nlength);
		for (i < array.length) narray[i] = array[i];
		return narray;
	}
	def growV<T>(array: Array<T>, nlength: int, val: T) -> Array<T> {
		var narray = Array<T>.new(nlength);
		for (i < array.length) narray[i] = array[i];
		for (i = array.length; i < narray.length; i++) narray[i] = val;
		return narray;
	}
	def range<T>(array: Array<T>, start: int, end: int) -> Array<T> {
		var len = end - start;
		var narray = Array<T>.new(len);
		for (i < len) narray[i] = array[i + start];
		return narray;
	}
	def copyInto<T>(dst: Array<T>, dst_start: int,
			src: Array<T>, src_start: int, src_end: int) {
		var len = src_end - src_start;
		for (i < len) dst[dst_start + i] = src[src_start + i];
	}
	def dup<T>(array: Array<T>) -> Array<T> {
		var r = Array<T>.new(array.length);
		for (i < array.length) r[i] = array[i];
		return r;
	}
	// prepend a single {val} to an {array}, returning a new array
	def prepend<T>(val: T, array: Array<T>) -> Array<T> {
		var max = array.length;
		if (array == null || max == 0) return [val];
		var narray = Array<T>.new(max + 1);
		narray[0] = val;
		for (i < max) narray[i + 1] = array[i];
		return narray;
	}
	// append a single {val} to an {array}, returning a new array
	def append<T>(val: T, array: Array<T>) -> Array<T> {
		var result = grow(array, array.length + 1);
		result[array.length] = val;
		return result;
	}
	def boundsCheck<T>(data: Array<T>, offset: u32, index: u32, size: u32) -> int {
		var length = if(data != null, u64.!(data.length));
		var x = u64.!(offset) + u64.!(index);
		return if(x + size > length, int.min, int.!(x));
	}
	def safeCopy<T>(dst: Array<T>, dst_offset: u32, src: Array<T>, src_offset: u32, size: u32) -> bool {
		var i = boundsCheck(dst, 0, dst_offset, size);
		if (i < 0) return false;
		var j = boundsCheck(src, 0, src_offset, size);
		if (j < 0) return false;
		if (src == dst && i > j) { // potentially overlapping, copy in reverse
			var max = int.!(size) - 1;
			for (k = max; k >= 0; k--) dst[i + k] = src[j + k];
		} else {
			for (k < int.!(size)) dst[i + k] = src[j + k];
		}
		return true;
	}
	def safeCopyF<D, S>(dst: Array<D>, dst_offset: u32, src: Array<S>, src_offset: u32, size: u32, f: S -> D) -> bool {
		var i = boundsCheck(dst, 0, dst_offset, size);
		if (i < 0) return false;
		var j = boundsCheck(src, 0, src_offset, size);
		if (j < 0) return false;
		for (k < int.!(size)) {
			dst[i + k] = f(src[j + k]);
		}
		return true;
	}
	def map<A, B>(a: Array<A>, f: A -> B) -> Array<B> {
		if (a == null) return null;
		var b = Array<B>.new(a.length);
		for (i < b.length) b[i] = f(a[i]);
		return b;
	}
}
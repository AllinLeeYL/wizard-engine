// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

component Utf8 {
	// Returns {true} if the given string is valid UTF-8, false otherwise.
	def validate(str: string) -> bool {
		return findError(str) < 0;
	}
	// Returns the offset of any UTF-8 encoding error in the given string.
	// Returns {-1} if there is no error in the given string.
	def findError(str: string) -> int {
		if (str == null) return -1;
		var i = 0;
		while (i < str.length) {
			var b = str[i++], codepoint: u32 = b;
			if ((b & 0x80) == 0) continue;

			// Compute how many continuation bytes there are.
			var extra = 0, min = 0u;
			if ((b & 0b11100000u) == 0b11000000u) {
				extra = 1;
				min = 0x80u;
			} else if ((b & 0b11110000u) == 0b11100000u) {
				extra = 2;
				min = 0x800u;
			} else if ((b & 0b11111000u) == 0b11110000u) {
				extra = 3;
				min = 0x10000u;
			} else {
				return i; // completely invalid character
			}

			// Check the continuation bytes and compute the codepoint.
			var next = i + extra;
			codepoint = codepoint & ~(0xFFFFFFFFu << u5.!(6 - extra));
			if (next > str.length) return i;
			while (i < next) {
				var b = str[i++];
				if ((b & 0b11000000u) != 0b10000000u) return i;
				codepoint = codepoint << 6 | (b & 0b00111111u);
			}
			// Check for invalid codepoints.
			if (codepoint > 0x10FFFF) return i; // not encodable by UTF-16
			if (codepoint >= 0xD800 && codepoint <= 0xDFFF) return i; // UTF-16 surrogates
			if (codepoint >= 0xFFFE && codepoint <= 0xFFFF) return i; // special characters
			// Check for overlong character.
			if (codepoint < min) return 1;
		}
		return -1;
	}
}

// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

component Utf8 {
	// Returns {true} if the given string is valid UTF-8, false otherwise.
	def validate(str: string) -> bool {
		return findError(str) < 0;
	}
	// Returns the offset of any UTF-8 encoding error in the given string.
	// Returns {-1} if there is no error in the given string.
	def findError(str: string) -> int {
		if (str == null) return -1;
		var i = 0;
		while (i < str.length) {
			var b = str[i++], codepoint: u32 = b;
			if ((b & 0x80) == 0) continue;

			// Compute how many continuation bytes there are.
			var extra = 0, min = 0u;
			if ((b & 0b11100000u) == 0b11000000u) {
				extra = 1;
				min = 0x80u;
			} else if ((b & 0b11110000u) == 0b11100000u) {
				extra = 2;
				min = 0x800u;
			} else if ((b & 0b11111000u) == 0b11110000u) {
				extra = 3;
				min = 0x10000u;
			} else {
				return i; // completely invalid character
			}

			// Check the continuation bytes and compute the codepoint.
			var next = i + extra;
			codepoint = codepoint & ~(0xFFFFFFFFu << u5.!(6 - extra));
			if (next > str.length) return i;
			while (i < next) {
				var b = str[i++];
				if ((b & 0b11000000u) != 0b10000000u) return i;
				codepoint = codepoint << 6 | (b & 0b00111111u);
			}
			// Check for invalid codepoints.
			if (!isValidCodepoint(codepoint)) return i;
			// Check for overlong character.
			if (codepoint < min) return 1;
		}
		return -1;
	}
	// Encode the given codepoint into the {dest} array at {pos}, assuming there
	// is enough space for up to maximum 4 bytes, returning the number of bytes
	// used. If the codepoint cannot be encoded into UTF-8 (e.g. is invalid),
	// return {0}.
	def encode(codepoint: u32, dest: Array<byte>, pos: int) -> int {
		if (!isValidCodepoint(codepoint)) return 0;
		if (codepoint < (1 << 7)) {
			dest[pos] = byte.!(codepoint);
			return 1;
		}
		if (codepoint < (1 << 11)) {
			dest[pos]   = byte.!((codepoint >> 6) | 0b11000000u);
			dest[pos+1] = byte.!((0b00111111u & codepoint) | 0b10000000u);
			return 2;
		}
		if (codepoint < (1 << 16)) {
			dest[pos]   = byte.!((codepoint >> 12) | 0b11100000u);
			dest[pos+1] = byte.!((0b00111111u & (codepoint >> 6)) | 0b10000000u);
			dest[pos+2] = byte.!((0b00111111u & codepoint) | 0b10000000u);
			return 3;
		}
		dest[pos]   = byte.!((codepoint >> 18) | 0b11110000u);
		dest[pos+1] = byte.!((0b00111111u & (codepoint >> 12)) | 0b10000000u);
		dest[pos+2] = byte.!((0b00111111u & (codepoint >> 6)) | 0b10000000u);
		dest[pos+3] = byte.!((0b00111111u & codepoint) | 0b10000000u);
		return 4;
	}
	def isValidCodepoint(codepoint: u32) -> bool {
		if (codepoint > 0x10FFFF) return false; // not encodable by UTF-16
		if (codepoint >= 0xD800 && codepoint <= 0xDFFF) return false; // UTF-16 surrogates
		// TODO(utf8): validation should reject special substitution characters?
//		if (codepoint >= 0xFFFE && codepoint <= 0xFFFF) return false; // special characters
		return true;
	}
}

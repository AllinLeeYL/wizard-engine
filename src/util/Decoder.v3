// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A decoder is a helper class for parsing a stream of bytes into a structured
// format, offering routines to read bytes, integers, LEBs, etc. A decoder
// has state for whether an error occurred, keeping the first (earliest position)
// error. Read operations only succeed if all of the data they expect is
// in the current buffer and instead signal an end-of-file error if they
// would go past the end of the current buffer. When the caller has more data
// to supply, they can use the append() and extract() calls to create new
// instances that remember the position from the beginning of the
// stream but do not retain any bytes before the current position.
def LEB32_MAX_LENGTH = 5;
def LEB64_MAX_LENGTH = 10;
class Decoder(data: Array<byte>) {
	var pos: int;
        var context: string;
        var eof_flag: bool;
        var error_pos = int.max;
        var error_msg: string;
        var limit = data.length;
        // N.B. this field tracks the number of bytes from the beginning of a stream,
        // i.e. bytes skipped by append() and extract() calls. Thus an {error_pos}
        // is always relative to the start of the current {data} buffer, and its
        // absolute position is {error_pos + skipped}.
        var skipped: int;

	// Checks whether any error has occured yet and returns {true} if not.
	def ok() -> bool {
        	return error_pos == int.max;
        }
	// Checks whether any error has occurred yet and returns {true} if so.
        def error() -> bool {
        	return error_pos < int.max;
        }
        // Checks whether the input has been completely consumed.
	def done() -> bool {
        	return pos >= limit;
        }
        // Checks whether more input remains.
        def more() -> bool {
        	return pos < limit;
        }
        // Returns the number of available bytes.
        def available() -> int {
        	var diff = limit - pos;
                return if(diff > 0, diff);
        }
        // Returns {true} if the first error encountered was an end-of-file.
        def eof() -> bool {
        	return eof_flag && error_pos < int.max;
        }
        // Set the current position of the decoder.
        def at(npos: int) -> this {
        	pos = npos;
        }
	// Set the current position of the decoder and reset any EOF error.
	def reset(npos: int) -> this {
                pos = npos;
                if (eof_flag) {
                	error_pos = int.max;
                        error_msg = null;
                        eof_flag = false;
                }
        }
	// Record an error at the current position.
	def fail(msg: string) -> this {
        	fail_at(pos, msg);
        }
        // Record an error at the given position, if there is not already an
        // error at an earlier position. Resets the limit for early termination.
        def fail_at(pos: int, msg: string) -> this {
        	if (error_pos <= pos) return;
                error_pos = pos;
                error_msg = msg;
                eof_flag = false;
                limit = 0;
        }
        // Record an end-of-file for the quantity beginning at the given position.
        def eof_at(pos: int, msg: string) -> this {
        	if (error_pos <= pos) return;
                error_pos = pos;
                error_msg = msg;
                eof_flag = true;
        }

	// Read a single byte.
	def read_u8() -> byte {
        	if (pos >= limit) {
                	eof_at(pos, "expected byte");
                        return 0;
                }
                return data[pos++];
        }
        // Read a 4-byte quantity as an unsigned integer.
        def read_u32() -> u32 {
        	if (limit - pos < 4) {
                	eof_at(pos, "expected 4-byte integer");
                        return 0;
                }
		var b0: u32 = data[pos];
		var b1: u32 = data[pos + 1];
		var b2: u32 = data[pos + 2];
		var b3: u32 = data[pos + 3];
		pos += 4;
		var result = (b3 << 24) | (b2 << 16) | (b1 << 8) | b0;
		return result;
        }
        // Read an unsigned 32-bit LEB-encoded integer, returning (length, value)
        def read_u32leb() -> (int, u32) {
        	var t = read_x32leb();
                if (t.2 != 0) fail_at(pos - t.0, "LEB out of unsigned 32-bit range");
		return (t.0, t.1);                
        }
        // Read an unsigned 32-bit LEB-encoded integer, returning (length, value).
        def read_i32leb() -> (int, i32) {
        	var t = read_x32leb();
                if (t.2 != 0 && t.2 != u3.max) fail_at(pos - t.0, "LEB out of signed 32-bit range");
		return (t.0, int.!(t.1));                
        }
        // Common routine between signed and unsigned 32-bit LEBs. Returns
        // (length, value, upper), as signed and unsigned check the upper 3 bits
        // (5 x 7 - 32) slightly differently.
        private def read_x32leb() -> (int, u32, u8) {
        	var result: u32;
        	var max = pos + LEB32_MAX_LENGTH;
                if (max < limit) max = limit;
                var p = pos, shift: u5 = 0;
                while (p < max) {
                	var b = data[p++];
                        result = result | u32.!(b & 0x7F) << shift;
                        if (b < 0x80) {
                        	var length = p - pos;
                                var upper = if(length == LEB32_MAX_LENGTH, b >> 4);
                                pos = p;
                                return (length, result, upper);
                        }
                        shift += 7;
                }
                if (p == pos) eof_at(pos, "expected LEB");
                else eof_at(pos, "unterminated LEB");
                return (0, 0, 0);
        }
        // Read an unsigned 64-bit LEB-encoded integer, returning (length, value).
        def read_u64leb() -> (int, u64) {
        	var t = read_x64leb();
                if (t.2 != 0) fail_at(pos - t.0, "LEB out of unsigned 64-bit range");
		return (t.0, t.1);                
        }
        // Read a signed 64-bit LEB-encoded integer, returning (length, value).
        def read_i64leb() -> (int, i64) {
        	var t = read_x64leb();
                if (t.2 != 0 && t.2 != u6.max) fail_at(pos - t.0, "LEB out of signed 64-bit range");
		return (t.0, i64.!(t.1));                
        }
        // Common routine between signed and unsigned 32-bit LEBs. Returns
        // (length, value, upper), as signed and unsigned check the upper 6 bits
        // (10 x 7 - 64) slightly differently.
        private def read_x64leb() -> (int, u64, u8) {
        	var result: u64;
        	var max = pos + LEB64_MAX_LENGTH;
                if (max < limit) max = limit;
                var p = pos, shift: u6 = 0;
                while (p < max) {
                	var b = data[p++];
                        result = result | u64.!(b & 0x7F) << shift;
                        if (b < 0x80) {
                        	var length = p - pos;
                                var upper = if(length == LEB64_MAX_LENGTH, b >> 1);
                                pos = p;
                                return (length, result, upper);
                        }
                        shift += 7;
                }
                if (p == pos) fail("EOF expecting LEB");
                else fail("EOF in unterminated LEB");
                return (0, 0, 0);
        }

	// Read a string of {length} bytes.
        def read_bytes(length: int) -> string {
        	if (limit - pos < length) {
	                eof_at(pos, "EOF expecting N bytes"); // TODO: better error msg
                        return Array.new(length);
                }
               	var result = Array<byte>.new(length);
                for (i < length) result[i] = data[pos + i];
                pos += length;
                return result;
        }
	// Check that a string of {length} bytes could be read. Signals an EOF error
        // if not possible.
        def check_bytes(length: int) -> bool {
        	if (limit - pos < length) {
	                eof_at(pos, "EOF expecting N bytes"); // TODO: better error msg
                }
                return eof();
        }

	// Append more data to the buffer of this decoder, returning a new decoder
        // if necessary. In either case, the returned decoder will have its EOF flag
        // reset. The {hint} parameter is a size hint so that if a new buffer needs
        // to be created, it can be made large enough to accommodate future {append()}
        // calls.
	def append(hint: int, x: Array<byte>, xpos: int, xlength: int) -> Decoder {
		if ((data.length - limit) >= xlength) {
			// There is enough space to copy into this decoder's buffer.
		        for (i < xlength) {
				data[pos + i] = x[xpos + i];
			}
			limit += xlength;
			reset(pos);  // reset EOF
                        return this;
		} else {
			// Not enough space. Copy the old data and the new data together
			// into a new buffer in a new decoder.
                        var avail = available();
			var combined = avail + xlength;
			var nlength = if(hint > combined, hint, combined);
			var nbuf = Array<byte>.new(nlength);
			for (i < avail) {
				nbuf[i] = data[pos + i];
			}
			for (i < xlength) {
				nbuf[avail + i] = x[xpos + i];
			}
			var result = Decoder.new(nbuf);
			result.limit = combined;
                        result.error_pos = error_pos - pos;
                        result.error_msg = error_msg;
                        result.skipped = pos;
                        return result;
		}
	}
        // Extract the available bytes from this decoder, producing a new decoder.
        // The new decoder will have its EOF flag equal to this one's.
        def extract(hint: int) -> Decoder {
                var avail = available();
		var nlength = if(hint > avail, hint, avail);
		var nbuf = Array<byte>.new(nlength);
		for (i < avail) {
			nbuf[i] = data[pos + i];
		}
                var result = Decoder.new(nbuf);
                result.limit = avail;
                result.error_pos = error_pos - pos;
                result.error_msg = error_msg;
                result.eof_flag = eof_flag;
                result.skipped = skipped + pos;
                return result;
	}
}
// A utility class to represent either a successfully decoded item or an error.
class Decoded<T>(filename: string, offset: int, length: int, result: T, error_msg: string) {
        def ok() -> bool {
        	return error_msg == null;
        }
}

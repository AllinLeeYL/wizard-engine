// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Utility for parsing a stream of bytes into a structured format, offering
// routines to read bytes, integers, LEBs, etc. A decoder has state for whether
// an error occurred, keeping the first (earliest position) error. Read
// operations only succeed if all of the data they expect is in the current
// buffer and instead signal an end-of-file error if they would go past the end
// of the current buffer. When the caller has more data to supply, they can use
// the {append()} and {divest()} calls add data to this buffer while minding
// propering aliasing.
class Decoder(var data: Array<byte>, err: ErrorGen) {
	var pos: int;
	var limit = data.length;
	// Number of bytes skipped by append(), used for absolute position.
	var pos_offset: int;
	// End-of-file behavior function called upon EOF.
	var eof_behavior: (Decoder, int, int, string) -> void;

	new() {
		eof_behavior = Decoder.eof_error;
	}

	// Check whether the input has been completely consumed.
	def done() -> bool {
		return pos >= limit;
	}
	// Check whether more input remains, i.e. {!done()}.
	def more() -> bool {
		return pos < limit;
	}
	// Return the number of available bytes.
	def available() -> int {
		var diff = limit - pos;
		return if(diff > 0, diff);
	}
	// Set the current position of the decoder.
	def at(npos: int) -> this {
		pos = npos;
	}
	// Calculate the absolute offset of a given position.
	def abs(pos: int) -> int {
		return pos + pos_offset;
	}
	// Calculate the absolute offset of the current position.
	def abs_pos() -> int {
		return pos + pos_offset;
	}
	// Set the current position of the decoder.
	def reset(x: Array<byte>, xpos: int, xlength: int) -> this {
		pos_offset = 0;
		err.reset();
		data = x;
		pos = xpos;
		limit = xpos + xlength;
	}
	// Record an error at the current position.
	def fail(msg: string) -> this {
		fail_at(pos, msg, ());
	}
	// Record an error at the given position, if there is not already an
	// error at an earlier position.
	def fail_at<T>(pos: int, msg: string, arg: T) -> this {
		if (err.abs(pos + pos_offset).set(msg)) {
			err.error_msg = Strings.format1(msg, arg);
		}
	}
	// Record end-of-file for a read beginning at the given position.
	def eof_at(pos: int, size: int, msg: string) -> this {
		eof_behavior(this, pos, size, msg);
	}
	// Read a single byte.
	def read_u8() -> byte {
		if (pos >= limit) {
			eof_at(pos, 1, "expected byte");
			return 0;
		}
		return data[pos++];
	}
	// Peak a single byte, if available. Returns {-1} if EOF.
	def peek_u8() -> int {
		return if(pos >= limit, -1, data[pos]);
	}
	// Read a 4-byte quantity as an unsigned integer.
	def read_u32() -> u32 {
		if (limit - pos < 4) {
			eof_at(pos, 4, "expected %d bytes");
			return 0;
		}
		var b0: u32 = data[pos];
		var b1: u32 = data[pos + 1];
		var b2: u32 = data[pos + 2];
		var b3: u32 = data[pos + 3];
		pos += 4;
		var result = (b3 << 24) | (b2 << 16) | (b1 << 8) | b0;
		return result;
	}
	// Read a 8-byte quantity as an unsigned integer.
	def read_u64() -> u64 {
		if (limit - pos < 8) {
			eof_at(pos, 8, "expected %d bytes");
			return 0;
		}
		var w0 = read_u32();
		var w1 = read_u32();
		return (u64.!(w1) << 32) | w0;
	}
	// Read an unsigned 32-bit LEB-encoded integer.
	def read_u32leb() -> u32 {
		return read_x32leb(false, "LEB out of unsigned 32-bit range");
	}
	// Read a signed 32-bit LEB-encoded integer.
	def read_i32leb() -> i32 {
		return int.!(read_x32leb(true, "LEB out of signed 32-bit range"));
	}
	private def check_leb_ext(b: byte, signed: bool, shift: u3, msg: string) {
		if ((b & 0x80) != 0) {
			fail("overlong LEB");
			return;
		}
		if (signed) {
			var upper = i7.!(b) >> (shift - u3.!(1));
			if (upper != 0 && upper != -1) fail(msg);
		} else {
			var upper = i7.!(b) >> shift;
			if (upper != 0) fail(msg);
		}
	}
	private def read_x32leb(signed: bool, msg: string) -> u32 {
		var result: u32, p = pos, shift = 0;
		while (p < limit) {
			var b = data[p++];
			result = result | u32.!(b & 0x7F) << u5.!(shift);
			shift += 7;
			if (shift == 35) { // consumed (special) 5th byte
				// check upper bits of last byte and extension
				check_leb_ext(b, signed, 4, msg);
				pos = p;
				return result;
			}
			if (b < 0x80) { // no continuation byte
				if (signed) { // perform sign-extension
					var rem = u5.!(0 - shift);
					result = u32.!(i32.!(result << rem) >> rem);
				}
				pos = p;
				return result;
			}
		}
		if (p == pos) eof_at(pos, 1, "expected LEB");
		else eof_at(pos, 0, "unterminated LEB");
		return 0;
	}
	// Read an unsigned 64-bit LEB-encoded integer.
	def read_u64leb() -> u64 {
		return read_x64leb(false, "LEB out of unsigned 64-bit range");
	}
	// Read a signed 64-bit LEB-encoded integer.
	def read_i64leb() -> i64 {
		return i64.!(read_x64leb(true, "LEB out of signed 64-bit range"));
	}
	private def read_x64leb(signed: bool, msg: string) -> u64 {
		var result: u64, p = pos, shift = 0;
		while (p < limit) {
			var b = data[p++];
			result = result | u64.!(b & 0x7F) << u6.!(shift);
			shift += 7;
			if (shift == 70) { // consumed (special) 10th byte
				// check upper bits of last byte and extension
				check_leb_ext(b, signed, 1, msg);
				pos = p;
				return result;
			}
			if (b < 0x80) { // no continuation byte
				if (signed) { // perform sign-extension
					var rem = u6.!(0 - shift);
					result = u64.!(i64.!(result << rem) >> rem);
				}
				pos = p;
				return result;
			}
		}
		if (p == pos) eof_at(pos, 1, "expected LEB");
		else eof_at(pos, 0, "unterminated LEB");
		return 0;

	}
	// Read {length} bytes, copying them into a new array.
	def read_bytes(length: int) -> Array<byte> {
		if (limit - pos < length) {
			eof_at(pos, length, "expecting %d bytes");
			return [];
		}
		var result = Arrays.range(data, pos, pos + length);
		pos += length;
		return result;
	}
	// Check that a string of {length} bytes could be read. Records an EOF
	// error if not possible.
	def check_bytes(length: int) -> bool {
		if (limit - pos < length) {
			eof_at(pos, length, "expecting %d bytes");
			return false;
		}
		return true;
	}
	// Skip {length} bytes.
	def skip_bytes(length: int) {
		if (limit - pos < length) {
			eof_at(pos, length, "expecting %d bytes");
			return;
		}
		pos += length;
	}
	// Append more data to the buffer of this decoder. Reuse the provided
	// buffer {x}, i.e. *alias* it, if there is no remaining data in the
	// internal buffer. The caller may specify an {expecting} argument that
	// it is expecting a given number of bytes, and thus this method should
	// preallocate more space to avoid future reallocations.
	def append(expecting: int, x: Array<byte>, xpos: int, xlength: int) -> this {
		if ((data.length - limit) >= xlength) {
			// Enough space to copy into this decoder's buffer.
			for (i < xlength) data[limit + i] = x[xpos + i];
			limit += xlength;
			return;
		}
		var avail = available(), diff = 0;
		if (avail == 0 && x.length >= expecting) {
			// Reuse {x} in-place by aliasing it.
			diff = pos - xpos;
			data = x;
			pos = xpos;
			limit = xpos + xlength;
		} else {
			// Not enough space. Copy the old data and the new data
			// together into a new buffer.
			var combined = avail + xlength;
			var nlength = if(expecting > combined, expecting, combined);
			var nbuf = Array<byte>.new(nlength);
			for (i < avail) nbuf[i] = data[pos + i];
			for (i < xlength) nbuf[avail + i] = x[xpos + i];

			diff = pos;
			data = nbuf;
			pos = 0;
			limit = combined;
		}
		pos_offset += diff;
	}
	// Divest from the given buffer {alias} so that this decoder no longer
	// aliases it. Callers should use this method if they have previously
	// provided {alias} to this decoder through the constructor or
	// {append()} but now need to reuse {alias}.
	def divest(expecting: int, alias: Array<byte>) -> this {
		if (alias != data) return; // nothing to do
		var avail = available();
		var nlength = if(expecting > avail, expecting, avail);
		var nbuf = Array<byte>.new(nlength);
		Arrays.copyInto(nbuf, 0, data, pos, pos + avail);
		data = nbuf;
		pos_offset += pos;
		limit = avail;
		pos = 0;
	}
	// Default behavior for end-of-file: signal an error.
	def eof_error(pos: int, size: int, msg: string) {
		var buf = StringBuilder.new();
		buf.puts("EOF: ");
		buf.put1(msg, size);
		err.abs(pos + pos_offset).set(buf.extract());
	}
	// Populate the given sub-decoder with the range of bytes from {pos}
	// to {pos+length}.
	def sub_bytes(d: Decoder, length: int) {
		if (limit - pos < length) {
			eof_at(pos, length, "expecting %d bytes");
			if (pos < limit) pos = limit;  // consume remaining
			return;
		}
		d.data = data;
		d.pos = this.pos;
		d.limit = this.pos + length;
		d.pos_offset = this.pos_offset;
		this.pos += length;
	}
}

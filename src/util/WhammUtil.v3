// Copyright 2024 Wizard authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Represents a declared parameter to a Whamm probe call.
type WhammParam {
	case DynamicLoc;
	case FrameAccessor;
	case Pc;
	case Func;
	case Imm(orig: Token, i: u31);
	case Stack(orig: Token, i: u31);
	case Local(orig: Token, i: u31);
	case Call(target: Token, params: Array<WhammParam>);

	def render(buf: StringBuilder) -> StringBuilder {
		match (this) {
			DynamicLoc => return buf.puts("loc");
			FrameAccessor => return buf.puts("frame");
			Pc => return buf.puts("pc");
			Func => return buf.puts("func");
			Imm(orig, i) => return buf.put1("imm%d", i);
			Stack(orig, i) => return buf.put1("arg%d", i);
			Local(orig, i) => return buf.put1("local%d", i);
			Call(target, params) => {
				buf.puts(target.image);
				buf.putc('(');
				for (i < params.length) {
					if (i > 0) buf.csp();
					params[i].render(buf);
				}
				buf.putc(')');
				return buf;
			}
		}
	}
}

// {WhammParam}s are converted to {WhammArg}s when they are bound at a match site.
// After a match is determined, some probe parameters can be turned into constants
// (e.g. func, pc), while others (e.g. local slot) have their types determined by the
// match location. Similarly, calls will be evaluated at the match site and replaced
// with their results.
type WhammArg {
	case FrameAccessor;
	case Val(v: Value);
	case Operand(t: ValueType, i: int);
	case Local(t: ValueType, i: int);
}

// Utilities associated with Whamm probes.
component WhammUtil {
	def parseParams(r: TextReader) -> Array<WhammParam> {
		var params = Vector<WhammParam>.new();
		r.req1('(');
		while (r.pos < r.limit) {
			if (r.char == ')') {
				r.advance1();
				break;
			}
			var p = parseParam0(r);
			if (!r.ok) break;
			params.put(p);

			if (r.char == ',') {
				r.advance1();
				continue;
			} else {
				r.req1(')');
				break;
			}
		}
		return params.extract();
	}
}

def parseParam0(r: TextReader) -> WhammParam {
	var i = r.star_rel(0, isAlphaOrUnderscore);
	var id = r.data[r.pos ... i];
	if (Ranges.equal("arg", id)) return parseUint(r, i, WhammParam.Stack);
	if (Ranges.equal("imm", id)) return parseUint(r, i, WhammParam.Imm);
	if (Ranges.equal("local", id)) return parseUint(r, i, WhammParam.Local);

	i = r.star_rel(i - r.pos, isIdentChar);
	var token = r.readToken(i - r.pos);

	if (r.char == '(') {
		var params = WhammUtil.parseParams(r);
		return WhammParam.Call(token, params);
	}

	if (Strings.equal("pc", token.image)) return WhammParam.Pc;
	if (Strings.equal("func", token.image)) return WhammParam.Func;
	if (Strings.equal("frame", token.image)) return WhammParam.FrameAccessor;

	r.setFirstError(token.beginLine, token.beginColumn, Strings.format1("Unresolved identifier: \"%s\"", token.image));
	return WhammParam.DynamicLoc;
}
def parseUint<T>(r: TextReader, i: int, f: (Token, u31) -> T) -> T {
	var token = r.readToken(i);
	var t = Ints.parsePosDecimal(r.data, r.pos + i);
	if (t.0 > 0) {
		var token = r.readToken(i + t.0);
		return f(token, u31.!(t.1));
	}
	r.failRel(i, "expected positive integer");
	var d: T;
	return d;
}
def isAlphaOrUnderscore(ch: byte) -> bool {
	return (ch >= 'a' && ch <= 'z')
		|| (ch >= 'A' && ch <= 'Z')
		|| ch == '_';
}
def isIdentChar(ch: byte) -> bool {
	return (ch >= 'a' && ch <= 'z')
		|| (ch >= 'A' && ch <= 'Z')
		|| (ch >= '0' && ch <= '9')
		|| ch == '_' || ch == '$';
}

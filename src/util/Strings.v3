// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Utility routines for strings.
component Strings {
	def hexMap_l = "0123456789abcdef";
	def hexMap_u = "0123456789ABCDEF";
	def equals(a: string, b: string) -> bool {
        	if (a == b) return true;
                if (a.length != b.length) return false;
                for (i < a.length) if (a[i] != b[i]) return false;
                return true;
        }
        def endsWith(str: string, end: string) -> bool {
        	if (str.length <= end.length) return false;
                for (i < end.length) {
                	if (str[str.length - i - 1] != end[end.length - i - 1]) return false;
                }
                return true;
        }
	def format1<T>(fmt: string, arg: T) -> string {
		return StringBuffer.new().put1(fmt, arg).extract();
	}
	def format2<T, U>(fmt: string, arg1: T, arg2: U) -> string {
		return StringBuffer.new().put2(fmt, arg1, arg2).extract();
	}
	def format3<T, U, V>(fmt: string, arg1: T, arg2: U, arg3: V) -> string {
		return StringBuffer.new().put3(fmt, arg1, arg2, arg3).extract();
	}
}
// An object with formatting capabilities for strings, including the ability to render
// integers, characters, strings, etc according to printf-like format specifiers.
// This class supports these specifiers:
//   %d - render an integer as a decimal
//   %c - render an integer as an 8-bit ASCII character
//   %s - inline a string argument
//   %x - render an integer as a 0-padded hexadecimal of natural width
//   %z - render a boolean as "true" or "false"
//   %q - call a closure of type StringBuffer -> StringBuffer
class StringBuffer {
	private var pos: int;
	private var buf: Array<byte>;

	// Format a string, rendering (1) argument according to {fmt}.
	def put1<T1>(fmt: string, p1: T1) -> this {
		var offset = 0;
		offset = putArg(fmt, offset, p1);
		finishFmt(fmt, offset);
	}
	// Format a string, rendering (2) arguments according to {fmt}.
	def put2<T1, T2>(fmt: string, p1: T1, p2: T2) -> this {
		var offset = 0;
		offset = putArg(fmt, offset, p1);
		offset = putArg(fmt, offset, p2);
		finishFmt(fmt, offset);
	}
	// Format a string, rendering (3) arguments according to {fmt}.
	def put3<T1, T2, T3>(fmt: string, p1: T1, p2: T2, p3: T3) -> this {
		var offset = 0;
		offset = putArg(fmt, offset, p1);
		offset = putArg(fmt, offset, p2);
		offset = putArg(fmt, offset, p3);
		finishFmt(fmt, offset);
	}

	// Append the portion of the format string from {offset} up to and including
	// the next argument, returning the position after the next argument.
	private def putArg<T>(fmt: string, offset: int, p: T) -> int {
		var t = putUpToArg(fmt, offset);
		match (t.0) {
			-1 => ;
			'd' => putd(p);
			'c' => putc(byte.!(p));
			'x' => putx(p);
			's' => puts(string.!(p));
			'z' => putz(bool.!(p));
			'q' => putq(p);
			_ => {
				System.error("FormatError", "invalid format specifier");
			}
		}
		return t.1;
	}

	private def finishFmt(fmt: string, offset: int) {
		var t = putUpToArg(fmt, offset);
		if (t.0 != -1) System.error("FormatError", "too many format specifiers");
	}

	// Append the portion of the format string from {offset} up to and *not* including
	// the next argument. (Factored out in order to avoid code duplication due to
	// monomorphization).
	private def putUpToArg(fmt: string, offset: int) -> (int, int) {
		var start = offset, end = fmt.length;
		acquire(end - start);
		while (true) {
			if (offset == end) { // End of string.
				break;
			}
			var c1 = fmt[offset];
			if (c1 != '%') {  // Normal character (not a "%").
				buf[pos++] = c1;
				offset++;
				continue;
			}
			if (offset == end - 1) { // Last character.
				buf[pos++] = c1;
				offset++;
				break;
			}
			
			var c2 = fmt[offset+1];
			if (c2 == '%') { // Escaped percent "%%"
				buf[pos++] = c2;
				offset += 2;
				start = offset;
				continue;
			}
			// Return the format character to caller for dispatch.
			return (c2, offset + 2);
		}
		return (-1, offset);
	}

	// Append an integer (of any width) as decimal.
	def putd<T>(i: T) -> this {
		if (i32.?(i)) putd_i32(i32.!(i));
		else if (u32.?(i)) putd_u32(u32.!(i));
		else if (i64.?(i)) putd_i64(i64.!(i));
		else if (u64.?(i)) putd_u64(u64.!(i));
		else if (u8.?(i)) putd_u32(u32.!(i));
		else System.error("TypeError", "not an integer"); 
	}
	// Append a signed 32-bit integer as decimal.
	def putd_i32(i: i32) -> this {
		if (i < 0) { // negative, invert and use unsigned routine
			if (i == i32.min) { // special case where 0-i == i
				puts("-2147483648");
			} else {
				acquire(11);
				buf[pos++] = '-';
				putd_u32(u32.!(0 - i));
			}
			return;
		}
		putd_u32(u32.!(i)); // non-negative, use unsigned routine
	}
	// Append an unsigned 32-bit integer as decimal.
	def putd_u32(i: u32) -> this {
		if (i < 10) {  // fastpath for small integers.
			acquire(1);
			buf[pos++] = Strings.hexMap_u[int.!(i)];
			return;
		}
		if (i < 100) { // fastpath for small integers.
			acquire(2);
			buf[pos++] = Strings.hexMap_u[int.!(i / 10)];
			buf[pos++] = Strings.hexMap_u[int.!(i % 10)];
			return;
		}
		acquire(10);
		var nonZero = false;
		// TODO(fast): worth it to compute digits low to high? 1 divide vs 2.
		for (radix = 1000000000u; radix > 0; radix = radix / 10) {
			var digit = int.!(i / radix);
			i = i % radix;
			if (digit != 0) nonZero = true;
			if (nonZero) buf[pos++] = Strings.hexMap_u[digit];
		}
	}
	// Append a signed 64-bit integer as decimal.
	def putd_i64(i: i64) -> this {
		var small = i32.!(i);
		if (small == i) { putd_i32(small); return; } // use more efficient 32-bit routine.
		if (i < 0) { // negative, invert and use unsigned routine
			if (i == i64.min) { // special case where 0-i == i
				puts("-9223372036854775808");
			} else {
				acquire(20);
				buf[pos++] = '-';
				putd_u64(u64.!(0 - i));
			}
			return;
		}
		putd_u64(u64.!(i)); // non-negative, use unsigned routine
	}
	// Append an unsigned 64-bit integer as decimal.
	def putd_u64(i: u64) -> this {
		var small = u32.!(i);
		if (small == i) { putd_u32(small); return; } // use more efficient 32-bit routine.
		acquire(20);
		var nonZero = false;
		// TODO(fast): worth it to compute digits low to high? 1 divide vs 2.
		for (radix = 10000000000000000000ul; radix > 0; radix = radix / 10) {
			var digit = int.!(i / radix);
			i = i % radix;
			if (digit != 0) nonZero = true;
			if (nonZero) buf[pos++] = Strings.hexMap_u[digit];
		}
	}
	// Append an integer (of any width) as hexadecimal.
	def putx<T>(i: T) -> this {
		if (i32.?(i)) putx_32(u32.!(i));
		else if (u32.?(i)) putx_32(u32.!(i));
		else if (i64.?(i)) putx_64(u64.!(i));
		else if (u64.?(i)) putx_64(u64.!(i));
		else if (i16.?(i)) putx_16(u16.!(i));
		else if (u16.?(i)) putx_16(u16.!(i));
		else if (u8.?(i)) putx_8(u8.!(i));
		else System.error("TypeError", "not an integer"); 
	}
	// Append an 8-bit integer as hexadecimal (e.g. 0F).
	def putx_8(i: u32) -> this {
		acquire(2);
		var n1 = int.!((i >> 4) & 0xF), n2 = int.!((i >> 0) & 0xF);
		buf[pos++] = Strings.hexMap_u[n1];
		buf[pos++] = Strings.hexMap_u[n2];
	}
	// Append a 16-bit integer as hexadecimal (e.g. 034F).
	def putx_16(i: u32) -> this {
		acquire(4);
		var shift: u5 = 12;
		while (true) {
			var nibble = int.!((i >> shift) & 0xF);
			buf[pos++] = Strings.hexMap_u[nibble];
			if (shift == 0) break;
			shift -= 4;
		}
	}
	// Append a 32-bit integer as hexadecimal (e.g. 0673401F).
	def putx_32(i: u32) -> this {
		acquire(8);
		var shift: u5 = 28;
		while (true) {
			var nibble = int.!((i >> shift) & 0xF);
			buf[pos++] = Strings.hexMap_u[nibble];
			if (shift == 0) break;
			shift -= 4;
		}
	}
	// Append a 64-bit integer as hexadecimal (e.g. 0673401FEE77881122).
	def putx_64(i: u64) -> this {
		acquire(16);
		var shift: u6 = 60;
		while (true) {
			var nibble = int.!((i >> shift) & 0xF);
			buf[pos++] = Strings.hexMap_u[nibble];
			if (shift == 0) break;
			shift -= 4;
		}
	}
	// Append a byte as a character.
	def putc(c: byte) -> this {
		var p = acquire(1);
		buf[pos++] = c;
	}
	// Append a string.
	def puts(s: string) -> this {
		var n = s.length, p = acquire(n);
		for (i < n) buf[p + i] = s[i];
		pos += n;
	}
	// Append a substring from {start} to {end}.
	def putk(s: string, start: int, end: int) -> this {
		var n = end - start, p = acquire(n);
		for (i < n) buf[p + i] = s[i + start];
		pos += n;
	}
	// Append a boolean as "true" or "false".
	def putz(b: bool) -> this {
		puts(if(b, "true", "false"));
	}
	// Append a closure of type StringBuffer -> StringBuffer.
	def putq<T>(p: T) -> this {
		var func = cast<T, StringBuffer -> StringBuffer>(p);
		func(this);
	}

	// Extract the characters in this buffer as a complete string.
	def extract() -> string {
		if (buf == null) return "";
		if (pos == buf.length) {
			var b = buf;
			buf = null;
			pos = 0;
			return b;
		}
		var b = Array<byte>.new(pos);
		for (i < pos) b[i] = buf[i];
		buf = null;
		pos = 0;
		return b;
	}

	// Append a line terminator.
	def ln() -> this {
		putc('\n');
	}
	// Append a space.
	def sp() -> this {
		putc(' ');
	}
	// Reset the size of this buffer, reusing internal storage.
	def reset() -> this {
		pos = 0;
	}
	// Grow the (total) internal storage of this buffer to at least {n} bytes.
	def grow(n: int) -> this {
		if (buf == null) buf = Array<byte>.new(n); // no buffer yet
		else if (n < buf.length) return; // buffer already large enough
		var b = Array<byte>.new(n);
		for (i < pos) b[i] = buf[i];
		buf = b;
	}
	
	// Acquire {n} more bytes of internal storage, growing if necessary.
	private def acquire(n: int) -> int {
		if (buf == null) {
			buf = Array<byte>.new(n);
			return pos;
		}
		if (buf.length - pos < n) {
			var b = Array<byte>.new(n + buf.length * 2);
			for (i < pos) b[i] = buf[i];
			buf = b;
		}
		return pos;
	}
}
def cast<F, T>(p: F) -> T {
	return T.!(p);
}
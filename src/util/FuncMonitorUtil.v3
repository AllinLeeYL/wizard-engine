private class FuncWithLoopEnterProbe(probe: Probe, frameAccessors: ListStack<FrameAccessor>) extends Probe {
	def fire(func: WasmFunction, pc: int, frame: TargetFrame) -> Resumption {
        var curAccessor = frame.getFrameAccessor();
		if (!frameAccessors.empty() && curAccessor == frameAccessors.peek())
			return Resumption.Continue;
		frameAccessors.push(curAccessor);
		if (probe != null)
			return probe.fire(func, pc, frame);
		return Resumption.Continue;
	}
}

private class FuncWithLoopExitProbe(probe: Probe, frameAccessors: ListStack<FrameAccessor>) extends Probe {
	def fire(func: WasmFunction, pc: int, frame: TargetFrame) -> Resumption {
		frameAccessors.pop();
		if (probe != null)
			return probe.fire(func, pc, frame);
		return Resumption.Continue;
	}
}

component FuncMonitorUtil {
	def probeOnEnterExitFunc(module: Module, func: FuncDecl, enterProbe: Probe, exitProbe: Probe) {
		var it = BytecodeIterator.new();
		var bi = it.reset(func);

		var startsWithLoop = false;
		var frameAccessors: ListStack<FrameAccessor>;
		if (bi.current() == Opcode.LOOP) {
			startsWithLoop = true;
			frameAccessors = ListStack<FrameAccessor>.new();
			module.insertProbeAt(func.func_index, bi.pc, FuncWithLoopEnterProbe.new(enterProbe, frameAccessors));
		} else if (enterProbe != null) {
			module.insertProbeAt(func.func_index, bi.pc, enterProbe);
		}

		for (bi = it.reset(func); bi.more(); bi.next()) {
            var op = bi.current();
            match (op) {
                RETURN => ;
                END => if (bi.pc + 1 < bi.func.cur_bytecode.length) continue;
                _ => continue;
            }

			if (startsWithLoop) {
				module.insertProbeAt(func.func_index, bi.pc, FuncWithLoopExitProbe.new(exitProbe, frameAccessors));
			} else if (exitProbe != null) {
				module.insertProbeAt(func.func_index, bi.pc, exitProbe);
			}
        }
	}
}
component StackDelta {
  def stackDelta(func_sig: SigDecl, opcode: Opcode, parser: WasmParser) -> (int, int) {
  	var sig = opcode.sig;
  	if (sig != null) return (sig.params.length, sig.results.length);
  	def noFallThru = -1;
  	def error = (-1, -1);
  	match (opcode) {
  		INVALID =>							return (0, noFallThru);
  		UNREACHABLE, BR, DELEGATE =>					return (0, noFallThru);
  		ELSE, CATCH, CATCH_ALL, RETHROW => 				return (0, noFallThru);
  		THROW_REF, BR_TABLE => 						return (1, noFallThru);
  		BR_ON_NULL, BR_ON_CAST, BR_ON_CAST_FAIL =>			return (1, 1);
  		BR_IF, BR_ON_NON_NULL =>					return (1, 0);
  		END =>								return (0, 0);
  		DROP =>								return (1, 0);
  		SELECT =>							return (3, 1);
  		LOCAL_GET =>							return (0, 1);
  		LOCAL_SET =>							return (1, 0);
  		LOCAL_TEE =>							return (1, 1);
  		GLOBAL_GET =>							return (0, 1);
  		GLOBAL_SET =>							return (1, 0);
  		TABLE_GET =>							return (1, 0);
  		TABLE_SET =>							return (2, 0);
  		MEMORY_SIZE =>							return (0, 1);
  		MEMORY_GROW =>							return (1, 1);
  		I32_CONST, I64_CONST, F32_CONST, F64_CONST, REF_NULL =>		return (0, 1);
  		REF_IS_NULL =>							return (1, 1);
  		REF_FUNC =>							return (0, 1);
  		REF_AS_NON_NULL =>						return (1, 1);
  		REF_EQ =>							return (2, 1);
  		STRUCT_NEW_DEFAULT =>						return (0, 1);
  		STRUCT_GET, STRUCT_GET_S, STRUCT_GET_U =>			return (1, 1);
  		STRUCT_SET =>							return (2, 0);
  		ARRAY_NEW_DEFAULT =>						return (1, 1);
  		ARRAY_GET, ARRAY_GET_S, ARRAY_GET_U =>				return (2, 1);
  		ARRAY_SET =>							return (3, 1);
  		ARRAY_LEN =>							return (1, 1);
  		ARRAY_FILL =>							return (3, 0);
  		ARRAY_COPY =>							return (5, 0);
  		ARRAY_INIT_DATA =>						return (4, 0);
  		ARRAY_INIT_ELEM =>						return (4, 0);
  		ARRAY_NEW_DATA =>						return (3, 1);
  		ARRAY_NEW_ELEM =>						return (2, 1);
  		REF_I31 =>							return (1, 1);
  		I31_GET_S =>							return (1, 1);
  		I31_GET_U =>							return (1, 1);
  		REF_TEST, REF_TEST_NULL =>					return (1, 1);
  		REF_CAST, REF_CAST_NULL =>					return (1, 1);
  		ANY_CONVERT_EXTERN =>						return (1, 1);
  		EXTERN_CONVERT_ANY =>						return (1, 1);
  		MEMORY_INIT =>							return (3, 0);
  		MEMORY_COPY =>							return (3, 0);
  		MEMORY_FILL =>							return (3, 0);
  		TABLE_INIT =>							return (3, 0);
  		TABLE_COPY =>							return (3, 0);
  		TABLE_GROW =>							return (2, 0);
  		TABLE_SIZE =>							return (0, 1);
  		TABLE_FILL =>							return (3, 0);
  		CONT_NEW =>							return (1, 1);

  		BLOCK, LOOP, TRY, TRY_TABLE => {
  			var pr = parser.readBlockType();
  			return (pr.0.length, pr.0.length); // consumes and leaves params on stack
  		}
  		IF => {
  			var pr = parser.readBlockType();
  			return (1 + pr.0.length, pr.0.length);
  		}
  		THROW => {
  			var tag = parser.readTagRef();
  			if (tag == null) return error;
  			return (tag.fields.length, noFallThru);
  		}
  		RETURN => {
  			return (func_sig.results.length, noFallThru);
  		}
  		CALL => {
  			var func = parser.readFuncRef();
  			if (func == null) return error;
  			return (func.sig.params.length, func.sig.results.length);
  		}
  		CALL_INDIRECT => {
  			var sig = parser.readSigRef();
  			if (sig == null) return error;
  			var unused_ = parser.readTableImm();
  			return (1 + sig.params.length, sig.results.length);
  		}
  		RETURN_CALL => {
  			var func = parser.readFuncRef();
  			if (func == null) return error;
  			return (func.sig.params.length, noFallThru);
  		}
  		RETURN_CALL_INDIRECT => {
  			var sig = parser.readSigRef();
  			if (sig == null) return error;
  			var unused_ = parser.readTableImm();
  			return (1 + sig.params.length, noFallThru);
  		}
  		CALL_REF => {
  			var sig = parser.readSigRef();
  			if (sig == null) return error;
  			return (1 + sig.params.length, sig.results.length);
  		}
  		RETURN_CALL_REF => {
  			var sig = parser.readSigRef();
  			if (sig == null) return error;
  			return (1 + sig.params.length, noFallThru);
  		}
  		SELECT_T => {
  			var at = parser.readValueTypes("select count", parser.limits.max_num_select_results);
  			// arity == 1 + 2 * at.length
  			if (at.length == 0) return error;
  			return (1 + 2 * at.length, at.length);
  		}
  		STRUCT_NEW => {
  			var st = parser.readStructType();
  			if (st == null) return error;
  			return (st.field_types.length, 1);
  		}
  		ARRAY_NEW => {
  			var at = parser.readArrayType();
  			if (at == null) return error;
  			return (1 + at.elem_types.length, 1);
  		}
  		ARRAY_NEW_FIXED => {
  			var at = parser.readArrayType();
  			if (at == null) return error;
  			var size = parser.readU32_i("array size", parser.limits.max_array_length);
  			return (1 + size, 1);
  		}
  		CONT_BIND => {
  			var input_cont = parser.readCont();
  			if (input_cont == null) return error;
  			var output_cont = parser.readCont();
  			if (output_cont == null) return error;
  			return (1 + input_cont.sig.params.length - output_cont.sig.params.length, 1);
  		}
  		SUSPEND => {
  			var tag = parser.readTagRef();
  			if (tag == null) return error;
  			var tag_sig = parser.module.heaptypes[tag.sig_index];
  			if (!SigDecl.?(tag_sig)) return error;
  			var sig = SigDecl.!(tag_sig);
  			return (sig.params.length, sig.results.length);
  		}
  		RESUME => {
  			var ct = parser.readCont();
  			if (ct == null) return error;
  			return (1 + ct.sig.params.length, ct.sig.results.length);
  		}
  		RESUME_THROW => {
  			var ct = parser.readCont();
  			if (ct == null) return error;
  			var tag = parser.readTagRef();
  			var tag_sig = parser.module.heaptypes[tag.sig_index];
  			if (!SigDecl.?(tag_sig)) return error;
  			var sig = SigDecl.!(tag_sig);
  			return (sig.params.length, ct.sig.results.length);
  		}
  		_ => {
  			return error;
  		}
  	}
  }
}

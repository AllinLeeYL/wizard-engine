// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A {Vector} is a growable, appendable array.
class Vector<T> {
	private var length: int;
        private var data: Array<T>;

	// Read the value at the given index.
	def [i: int] -> T {
		if (i < 0 || i >= length || data == null) System.error("BoundsCheckException", "");
		return data[i];
	}
	// Write a value at the given index.
	def [i: int] = v: T {
		if (i < 0 || i >= length || data == null) System.error("BoundsCheckException", "");
		data[i] = v;
	}
	// Append the given value to this vector.
	def add(v: T) {
		var end = length;
		grow(end + 1);
		data[end] = v;
		length = end + 1;
	}
	// Append the given values to this vector.
	def addv(v: Array<T>) {
		var end = length;
		grow(end + v.length);
		for (i < v.length) data[end + i] = v[i];
		length = end + v.length;
	}

	def size() -> int { return length; }

        // Write a value at the given index, growing if necessary and updating the length.
	def set(i: int, v: T) {
		grow(i + 1);
		if (length <= i) length = i + 1;
		data[i] = v;
       	}
	// Grow the internal storage capacity to the given new length.
	def grow(nlength: int) -> this {
        	if (data == null) { // no array yet.
			if (nlength > 0) data = Array.new(nlength);
                        return;
                }
                if (nlength > data.length) { // allocate and copy.
			data = Arrays.grow(data, nlength);
                	return;
                }
      	}
	// Resize this vector to the given new length.
	def resize(nlength: int) -> this {
		grow(nlength);
		length = nlength;
	}

	// Extract the values from this vector as an array. The length of this
        // vector is reset to {0}.
        def extract() -> Array<T> {
        	if (length == 0) {
                	return [];
                }
                var ret: Array<T>;
                if (length == data.length) {  // steal the underlying storage.
                	ret = data;
                        data = null;
                } else { // make a copy and retain underlying storage.
	                ret = Array<T>.new(length);
                        var d = data;
        	        for (i < ret.length) ret[i] = d[i];
                }
                length = 0;
                return ret;
        }
	// Get a view of the internal storage of this vector for direct access.
	// Return an array, an offset into the array, and a length.
	def storage() -> (Array<T>, int, int) {
		return (data, 0, length);
	}
}

// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A {Vector} is a growable, appendable array. It has a number of operations to
// append individual items, arrays of items, and to resize. It is designed for
// performance, allowing the user to adjust the internal storage size, extract
// the internal storage, copy out the internal storage, and even alias the
// (current) internal storage. Use wisely.
class Vector<T> {
	def var length: int;
	private var data: Array<T>;

	// Read the value at the given index.
	def [i: int] -> T {
		if (i < 0 || i >= length || data == null) System.error("BoundsCheckException", "");
		return data[i];
	}
	// Write a value at the given index.
	def [i: int] = v: T {
		if (i < 0 || i >= length || data == null) System.error("BoundsCheckException", "");
		data[i] = v;
	}
	// Append {v} to this vector.
	def put(v: T) {
		var end = length;
		growH(end + 1, 10);
		data[end] = v;
		length = end + 1;
	}
	// Append {v} {n} times to this vector.
	def putn(v: T, n: int) {
		var max = length + n;
		grow(max);
		for (i = length; i < max; i++) {
			data[i] = v;
		}
		length += n;
	}
	// Append the given values to this vector.
	def puta(v: Array<T>) {
		var end = length;
		grow(end + v.length);
		for (i < v.length) data[end + i] = v[i];
		length = end + v.length;
	}
	// Write the value {v} at index {i}, first growing if necessary.
	// Update the length if {i} and fill intermediate indices with the
	// default value for {T} if {i} was beyond the current end.
	def set(i: int, v: T) {
		grow(i + 1);
		if (length <= i) length = i + 1;
		data[i] = v;
	}
	// Grow the internal storage capacity to the given new length.
	def grow(nlength: int) -> this {
		growH(nlength, 0);
	}
	private def growH(nlength: int, hint: int) -> this {
		if (data == null) { // no array yet.
			if (nlength > 0) data = Array.new(nlength + hint);
		} else if (nlength > data.length) { // allocate and copy.
			data = Arrays.grow(data, nlength + data.length);
		}
	}
	// Resize this vector to the given new length.
	def resize(nlength: int) -> this {
		grow(nlength);
		length = nlength;
	}
	// Extract the values from this vector as an array. The length of this
	// vector is reset to {0}. If there is an exact match between the size
	// of the internal storage and the current length, the internal storage
	// will be returned without copying.
	def extract() -> Array<T> {
		if (length == 0) return [];

		var ret: Array<T>;
		if (length == data.length) {  // steal the underlying storage.
			ret = data;
			data = null;
		} else { // make a copy and retain underlying storage.
			ret = Array<T>.new(length);
			var d = data;
			for (i < ret.length) ret[i] = d[i];
		}
		length = 0;
		return ret;
	}
	// Make a copy of the data in this vector without modifying it.
	def copy() -> Array<T> {
		if (length == 0) return [];
		return Arrays.range(data, 0, length);
	}
	// Get an alias of the internal storage of this vector for direct
	// access. Return an array, an offset into the array, and a length.
	def storage() -> (Array<T>, int, int) {
		return (data, 0, length);
	}
	// Return the length as an unsigned number.
	def usize() -> u32 {
		return u32.!(length);
	}
}

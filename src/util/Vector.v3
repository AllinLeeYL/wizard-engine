// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A {Vector} is a growable, appendable array. It has a number of
// operations to append individual items, arrays of items, and to
// resize. It is designed for performance, allowing the user to
// adjust the internal storage size, extract the internal storage,
// copy out the internal storage, and even alias the (current)
// internal storage. Use wisely.
class Vector<T> {
	private var length: int;
	private var data: Array<T>;

	// Read the value at the given index.
	def [i: int] -> T {
		if (i < 0 || i >= length || data == null) System.error("BoundsCheckException", "");
		return data[i];
	}
	// Write a value at the given index.
	def [i: int] = v: T {
		if (i < 0 || i >= length || data == null) System.error("BoundsCheckException", "");
		data[i] = v;
	}
	// Append the given value to this vector.
	def add(v: T) {
		var end = length;
		grow(end + 1);
		data[end] = v;
		length = end + 1;
	}
	// Append the given values to this vector.
	def addv(v: Array<T>) {
		var end = length;
		grow(end + v.length);
		for (i < v.length) data[end + i] = v[i];
		length = end + v.length;
	}

	// Get the current size of the vector.
	def size() -> int { return length; }

	// Write a value at the given index, growing if necessary and updating the length.
	def set(i: int, v: T) {
		grow(i + 1);
		if (length <= i) length = i + 1;
		data[i] = v;
	}
	// Grow the internal storage capacity to the given new length.
	def grow(nlength: int) -> this {
		if (data == null) { // no array yet.
			if (nlength > 0) data = Array.new(nlength);
			return;
		}
		if (nlength > data.length) { // allocate and copy.
			data = Arrays.grow(data, nlength);
			return;
		}
	}
	// Resize this vector to the given new length.
	def resize(nlength: int) -> this {
		grow(nlength);
		length = nlength;
	}
	// Extract the values from this vector as an array. The length of this
	// vector is reset to {0}. If there is an exact match between the
	// size of the internal storage and the current length, the internal
	// storage will be returned.
	def extract() -> Array<T> {
		if (length == 0) return [];

		var ret: Array<T>;
		if (length == data.length) {  // steal the underlying storage.
			ret = data;
			data = null;
		} else { // make a copy and retain underlying storage.
			ret = Array<T>.new(length);
			var d = data;
			for (i < ret.length) ret[i] = d[i];
		}
		length = 0;
		return ret;
	}
	// Make a copy of the data in this vector without modifying it.
	def copy() -> Array<T> {
		if (length == 0) return [];
		return Arrays.range(data, 0, length);
	}
	// Get an alias of the internal storage of this vector for direct access.
	// Return an array, an offset into the array, and a length.
	def storage() -> (Array<T>, int, int) {
		return (data, 0, length);
	}
}
